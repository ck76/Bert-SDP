package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class FilterIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private final DTMFilter _filter ; private final boolean _isReverse ; public FilterIterator ( DTMAxisIterator source , DTMFilter filter ) { _source = source ; _filter = filter ; _isReverse = source . isReverse ( ) ; } public boolean isReverse ( ) { return _isReverse ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator cloneIterator ( ) { try { final FilterIterator clone = ( FilterIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { if ( _filter . acceptNode ( node , DTMFilter . SHOW_ALL ) == DTMIterator . FILTER_ACCEPT ) { return returnNode ( node ) ; } } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; return resetPosition ( ) ; } return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0
package org . apache . xml . serializer ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Transformer ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . BoolStack ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; abstract public class SerializerBase implements SerializationHandler , SerializerConstants , org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler { protected void fireEndElem ( String name ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENDELEMENT , name , ( Attributes ) null ) ; } protected void fireCharEvent ( char [ ] chars , int start , int length ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_CHARACTERS , chars , start , length ) ; } protected boolean m_needToCallStartDocument = true ; protected boolean m_startTagOpen = false ; int m_currentElemDepth = 0 ; protected String m_elementName = null ; protected String m_elementLocalName = null ; protected String m_elementURI = null ; protected boolean m_cdataTagOpen = false ; protected AttributesImplSerializer m_attributes = new AttributesImplSerializer ( ) ; protected boolean m_inEntityRef = false ; protected boolean m_inExternalDTD = false ; protected BoolStack m_cdataSectionStates = new BoolStack ( ) ; private String m_doctypeSystem ; private String m_doctypePublic ; boolean m_needToOutputDocTypeDecl = true ; private String m_encoding = null ; protected Stack m_nodeStack ; protected Stack m_prefixStack ; private boolean m_shouldNotWriteXMLHeader = false ; private String m_standalone ; protected boolean m_standaloneWasSpecified = false ; protected boolean m_doIndent = false ; protected int m_indentAmount = 0 ; private String m_version = null ; private String m_mediatype ; private Transformer m_transformer ; protected Vector m_cdataSectionElements = null ; protected NamespaceMappings m_prefixMap ; protected SerializerTrace m_tracer ; protected SourceLocator m_sourceLocator ; protected java . io . Writer m_writer = null ; public void comment ( String data ) throws SAXException { this . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } protected String patchName ( String qname ) { final int lastColon = qname . lastIndexOf ( ':' ) ; if ( lastColon > 0 ) { final int firstColon = qname . indexOf ( ':' ) ; final String prefix = qname . substring ( 0 , firstColon ) ; final String localName = qname . substring ( lastColon + 1 ) ; final String uri = m_prefixMap . lookupNamespace ( prefix ) ; if ( uri != null && uri . length ( ) == 0 ) { return localName ; } else if ( firstColon != lastColon ) { return prefix + ':' + localName ; } } return qname ; } protected static String getLocalName ( String qname ) { final int col = qname . lastIndexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( col + 1 ) : qname ; } public void setDocumentLocator ( Locator locator ) { return ; } public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException { if ( m_startTagOpen ) { addAttributeAlways ( uri , localName , rawName , type , value ) ; } } public void addAttributeAlways ( String uri , String localName , String rawName , String type , String value ) { int index ; index = m_attributes . getIndex ( rawName ) ; if ( index >= 0 ) { m_attributes . setValue ( index , value ) ; } else { m_attributes . addAttribute ( uri , localName , rawName , type , value ) ; } } public void addAttribute ( String name , final String value ) { if ( m_startTagOpen ) { final String patchedName = patchName ( name ) ; final String localName = getLocalName ( patchedName ) ; final String uri = getNamespaceURI ( patchedName , false ) ; addAttributeAlways ( uri , localName , patchedName , "CDATA" , value ) ; } } public void addAttributes ( Attributes atts ) throws SAXException { int nAtts = atts . getLength ( ) ; for ( int i = 0 ; i < nAtts ; i ++ ) { String uri = atts . getURI ( i ) ; if ( null == uri ) uri = "" ; addAttributeAlways ( uri , atts . getLocalName ( i ) , atts . getQName ( i ) , atts . getType ( i ) , atts . getValue ( i ) ) ; } } public ContentHandler asContentHandler ( ) throws IOException { return this ; } public void endEntity ( String name ) throws org . xml . sax . SAXException { if ( name . equals ( "[dtd]" ) ) m_inExternalDTD = false ; m_inEntityRef = false ; this . fireEndEntity ( name ) ; } public void close ( ) { } protected void initCDATA ( ) { } public String getEncoding ( ) { return m_encoding ; } public void setEncoding ( String m_encoding ) { this . m_encoding = m_encoding ; } public void setOmitXMLDeclaration ( boolean b ) { this . m_shouldNotWriteXMLHeader = b ; } public boolean getOmitXMLDeclaration ( ) { return m_shouldNotWriteXMLHeader ; } public String getDoctypePublic ( ) { return m_doctypePublic ; } public void setDoctypePublic ( String doctypePublic ) { this . m_doctypePublic = doctypePublic ; } public String getDoctypeSystem ( ) { return m_doctypeSystem ; } public void setDoctypeSystem ( String doctypeSystem ) { this . m_doctypeSystem = doctypeSystem ; } public void setDoctype ( String doctypeSystem , String doctypePublic ) { this . m_doctypeSystem = doctypeSystem ; this . m_doctypePublic = doctypePublic ; } public void setStandalone ( String standalone ) { if ( standalone != null ) { m_standaloneWasSpecified = true ; setStandaloneInternal ( standalone ) ; } } protected void setStandaloneInternal ( String standalone ) { if ( "yes" . equals ( standalone ) ) m_standalone = "yes" ; else m_standalone = "no" ; } public String getStandalone ( ) { return m_standalone ; } public boolean getIndent ( ) { return m_doIndent ; } public String getMediaType ( ) { return m_mediatype ; } public String getVersion ( ) { return m_version ; } public void setVersion ( String version ) { m_version = version ; } public void setMediaType ( String mediaType ) { m_mediatype = mediaType ; } public int getIndentAmount ( ) { return m_indentAmount ; } public void setIndentAmount ( int m_indentAmount ) { this . m_indentAmount = m_indentAmount ; } public void setIndent ( boolean doIndent ) { m_doIndent = doIndent ; } public void namespaceAfterStartElement ( String uri , String prefix ) throws SAXException { } public DOMSerializer asDOMSerializer ( ) throws IOException { return this ; } protected void pushCdataSectionState ( ) { boolean b ; if ( null != m_cdataSectionElements ) { b = false ; if ( m_elementLocalName == null ) m_elementLocalName = getLocalName ( m_elementName ) ; if ( m_elementURI == null ) { String prefix = getPrefixPart ( m_elementName ) ; if ( prefix != null ) m_elementURI = m_prefixMap . lookupNamespace ( prefix ) ; } if ( ( null != m_elementURI ) && m_elementURI . length ( ) == 0 ) m_elementURI = null ; int nElems = m_cdataSectionElements . size ( ) ; for ( int i = 0 ; i < nElems ; i += 2 ) { String uri = ( String ) m_cdataSectionElements . elementAt ( i ) ; String loc = ( String ) m_cdataSectionElements . elementAt ( i + 1 ) ; if ( loc . equals ( m_elementLocalName ) && subPartMatch ( m_elementURI , uri ) ) { b = true ; break ; } } } else { b = m_cdataSectionStates . peekOrFalse ( ) ; } m_cdataSectionStates . push ( b ) ; } private static final boolean subPartMatch ( String p , String t ) { return ( p == t ) || ( ( null != p ) && ( p . equals ( t ) ) ) ; } protected static final String getPrefixPart ( String qname ) { final int col = qname . indexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( 0 , col ) : null ; } public NamespaceMappings getNamespaceMappings ( ) { return m_prefixMap ; } public String getPrefix ( String namespaceURI ) { String prefix = m_prefixMap . lookupPrefix ( namespaceURI ) ; return prefix ; } public String getNamespaceURI ( String qname , boolean isElement ) { String uri = EMPTYSTRING ; int col = qname . lastIndexOf ( ':' ) ; final String prefix = ( col > 0 ) ? qname . substring ( 0 , col ) : EMPTYSTRING ; if ( ! EMPTYSTRING . equals ( prefix ) || isElement ) { if ( m_prefixMap != null ) { uri = m_prefixMap . lookupNamespace ( prefix ) ; if ( uri == null && ! prefix . equals ( XMLNS_PREFIX ) ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NAMESPACE_PREFIX , new Object [ ] { qname . substring ( 0 , col ) } ) ) ; } } } return uri ; } public String getNamespaceURIFromPrefix ( String prefix ) { String uri = null ; if ( m_prefixMap != null ) uri = m_prefixMap . lookupNamespace ( prefix ) ; return uri ; } public void entityReference ( String name ) throws org . xml . sax . SAXException { flushPending ( ) ; startEntity ( name ) ; endEntity ( name ) ; fireEntityReference ( name ) ; } public void setTransformer ( Transformer t ) { m_transformer = t ; if ( ( m_transformer instanceof SerializerTrace ) && ( ( ( SerializerTrace ) m_transformer ) . hasTraceListeners ( ) ) ) { m_tracer = ( SerializerTrace ) m_transformer ; } else { m_tracer = null ; } } public Transformer getTransformer ( ) { return m_transformer ; } public void characters ( org . w3c . dom . Node node ) throws org . xml . sax . SAXException { flushPending ( ) ; String data = node . getNodeValue ( ) ; char [ ] ch = null ; int length = 0 ; if ( data != null ) { ch = data . toCharArray ( ) ; length = data . length ( ) ; characters ( ch , 0 , length ) ; } } public void error ( SAXParseException exc ) throws SAXException { } public void fatalError ( SAXParseException exc ) throws SAXException { m_startTagOpen = false ; } public void warning ( SAXParseException exc ) throws SAXException { } protected void fireStartEntity ( String name ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENTITYREF , name ) ; } private void flushMyWriter ( ) { if ( m_writer != null ) { try { m_writer . flush ( ) ; } catch ( IOException ioe ) { } } } protected void fireCDATAEvent ( char [ ] chars , int start , int length ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_CDATA , chars , start , length ) ; } protected void fireCommentEvent ( char [ ] chars , int start , int length ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_COMMENT , new String ( chars , start , length ) ) ; } public void fireEndEntity ( String name ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; } protected void fireStartDoc ( ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_STARTDOCUMENT ) ; } protected void fireEndDoc ( ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENDDOCUMENT ) ; } protected void fireStartElem ( String elemName ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_STARTELEMENT , elemName , m_attributes ) ; } protected void fireEscapingEvent ( String name , String data ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_PI , name , data ) ; } protected void fireEntityReference ( String name ) throws org . xml . sax . SAXException { flushMyWriter ( ) ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_ENTITYREF , name , ( Attributes ) null ) ; } public void startDocument ( ) throws org . xml . sax . SAXException { startDocumentInternal ( ) ; m_needToCallStartDocument = false ; return ; } protected void startDocumentInternal ( ) throws org . xml . sax . SAXException { this . fireStartDoc ( ) ; } public void setSourceLocator ( SourceLocator locator ) { m_sourceLocator = locator ; } public void setNamespaceMappings ( NamespaceMappings mappings ) { m_prefixMap = mappings ; } } 	1
package org . apache . xalan . xsltc . compiler ; abstract class RelativePathPattern extends LocationPathPattern { } 	0
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; public class SelfIteratorNoPredicate extends LocPathIterator { SelfIteratorNoPredicate ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; } public SelfIteratorNoPredicate ( ) throws javax . xml . transform . TransformerException { super ( null ) ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; DTM dtm = m_cdtm ; m_lastFetched = next = ( DTM . NULL == m_lastFetched ) ? m_context : DTM . NULL ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return xctxt . getCurrentNode ( ) ; } public int getLastPos ( XPathContext xctxt ) { return 1 ; } } 	1
package org . apache . xpath . axes ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . res . XPATHErrorResources ; public class AxesWalker extends PredicatedNodeTest implements Cloneable , PathComponent , ExpressionOwner { public AxesWalker ( LocPathIterator locPathIterator , int axis ) { super ( locPathIterator ) ; m_axis = axis ; } public final WalkingIterator wi ( ) { return ( WalkingIterator ) m_lpi ; } public void init ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { initPredicateInfo ( compiler , opPos ) ; } public Object clone ( ) throws CloneNotSupportedException { AxesWalker clone = ( AxesWalker ) super . clone ( ) ; return clone ; } AxesWalker cloneDeep ( WalkingIterator cloneOwner , Vector cloneList ) throws CloneNotSupportedException { AxesWalker clone = findClone ( this , cloneList ) ; if ( null != clone ) return clone ; clone = ( AxesWalker ) this . clone ( ) ; clone . setLocPathIterator ( cloneOwner ) ; if ( null != cloneList ) { cloneList . addElement ( this ) ; cloneList . addElement ( clone ) ; } if ( wi ( ) . m_lastUsedWalker == this ) cloneOwner . m_lastUsedWalker = clone ; if ( null != m_nextWalker ) clone . m_nextWalker = m_nextWalker . cloneDeep ( cloneOwner , cloneList ) ; if ( null != cloneList ) { if ( null != m_prevWalker ) clone . m_prevWalker = m_prevWalker . cloneDeep ( cloneOwner , cloneList ) ; } else { if ( null != m_nextWalker ) clone . m_nextWalker . m_prevWalker = clone ; } return clone ; } static AxesWalker findClone ( AxesWalker key , Vector cloneList ) { if ( null != cloneList ) { int n = cloneList . size ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( key == cloneList . elementAt ( i ) ) return ( AxesWalker ) cloneList . elementAt ( i + 1 ) ; } } return null ; } public void detach ( ) { m_currentNode = DTM . NULL ; m_dtm = null ; m_traverser = null ; m_isFresh = true ; m_root = DTM . NULL ; } public int getRoot ( ) { return m_root ; } public int getAnalysisBits ( ) { int axis = getAxis ( ) ; int bit = WalkerFactory . getAnalysisBitFromAxes ( axis ) ; return bit ; } public void setRoot ( int root ) { XPathContext xctxt = wi ( ) . getXPathContext ( ) ; m_dtm = xctxt . getDTM ( root ) ; m_traverser = m_dtm . getAxisTraverser ( m_axis ) ; m_isFresh = true ; m_foundLast = false ; m_root = root ; m_currentNode = root ; if ( DTM . NULL == root ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_SETTING_WALKER_ROOT_TO_NULL , null ) ) ; } resetProximityPositions ( ) ; } public final int getCurrentNode ( ) { return m_currentNode ; } public void setNextWalker ( AxesWalker walker ) { m_nextWalker = walker ; } public AxesWalker getNextWalker ( ) { return m_nextWalker ; } public void setPrevWalker ( AxesWalker walker ) { m_prevWalker = walker ; } public AxesWalker getPrevWalker ( ) { return m_prevWalker ; } private int returnNextNode ( int n ) { return n ; } protected int getNextNode ( ) { if ( m_foundLast ) return DTM . NULL ; if ( m_isFresh ) { m_currentNode = m_traverser . first ( m_root ) ; m_isFresh = false ; } else if ( DTM . NULL != m_currentNode ) { m_currentNode = m_traverser . next ( m_root , m_currentNode ) ; } if ( DTM . NULL == m_currentNode ) this . m_foundLast = true ; return m_currentNode ; } public int nextNode ( ) { int nextNode = DTM . NULL ; AxesWalker walker = wi ( ) . getLastUsedWalker ( ) ; while ( true ) { if ( null == walker ) break ; nextNode = walker . getNextNode ( ) ; if ( DTM . NULL == nextNode ) { walker = walker . m_prevWalker ; } else { if ( walker . acceptNode ( nextNode ) != DTMIterator . FILTER_ACCEPT ) { continue ; } if ( null == walker . m_nextWalker ) { wi ( ) . setLastUsedWalker ( walker ) ; break ; } else { AxesWalker prev = walker ; walker = walker . m_nextWalker ; walker . setRoot ( nextNode ) ; walker . m_prevWalker = prev ; continue ; } } } return nextNode ; } public int getLastPos ( XPathContext xctxt ) { int pos = getProximityPosition ( ) ; AxesWalker walker ; try { walker = ( AxesWalker ) clone ( ) ; } catch ( CloneNotSupportedException cnse ) { return - 1 ; } walker . setPredicateCount ( walker . getPredicateCount ( ) - 1 ) ; walker . setNextWalker ( null ) ; walker . setPrevWalker ( null ) ; WalkingIterator lpi = wi ( ) ; AxesWalker savedWalker = lpi . getLastUsedWalker ( ) ; try { lpi . setLastUsedWalker ( walker ) ; int next ; while ( DTM . NULL != ( next = walker . nextNode ( ) ) ) { pos ++ ; } } finally { lpi . setLastUsedWalker ( savedWalker ) ; } return pos ; } private DTM m_dtm ; public void setDefaultDTM ( DTM dtm ) { m_dtm = dtm ; } public DTM getDTM ( int node ) { return wi ( ) . getXPathContext ( ) . getDTM ( node ) ; } public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return m_axis ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitStep ( owner , this ) ) { callPredicateVisitors ( visitor ) ; if ( null != m_nextWalker ) { m_nextWalker . callVisitors ( this , visitor ) ; } } } public Expression getExpression ( ) { return m_nextWalker ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_nextWalker = ( AxesWalker ) exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; AxesWalker walker = ( AxesWalker ) expr ; if ( this . m_axis != walker . m_axis ) return false ; return true ; } transient int m_root = DTM . NULL ; private transient int m_currentNode = DTM . NULL ; transient boolean m_isFresh ; protected AxesWalker m_nextWalker ; AxesWalker m_prevWalker ; protected int m_axis = - 1 ; protected DTMAxisTraverser m_traverser ; } 	0
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . MethodGen ; import org . apache . bcel . generic . Type ; public class MethodGenerator extends MethodGen implements org . apache . xalan . xsltc . compiler . Constants { protected static final int INVALID_INDEX = - 1 ; private static final String START_ELEMENT_SIG = "(" + STRING_SIG + ")V" ; private static final String END_ELEMENT_SIG = START_ELEMENT_SIG ; private InstructionList _mapTypeSub ; private static final int DOM_INDEX = 1 ; private static final int ITERATOR_INDEX = 2 ; private static final int HANDLER_INDEX = 3 ; private Instruction _iloadCurrent ; private Instruction _istoreCurrent ; private final Instruction _astoreHandler ; private final Instruction _aloadHandler ; private final Instruction _astoreIterator ; private final Instruction _aloadIterator ; private final Instruction _aloadDom ; private final Instruction _astoreDom ; private final Instruction _startElement ; private final Instruction _endElement ; private final Instruction _startDocument ; private final Instruction _endDocument ; private final Instruction _attribute ; private final Instruction _namespace ; private final Instruction _setStartNode ; private final Instruction _reset ; private final Instruction _nextNode ; private final Instruction _nextNodeId ; private SlotAllocator _slotAllocator ; private boolean _allocatorInit = false ; public MethodGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cpg ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cpg ) ; _astoreHandler = new ASTORE ( HANDLER_INDEX ) ; _aloadHandler = new ALOAD ( HANDLER_INDEX ) ; _astoreIterator = new ASTORE ( ITERATOR_INDEX ) ; _aloadIterator = new ALOAD ( ITERATOR_INDEX ) ; _aloadDom = new ALOAD ( DOM_INDEX ) ; _astoreDom = new ASTORE ( DOM_INDEX ) ; final int startElement = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "startElement" , START_ELEMENT_SIG ) ; _startElement = new INVOKEINTERFACE ( startElement , 2 ) ; final int endElement = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "endElement" , END_ELEMENT_SIG ) ; _endElement = new INVOKEINTERFACE ( endElement , 2 ) ; final int attribute = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "addAttribute" , "(" + STRING_SIG + STRING_SIG + ")V" ) ; _attribute = new INVOKEINTERFACE ( attribute , 3 ) ; final int namespace = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "namespaceAfterStartElement" , "(" + STRING_SIG + STRING_SIG + ")V" ) ; _namespace = new INVOKEINTERFACE ( namespace , 3 ) ; int index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "startDocument" , "()V" ) ; _startDocument = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "endDocument" , "()V" ) ; _endDocument = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , SET_START_NODE , SET_START_NODE_SIG ) ; _setStartNode = new INVOKEINTERFACE ( index , 2 ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , "reset" , "()" + NODE_ITERATOR_SIG ) ; _reset = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , NEXT , NEXT_SIG ) ; _nextNode = new INVOKEINTERFACE ( index , 1 ) ; index = cpg . addInterfaceMethodref ( "org.apache.xalan.xsltc.dom.SAXImpl$SingletonNodeIDIterator" , NEXTID , NEXT_SIG ) ; _nextNodeId = new INVOKEINTERFACE ( index , 1 ) ; _slotAllocator = new SlotAllocator ( ) ; _slotAllocator . initialize ( getLocalVariables ( ) ) ; _allocatorInit = true ; } public LocalVariableGen addLocalVariable ( String name , Type type , InstructionHandle start , InstructionHandle end ) { return ( _allocatorInit ) ? addLocalVariable2 ( name , type , start ) : super . addLocalVariable ( name , type , start , end ) ; } public LocalVariableGen addLocalVariable2 ( String name , Type type , InstructionHandle start ) { return super . addLocalVariable ( name , type , _slotAllocator . allocateSlot ( type ) , start , null ) ; } public void removeLocalVariable ( LocalVariableGen lvg ) { _slotAllocator . releaseSlot ( lvg ) ; super . removeLocalVariable ( lvg ) ; } public Instruction loadDOM ( ) { return _aloadDom ; } public Instruction storeDOM ( ) { return _astoreDom ; } public Instruction storeHandler ( ) { return _astoreHandler ; } public Instruction loadHandler ( ) { return _aloadHandler ; } public Instruction storeIterator ( ) { return _astoreIterator ; } public Instruction loadIterator ( ) { return _aloadIterator ; } public final Instruction setStartNode ( ) { return _setStartNode ; } public final Instruction reset ( ) { return _reset ; } public final Instruction nextNode ( ) { return _nextNode ; } public final Instruction nextNodeId ( ) { return _nextNodeId ; } public final Instruction startElement ( ) { return _startElement ; } public final Instruction endElement ( ) { return _endElement ; } public final Instruction startDocument ( ) { return _startDocument ; } public final Instruction endDocument ( ) { return _endDocument ; } public final Instruction attribute ( ) { return _attribute ; } public final Instruction namespace ( ) { return _namespace ; } public Instruction loadCurrentNode ( ) { if ( _iloadCurrent == null ) { int idx = getLocalIndex ( "current" ) ; if ( idx > 0 ) _iloadCurrent = new ILOAD ( idx ) ; else _iloadCurrent = new ICONST ( 0 ) ; } return _iloadCurrent ; } public Instruction storeCurrentNode ( ) { return _istoreCurrent != null ? _istoreCurrent : ( _istoreCurrent = new ISTORE ( getLocalIndex ( "current" ) ) ) ; } public Instruction loadContextNode ( ) { return loadCurrentNode ( ) ; } public Instruction storeContextNode ( ) { return storeCurrentNode ( ) ; } public int getLocalIndex ( String name ) { return getLocalVariable ( name ) . getIndex ( ) ; } public LocalVariableGen getLocalVariable ( String name ) { final LocalVariableGen [ ] vars = getLocalVariables ( ) ; for ( int i = 0 ; i < vars . length ; i ++ ) if ( vars [ i ] . getName ( ) . equals ( name ) ) return vars [ i ] ; return null ; } public void setMaxLocals ( ) { int maxLocals = super . getMaxLocals ( ) ; int prevLocals = maxLocals ; final LocalVariableGen [ ] localVars = super . getLocalVariables ( ) ; if ( localVars != null ) { if ( localVars . length > maxLocals ) maxLocals = localVars . length ; } if ( maxLocals < 5 ) maxLocals = 5 ; super . setMaxLocals ( maxLocals ) ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class SimpleAttributeValue extends AttributeValue { private String _value ; public SimpleAttributeValue ( String value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _type = Type . String ; } public String toString ( ) { return _value ; } protected boolean contextDependent ( ) { return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } } 	0
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncBoolean extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_arg0 . execute ( xctxt ) . bool ( ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Message extends Instruction { private boolean _terminate = false ; public void parseContents ( Parser parser ) { String termstr = getAttribute ( "terminate" ) ; if ( termstr != null ) { _terminate = termstr . equals ( "yes" ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( classGen . loadTranslet ( ) ) ; switch ( elementCount ( ) ) { case 0 : il . append ( new PUSH ( cpg , "" ) ) ; break ; case 1 : SyntaxTreeNode child = ( SyntaxTreeNode ) elementAt ( 0 ) ; if ( child instanceof Text ) { il . append ( new PUSH ( cpg , ( ( Text ) child ) . getText ( ) ) ) ; break ; } default : il . append ( methodGen . loadHandler ( ) ) ; il . append ( new NEW ( cpg . addClass ( STREAM_XML_OUTPUT ) ) ) ; il . append ( methodGen . storeHandler ( ) ) ; il . append ( new NEW ( cpg . addClass ( STRING_WRITER ) ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( STRING_WRITER , "<init>" , "()V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( STREAM_XML_OUTPUT , "<init>" , "()V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "setWriter" , "(" + WRITER_SIG + ")V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , "UTF-8" ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "setEncoding" , "(" + STRING_SIG + ")V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( ICONST_1 ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "setOmitXMLDeclaration" , "(Z)V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "startDocument" , "()V" ) ) ) ; translateContents ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "endDocument" , "()V" ) ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_WRITER , "toString" , "()" + STRING_SIG ) ) ) ; il . append ( SWAP ) ; il . append ( methodGen . storeHandler ( ) ) ; break ; } il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , "displayMessage" , "(" + STRING_SIG + ")V" ) ) ) ; if ( _terminate == true ) { final int einit = cpg . addMethodref ( "java.lang.RuntimeException" , "<init>" , "(Ljava/lang/String;)V" ) ; il . append ( new NEW ( cpg . addClass ( "java.lang.RuntimeException" ) ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "Termination forced by an " + "xsl:message instruction" ) ) ; il . append ( new INVOKESPECIAL ( einit ) ) ; il . append ( ATHROW ) ; } } } 	0
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; final class VariableRef extends VariableRefBase { public VariableRef ( Variable variable ) { super ( variable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _type . implementedAsMethod ( ) ) return ; final String name = _variable . getVariable ( ) ; final String signature = _type . toSignature ( ) ; if ( _variable . isLocal ( ) ) { if ( classGen . isExternal ( ) ) { Closure variableClosure = _closure ; while ( variableClosure != null ) { if ( variableClosure . inInnerClass ( ) ) break ; variableClosure = variableClosure . getParentClosure ( ) ; } if ( variableClosure != null ) { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( variableClosure . getInnerClassName ( ) , name , signature ) ) ) ; } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { final String className = classGen . getClassName ( ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new GETFIELD ( cpg . addFieldref ( className , name , signature ) ) ) ; } if ( _variable . getType ( ) instanceof NodeSetType ) { final int clone = cpg . addInterfaceMethodref ( NODE_ITERATOR , "cloneIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( clone , 1 ) ) ; } } } 	1
package org . apache . xpath . compiler ; public class PsuedoNames { public static final String PSEUDONAME_ANY = "*" ; public static final String PSEUDONAME_ROOT = "/" ; public static final String PSEUDONAME_TEXT = "#text" ; public static final String PSEUDONAME_COMMENT = "#comment" ; public static final String PSEUDONAME_PI = "#pi" ; public static final String PSEUDONAME_OTHER = "*" ; } 	0
package org . apache . xalan . templates ; import java . util . StringTokenizer ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . processor . StylesheetHandler ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . StringBufferPool ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; public class AVT implements java . io . Serializable , XSLTVisitable { private String m_simpleString = null ; private Vector m_parts = null ; private String m_rawName ; public String getRawName ( ) { return m_rawName ; } public void setRawName ( String rawName ) { m_rawName = rawName ; } private String m_name ; public String getName ( ) { return m_name ; } public void setName ( String name ) { m_name = name ; } private String m_uri ; public String getURI ( ) { return m_uri ; } public void setURI ( String uri ) { m_uri = uri ; } public AVT ( StylesheetHandler handler , String uri , String name , String rawName , String stringedValue , ElemTemplateElement owner ) throws javax . xml . transform . TransformerException { m_uri = uri ; m_name = name ; m_rawName = rawName ; StringTokenizer tokenizer = new StringTokenizer ( stringedValue , "{}\"\'" , true ) ; int nTokens = tokenizer . countTokens ( ) ; if ( nTokens < 2 ) { m_simpleString = stringedValue ; } else { FastStringBuffer buffer = StringBufferPool . get ( ) ; FastStringBuffer exprBuffer = StringBufferPool . get ( ) ; try { m_parts = new Vector ( nTokens + 1 ) ; String t = null ; String lookahead = null ; String error = null ; while ( tokenizer . hasMoreTokens ( ) ) { if ( lookahead != null ) { t = lookahead ; lookahead = null ; } else t = tokenizer . nextToken ( ) ; if ( t . length ( ) == 1 ) { switch ( t . charAt ( 0 ) ) { case ( '\"' ) : case ( '\'' ) : { buffer . append ( t ) ; break ; } case ( '{' ) : { try { lookahead = tokenizer . nextToken ( ) ; if ( lookahead . equals ( "{" ) ) { buffer . append ( lookahead ) ; lookahead = null ; break ; } else { if ( buffer . length ( ) > 0 ) { m_parts . addElement ( new AVTPartSimple ( buffer . toString ( ) ) ) ; buffer . setLength ( 0 ) ; } exprBuffer . setLength ( 0 ) ; while ( null != lookahead ) { if ( lookahead . length ( ) == 1 ) { switch ( lookahead . charAt ( 0 ) ) { case '\'' : case '\"' : { exprBuffer . append ( lookahead ) ; String quote = lookahead ; lookahead = tokenizer . nextToken ( ) ; while ( ! lookahead . equals ( quote ) ) { exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; } exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; break ; } case '{' : { error = XSLMessages . createMessage ( XSLTErrorResources . ER_NO_CURLYBRACE , null ) ; lookahead = null ; break ; } case '}' : { buffer . setLength ( 0 ) ; XPath xpath = handler . createXPath ( exprBuffer . toString ( ) , owner ) ; m_parts . addElement ( new AVTPartXPath ( xpath ) ) ; lookahead = null ; break ; } default : { exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; } } } else { exprBuffer . append ( lookahead ) ; lookahead = tokenizer . nextToken ( ) ; } } if ( error != null ) { break ; } } break ; } catch ( java . util . NoSuchElementException ex ) { error = XSLMessages . createMessage ( XSLTErrorResources . ER_ILLEGAL_ATTRIBUTE_VALUE , new Object [ ] { name , stringedValue } ) ; break ; } } case ( '}' ) : { lookahead = tokenizer . nextToken ( ) ; if ( lookahead . equals ( "}" ) ) { buffer . append ( lookahead ) ; lookahead = null ; } else { try { handler . warn ( XSLTErrorResources . WG_FOUND_CURLYBRACE , null ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } buffer . append ( "}" ) ; } break ; } default : { buffer . append ( t ) ; } } } else { buffer . append ( t ) ; } if ( null != error ) { try { handler . warn ( XSLTErrorResources . WG_ATTR_TEMPLATE , new Object [ ] { error } ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } break ; } } if ( buffer . length ( ) > 0 ) { m_parts . addElement ( new AVTPartSimple ( buffer . toString ( ) ) ) ; buffer . setLength ( 0 ) ; } } finally { StringBufferPool . free ( buffer ) ; StringBufferPool . free ( exprBuffer ) ; } } if ( null == m_parts && ( null == m_simpleString ) ) { m_simpleString = "" ; } } public String getSimpleString ( ) { if ( null != m_simpleString ) { return m_simpleString ; } else if ( null != m_parts ) { FastStringBuffer buf = StringBufferPool . get ( ) ; String s ; try { buf . setLength ( 0 ) ; int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; buf . append ( part . getSimpleString ( ) ) ; } s = buf . toString ( ) ; } finally { StringBufferPool . free ( buf ) ; } return s ; } else { return "" ; } } public String evaluate ( XPathContext xctxt , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException { FastStringBuffer buf = StringBufferPool . get ( ) ; try { if ( null != m_simpleString ) { return m_simpleString ; } else if ( null != m_parts ) { buf . setLength ( 0 ) ; int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; part . evaluate ( xctxt , buf , context , nsNode ) ; } return buf . toString ( ) ; } else { return "" ; } } finally { StringBufferPool . free ( buf ) ; } } public boolean isContextInsensitive ( ) { return null != m_simpleString ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_parts ) { int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; if ( part . canTraverseOutsideSubtree ( ) ) return true ; } } return false ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { if ( null != m_parts ) { int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; part . fixupVariables ( vars , globalsSize ) ; } } } public void callVisitors ( XSLTVisitor visitor ) { if ( visitor . visitAVT ( this ) && ( null != m_parts ) ) { int n = m_parts . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { AVTPart part = ( AVTPart ) m_parts . elementAt ( i ) ; part . callVisitors ( visitor ) ; } } } public boolean isSimple ( ) { return m_simpleString != null ; } } 	1
package org . apache . xalan . transformer ; import java . io . IOException ; import javax . xml . transform . Result ; import javax . xml . transform . Transformer ; import javax . xml . transform . sax . TransformerHandler ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . IncrementalSAXSource_Filter ; import org . apache . xml . dtm . ref . sax2dtm . SAX2DTM ; import org . apache . xpath . XPathContext ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . apache . xml . serializer . SerializationHandler ; public class TransformerHandlerImpl implements EntityResolver , DTDHandler , ContentHandler , ErrorHandler , LexicalHandler , TransformerHandler , DeclHandler { private boolean m_insideParse = false ; public TransformerHandlerImpl ( TransformerImpl transformer , boolean doFragment , String baseSystemID ) { super ( ) ; m_transformer = transformer ; m_baseSystemID = baseSystemID ; XPathContext xctxt = transformer . getXPathContext ( ) ; DTM dtm = xctxt . getDTM ( null , true , transformer , true , true ) ; m_dtm = dtm ; dtm . setDocumentBaseURI ( baseSystemID ) ; m_contentHandler = dtm . getContentHandler ( ) ; m_dtdHandler = dtm . getDTDHandler ( ) ; m_entityResolver = dtm . getEntityResolver ( ) ; m_errorHandler = dtm . getErrorHandler ( ) ; m_lexicalHandler = dtm . getLexicalHandler ( ) ; } protected void clearCoRoutine ( ) { clearCoRoutine ( null ) ; } protected void clearCoRoutine ( SAXException ex ) { if ( null != ex ) m_transformer . setExceptionThrown ( ex ) ; if ( m_dtm instanceof SAX2DTM ) { if ( DEBUG ) System . err . println ( "In clearCoRoutine..." ) ; try { SAX2DTM sax2dtm = ( ( SAX2DTM ) m_dtm ) ; if ( null != m_contentHandler && m_contentHandler instanceof IncrementalSAXSource_Filter ) { IncrementalSAXSource_Filter sp = ( IncrementalSAXSource_Filter ) m_contentHandler ; sp . deliverMoreNodes ( false ) ; } sax2dtm . clearCoRoutine ( true ) ; m_contentHandler = null ; m_dtdHandler = null ; m_entityResolver = null ; m_errorHandler = null ; m_lexicalHandler = null ; } catch ( Throwable throwable ) { throwable . printStackTrace ( ) ; } if ( DEBUG ) System . err . println ( "...exiting clearCoRoutine" ) ; } } public void setResult ( Result result ) throws IllegalArgumentException { if ( null == result ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_RESULT_NULL , null ) ) ; try { SerializationHandler xoh = m_transformer . createSerializationHandler ( result ) ; m_transformer . setSerializationHandler ( xoh ) ; } catch ( javax . xml . transform . TransformerException te ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_RESULT_COULD_NOT_BE_SET , null ) ) ; } m_result = result ; } public void setSystemId ( String systemID ) { m_baseSystemID = systemID ; m_dtm . setDocumentBaseURI ( systemID ) ; } public String getSystemId ( ) { return m_baseSystemID ; } public Transformer getTransformer ( ) { return m_transformer ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( m_entityResolver != null ) { return m_entityResolver . resolveEntity ( publicId , systemId ) ; } else { return null ; } } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { if ( m_dtdHandler != null ) { m_dtdHandler . notationDecl ( name , publicId , systemId ) ; } } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( m_dtdHandler != null ) { m_dtdHandler . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } } public void setDocumentLocator ( Locator locator ) { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#setDocumentLocator: " + locator . getSystemId ( ) ) ; this . m_locator = locator ; if ( null == m_baseSystemID ) { setSystemId ( locator . getSystemId ( ) ) ; } if ( m_contentHandler != null ) { m_contentHandler . setDocumentLocator ( locator ) ; } } public void startDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startDocument" ) ; m_insideParse = true ; if ( m_contentHandler != null ) { if ( DTMManager . getIncremental ( ) ) { m_transformer . setSourceTreeDocForThread ( m_dtm . getDocument ( ) ) ; int cpriority = Thread . currentThread ( ) . getPriority ( ) ; m_transformer . runTransformThread ( cpriority ) ; } m_contentHandler . startDocument ( ) ; } } public void endDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endDocument" ) ; m_insideParse = false ; if ( m_contentHandler != null ) { m_contentHandler . endDocument ( ) ; } if ( DTMManager . getIncremental ( ) ) { m_transformer . waitTransformThread ( ) ; } else { m_transformer . setSourceTreeDocForThread ( m_dtm . getDocument ( ) ) ; m_transformer . run ( ) ; } } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startPrefixMapping: " + prefix + ", " + uri ) ; if ( m_contentHandler != null ) { m_contentHandler . startPrefixMapping ( prefix , uri ) ; } } public void endPrefixMapping ( String prefix ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endPrefixMapping: " + prefix ) ; if ( m_contentHandler != null ) { m_contentHandler . endPrefixMapping ( prefix ) ; } } public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startElement: " + qName ) ; if ( m_contentHandler != null ) { m_contentHandler . startElement ( uri , localName , qName , atts ) ; } } public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endElement: " + qName ) ; if ( m_contentHandler != null ) { m_contentHandler . endElement ( uri , localName , qName ) ; } } public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#characters: " + start + ", " + length ) ; if ( m_contentHandler != null ) { m_contentHandler . characters ( ch , start , length ) ; } } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#ignorableWhitespace: " + start + ", " + length ) ; if ( m_contentHandler != null ) { m_contentHandler . ignorableWhitespace ( ch , start , length ) ; } } public void processingInstruction ( String target , String data ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#processingInstruction: " + target + ", " + data ) ; if ( m_contentHandler != null ) { m_contentHandler . processingInstruction ( target , data ) ; } } public void skippedEntity ( String name ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#skippedEntity: " + name ) ; if ( m_contentHandler != null ) { m_contentHandler . skippedEntity ( name ) ; } } public void warning ( SAXParseException e ) throws SAXException { javax . xml . transform . ErrorListener errorListener = m_transformer . getErrorListener ( ) ; if ( errorListener instanceof ErrorHandler ) { ( ( ErrorHandler ) errorListener ) . warning ( e ) ; } else { try { errorListener . warning ( new javax . xml . transform . TransformerException ( e ) ) ; } catch ( javax . xml . transform . TransformerException te ) { throw e ; } } } public void error ( SAXParseException e ) throws SAXException { javax . xml . transform . ErrorListener errorListener = m_transformer . getErrorListener ( ) ; if ( errorListener instanceof ErrorHandler ) { ( ( ErrorHandler ) errorListener ) . error ( e ) ; if ( null != m_errorHandler ) m_errorHandler . error ( e ) ; } else { try { errorListener . error ( new javax . xml . transform . TransformerException ( e ) ) ; if ( null != m_errorHandler ) m_errorHandler . error ( e ) ; } catch ( javax . xml . transform . TransformerException te ) { throw e ; } } } public void fatalError ( SAXParseException e ) throws SAXException { if ( null != m_errorHandler ) { try { m_errorHandler . fatalError ( e ) ; } catch ( SAXParseException se ) { } } javax . xml . transform . ErrorListener errorListener = m_transformer . getErrorListener ( ) ; if ( errorListener instanceof ErrorHandler ) { ( ( ErrorHandler ) errorListener ) . fatalError ( e ) ; if ( null != m_errorHandler ) m_errorHandler . fatalError ( e ) ; } else { try { errorListener . fatalError ( new javax . xml . transform . TransformerException ( e ) ) ; if ( null != m_errorHandler ) m_errorHandler . fatalError ( e ) ; } catch ( javax . xml . transform . TransformerException te ) { throw e ; } } } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startDTD: " + name + ", " + publicId + ", " + systemId ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startDTD ( name , publicId , systemId ) ; } } public void endDTD ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endDTD" ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endDTD ( ) ; } } public void startEntity ( String name ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startEntity: " + name ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startEntity ( name ) ; } } public void endEntity ( String name ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endEntity: " + name ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endEntity ( name ) ; } } public void startCDATA ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#startCDATA" ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endCDATA" ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . endCDATA ( ) ; } } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#comment: " + start + ", " + length ) ; if ( null != m_lexicalHandler ) { m_lexicalHandler . comment ( ch , start , length ) ; } } public void elementDecl ( String name , String model ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#elementDecl: " + name + ", " + model ) ; if ( null != m_declHandler ) { m_declHandler . elementDecl ( name , model ) ; } } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#attributeDecl: " + eName + ", " + aName + ", etc..." ) ; if ( null != m_declHandler ) { m_declHandler . attributeDecl ( eName , aName , type , valueDefault , value ) ; } } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#internalEntityDecl: " + name + ", " + value ) ; if ( null != m_declHandler ) { m_declHandler . internalEntityDecl ( name , value ) ; } } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#externalEntityDecl: " + name + ", " + publicId + ", " + systemId ) ; if ( null != m_declHandler ) { m_declHandler . externalEntityDecl ( name , publicId , systemId ) ; } } private static boolean DEBUG = false ; private TransformerImpl m_transformer ; private String m_baseSystemID ; private Result m_result = null ; private Locator m_locator = null ; private EntityResolver m_entityResolver = null ; private DTDHandler m_dtdHandler = null ; private ContentHandler m_contentHandler = null ; private ErrorHandler m_errorHandler = null ; private LexicalHandler m_lexicalHandler = null ; private DeclHandler m_declHandler = null ; DTM m_dtm ; } 	0
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncFalse extends Function { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return XBoolean . S_FALSE ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	1
package org . apache . xpath . compiler ; import java . util . Vector ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . res . XPATHErrorResources ; class Lexer { private Compiler m_compiler ; PrefixResolver m_namespaceContext ; XPathParser m_processor ; static final int TARGETEXTRA = 10000 ; private int m_patternMap [ ] = new int [ 100 ] ; private int m_patternMapSize ; Lexer ( Compiler compiler , PrefixResolver resolver , XPathParser xpathProcessor ) { m_compiler = compiler ; m_namespaceContext = resolver ; m_processor = xpathProcessor ; } void tokenize ( String pat ) throws javax . xml . transform . TransformerException { tokenize ( pat , null ) ; } void tokenize ( String pat , Vector targetStrings ) throws javax . xml . transform . TransformerException { m_compiler . m_currentPattern = pat ; m_patternMapSize = 0 ; m_compiler . m_opMap = new OpMapVector ( OpMap . MAXTOKENQUEUESIZE * 5 , OpMap . BLOCKTOKENQUEUESIZE * 5 , OpMap . MAPINDEX_LENGTH ) ; int nChars = pat . length ( ) ; int startSubstring = - 1 ; int posOfNSSep = - 1 ; boolean isStartOfPat = true ; boolean isAttrName = false ; boolean isNum = false ; int nesting = 0 ; for ( int i = 0 ; i < nChars ; i ++ ) { char c = pat . charAt ( i ) ; switch ( c ) { case '\"' : { if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } } startSubstring = i ; for ( i ++ ; ( i < nChars ) && ( ( c = pat . charAt ( i ) ) != '\"' ) ; i ++ ) ; if ( c == '\"' && i < nChars ) { addToTokenQueue ( pat . substring ( startSubstring , i + 1 ) ) ; startSubstring = - 1 ; } else { m_processor . error ( XPATHErrorResources . ER_EXPECTED_DOUBLE_QUOTE , null ) ; } } break ; case '\'' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } } startSubstring = i ; for ( i ++ ; ( i < nChars ) && ( ( c = pat . charAt ( i ) ) != '\'' ) ; i ++ ) ; if ( c == '\'' && i < nChars ) { addToTokenQueue ( pat . substring ( startSubstring , i + 1 ) ) ; startSubstring = - 1 ; } else { m_processor . error ( XPATHErrorResources . ER_EXPECTED_SINGLE_QUOTE , null ) ; } break ; case 0x0A : case 0x0D : case ' ' : case '\t' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } startSubstring = - 1 ; } break ; case '@' : isAttrName = true ; case '-' : if ( '-' == c ) { if ( ! ( isNum || ( startSubstring == - 1 ) ) ) { break ; } isNum = false ; } case '(' : case '[' : case ')' : case ']' : case '|' : case '/' : case '*' : case '+' : case '=' : case ',' : case '\\' : case '^' : case '!' : case '$' : case '<' : case '>' : if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; if ( - 1 != posOfNSSep ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , i ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , i ) ) ; } startSubstring = - 1 ; } else if ( ( '/' == c ) && isStartOfPat ) { isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; } else if ( '*' == c ) { isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; isAttrName = false ; } if ( 0 == nesting ) { if ( '|' == c ) { if ( null != targetStrings ) { recordTokenString ( targetStrings ) ; } isStartOfPat = true ; } } if ( ( ')' == c ) || ( ']' == c ) ) { nesting -- ; } else if ( ( '(' == c ) || ( '[' == c ) ) { nesting ++ ; } addToTokenQueue ( pat . substring ( i , i + 1 ) ) ; break ; case ':' : if ( i > 0 ) { if ( posOfNSSep == ( i - 1 ) ) { if ( startSubstring != - 1 ) { if ( startSubstring < ( i - 1 ) ) addToTokenQueue ( pat . substring ( startSubstring , i - 1 ) ) ; } isNum = false ; isAttrName = false ; startSubstring = - 1 ; posOfNSSep = - 1 ; addToTokenQueue ( pat . substring ( i - 1 , i + 1 ) ) ; break ; } else { posOfNSSep = i ; } } default : if ( - 1 == startSubstring ) { startSubstring = i ; isNum = Character . isDigit ( c ) ; } else if ( isNum ) { isNum = Character . isDigit ( c ) ; } } } if ( startSubstring != - 1 ) { isNum = false ; isStartOfPat = mapPatternElemPos ( nesting , isStartOfPat , isAttrName ) ; if ( ( - 1 != posOfNSSep ) || ( ( m_namespaceContext != null ) && ( m_namespaceContext . handlesNullPrefixes ( ) ) ) ) { posOfNSSep = mapNSTokens ( pat , startSubstring , posOfNSSep , nChars ) ; } else { addToTokenQueue ( pat . substring ( startSubstring , nChars ) ) ; } } if ( 0 == m_compiler . getTokenQueueSize ( ) ) { m_processor . error ( XPATHErrorResources . ER_EMPTY_EXPRESSION , null ) ; } else if ( null != targetStrings ) { recordTokenString ( targetStrings ) ; } m_processor . m_queueMark = 0 ; } private boolean mapPatternElemPos ( int nesting , boolean isStart , boolean isAttrName ) { if ( 0 == nesting ) { if ( m_patternMapSize >= m_patternMap . length ) { int patternMap [ ] = m_patternMap ; int len = m_patternMap . length ; m_patternMap = new int [ m_patternMapSize + 100 ] ; System . arraycopy ( patternMap , 0 , m_patternMap , 0 , len ) ; } if ( ! isStart ) { m_patternMap [ m_patternMapSize - 1 ] -= TARGETEXTRA ; } m_patternMap [ m_patternMapSize ] = ( m_compiler . getTokenQueueSize ( ) - ( isAttrName ? 1 : 0 ) ) + TARGETEXTRA ; m_patternMapSize ++ ; isStart = false ; } return isStart ; } private int getTokenQueuePosFromMap ( int i ) { int pos = m_patternMap [ i ] ; return ( pos >= TARGETEXTRA ) ? ( pos - TARGETEXTRA ) : pos ; } private final void resetTokenMark ( int mark ) { int qsz = m_compiler . getTokenQueueSize ( ) ; m_processor . m_queueMark = ( mark > 0 ) ? ( ( mark <= qsz ) ? mark - 1 : mark ) : 0 ; if ( m_processor . m_queueMark < qsz ) { m_processor . m_token = ( String ) m_compiler . getTokenQueue ( ) . elementAt ( m_processor . m_queueMark ++ ) ; m_processor . m_tokenChar = m_processor . m_token . charAt ( 0 ) ; } else { m_processor . m_token = null ; m_processor . m_tokenChar = 0 ; } } final int getKeywordToken ( String key ) { int tok ; try { Integer itok = ( Integer ) Keywords . m_keywords . get ( key ) ; tok = ( null != itok ) ? itok . intValue ( ) : 0 ; } catch ( NullPointerException npe ) { tok = 0 ; } catch ( ClassCastException cce ) { tok = 0 ; } return tok ; } private void recordTokenString ( Vector targetStrings ) { int tokPos = getTokenQueuePosFromMap ( m_patternMapSize - 1 ) ; resetTokenMark ( tokPos + 1 ) ; if ( m_processor . lookahead ( '(' , 1 ) ) { int tok = getKeywordToken ( m_processor . m_token ) ; switch ( tok ) { case OpCodes . NODETYPE_COMMENT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_COMMENT ) ; break ; case OpCodes . NODETYPE_TEXT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_TEXT ) ; break ; case OpCodes . NODETYPE_NODE : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; case OpCodes . NODETYPE_ROOT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ROOT ) ; break ; case OpCodes . NODETYPE_ANYELEMENT : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; case OpCodes . NODETYPE_PI : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; break ; default : targetStrings . addElement ( PsuedoNames . PSEUDONAME_ANY ) ; } } else { if ( m_processor . tokenIs ( '@' ) ) { tokPos ++ ; resetTokenMark ( tokPos + 1 ) ; } if ( m_processor . lookahead ( ':' , 1 ) ) { tokPos += 2 ; } targetStrings . addElement ( m_compiler . getTokenQueue ( ) . elementAt ( tokPos ) ) ; } } private final void addToTokenQueue ( String s ) { m_compiler . getTokenQueue ( ) . addElement ( s ) ; } private int mapNSTokens ( String pat , int startSubstring , int posOfNSSep , int posOfScan ) throws javax . xml . transform . TransformerException { String prefix = "" ; if ( ( startSubstring >= 0 ) && ( posOfNSSep >= 0 ) ) { prefix = pat . substring ( startSubstring , posOfNSSep ) ; } String uName ; if ( ( null != m_namespaceContext ) && ! prefix . equals ( "*" ) && ! prefix . equals ( "xmlns" ) ) { try { if ( prefix . length ( ) > 0 ) uName = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; else { if ( false ) { addToTokenQueue ( ":" ) ; String s = pat . substring ( posOfNSSep + 1 , posOfScan ) ; if ( s . length ( ) > 0 ) addToTokenQueue ( s ) ; return - 1 ; } else { uName = ( ( PrefixResolver ) m_namespaceContext ) . getNamespaceForPrefix ( prefix ) ; } } } catch ( ClassCastException cce ) { uName = m_namespaceContext . getNamespaceForPrefix ( prefix ) ; } } else { uName = prefix ; } if ( ( null != uName ) && ( uName . length ( ) > 0 ) ) { addToTokenQueue ( uName ) ; addToTokenQueue ( ":" ) ; String s = pat . substring ( posOfNSSep + 1 , posOfScan ) ; if ( s . length ( ) > 0 ) addToTokenQueue ( s ) ; } else { m_processor . error ( XPATHErrorResources . ER_PREFIX_MUST_RESOLVE , new String [ ] { prefix } ) ; } return - 1 ; } } 	0
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class LiteralElement extends Instruction { private String _name ; private LiteralElement _literalElemParent ; private Vector _attributeElements = null ; private Hashtable _accessedPrefixes = null ; private final static String XMLNS_STRING = "xmlns" ; public QName getName ( ) { return _qname ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "LiteralElement name = " + _name ) ; displayContents ( indent + IndentIncrement ) ; } private String accessedNamespace ( String prefix ) { if ( _accessedPrefixes == null ) return ( null ) ; else return ( ( String ) _accessedPrefixes . get ( prefix ) ) ; } public void registerNamespace ( String prefix , String uri , SymbolTable stable , boolean declared ) { if ( _literalElemParent != null ) { final String parentUri = _literalElemParent . accessedNamespace ( prefix ) ; if ( parentUri == null ) { _literalElemParent . registerNamespace ( prefix , uri , stable , declared ) ; return ; } if ( parentUri . equals ( uri ) ) return ; } if ( _accessedPrefixes == null ) { _accessedPrefixes = new Hashtable ( ) ; } else { if ( ! declared ) { final String old = ( String ) _accessedPrefixes . get ( prefix ) ; if ( old != null ) { if ( old . equals ( uri ) ) return ; else prefix = stable . generateNamespacePrefix ( ) ; } } } if ( ! prefix . equals ( "xml" ) ) { _accessedPrefixes . put ( prefix , uri ) ; } } private String translateQName ( QName qname , SymbolTable stable ) { String localname = qname . getLocalPart ( ) ; String prefix = qname . getPrefix ( ) ; if ( prefix == null ) prefix = Constants . EMPTYSTRING ; else if ( prefix . equals ( XMLNS_STRING ) ) return ( XMLNS_STRING ) ; final String alternative = stable . lookupPrefixAlias ( prefix ) ; if ( alternative != null ) { stable . excludeNamespaces ( prefix ) ; prefix = alternative ; } String uri = lookupNamespace ( prefix ) ; if ( uri == null ) return ( localname ) ; registerNamespace ( prefix , uri , stable , false ) ; if ( prefix != Constants . EMPTYSTRING ) return ( prefix + ":" + localname ) ; else return ( localname ) ; } public void addAttribute ( SyntaxTreeNode attribute ) { if ( _attributeElements == null ) { _attributeElements = new Vector ( 2 ) ; } _attributeElements . add ( attribute ) ; } public void setFirstAttribute ( SyntaxTreeNode attribute ) { if ( _attributeElements == null ) { _attributeElements = new Vector ( 2 ) ; } _attributeElements . insertElementAt ( attribute , 0 ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _attributeElements != null ) { final int count = _attributeElements . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode node = ( SyntaxTreeNode ) _attributeElements . elementAt ( i ) ; node . typeCheck ( stable ) ; } } typeCheckContents ( stable ) ; return Type . Void ; } public Enumeration getNamespaceScope ( SyntaxTreeNode node ) { Hashtable all = new Hashtable ( ) ; while ( node != null ) { Hashtable mapping = node . getPrefixMapping ( ) ; if ( mapping != null ) { Enumeration prefixes = mapping . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; if ( ! all . containsKey ( prefix ) ) { all . put ( prefix , mapping . get ( prefix ) ) ; } } } node = node . getParent ( ) ; } return ( all . keys ( ) ) ; } public void parseContents ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; stable . setCurrentNode ( this ) ; SyntaxTreeNode _literalElemParent = getParent ( ) ; while ( _literalElemParent != null && ! ( _literalElemParent instanceof LiteralElement ) ) { _literalElemParent = _literalElemParent . getParent ( ) ; } if ( ! ( _literalElemParent instanceof LiteralElement ) ) { _literalElemParent = null ; } _name = translateQName ( _qname , stable ) ; final int count = _attributes . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final QName qname = parser . getQName ( _attributes . getQName ( i ) ) ; final String uri = qname . getNamespace ( ) ; final String val = _attributes . getValue ( i ) ; if ( qname == parser . getUseAttributeSets ( ) ) { setFirstAttribute ( new UseAttributeSets ( val , parser ) ) ; } else if ( qname == parser . getExtensionElementPrefixes ( ) ) { stable . excludeNamespaces ( val ) ; } else if ( qname == parser . getExcludeResultPrefixes ( ) ) { stable . excludeNamespaces ( val ) ; } else { final String prefix = qname . getPrefix ( ) ; if ( prefix != null && prefix . equals ( XMLNS_PREFIX ) || prefix == null && qname . getLocalPart ( ) . equals ( "xmlns" ) || uri != null && uri . equals ( XSLT_URI ) ) { continue ; } final String name = translateQName ( qname , stable ) ; LiteralAttribute attr = new LiteralAttribute ( name , val , parser ) ; addAttribute ( attr ) ; attr . setParent ( this ) ; attr . parseContents ( parser ) ; } } final Enumeration include = getNamespaceScope ( this ) ; while ( include . hasMoreElements ( ) ) { final String prefix = ( String ) include . nextElement ( ) ; if ( ! prefix . equals ( "xml" ) ) { final String uri = lookupNamespace ( prefix ) ; if ( uri != null && ! stable . isExcludedNamespace ( uri ) ) { registerNamespace ( prefix , uri , stable , true ) ; } } } parseChildren ( parser ) ; for ( int i = 0 ; i < count ; i ++ ) { final QName qname = parser . getQName ( _attributes . getQName ( i ) ) ; final String val = _attributes . getValue ( i ) ; if ( qname == parser . getExtensionElementPrefixes ( ) ) { stable . unExcludeNamespaces ( val ) ; } else if ( qname == parser . getExcludeResultPrefixes ( ) ) { stable . unExcludeNamespaces ( val ) ; } } } protected boolean contextDependent ( ) { return dependentContents ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _name ) ) ; il . append ( DUP2 ) ; il . append ( methodGen . startElement ( ) ) ; for ( int i = 0 ; i < elementCount ( ) ; i ++ ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) elementAt ( i ) ; if ( item instanceof Variable ) { item . translate ( classGen , methodGen ) ; removeElement ( item ) ; } } if ( _accessedPrefixes != null ) { boolean declaresDefaultNS = false ; Enumeration e = _accessedPrefixes . keys ( ) ; while ( e . hasMoreElements ( ) ) { final String prefix = ( String ) e . nextElement ( ) ; final String uri = ( String ) _accessedPrefixes . get ( prefix ) ; if ( uri != Constants . EMPTYSTRING || prefix != Constants . EMPTYSTRING ) { if ( prefix == Constants . EMPTYSTRING ) { declaresDefaultNS = true ; } il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , prefix ) ) ; il . append ( new PUSH ( cpg , uri ) ) ; il . append ( methodGen . namespace ( ) ) ; } } if ( ! declaresDefaultNS && ( _parent instanceof XslElement ) && ( ( XslElement ) _parent ) . declaresDefaultNS ( ) ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; il . append ( methodGen . namespace ( ) ) ; } } if ( _attributeElements != null ) { final int count = _attributeElements . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode node = ( SyntaxTreeNode ) _attributeElements . elementAt ( i ) ; node . translate ( classGen , methodGen ) ; } } translateContents ( classGen , methodGen ) ; il . append ( methodGen . endElement ( ) ) ; } } 	1
package org . apache . xml . utils ; public class XMLStringFactoryDefault extends XMLStringFactory { private static final XMLStringDefault EMPTY_STR = new XMLStringDefault ( "" ) ; public XMLString newstr ( String string ) { return new XMLStringDefault ( string ) ; } public XMLString newstr ( FastStringBuffer fsb , int start , int length ) { return new XMLStringDefault ( fsb . getString ( start , length ) ) ; } public XMLString newstr ( char [ ] string , int start , int length ) { return new XMLStringDefault ( new String ( string , start , length ) ) ; } public XMLString emptystr ( ) { return EMPTY_STR ; } } 	0
package org . apache . xpath ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . utils . NodeVector ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class NodeSetDTM extends NodeVector implements DTMIterator , Cloneable { public NodeSetDTM ( DTMManager dtmManager ) { super ( ) ; m_manager = dtmManager ; } public NodeSetDTM ( int blocksize , int dummy , DTMManager dtmManager ) { super ( blocksize ) ; m_manager = dtmManager ; } public NodeSetDTM ( NodeSetDTM nodelist ) { super ( ) ; m_manager = nodelist . getDTMManager ( ) ; m_root = nodelist . getRoot ( ) ; addNodes ( ( DTMIterator ) nodelist ) ; } public NodeSetDTM ( DTMIterator ni ) { super ( ) ; m_manager = ni . getDTMManager ( ) ; m_root = ni . getRoot ( ) ; addNodes ( ni ) ; } public NodeSetDTM ( NodeIterator iterator , XPathContext xctxt ) { super ( ) ; Node node ; m_manager = xctxt . getDTMManager ( ) ; while ( null != ( node = iterator . nextNode ( ) ) ) { int handle = xctxt . getDTMHandleFromNode ( node ) ; addNodeInDocOrder ( handle , xctxt ) ; } } public NodeSetDTM ( NodeList nodeList , XPathContext xctxt ) { super ( ) ; m_manager = xctxt . getDTMManager ( ) ; int n = nodeList . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Node node = nodeList . item ( i ) ; int handle = xctxt . getDTMHandleFromNode ( node ) ; addNode ( handle ) ; } } public NodeSetDTM ( int node , DTMManager dtmManager ) { super ( ) ; m_manager = dtmManager ; addNode ( node ) ; } public void setEnvironment ( Object environment ) { } public int getRoot ( ) { if ( DTM . NULL == m_root ) { if ( size ( ) > 0 ) return item ( 0 ) ; else return DTM . NULL ; } else return m_root ; } public void setRoot ( int context , Object environment ) { } public Object clone ( ) throws CloneNotSupportedException { NodeSetDTM clone = ( NodeSetDTM ) super . clone ( ) ; return clone ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { NodeSetDTM clone = ( NodeSetDTM ) clone ( ) ; clone . reset ( ) ; return clone ; } public void reset ( ) { m_next = 0 ; } public int getWhatToShow ( ) { return DTMFilter . SHOW_ALL & ~ DTMFilter . SHOW_ENTITY_REFERENCE ; } public DTMFilter getFilter ( ) { return null ; } public boolean getExpandEntityReferences ( ) { return true ; } public DTM getDTM ( int nodeHandle ) { return m_manager . getDTM ( nodeHandle ) ; } DTMManager m_manager ; public DTMManager getDTMManager ( ) { return m_manager ; } public int nextNode ( ) { if ( ( m_next ) < this . size ( ) ) { int next = this . elementAt ( m_next ) ; m_next ++ ; return next ; } else return DTM . NULL ; } public int previousNode ( ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_ITERATE , null ) ) ; if ( ( m_next - 1 ) > 0 ) { m_next -- ; return this . elementAt ( m_next ) ; } else return DTM . NULL ; } public void detach ( ) { } public void allowDetachToRelease ( boolean allowRelease ) { } public boolean isFresh ( ) { return ( m_next == 0 ) ; } public void runTo ( int index ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_INDEX , null ) ) ; if ( ( index >= 0 ) && ( m_next < m_firstFree ) ) m_next = index ; else m_next = m_firstFree - 1 ; } public int item ( int index ) { runTo ( index ) ; return this . elementAt ( index ) ; } public int getLength ( ) { runTo ( - 1 ) ; return this . size ( ) ; } public void addNode ( int n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; this . addElement ( n ) ; } public void insertNode ( int n , int pos ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; insertElementAt ( n , pos ) ; } public void removeNode ( int n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; this . removeElement ( n ) ; } public void addNodes ( DTMIterator iterator ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; if ( null != iterator ) { int obj ; while ( DTM . NULL != ( obj = iterator . nextNode ( ) ) ) { addElement ( obj ) ; } } } public void addNodesInDocOrder ( DTMIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; int node ; while ( DTM . NULL != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } } public int addNodeInDocOrder ( int node , boolean test , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; int insertIndex = - 1 ; if ( test ) { int size = size ( ) , i ; for ( i = size - 1 ; i >= 0 ; i -- ) { int child = elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } DTM dtm = support . getDTM ( node ) ; if ( ! dtm . isNodeAfter ( node , child ) ) { break ; } } if ( i != - 2 ) { insertIndex = i + 1 ; insertElementAt ( node , insertIndex ) ; } } else { insertIndex = this . size ( ) ; boolean foundit = false ; for ( int i = 0 ; i < insertIndex ; i ++ ) { if ( i == node ) { foundit = true ; break ; } } if ( ! foundit ) addElement ( node ) ; } return insertIndex ; } public int addNodeInDocOrder ( int node , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; return addNodeInDocOrder ( node , true , support ) ; } public int size ( ) { return super . size ( ) ; } public void addElement ( int value ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . addElement ( value ) ; } public void insertElementAt ( int value , int at ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . insertElementAt ( value , at ) ; } public void appendNodes ( NodeVector nodes ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . appendNodes ( nodes ) ; } public void removeAllElements ( ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . removeAllElements ( ) ; } public boolean removeElement ( int s ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; return super . removeElement ( s ) ; } public void removeElementAt ( int i ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . removeElementAt ( i ) ; } public void setElementAt ( int node , int index ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . setElementAt ( node , index ) ; } public void setItem ( int node , int index ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; super . setElementAt ( node , index ) ; } public int elementAt ( int i ) { runTo ( i ) ; return super . elementAt ( i ) ; } public boolean contains ( int s ) { runTo ( - 1 ) ; return super . contains ( s ) ; } public int indexOf ( int elem , int index ) { runTo ( - 1 ) ; return super . indexOf ( elem , index ) ; } public int indexOf ( int elem ) { runTo ( - 1 ) ; return super . indexOf ( elem ) ; } transient protected int m_next = 0 ; public int getCurrentPos ( ) { return m_next ; } public void setCurrentPos ( int i ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_INDEX , null ) ) ; m_next = i ; } public int getCurrentNode ( ) { if ( ! m_cacheNodes ) throw new RuntimeException ( "This NodeSetDTM can not do indexing or counting functions!" ) ; int saved = m_next ; int current = ( m_next > 0 ) ? m_next - 1 : m_next ; int n = ( current < m_firstFree ) ? elementAt ( current ) : DTM . NULL ; m_next = saved ; return n ; } transient protected boolean m_mutable = true ; transient protected boolean m_cacheNodes = true ; protected int m_root = DTM . NULL ; public boolean getShouldCacheNodes ( ) { return m_cacheNodes ; } public void setShouldCacheNodes ( boolean b ) { if ( ! isFresh ( ) ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANNOT_CALL_SETSHOULDCACHENODE , null ) ) ; m_cacheNodes = b ; m_mutable = true ; } public boolean isMutable ( ) { return m_mutable ; } transient private int m_last = 0 ; public int getLast ( ) { return m_last ; } public void setLast ( int last ) { m_last = last ; } public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return - 1 ; } } 	1
package org . apache . xml . dtm . ref ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; public interface CoroutineParser { public int getParserCoroutineID ( ) ; public CoroutineManager getCoroutineManager ( ) ; public void setContentHandler ( ContentHandler handler ) ; public void setLexHandler ( org . xml . sax . ext . LexicalHandler handler ) ; public Object doParse ( InputSource source , int appCoroutine ) ; public Object doMore ( boolean parsemore , int appCoroutine ) ; public void doTerminate ( int appCoroutine ) ; public void init ( CoroutineManager co , int appCoroutineID , XMLReader parser ) ; } 	0
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExtensionNamespaceSupport ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class ElemExsltFunction extends ElemTemplate { private boolean m_isResultSet = false ; private XObject m_result ; private int m_callerFrameSize = 0 ; public int getXSLToken ( ) { return Constants . EXSLT_ELEMNAME_FUNCTION ; } public String getNodeName ( ) { return Constants . EXSLT_ELEMNAME_FUNCTION_STRING ; } public void execute ( TransformerImpl transformer , XObject [ ] args ) throws TransformerException { m_isResultSet = false ; m_result = null ; XPathContext xctxt = transformer . getXPathContext ( ) ; VariableStack vars = xctxt . getVarStack ( ) ; int oldStackFrame = vars . getStackFrame ( ) ; vars . setStackFrame ( m_callerFrameSize + oldStackFrame ) ; NodeList children = this . getChildNodes ( ) ; int numparams = 0 ; for ( int i = 0 ; i < args . length ; i ++ ) { Node child = children . item ( i ) ; if ( children . item ( i ) instanceof ElemParam ) { numparams ++ ; ElemParam param = ( ElemParam ) children . item ( i ) ; vars . setLocalVariable ( param . getIndex ( ) , args [ i ] ) ; } } if ( numparams < args . length ) throw new TransformerException ( "function called with too many args" ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; transformer . executeChildTemplates ( this , true ) ; vars . setStackFrame ( oldStackFrame ) ; m_callerFrameSize = 0 ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; String namespace = getName ( ) . getNamespace ( ) ; String handlerClass = "org.apache.xalan.extensions.ExtensionHandlerExsltFunction" ; Object [ ] args = { namespace , sroot } ; ExtensionNamespaceSupport extNsSpt = new ExtensionNamespaceSupport ( namespace , handlerClass , args ) ; sroot . getExtensionNamespacesManager ( ) . registerExtension ( extNsSpt ) ; if ( ! ( namespace . equals ( Constants . S_EXSLT_FUNCTIONS_URL ) ) ) { namespace = Constants . S_EXSLT_FUNCTIONS_URL ; args = new Object [ ] { namespace , sroot } ; extNsSpt = new ExtensionNamespaceSupport ( namespace , handlerClass , args ) ; sroot . getExtensionNamespacesManager ( ) . registerExtension ( extNsSpt ) ; } } public XObject getResult ( ) { return m_result ; } public void setResult ( XObject result ) { m_isResultSet = true ; m_result = result ; } public boolean isResultSet ( ) { return m_isResultSet ; } public void clearResult ( ) { m_isResultSet = false ; m_result = null ; } public void setCallerFrameSize ( int callerFrameSize ) { m_callerFrameSize = callerFrameSize ; } } 	1
package org . apache . xpath . compiler ; public class XPathDumper { } 	0
package org . apache . xpath . operations ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . QName ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . axes . PathComponent ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class Variable extends Expression implements PathComponent { private boolean m_fixUpWasCalled = false ; protected QName m_qname ; protected int m_index ; public void setIndex ( int index ) { m_index = index ; } public int getIndex ( ) { return m_index ; } public void setIsGlobal ( boolean isGlobal ) { m_isGlobal = isGlobal ; } public boolean getGlobal ( ) { return m_isGlobal ; } protected boolean m_isGlobal = false ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_fixUpWasCalled = true ; int sz = vars . size ( ) ; for ( int i = vars . size ( ) - 1 ; i >= 0 ; i -- ) { QName qn = ( QName ) vars . elementAt ( i ) ; if ( qn . equals ( m_qname ) ) { if ( i < globalsSize ) { m_isGlobal = true ; m_index = i ; } else { m_index = i - globalsSize ; } return ; } } java . lang . String msg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_COULD_NOT_FIND_VAR , new Object [ ] { m_qname . toString ( ) } ) ; TransformerException te = new TransformerException ( msg , this ) ; throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } public void setQName ( QName qname ) { m_qname = qname ; } public QName getQName ( ) { return m_qname ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return execute ( xctxt , false ) ; } public XObject execute ( XPathContext xctxt , boolean destructiveOK ) throws javax . xml . transform . TransformerException { org . apache . xml . utils . PrefixResolver xprefixResolver = xctxt . getNamespaceContext ( ) ; if ( m_fixUpWasCalled ) { XObject result ; if ( m_isGlobal ) result = xctxt . getVarStack ( ) . getGlobalVariable ( xctxt , m_index , destructiveOK ) ; else result = xctxt . getVarStack ( ) . getLocalVariable ( xctxt , m_index , destructiveOK ) ; if ( null == result ) { warn ( xctxt , XPATHErrorResources . WG_ILLEGAL_VARIABLE_REFERENCE , new Object [ ] { m_qname . getLocalPart ( ) } ) ; result = new XNodeSet ( xctxt . getDTMManager ( ) ) ; } return result ; } else { synchronized ( this ) { org . apache . xalan . templates . ElemVariable vvar = getElemVariable ( ) ; if ( null != vvar ) { m_index = vvar . getIndex ( ) ; m_isGlobal = vvar . getIsTopLevel ( ) ; m_fixUpWasCalled = true ; return execute ( xctxt ) ; } } throw new javax . xml . transform . TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VAR_NOT_RESOLVABLE , new Object [ ] { m_qname . toString ( ) } ) ) ; } } public org . apache . xalan . templates . ElemVariable getElemVariable ( ) { org . apache . xpath . ExpressionNode owner = getExpressionOwner ( ) ; if ( null != owner && owner instanceof org . apache . xalan . templates . ElemTemplateElement ) { org . apache . xalan . templates . ElemVariable vvar ; org . apache . xalan . templates . ElemTemplateElement prev = ( org . apache . xalan . templates . ElemTemplateElement ) owner ; if ( ! ( prev instanceof org . apache . xalan . templates . Stylesheet ) ) { while ( ! ( prev . getParentNode ( ) instanceof org . apache . xalan . templates . Stylesheet ) ) { org . apache . xalan . templates . ElemTemplateElement savedprev = prev ; while ( null != ( prev = prev . getPreviousSiblingElem ( ) ) ) { if ( prev instanceof org . apache . xalan . templates . ElemVariable ) { vvar = ( org . apache . xalan . templates . ElemVariable ) prev ; if ( vvar . getName ( ) . equals ( m_qname ) ) { return vvar ; } } } prev = savedprev . getParentElem ( ) ; } } vvar = prev . getStylesheetRoot ( ) . getVariableOrParamComposed ( m_qname ) ; if ( null != vvar ) { return vvar ; } } return null ; } public boolean isStableNumber ( ) { return true ; } public int getAnalysisBits ( ) { org . apache . xalan . templates . ElemVariable vvar = getElemVariable ( ) ; if ( null != vvar ) { XPath xpath = vvar . getSelect ( ) ; if ( null != xpath ) { Expression expr = xpath . getExpression ( ) ; if ( null != expr && expr instanceof PathComponent ) { return ( ( PathComponent ) expr ) . getAnalysisBits ( ) ; } } } return WalkerFactory . BIT_FILTER ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { visitor . visitVariableRef ( owner , this ) ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_qname . equals ( ( ( Variable ) expr ) . m_qname ) ) return false ; if ( getElemVariable ( ) != ( ( Variable ) expr ) . getElemVariable ( ) ) return false ; return true ; } static final java . lang . String PSUEDOVARNAMESPACE = "http://xml.apache.org/xalan/psuedovar" ; public boolean isPsuedoVarRef ( ) { java . lang . String ns = m_qname . getNamespaceURI ( ) ; if ( ( null != ns ) && ns . equals ( PSUEDOVARNAMESPACE ) ) { if ( m_qname . getLocalName ( ) . startsWith ( "#" ) ) return true ; } return false ; } } 	1
package org . apache . xml . dtm . ref ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMException ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . dom2dtm . DOM2DTM ; import org . apache . xml . dtm . ref . sax2dtm . SAX2DTM ; import org . apache . xml . dtm . ref . sax2dtm . SAX2RTFDTM ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . XMLStringFactory ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . xml . sax . InputSource ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class DTMManagerDefault extends DTMManager { private static final boolean DUMPTREE = false ; private static final boolean DEBUG = false ; protected DTM m_dtms [ ] = new DTM [ 256 ] ; int m_dtm_offsets [ ] = new int [ 256 ] ; synchronized public void addDTM ( DTM dtm , int id ) { addDTM ( dtm , id , 0 ) ; } synchronized public void addDTM ( DTM dtm , int id , int offset ) { if ( id >= IDENT_MAX_DTMS ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } int oldlen = m_dtms . length ; if ( oldlen <= id ) { int newlen = Math . min ( ( id + 256 ) , IDENT_MAX_DTMS ) ; DTM new_m_dtms [ ] = new DTM [ newlen ] ; System . arraycopy ( m_dtms , 0 , new_m_dtms , 0 , oldlen ) ; m_dtms = new_m_dtms ; int new_m_dtm_offsets [ ] = new int [ newlen ] ; System . arraycopy ( m_dtm_offsets , 0 , new_m_dtm_offsets , 0 , oldlen ) ; m_dtm_offsets = new_m_dtm_offsets ; } m_dtms [ id ] = dtm ; m_dtm_offsets [ id ] = offset ; dtm . documentRegistration ( ) ; } synchronized public int getFirstFreeDTMID ( ) { int n = m_dtms . length ; for ( int i = 1 ; i < n ; i ++ ) { if ( null == m_dtms [ i ] ) { return i ; } } return n ; } private ExpandedNameTable m_expandedNameTable = new ExpandedNameTable ( ) ; public DTMManagerDefault ( ) { } synchronized public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing ) { if ( DEBUG && null != source ) System . out . println ( "Starting " + ( unique ? "UNIQUE" : "shared" ) + " source: " + source . getSystemId ( ) ) ; XMLStringFactory xstringFactory = m_xsf ; int dtmPos = getFirstFreeDTMID ( ) ; int documentID = dtmPos << IDENT_DTM_NODE_BITS ; if ( ( null != source ) && source instanceof DOMSource ) { DOM2DTM dtm = new DOM2DTM ( this , ( DOMSource ) source , documentID , whiteSpaceFilter , xstringFactory , doIndexing ) ; addDTM ( dtm , dtmPos , 0 ) ; return dtm ; } else { boolean isSAXSource = ( null != source ) ? ( source instanceof SAXSource ) : true ; boolean isStreamSource = ( null != source ) ? ( source instanceof StreamSource ) : false ; if ( isSAXSource || isStreamSource ) { XMLReader reader ; InputSource xmlSource ; if ( null == source ) { xmlSource = null ; reader = null ; } else { reader = getXMLReader ( source ) ; xmlSource = SAXSource . sourceToInputSource ( source ) ; String urlOfSource = xmlSource . getSystemId ( ) ; if ( null != urlOfSource ) { try { urlOfSource = SystemIDResolver . getAbsoluteURI ( urlOfSource ) ; } catch ( Exception e ) { System . err . println ( "Can not absolutize URL: " + urlOfSource ) ; } xmlSource . setSystemId ( urlOfSource ) ; } } SAX2DTM dtm ; if ( source == null && unique && ! incremental && ! doIndexing ) { dtm = new SAX2RTFDTM ( this , source , documentID , whiteSpaceFilter , xstringFactory , doIndexing ) ; } else { dtm = new SAX2DTM ( this , source , documentID , whiteSpaceFilter , xstringFactory , doIndexing ) ; } addDTM ( dtm , dtmPos , 0 ) ; boolean haveXercesParser = ( null != reader ) && ( reader . getClass ( ) . getName ( ) . equals ( "org.apache.xerces.parsers.SAXParser" ) ) ; if ( haveXercesParser ) incremental = true ; if ( m_incremental && incremental ) { IncrementalSAXSource coParser = null ; if ( haveXercesParser ) { try { coParser = org . apache . xml . dtm . ref . IncrementalSAXSource_Xerces . createIncrementalSAXSource ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; coParser = null ; } } if ( coParser == null ) { if ( null == reader ) coParser = new IncrementalSAXSource_Filter ( ) ; else { IncrementalSAXSource_Filter filter = new IncrementalSAXSource_Filter ( ) ; filter . setXMLReader ( reader ) ; coParser = filter ; } } dtm . setIncrementalSAXSource ( coParser ) ; if ( null == xmlSource ) { return dtm ; } if ( null == reader . getErrorHandler ( ) ) reader . setErrorHandler ( dtm ) ; reader . setDTDHandler ( dtm ) ; try { coParser . startParse ( xmlSource ) ; } catch ( RuntimeException re ) { dtm . clearCoRoutine ( ) ; throw re ; } catch ( Exception e ) { dtm . clearCoRoutine ( ) ; throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } else { if ( null == reader ) { return dtm ; } reader . setContentHandler ( dtm ) ; reader . setDTDHandler ( dtm ) ; if ( null == reader . getErrorHandler ( ) ) reader . setErrorHandler ( dtm ) ; try { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , dtm ) ; } catch ( SAXNotRecognizedException e ) { } catch ( SAXNotSupportedException e ) { } try { reader . parse ( xmlSource ) ; } catch ( RuntimeException re ) { dtm . clearCoRoutine ( ) ; throw re ; } catch ( Exception e ) { dtm . clearCoRoutine ( ) ; throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } if ( DUMPTREE ) { System . out . println ( "Dumping SAX2DOM" ) ; dtm . dumpDTM ( System . err ) ; } return dtm ; } else { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NOT_SUPPORTED , new Object [ ] { source } ) ) ; } } } synchronized public int getDTMHandleFromNode ( org . w3c . dom . Node node ) { if ( null == node ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NODE_NON_NULL , null ) ) ; if ( node instanceof org . apache . xml . dtm . ref . DTMNodeProxy ) return ( ( org . apache . xml . dtm . ref . DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; else { int max = m_dtms . length ; for ( int i = 0 ; i < max ; i ++ ) { DTM thisDTM = m_dtms [ i ] ; if ( ( null != thisDTM ) && thisDTM instanceof DOM2DTM ) { int handle = ( ( DOM2DTM ) thisDTM ) . getHandleOfNode ( node ) ; if ( handle != DTM . NULL ) return handle ; } } Node root = node ; Node p = ( root . getNodeType ( ) == Node . ATTRIBUTE_NODE ) ? ( ( org . w3c . dom . Attr ) root ) . getOwnerElement ( ) : root . getParentNode ( ) ; for ( ; p != null ; p = p . getParentNode ( ) ) { root = p ; } DOM2DTM dtm = ( DOM2DTM ) getDTM ( new javax . xml . transform . dom . DOMSource ( root ) , false , null , true , true ) ; int handle ; if ( node instanceof org . apache . xml . dtm . ref . dom2dtm . DOM2DTMdefaultNamespaceDeclarationNode ) { handle = dtm . getHandleOfNode ( ( ( org . w3c . dom . Attr ) node ) . getOwnerElement ( ) ) ; handle = dtm . getAttributeNode ( handle , node . getNamespaceURI ( ) , node . getLocalName ( ) ) ; } else handle = ( ( DOM2DTM ) dtm ) . getHandleOfNode ( node ) ; if ( DTM . NULL == handle ) throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_RESOLVE_NODE , null ) ) ; return handle ; } } synchronized public XMLReader getXMLReader ( Source inputSource ) { try { XMLReader reader = ( inputSource instanceof SAXSource ) ? ( ( SAXSource ) inputSource ) . getXMLReader ( ) : null ; if ( null == reader ) { try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) reader = XMLReaderFactory . createXMLReader ( ) ; } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } return reader ; } catch ( org . xml . sax . SAXException se ) { throw new DTMException ( se . getMessage ( ) , se ) ; } } synchronized public DTM getDTM ( int nodeHandle ) { try { return m_dtms [ nodeHandle > > > IDENT_DTM_NODE_BITS ] ; } catch ( java . lang . ArrayIndexOutOfBoundsException e ) { if ( nodeHandle == DTM . NULL ) return null ; else throw e ; } } synchronized public int getDTMIdentity ( DTM dtm ) { if ( dtm instanceof DTMDefaultBase ) { DTMDefaultBase dtmdb = ( DTMDefaultBase ) dtm ; if ( dtmdb . getManager ( ) == this ) return dtmdb . getDTMIDs ( ) . elementAt ( 0 ) ; else return - 1 ; } int n = m_dtms . length ; for ( int i = 0 ; i < n ; i ++ ) { DTM tdtm = m_dtms [ i ] ; if ( tdtm == dtm && m_dtm_offsets [ i ] == 0 ) return i << IDENT_DTM_NODE_BITS ; } return - 1 ; } synchronized public boolean release ( DTM dtm , boolean shouldHardDelete ) { if ( DEBUG ) { System . out . println ( "Releasing " + ( shouldHardDelete ? "HARD" : "soft" ) + " dtm=" + dtm . getDocumentBaseURI ( ) ) ; } if ( dtm instanceof SAX2DTM ) { ( ( SAX2DTM ) dtm ) . clearCoRoutine ( ) ; } if ( dtm instanceof DTMDefaultBase ) { org . apache . xml . utils . SuballocatedIntVector ids = ( ( DTMDefaultBase ) dtm ) . getDTMIDs ( ) ; for ( int i = ids . size ( ) - 1 ; i >= 0 ; -- i ) m_dtms [ ids . elementAt ( i ) > > > DTMManager . IDENT_DTM_NODE_BITS ] = null ; } else { int i = getDTMIdentity ( dtm ) ; if ( i >= 0 ) { m_dtms [ i > > > DTMManager . IDENT_DTM_NODE_BITS ] = null ; } } dtm . documentRelease ( ) ; return true ; } synchronized public DTM createDocumentFragment ( ) { try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document doc = db . newDocument ( ) ; Node df = doc . createDocumentFragment ( ) ; return getDTM ( new DOMSource ( df ) , true , null , false , false ) ; } catch ( Exception e ) { throw new DTMException ( e ) ; } } synchronized public DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) { return null ; } synchronized public DTMIterator createDTMIterator ( String xpathString , PrefixResolver presolver ) { return null ; } synchronized public DTMIterator createDTMIterator ( int node ) { return null ; } synchronized public DTMIterator createDTMIterator ( Object xpathCompiler , int pos ) { return null ; } public ExpandedNameTable getExpandedNameTable ( DTM dtm ) { return m_expandedNameTable ; } } 	0
package org . apache . xalan . processor ; import org . xml . sax . Attributes ; public class ProcessorUnknown extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { } } 	1
package org . apache . xml . dtm . ref ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; final class ChunkedIntArray { final int slotsize = 4 ; static final int lowbits = 10 ; static final int chunkalloc = 1 << lowbits ; static final int lowmask = chunkalloc - 1 ; ChunksVector chunks = new ChunksVector ( ) ; final int fastArray [ ] = new int [ chunkalloc ] ; int lastUsed = 0 ; ChunkedIntArray ( int slotsize ) { if ( this . slotsize < slotsize ) throw new ArrayIndexOutOfBoundsException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CHUNKEDINTARRAY_NOT_SUPPORTED , new Object [ ] { Integer . toString ( slotsize ) } ) ) ; else if ( this . slotsize > slotsize ) System . out . println ( "*****WARNING: ChunkedIntArray(" + slotsize + ") wasting " + ( this . slotsize - slotsize ) + " words per slot" ) ; chunks . addElement ( fastArray ) ; } int appendSlot ( int w0 , int w1 , int w2 , int w3 ) { { final int slotsize = 4 ; int newoffset = ( lastUsed + 1 ) * slotsize ; int chunkpos = newoffset > > lowbits ; int slotpos = ( newoffset & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + 1 ] = w1 ; chunk [ slotpos + 2 ] = w2 ; chunk [ slotpos + 3 ] = w3 ; return ++ lastUsed ; } } int readEntry ( int position , int offset ) throws ArrayIndexOutOfBoundsException { { if ( offset >= slotsize ) throw new ArrayIndexOutOfBoundsException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OFFSET_BIGGER_THAN_SLOT , null ) ) ; position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = position & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; return chunk [ slotpos + offset ] ; } } int specialFind ( int startPos , int position ) { int ancestor = startPos ; while ( ancestor > 0 ) { ancestor *= slotsize ; int chunkpos = ancestor > > lowbits ; int slotpos = ancestor & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; ancestor = chunk [ slotpos + 1 ] ; if ( ancestor == position ) break ; } if ( ancestor <= 0 ) { return position ; } return - 1 ; } int slotsUsed ( ) { return lastUsed ; } void discardLast ( ) { -- lastUsed ; } void writeEntry ( int position , int offset , int value ) throws ArrayIndexOutOfBoundsException { { if ( offset >= slotsize ) throw new ArrayIndexOutOfBoundsException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OFFSET_BIGGER_THAN_SLOT , null ) ) ; position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = position & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos + offset ] = value ; } } void writeSlot ( int position , int w0 , int w1 , int w2 , int w3 ) { position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = ( position & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + 1 ] = w1 ; chunk [ slotpos + 2 ] = w2 ; chunk [ slotpos + 3 ] = w3 ; } void readSlot ( int position , int [ ] buffer ) { { position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = ( position & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; System . arraycopy ( chunk , slotpos , buffer , 0 , slotsize ) ; } } class ChunksVector { final int BLOCKSIZE = 64 ; int [ ] m_map [ ] = new int [ BLOCKSIZE ] [ ] ; int m_mapSize = BLOCKSIZE ; int pos = 0 ; ChunksVector ( ) { } final int size ( ) { return pos ; } void addElement ( int [ ] value ) { if ( pos >= m_mapSize ) { int orgMapSize = m_mapSize ; while ( pos >= m_mapSize ) m_mapSize += BLOCKSIZE ; int [ ] newMap [ ] = new int [ m_mapSize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , orgMapSize ) ; m_map = newMap ; } m_map [ pos ] = value ; pos ++ ; } final int [ ] elementAt ( int pos ) { return m_map [ pos ] ; } } } 	0
package org . apache . xml . utils ; import java . util . Hashtable ; class ElemDesc { Hashtable m_attrs = null ; int m_flags ; static final int EMPTY = ( 1 << 1 ) ; static final int FLOW = ( 1 << 2 ) ; static final int BLOCK = ( 1 << 3 ) ; static final int BLOCKFORM = ( 1 << 4 ) ; static final int BLOCKFORMFIELDSET = ( 1 << 5 ) ; static final int CDATA = ( 1 << 6 ) ; static final int PCDATA = ( 1 << 7 ) ; static final int RAW = ( 1 << 8 ) ; static final int INLINE = ( 1 << 9 ) ; static final int INLINEA = ( 1 << 10 ) ; static final int INLINELABEL = ( 1 << 11 ) ; static final int FONTSTYLE = ( 1 << 12 ) ; static final int PHRASE = ( 1 << 13 ) ; static final int FORMCTRL = ( 1 << 14 ) ; static final int SPECIAL = ( 1 << 15 ) ; static final int ASPECIAL = ( 1 << 16 ) ; static final int HEADMISC = ( 1 << 17 ) ; static final int HEAD = ( 1 << 18 ) ; static final int LIST = ( 1 << 19 ) ; static final int PREFORMATTED = ( 1 << 20 ) ; static final int WHITESPACESENSITIVE = ( 1 << 21 ) ; static final int ATTRURL = ( 1 << 1 ) ; static final int ATTREMPTY = ( 1 << 2 ) ; ElemDesc ( int flags ) { m_flags = flags ; } boolean is ( int flags ) { return ( m_flags & flags ) != 0 ; } void setAttr ( String name , int flags ) { if ( null == m_attrs ) m_attrs = new Hashtable ( ) ; m_attrs . put ( name , new Integer ( flags ) ) ; } boolean isAttrFlagSet ( String name , int flags ) { if ( null != m_attrs ) { Integer _flags = ( Integer ) m_attrs . get ( name ) ; if ( null != _flags ) { return ( _flags . intValue ( ) & flags ) != 0 ; } } return false ; } } 	1
package org . apache . xalan . xsltc ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . serializer . SerializationHandler ; public interface Translet { public void transform ( DOM document , SerializationHandler handler ) throws TransletException ; public void transform ( DOM document , SerializationHandler [ ] handlers ) throws TransletException ; public void transform ( DOM document , DTMAxisIterator iterator , SerializationHandler handler ) throws TransletException ; public Object addParameter ( String name , Object value ) ; public void buildKeys ( DOM document , DTMAxisIterator iterator , SerializationHandler handler , int root ) throws TransletException ; public void addAuxiliaryClass ( Class auxClass ) ; public Class getAuxiliaryClass ( String className ) ; public String [ ] getNamesArray ( ) ; public String [ ] getNamespaceArray ( ) ; } 	0
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XObject ; public abstract class Function extends Expression { public void setArg ( Expression arg , int argNum ) throws WrongNumberArgsException { reportWrongNumberArgs ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum != 0 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "zero" , null ) ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { System . out . println ( "Error! Function.execute should not be called!" ) ; return null ; } public void callArgVisitors ( XPathVisitor visitor ) { } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitFunction ( owner , this ) ) { callArgVisitors ( visitor ) ; } } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; return true ; } public void postCompileStep ( Compiler compiler ) { } } 	1
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFNULL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . runtime . TransletLoader ; public final class ObjectType extends Type { private String _javaClassName = "java.lang.Object" ; private Class _clazz = java . lang . Object . class ; protected ObjectType ( ) { } public ObjectType ( String javaClassName ) { _javaClassName = javaClassName ; try { TransletLoader loader = new TransletLoader ( ) ; _clazz = loader . loadClass ( javaClassName ) ; } catch ( ClassNotFoundException e ) { _clazz = null ; } } public ObjectType ( Class clazz ) { _clazz = clazz ; _javaClassName = clazz . getName ( ) ; } public int hashCode ( ) { return toString ( ) . hashCode ( ) ; } public boolean equals ( Object obj ) { return ( obj instanceof ObjectType ) ; } public String getJavaClassName ( ) { return _javaClassName ; } public Class getJavaClass ( ) { return _clazz ; } public String toString ( ) { return _javaClassName ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { final StringBuffer result = new StringBuffer ( "L" ) ; result . append ( _javaClassName . replace ( '.' , '/' ) ) . append ( ';' ) ; return result . toString ( ) ; } public org . apache . bcel . generic . Type toJCType ( ) { return Util . getJCRefType ( toSignature ( ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP ) ; final BranchHandle ifNull = il . append ( new IFNULL ( null ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( _javaClassName , "toString" , "()" + STRING_SIG ) ) ) ; final BranchHandle gotobh = il . append ( new GOTO ( null ) ) ; ifNull . setTarget ( il . append ( POP ) ) ; il . append ( new PUSH ( cpg , "" ) ) ; gotobh . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz . isAssignableFrom ( _clazz ) ) methodGen . getInstructionList ( ) . append ( NOP ) ; else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getClass ( ) . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0
package org . apache . xalan . extensions ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; public class ExtensionHandlerJavaPackage extends ExtensionHandlerJava { public ExtensionHandlerJavaPackage ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang , className ) ; } public boolean isFunctionAvailable ( String function ) { try { String fullName = m_className + function ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot >= 0 ) { Class myClass = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; Method [ ] methods = myClass . getMethods ( ) ; int nMethods = methods . length ; function = fullName . substring ( lastDot + 1 ) ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( function ) ) return true ; } } } catch ( ClassNotFoundException cnfe ) { } return false ; } public boolean isElementAvailable ( String element ) { try { String fullName = m_className + element ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot >= 0 ) { Class myClass = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; Method [ ] methods = myClass . getMethods ( ) ; int nMethods = methods . length ; element = fullName . substring ( lastDot + 1 ) ; for ( int i = 0 ; i < nMethods ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( element ) ) { Class [ ] paramTypes = methods [ i ] . getParameterTypes ( ) ; if ( ( paramTypes . length == 2 ) && paramTypes [ 0 ] . isAssignableFrom ( org . apache . xalan . extensions . XSLProcessorContext . class ) && paramTypes [ 1 ] . isAssignableFrom ( org . apache . xalan . templates . ElemExtensionCall . class ) ) { return true ; } } } } } catch ( ClassNotFoundException cnfe ) { } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { String className ; String methodName ; Class classObj ; Object targetObject ; int lastDot = funcName . lastIndexOf ( "." ) ; Object [ ] methodArgs ; Object [ ] [ ] convertedArgs ; Class [ ] paramTypes ; try { if ( funcName . endsWith ( ".new" ) ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Constructor c = ( Constructor ) getFromCache ( methodKey , null , methodArgs ) ; if ( c != null ) { try { paramTypes = c . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } className = m_className + funcName . substring ( 0 , lastDot ) ; try { classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } c = MethodResolver . getConstructor ( classObj , methodArgs , convertedArgs , exprContext ) ; putToCache ( methodKey , null , methodArgs , c ) ; return c . newInstance ( convertedArgs [ 0 ] ) ; } else if ( - 1 != lastDot ) { methodArgs = new Object [ args . size ( ) ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i ) ; } Method m = ( Method ) getFromCache ( methodKey , null , methodArgs ) ; if ( m != null ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return m . invoke ( null , convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } className = m_className + funcName . substring ( 0 , lastDot ) ; methodName = funcName . substring ( lastDot + 1 ) ; try { classObj = getClassForName ( className ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } m = MethodResolver . getMethod ( classObj , methodName , methodArgs , convertedArgs , exprContext , MethodResolver . STATIC_ONLY ) ; putToCache ( methodKey , null , methodArgs , m ) ; return m . invoke ( null , convertedArgs [ 0 ] ) ; } else { if ( args . size ( ) < 1 ) { throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INSTANCE_MTHD_CALL_REQUIRES , new Object [ ] { funcName } ) ) ; } targetObject = args . elementAt ( 0 ) ; if ( targetObject instanceof XObject ) targetObject = ( ( XObject ) targetObject ) . object ( ) ; methodArgs = new Object [ args . size ( ) - 1 ] ; convertedArgs = new Object [ 1 ] [ ] ; for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = args . elementAt ( i + 1 ) ; } Method m = ( Method ) getFromCache ( methodKey , targetObject , methodArgs ) ; if ( m != null ) { try { paramTypes = m . getParameterTypes ( ) ; MethodResolver . convertParams ( methodArgs , convertedArgs , paramTypes , exprContext ) ; return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } catch ( InvocationTargetException ite ) { throw ite ; } catch ( Exception e ) { } } classObj = targetObject . getClass ( ) ; m = MethodResolver . getMethod ( classObj , funcName , methodArgs , convertedArgs , exprContext , MethodResolver . INSTANCE_ONLY ) ; putToCache ( methodKey , targetObject , methodArgs , m ) ; return m . invoke ( targetObject , convertedArgs [ 0 ] ) ; } } catch ( InvocationTargetException ite ) { Throwable resultException = ite ; Throwable targetException = ite . getTargetException ( ) ; if ( targetException instanceof TransformerException ) throw ( ( TransformerException ) targetException ) ; else if ( targetException != null ) resultException = targetException ; throw new TransformerException ( resultException ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } public Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException { return callFunction ( extFunction . getFunctionName ( ) , args , extFunction . getMethodKey ( ) , exprContext ) ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { Object result = null ; Class classObj ; Method m = ( Method ) getFromCache ( methodKey , null , null ) ; if ( null == m ) { try { String fullName = m_className + localPart ; int lastDot = fullName . lastIndexOf ( "." ) ; if ( lastDot < 0 ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_ELEMENT_NAME , new Object [ ] { fullName } ) ) ; try { classObj = getClassForName ( fullName . substring ( 0 , lastDot ) ) ; } catch ( ClassNotFoundException e ) { throw new TransformerException ( e ) ; } localPart = fullName . substring ( lastDot + 1 ) ; m = MethodResolver . getElementMethod ( classObj , localPart ) ; if ( ! Modifier . isStatic ( m . getModifiers ( ) ) ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ELEMENT_NAME_METHOD_STATIC , new Object [ ] { fullName } ) ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } putToCache ( methodKey , null , null , m ) ; } XSLProcessorContext xpc = new XSLProcessorContext ( transformer , stylesheetTree ) ; try { result = m . invoke ( null , new Object [ ] { xpc , element } ) ; } catch ( InvocationTargetException ite ) { Throwable resultException = ite ; Throwable targetException = ite . getTargetException ( ) ; if ( targetException instanceof TransformerException ) throw ( ( TransformerException ) targetException ) ; else if ( targetException != null ) resultException = targetException ; throw new TransformerException ( resultException ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } if ( result != null ) { xpc . outputToResultTree ( stylesheetTree , result ) ; } } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class BinOpExpr extends Expression { public static final int PLUS = 0 ; public static final int MINUS = 1 ; public static final int TIMES = 2 ; public static final int DIV = 3 ; public static final int MOD = 4 ; private static final String [ ] Ops = { "+" , "-" , "*" , "/" , "%" } ; private int _op ; private Expression _left , _right ; public BinOpExpr ( int op , Expression left , Expression right ) { _op = op ; ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public boolean hasPositionCall ( ) { if ( _left . hasPositionCall ( ) ) return true ; if ( _right . hasPositionCall ( ) ) return true ; return false ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tleft = _left . typeCheck ( stable ) ; final Type tright = _right . typeCheck ( stable ) ; final MethodType ptype = lookupPrimop ( stable , Ops [ _op ] , new MethodType ( Type . Void , tleft , tright ) ) ; if ( ptype != null ) { final Type arg1 = ( Type ) ptype . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) { _left = new CastExpr ( _left , arg1 ) ; } final Type arg2 = ( Type ) ptype . argsType ( ) . elementAt ( 1 ) ; if ( ! arg2 . identicalTo ( tright ) ) { _right = new CastExpr ( _right , arg1 ) ; } return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; switch ( _op ) { case PLUS : il . append ( _type . ADD ( ) ) ; break ; case MINUS : il . append ( _type . SUB ( ) ) ; break ; case TIMES : il . append ( _type . MUL ( ) ) ; break ; case DIV : il . append ( _type . DIV ( ) ) ; break ; case MOD : il . append ( _type . REM ( ) ) ; break ; default : ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_BINARY_OP_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } public String toString ( ) { return Ops [ _op ] + '(' + _left + ", " + _right + ')' ; } } 	0
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemComment extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_COMMENT ; } public String getNodeName ( ) { return Constants . ELEMNAME_COMMENT_STRING ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; try { String data = transformer . transformToString ( this ) ; transformer . getResultTreeHandler ( ) . comment ( data ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } finally { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : case Constants . ELEMNAME_APPLY_TEMPLATES : case Constants . ELEMNAME_APPLY_IMPORTS : case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_FOREACH : case Constants . ELEMNAME_VALUEOF : case Constants . ELEMNAME_COPY_OF : case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_CHOOSE : case Constants . ELEMNAME_IF : case Constants . ELEMNAME_TEXT : case Constants . ELEMNAME_COPY : case Constants . ELEMNAME_VARIABLE : case Constants . ELEMNAME_MESSAGE : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } } 	1
package org . apache . xml . utils ; public abstract class XMLStringFactory { public abstract XMLString newstr ( String string ) ; public abstract XMLString newstr ( FastStringBuffer string , int start , int length ) ; public abstract XMLString newstr ( char [ ] string , int start , int length ) ; public abstract XMLString emptystr ( ) ; } 	0
package org . apache . xpath . res ; import java . util . ListResourceBundle ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class XPATHErrorResources extends ListResourceBundle { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final String ERROR0000 = "ERROR0000" ; public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = "ER_CURRENT_NOT_ALLOWED_IN_MATCH" ; public static final String ER_CURRENT_TAKES_NO_ARGS = "ER_CURRENT_TAKES_NO_ARGS" ; public static final String ER_DOCUMENT_REPLACED = "ER_DOCUMENT_REPLACED" ; public static final String ER_CONTEXT_HAS_NO_OWNERDOC = "ER_CONTEXT_HAS_NO_OWNERDOC" ; public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = "ER_LOCALNAME_HAS_TOO_MANY_ARGS" ; public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = "ER_NAMESPACEURI_HAS_TOO_MANY_ARGS" ; public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = "ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS" ; public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = "ER_NUMBER_HAS_TOO_MANY_ARGS" ; public static final String ER_NAME_HAS_TOO_MANY_ARGS = "ER_NAME_HAS_TOO_MANY_ARGS" ; public static final String ER_STRING_HAS_TOO_MANY_ARGS = "ER_STRING_HAS_TOO_MANY_ARGS" ; public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = "ER_STRINGLENGTH_HAS_TOO_MANY_ARGS" ; public static final String ER_TRANSLATE_TAKES_3_ARGS = "ER_TRANSLATE_TAKES_3_ARGS" ; public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = "ER_UNPARSEDENTITYURI_TAKES_1_ARG" ; public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = "ER_NAMESPACEAXIS_NOT_IMPLEMENTED" ; public static final String ER_UNKNOWN_AXIS = "ER_UNKNOWN_AXIS" ; public static final String ER_UNKNOWN_MATCH_OPERATION = "ER_UNKNOWN_MATCH_OPERATION" ; public static final String ER_INCORRECT_ARG_LENGTH = "ER_INCORRECT_ARG_LENGTH" ; public static final String ER_CANT_CONVERT_TO_NUMBER = "ER_CANT_CONVERT_TO_NUMBER" ; public static final String ER_CANT_CONVERT_TO_NODELIST = "ER_CANT_CONVERT_TO_NODELIST" ; public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = "ER_CANT_CONVERT_TO_MUTABLENODELIST" ; public static final String ER_CANT_CONVERT_TO_TYPE = "ER_CANT_CONVERT_TO_TYPE" ; public static final String ER_EXPECTED_MATCH_PATTERN = "ER_EXPECTED_MATCH_PATTERN" ; public static final String ER_COULDNOT_GET_VAR_NAMED = "ER_COULDNOT_GET_VAR_NAMED" ; public static final String ER_UNKNOWN_OPCODE = "ER_UNKNOWN_OPCODE" ; public static final String ER_EXTRA_ILLEGAL_TOKENS = "ER_EXTRA_ILLEGAL_TOKENS" ; public static final String ER_EXPECTED_DOUBLE_QUOTE = "ER_EXPECTED_DOUBLE_QUOTE" ; public static final String ER_EXPECTED_SINGLE_QUOTE = "ER_EXPECTED_SINGLE_QUOTE" ; public static final String ER_EMPTY_EXPRESSION = "ER_EMPTY_EXPRESSION" ; public static final String ER_EXPECTED_BUT_FOUND = "ER_EXPECTED_BUT_FOUND" ; public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = "ER_INCORRECT_PROGRAMMER_ASSERTION" ; public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = "ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL" ; public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = "ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG" ; public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = "ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG" ; public static final String ER_PREDICATE_ILLEGAL_SYNTAX = "ER_PREDICATE_ILLEGAL_SYNTAX" ; public static final String ER_ILLEGAL_AXIS_NAME = "ER_ILLEGAL_AXIS_NAME" ; public static final String ER_UNKNOWN_NODETYPE = "ER_UNKNOWN_NODETYPE" ; public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = "ER_PATTERN_LITERAL_NEEDS_BE_QUOTED" ; public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = "ER_COULDNOT_BE_FORMATTED_TO_NUMBER" ; public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = "ER_COULDNOT_CREATE_XMLPROCESSORLIAISON" ; public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = "ER_DIDNOT_FIND_XPATH_SELECT_EXP" ; public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = "ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH" ; public static final String ER_ERROR_OCCURED = "ER_ERROR_OCCURED" ; public static final String ER_ILLEGAL_VARIABLE_REFERENCE = "ER_ILLEGAL_VARIABLE_REFERENCE" ; public static final String ER_AXES_NOT_ALLOWED = "ER_AXES_NOT_ALLOWED" ; public static final String ER_KEY_HAS_TOO_MANY_ARGS = "ER_KEY_HAS_TOO_MANY_ARGS" ; public static final String ER_COUNT_TAKES_1_ARG = "ER_COUNT_TAKES_1_ARG" ; public static final String ER_COULDNOT_FIND_FUNCTION = "ER_COULDNOT_FIND_FUNCTION" ; public static final String ER_UNSUPPORTED_ENCODING = "ER_UNSUPPORTED_ENCODING" ; public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = "ER_PROBLEM_IN_DTM_NEXTSIBLING" ; public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = "ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL" ; public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = "ER_SETDOMFACTORY_NOT_SUPPORTED" ; public static final String ER_PREFIX_MUST_RESOLVE = "ER_PREFIX_MUST_RESOLVE" ; public static final String ER_PARSE_NOT_SUPPORTED = "ER_PARSE_NOT_SUPPORTED" ; public static final String ER_SAX_API_NOT_HANDLED = "ER_SAX_API_NOT_HANDLED" ; public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = "ER_IGNORABLE_WHITESPACE_NOT_HANDLED" ; public static final String ER_DTM_CANNOT_HANDLE_NODES = "ER_DTM_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_CANNOT_HANDLE_NODES = "ER_XERCES_CANNOT_HANDLE_NODES" ; public static final String ER_XERCES_PARSE_ERROR_DETAILS = "ER_XERCES_PARSE_ERROR_DETAILS" ; public static final String ER_XERCES_PARSE_ERROR = "ER_XERCES_PARSE_ERROR" ; public static final String ER_INVALID_UTF16_SURROGATE = "ER_INVALID_UTF16_SURROGATE" ; public static final String ER_OIERROR = "ER_OIERROR" ; public static final String ER_CANNOT_CREATE_URL = "ER_CANNOT_CREATE_URL" ; public static final String ER_XPATH_READOBJECT = "ER_XPATH_READOBJECT" ; public static final String ER_FUNCTION_TOKEN_NOT_FOUND = "ER_FUNCTION_TOKEN_NOT_FOUND" ; public static final String ER_CANNOT_DEAL_XPATH_TYPE = "ER_CANNOT_DEAL_XPATH_TYPE" ; public static final String ER_NODESET_NOT_MUTABLE = "ER_NODESET_NOT_MUTABLE" ; public static final String ER_NODESETDTM_NOT_MUTABLE = "ER_NODESETDTM_NOT_MUTABLE" ; public static final String ER_VAR_NOT_RESOLVABLE = "ER_VAR_NOT_RESOLVABLE" ; public static final String ER_NULL_ERROR_HANDLER = "ER_NULL_ERROR_HANDLER" ; public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = "ER_PROG_ASSERT_UNKNOWN_OPCODE" ; public static final String ER_ZERO_OR_ONE = "ER_ZERO_OR_ONE" ; public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = "ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER" ; public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = "ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS" ; public static final String ER_COULD_NOT_FIND_VAR = "ER_COULD_NOT_FIND_VAR" ; public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = "ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING" ; public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = "ER_FASTSTRINGBUFFER_CANNOT_BE_NULL" ; public static final String ER_TWO_OR_THREE = "ER_TWO_OR_THREE" ; public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = "ER_VARIABLE_ACCESSED_BEFORE_BIND" ; public static final String ER_FSB_CANNOT_TAKE_STRING = "ER_FSB_CANNOT_TAKE_STRING" ; public static final String ER_SETTING_WALKER_ROOT_TO_NULL = "ER_SETTING_WALKER_ROOT_TO_NULL" ; public static final String ER_NODESETDTM_CANNOT_ITERATE = "ER_NODESETDTM_CANNOT_ITERATE" ; public static final String ER_NODESET_CANNOT_ITERATE = "ER_NODESET_CANNOT_ITERATE" ; public static final String ER_NODESETDTM_CANNOT_INDEX = "ER_NODESETDTM_CANNOT_INDEX" ; public static final String ER_NODESET_CANNOT_INDEX = "ER_NODESET_CANNOT_INDEX" ; public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = "ER_CANNOT_CALL_SETSHOULDCACHENODE" ; public static final String ER_ONLY_ALLOWS = "ER_ONLY_ALLOWS" ; public static final String ER_UNKNOWN_STEP = "ER_UNKNOWN_STEP" ; public static final String ER_EXPECTED_REL_LOC_PATH = "ER_EXPECTED_REL_LOC_PATH" ; public static final String ER_EXPECTED_LOC_PATH = "ER_EXPECTED_LOC_PATH" ; public static final String ER_EXPECTED_LOC_STEP = "ER_EXPECTED_LOC_STEP" ; public static final String ER_EXPECTED_NODE_TEST = "ER_EXPECTED_NODE_TEST" ; public static final String ER_EXPECTED_STEP_PATTERN = "ER_EXPECTED_STEP_PATTERN" ; public static final String ER_EXPECTED_REL_PATH_PATTERN = "ER_EXPECTED_REL_PATH_PATTERN" ; public static final String ER_CANT_CONVERT_TO_BOOLEAN = "ER_CANT_CONVERT_TO_BOOLEAN" ; public static final String ER_CANT_CONVERT_TO_SINGLENODE = "ER_CANT_CONVERT_TO_SINGLENODE" ; public static final String ER_CANT_GET_SNAPSHOT_LENGTH = "ER_CANT_GET_SNAPSHOT_LENGTH" ; public static final String ER_NON_ITERATOR_TYPE = "ER_NON_ITERATOR_TYPE" ; public static final String ER_DOC_MUTATED = "ER_DOC_MUTATED" ; public static final String ER_INVALID_XPATH_TYPE = "ER_INVALID_XPATH_TYPE" ; public static final String ER_EMPTY_XPATH_RESULT = "ER_EMPTY_XPATH_RESULT" ; public static final String ER_INCOMPATIBLE_TYPES = "ER_INCOMPATIBLE_TYPES" ; public static final String ER_NULL_RESOLVER = "ER_NULL_RESOLVER" ; public static final String ER_CANT_CONVERT_TO_STRING = "ER_CANT_CONVERT_TO_STRING" ; public static final String ER_NON_SNAPSHOT_TYPE = "ER_NON_SNAPSHOT_TYPE" ; public static final String ER_WRONG_DOCUMENT = "ER_WRONG_DOCUMENT" ; public static final String ER_WRONG_NODETYPE = "ER_WRONG_NODETYPE" ; public static final String ER_XPATH_ERROR = "ER_XPATH_ERROR" ; public static final String WG_LOCALE_NAME_NOT_HANDLED = "WG_LOCALE_NAME_NOT_HANDLED" ; public static final String WG_PROPERTY_NOT_SUPPORTED = "WG_PROPERTY_NOT_SUPPORTED" ; public static final String WG_DONT_DO_ANYTHING_WITH_NS = "WG_DONT_DO_ANYTHING_WITH_NS" ; public static final String WG_SECURITY_EXCEPTION = "WG_SECURITY_EXCEPTION" ; public static final String WG_QUO_NO_LONGER_DEFINED = "WG_QUO_NO_LONGER_DEFINED" ; public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = "WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST" ; public static final String WG_FUNCTION_TOKEN_NOT_FOUND = "WG_FUNCTION_TOKEN_NOT_FOUND" ; public static final String WG_COULDNOT_FIND_FUNCTION = "WG_COULDNOT_FIND_FUNCTION" ; public static final String WG_CANNOT_MAKE_URL_FROM = "WG_CANNOT_MAKE_URL_FROM" ; public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = "WG_EXPAND_ENTITIES_NOT_SUPPORTED" ; public static final String WG_ILLEGAL_VARIABLE_REFERENCE = "WG_ILLEGAL_VARIABLE_REFERENCE" ; public static final String WG_UNSUPPORTED_ENCODING = "WG_UNSUPPORTED_ENCODING" ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "The current() function is not allowed in a match pattern!" } , { ER_CURRENT_TAKES_NO_ARGS , "The current() function does not accept arguments!" } , { ER_DOCUMENT_REPLACED , "document() function implementation has been replaced by org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "context does not have an owner document!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() has too many arguments." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() has too many arguments." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() has too many arguments." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() has too many arguments." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() has too many arguments." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() has too many arguments." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() has too many arguments." } , { ER_TRANSLATE_TAKES_3_ARGS , "The translate() function takes three arguments!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "The unparsed-entity-uri function should take one argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "namespace axis not implemented yet!" } , { ER_UNKNOWN_AXIS , "unknown axis: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "unknown match operation!" } , { ER_INCORRECT_ARG_LENGTH , "Arg length of processing-instruction() node test is incorrect!" } , { ER_CANT_CONVERT_TO_NUMBER , "Can not convert {0} to a number" } , { ER_CANT_CONVERT_TO_NODELIST , "Can not convert {0} to a NodeList!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Can not convert {0} to a NodeSetDTM!" } , { ER_CANT_CONVERT_TO_TYPE , "Can not convert {0} to a type#{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Expected match pattern in getMatchScore!" } , { ER_COULDNOT_GET_VAR_NAMED , "Could not get variable named {0}" } , { ER_UNKNOWN_OPCODE , "ERROR! Unknown op code: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Extra illegal tokens: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "misquoted literal... expected double quote!" } , { ER_EXPECTED_SINGLE_QUOTE , "misquoted literal... expected single quote!" } , { ER_EMPTY_EXPRESSION , "Empty expression!" } , { ER_EXPECTED_BUT_FOUND , "Expected {0}, but found: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Programmer assertion is incorrect! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "boolean(...) argument is no longer optional with 19990709 XPath draft." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Found ',' but no preceding argument!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Found ',' but no following argument!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' or '.[predicate]' is illegal syntax.  Use 'self::node()[predicate]' instead." } , { ER_ILLEGAL_AXIS_NAME , "illegal axis name: {0}" } , { ER_UNKNOWN_NODETYPE , "Unknown nodetype: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Pattern literal ({0}) needs to be quoted!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} could not be formatted to a number!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Could not create XML TransformerFactory Liaison: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Error! Did not find xpath select expression (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERROR! Could not find ENDOP after OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Error occured!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference given for variable out of context or without definition!  Name = {0}" } , { ER_AXES_NOT_ALLOWED , "Only child:: and attribute:: axes are allowed in match patterns!  Offending axes = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() has an incorrect number of arguments." } , { ER_COUNT_TAKES_1_ARG , "The count function should take one argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Could not find function: {0}" } , { ER_UNSUPPORTED_ENCODING , "Unsupported encoding: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Problem occured in DTM in getNextSibling... trying to recover" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programmer error: EmptyNodeList can not be written to." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory is not supported by XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (InputSource source) not supported in XPathContext! Can not open {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]... not handled by the DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... not handled by the DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison can not handle nodes of type {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper can not handle nodes of type {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse error: SystemID - {0} line - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse error" } , { ER_INVALID_UTF16_SURROGATE , "Invalid UTF-16 surrogate detected: {0} ?" } , { ER_OIERROR , "IO error" } , { ER_CANNOT_CREATE_URL , "Cannot create url for: {0}" } , { ER_XPATH_READOBJECT , "In XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "function token not found." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Can not deal with XPath type: {0}" } , { ER_NODESET_NOT_MUTABLE , "This NodeSet is not mutable" } , { ER_NODESETDTM_NOT_MUTABLE , "This NodeSetDTM is not mutable" } , { ER_VAR_NOT_RESOLVABLE , "Variable not resolvable: {0}" } , { ER_NULL_ERROR_HANDLER , "Null error handler" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programmer''s assertion: unknown opcode: {0}" } , { ER_ZERO_OR_ONE , "0 or 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() not supported by XRTreeFragSelectWrapper" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() not supported by XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() not supported for XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Could not find variable with the name of {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars can not take a string for an argument" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "The FastStringBuffer argument can not be null" } , { ER_TWO_OR_THREE , "2 or 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Variable accessed before it is bound!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB can not take a string for an argument!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Error! Setting the root of a walker to null!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "This NodeSetDTM can not iterate to a previous node!" } , { ER_NODESET_CANNOT_ITERATE , "This NodeSet can not iterate to a previous node!" } , { ER_NODESETDTM_CANNOT_INDEX , "This NodeSetDTM can not do indexing or counting functions!" } , { ER_NODESET_CANNOT_INDEX , "This NodeSet can not do indexing or counting functions!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Can not call setShouldCacheNodes after nextNode has been called!" } , { ER_ONLY_ALLOWS , "{0} only allows {1} arguments" } , { ER_UNKNOWN_STEP , "Programmer''s assertion in getNextStepPos: unknown stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "A relative location path was expected following the '/' or '//' token." } , { ER_EXPECTED_LOC_PATH , "A location path was expected, but the following token was encountered:  {0}" } , { ER_EXPECTED_LOC_STEP , "A location step was expected following the '/' or '//' token." } , { ER_EXPECTED_NODE_TEST , "A node test that matches either NCName:* or QName was expected." } , { ER_EXPECTED_STEP_PATTERN , "A step pattern was expected, but '/' was encountered." } , { ER_EXPECTED_REL_PATH_PATTERN , "A relative path pattern was expected." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Cannot convert {0} to a boolean." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Cannot convert {0} to a single node. This getter applies to types ANY_UNORDERED_NODE_TYPE and FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Cannot get snapshot length on type: {0}. This getter applies to types UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Cannot iterate over non-iterator type: {0}" } , { ER_DOC_MUTATED , "Document mutated since result was returned. Iterator is invalid." } , { ER_INVALID_XPATH_TYPE , "Invalid XPath type argument: {0}" } , { ER_EMPTY_XPATH_RESULT , "Empty XPath result object" } , { ER_INCOMPATIBLE_TYPES , "The returned type: {0} cannot be coerced into the specified type: {1}" } , { ER_NULL_RESOLVER , "Unable to resolve prefix with null prefix resolver." } , { ER_CANT_CONVERT_TO_STRING , "Cannot convert {0} to a string." } , { ER_NON_SNAPSHOT_TYPE , "Cannot call snapshotItem on type: {0}. This method applies to types UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Context node does not belong to the document that is bound to this XPathEvaluator." } , { ER_WRONG_NODETYPE , "The context node type is not supported." } , { ER_XPATH_ERROR , "Unknown error in XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "locale name in the format-number function not yet handled!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL Property not supported: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Do not currently do anything with namespace {0} in property: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException when trying to access XSL system property: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Old syntax: quo(...) is no longer defined in XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath needs a derived object to implement nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "function token not found." } , { WG_COULDNOT_FIND_FUNCTION , "Could not find function: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Can not make URL from: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "-E option not supported for DTM parser" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference given for variable out of context or without definition!  Name = {0}" } , { WG_UNSUPPORTED_ENCODING , "Unsupported encoding: {0}" } , { "ui_language" , "en" } , { "help_language" , "en" } , { "language" , "en" } , { "BAD_CODE" , "Parameter to createMessage was out of bounds" } , { "FORMAT_FAILED" , "Exception thrown during messageFormat call" } , { "version" , ">>>>>>> Xalan Version " } , { "version2" , "<<<<<<<" } , { "yes" , "yes" } , { "line" , "Line #" } , { "column" , "Column #" } , { "xsldone" , "XSLProcessor: done" } , { "xpath_option" , "xpath options: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath expression]" } , { "optionMatch" , "   [-match match pattern (for match diagnostics)]" } , { "optionAnyExpr" , "Or just an xpath expression will do a diagnostic dump" } , { "noParsermsg1" , "XSL Process was not successful." } , { "noParsermsg2" , "** Could not find parser **" } , { "noParsermsg3" , "Please check your classpath." } , { "noParsermsg4" , "If you don't have IBM's XML Parser for Java, you can download it from" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } , { "gtone" , ">1" } , { "zero" , "0" } , { "one" , "1" } , { "two" , "2" } , { "three" , "3" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "#error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Warning: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } public static final XPATHErrorResources loadResourceBundle ( String className ) throws MissingResourceException { Locale locale = Locale . getDefault ( ) ; String suffix = getResourceSuffix ( locale ) ; try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className + suffix , locale ) ; } catch ( MissingResourceException e ) { try { return ( XPATHErrorResources ) ResourceBundle . getBundle ( className , new Locale ( "en" , "US" ) ) ; } catch ( MissingResourceException e2 ) { throw new MissingResourceException ( "Could not load any resource bundles." , className , "" ) ; } } } private static final String getResourceSuffix ( Locale locale ) { String suffix = "_" + locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; if ( country . equals ( "TW" ) ) suffix += "_" + country ; return suffix ; } } 	1
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; public class MatchPatternIterator extends LocPathIterator { protected StepPattern m_pattern ; protected int m_superAxis = - 1 ; protected DTMAxisTraverser m_traverser ; private static final boolean DEBUG = false ; MatchPatternIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_pattern = WalkerFactory . loadSteps ( this , compiler , firstStepPos , 0 ) ; boolean fromRoot = false ; boolean walkBack = false ; boolean walkDescendants = false ; boolean walkAttributes = false ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ROOT | WalkerFactory . BIT_ANY_DESCENDANT_FROM_ROOT ) ) ) fromRoot = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ANCESTOR | WalkerFactory . BIT_ANCESTOR_OR_SELF | WalkerFactory . BIT_PRECEDING | WalkerFactory . BIT_PRECEDING_SIBLING | WalkerFactory . BIT_FOLLOWING | WalkerFactory . BIT_FOLLOWING_SIBLING | WalkerFactory . BIT_PARENT | WalkerFactory . BIT_FILTER ) ) ) walkBack = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_DESCENDANT_OR_SELF | WalkerFactory . BIT_DESCENDANT | WalkerFactory . BIT_CHILD ) ) ) walkDescendants = true ; if ( 0 != ( analysis & ( WalkerFactory . BIT_ATTRIBUTE | WalkerFactory . BIT_NAMESPACE ) ) ) walkAttributes = true ; if ( false || DEBUG ) { System . out . print ( "analysis: " + Integer . toBinaryString ( analysis ) ) ; System . out . println ( ", " + WalkerFactory . getAnalysisString ( analysis ) ) ; } if ( fromRoot || walkBack ) { if ( walkAttributes ) { m_superAxis = Axis . ALL ; } else { m_superAxis = Axis . DESCENDANTSFROMROOT ; } } else if ( walkDescendants ) { if ( walkAttributes ) { m_superAxis = Axis . ALLFROMNODE ; } else { m_superAxis = Axis . DESCENDANTORSELF ; } } else { m_superAxis = Axis . ALL ; } if ( false || DEBUG ) { System . out . println ( "axis: " + Axis . names [ m_superAxis ] ) ; } } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_superAxis ) ; } public void detach ( ) { if ( m_allowDetach ) { m_traverser = null ; super . detach ( ) ; } } protected int getNextNode ( ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; return m_lastFetched ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; org . apache . xpath . VariableStack vars ; int savedStart ; if ( - 1 != m_stackFrame ) { vars = m_execContext . getVarStack ( ) ; savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; } else { vars = null ; savedStart = 0 ; } try { if ( DEBUG ) System . out . println ( "m_pattern" + m_pattern . toString ( ) ) ; do { next = getNextNode ( ) ; if ( DTM . NULL != next ) { if ( DTMIterator . FILTER_ACCEPT == acceptNode ( next , m_execContext ) ) break ; else continue ; } else break ; } while ( next != DTM . NULL ) ; if ( DTM . NULL != next ) { if ( DEBUG ) { System . out . println ( "next: " + next ) ; System . out . println ( "name: " + m_cdtm . getNodeName ( next ) ) ; } incrementCurrentPos ( ) ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } finally { if ( - 1 != m_stackFrame ) { vars . setStackFrame ( savedStart ) ; } } } public short acceptNode ( int n , XPathContext xctxt ) { try { xctxt . pushCurrentNode ( n ) ; xctxt . pushIteratorRoot ( m_context ) ; if ( DEBUG ) { System . out . println ( "traverser: " + m_traverser ) ; System . out . print ( "node: " + n ) ; System . out . println ( ", " + m_cdtm . getNodeName ( n ) ) ; System . out . println ( "pattern: " + m_pattern . toString ( ) ) ; m_pattern . debugWhatToShow ( m_pattern . getWhatToShow ( ) ) ; } XObject score = m_pattern . execute ( xctxt ) ; if ( DEBUG ) { System . out . println ( "score: " + score ) ; System . out . println ( "skip: " + ( score == NodeTest . SCORE_NONE ) ) ; } return ( score == NodeTest . SCORE_NONE ) ? DTMIterator . FILTER_SKIP : DTMIterator . FILTER_ACCEPT ; } catch ( javax . xml . transform . TransformerException se ) { throw new RuntimeException ( se . getMessage ( ) ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popIteratorRoot ( ) ; } } } 	0
package org . apache . xpath . res ; public class XPATHErrorResources_zh_TW extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , " current() " } , { ER_CURRENT_TAKES_NO_ARGS , "current() " } , { ER_DOCUMENT_REPLACED , "org.apache.xalan.xslt.FuncDocument  document() " } , { ER_CONTEXT_HAS_NO_OWNERDOC , "" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() " } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() " } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() " } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() " } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() " } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() " } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() " } , { ER_TRANSLATE_TAKES_3_ARGS , "translate()  3 " } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri  1 " } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "namespace " } , { ER_UNKNOWN_AXIS , "{0}" } , { ER_UNKNOWN_MATCH_OPERATION , "" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() " } , { ER_CANT_CONVERT_TO_NUMBER , "{0} " } , { ER_CANT_CONVERT_TO_NODELIST , "{0}  NodeList" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0}  NodeSetDTM" } , { ER_CANT_CONVERT_TO_TYPE , "{0}  type//{1}" } , { ER_EXPECTED_MATCH_PATTERN , " getMatchScore " } , { ER_COULDNOT_GET_VAR_NAMED , " {0} " } , { ER_UNKNOWN_OPCODE , "{0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "{0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "... " } , { ER_EXPECTED_SINGLE_QUOTE , "... " } , { ER_EMPTY_EXPRESSION , "" } , { ER_EXPECTED_BUT_FOUND , " {0}{1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "- {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "boolean(...)  19990709 XPath " } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , " ','" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , " ','" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]'  '.[predicate]'  'self::node()[predicate]' " } , { ER_ILLEGAL_AXIS_NAME , "{0}" } , { ER_UNKNOWN_NODETYPE , "{0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , " ({0}) " } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} " } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , " XML TransformerFactory Liaison{0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , " xpath select  (-select)" } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , " OP_LOCATIONPATH  ENDOP" } , { ER_ERROR_OCCURED , "" } , { ER_ILLEGAL_VARIABLE_REFERENCE , " VariableReference  = {0}" } , { ER_AXES_NOT_ALLOWED , " child::  attribute::   = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() " } , { ER_COUNT_TAKES_1_ARG , "count " } , { ER_COULDNOT_FIND_FUNCTION , "{0}" } , { ER_UNSUPPORTED_ENCODING , "{0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "getNextSibling  DTM ... " } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , " EmptyNodeList " } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory  XPathContext " } , { ER_PREFIX_MUST_RESOLVE , "{0}" } , { ER_PARSE_NOT_SUPPORTED , " XPathContext InputSource  {0}" } , { ER_SAX_API_NOT_HANDLED , "SAX API (char ch[]... DTM " } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... DTM " } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison  {0} " } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper  {0} " } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse SystemID - {0}  - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse " } , { ER_INVALID_UTF16_SURROGATE , " UTF-16 {0} ?" } , { ER_OIERROR , "/ (I/O) " } , { ER_CANNOT_CREATE_URL , " URL  {0}" } , { ER_XPATH_READOBJECT , " XPath.readObject{0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "" } , { ER_CANNOT_DEAL_XPATH_TYPE , " XPath {0}" } , { ER_NODESET_NOT_MUTABLE , " NodeSet " } , { ER_NODESETDTM_NOT_MUTABLE , " NodeSetDTM " } , { ER_VAR_NOT_RESOLVABLE , "{0}" } , { ER_NULL_ERROR_HANDLER , "" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "{0}" } , { ER_ZERO_OR_ONE , "0  1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "XRTreeFragSelectWrapper  rtf()" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "XRTreeFragSelectWrapper  asNodeIterator()" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "XStringForChars  fsb()" } , { ER_COULD_NOT_FIND_VAR , " {0} " } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars " } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer " } , { ER_TWO_OR_THREE , "2  3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB " } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n  walker " } , { ER_NODESETDTM_CANNOT_ITERATE , " NodeSetDTM" } , { ER_NODESET_CANNOT_ITERATE , " NodeSet" } , { ER_NODESETDTM_CANNOT_INDEX , " NodeSetDTM " } , { ER_NODESET_CANNOT_INDEX , " NodeSet " } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , " nextNode  setShouldCacheNodes" } , { ER_ONLY_ALLOWS , "{0}  {1} " } , { ER_UNKNOWN_STEP , " getNextStepPos  stepType{0}" } , { ER_EXPECTED_REL_LOC_PATH , "'/'  '//' " } , { ER_EXPECTED_LOC_PATH , " :  {0}" } , { ER_EXPECTED_LOC_STEP , "'/'  '//' " } , { ER_EXPECTED_NODE_TEST , " NCName:*  QName " } , { ER_EXPECTED_STEP_PATTERN , " '/'" } , { ER_EXPECTED_REL_PATH_PATTERN , "" } , { ER_CANT_CONVERT_TO_BOOLEAN , "{0} " } , { ER_CANT_CONVERT_TO_SINGLENODE , "{0}  getter  ANY_UNORDERED_NODE_TYPE  FIRST_ORDERED_NODE_TYPE " } , { ER_CANT_GET_SNAPSHOT_LENGTH , " {0}  getter  UNORDERED_NODE_SNAPSHOT_TYPE  ORDERED_NODE_SNAPSHOT_TYPE " } , { ER_NON_ITERATOR_TYPE , "{0}" } , { ER_DOC_MUTATED , "" } , { ER_INVALID_XPATH_TYPE , " XPath {0}" } , { ER_EMPTY_XPATH_RESULT , " XPath " } , { ER_INCOMPATIBLE_TYPES , "{0} {1}" } , { ER_NULL_RESOLVER , "" } , { ER_CANT_CONVERT_TO_STRING , "{0} " } , { ER_NON_SNAPSHOT_TYPE , " {0}  snapshotItem  UNORDERED_NODE_SNAPSHOT_TYPE  ORDERED_NODE_SNAPSHOT_TYPE " } , { ER_WRONG_DOCUMENT , " XPathEvaluator " } , { ER_WRONG_NODETYPE , "" } , { ER_XPATH_ERROR , "XPath " } , { WG_LOCALE_NAME_NOT_HANDLED , "format-number " } , { WG_PROPERTY_NOT_SUPPORTED , " XSL {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , " {1}  {0}" } , { WG_SECURITY_EXCEPTION , " XSL  {0}  SecurityException" } , { WG_QUO_NO_LONGER_DEFINED , "quo(...)  XPath " } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath  nodeTest" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "" } , { WG_COULDNOT_FIND_FUNCTION , "{0}" } , { WG_CANNOT_MAKE_URL_FROM , " {0}  URL" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "DTM  -E " } , { WG_ILLEGAL_VARIABLE_REFERENCE , " VariableReference  = {0}" } , { WG_UNSUPPORTED_ENCODING , "{0}" } , { "ui_language" , "zh_TW" } , { "help_language" , "zh_TW" } , { "language" , "zh_TW" } , { "BAD_CODE" , "createMessage " } , { "FORMAT_FAILED" , " messageFormat " } , { "version" , ">>>>>>> Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "" } , { "line" , " //" } , { "column" , " //" } , { "xsldone" , "XSLProcessor: done" } , { "xpath_option" , "xpath  " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath expression]" } , { "optionMatch" , "   [-match match pattern ()]" } , { "optionAnyExpr" , " xpath " } , { "noParsermsg1" , "XSL " } , { "noParsermsg2" , "**  **" } , { "noParsermsg3" , "" } , { "noParsermsg4" , " IBM  XML Parser for Java " } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//error" ; public static final String ERROR_HEADER = "" ; public static final String WARNING_HEADER = "" ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1
package org . apache . xalan . templates ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPath ; import org . apache . xpath . axes . AxesWalker ; import org . apache . xpath . axes . FilterExprIteratorSimple ; import org . apache . xpath . axes . FilterExprWalker ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . axes . SelfIteratorNoPredicate ; import org . apache . xpath . axes . WalkerFactory ; import org . apache . xpath . axes . WalkingIterator ; import org . apache . xpath . operations . Variable ; import org . apache . xpath . operations . VariableSafeAbsRef ; public class RedundentExprEliminator extends XSLTVisitor { Vector m_paths ; Vector m_absPaths ; boolean m_isSameContext ; AbsPathChecker m_absPathChecker = new AbsPathChecker ( ) ; static int m_uniquePsuedoVarID = 1 ; static final String PSUEDOVARNAMESPACE = Constants . S_VENDORURL + "/xalan/psuedovar" ; public static boolean DEBUG = false ; public static boolean DIAGNOSE_NUM_PATHS_REDUCED = false ; public static boolean DIAGNOSE_MULTISTEPLIST = false ; VarNameCollector m_varNameCollector = new VarNameCollector ( ) ; public RedundentExprEliminator ( ) { m_isSameContext = true ; m_absPaths = new Vector ( ) ; m_paths = null ; } public void eleminateRedundentLocals ( ElemTemplateElement psuedoVarRecipient ) { eleminateRedundent ( psuedoVarRecipient , m_paths ) ; } public void eleminateRedundentGlobals ( StylesheetRoot stylesheet ) { eleminateRedundent ( stylesheet , m_absPaths ) ; } protected void eleminateRedundent ( ElemTemplateElement psuedoVarRecipient , Vector paths ) { int n = paths . size ( ) ; int numPathsEliminated = 0 ; int numUniquePathsEliminated = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner owner = ( ExpressionOwner ) paths . elementAt ( i ) ; if ( null != owner ) { int found = findAndEliminateRedundant ( i + 1 , i , owner , psuedoVarRecipient , paths ) ; if ( found > 0 ) numUniquePathsEliminated ++ ; numPathsEliminated += found ; } } eleminateSharedPartialPaths ( psuedoVarRecipient , paths ) ; if ( DIAGNOSE_NUM_PATHS_REDUCED ) diagnoseNumPaths ( paths , numPathsEliminated , numUniquePathsEliminated ) ; } protected void eleminateSharedPartialPaths ( ElemTemplateElement psuedoVarRecipient , Vector paths ) { MultistepExprHolder list = createMultistepExprList ( paths ) ; if ( null != list ) { if ( DIAGNOSE_MULTISTEPLIST ) list . diagnose ( ) ; boolean isGlobal = ( paths == m_absPaths ) ; int longestStepsCount = list . m_stepCount ; for ( int i = longestStepsCount - 1 ; i >= 1 ; i -- ) { MultistepExprHolder next = list ; while ( null != next ) { if ( next . m_stepCount < i ) break ; list = matchAndEliminatePartialPaths ( next , list , isGlobal , i , psuedoVarRecipient ) ; next = next . m_next ; } } } } protected MultistepExprHolder matchAndEliminatePartialPaths ( MultistepExprHolder testee , MultistepExprHolder head , boolean isGlobal , int lengthToTest , ElemTemplateElement varScope ) { if ( null == testee . m_exprOwner ) return head ; WalkingIterator iter1 = ( WalkingIterator ) testee . m_exprOwner . getExpression ( ) ; if ( partialIsVariable ( testee , lengthToTest ) ) return head ; MultistepExprHolder matchedPaths = null ; MultistepExprHolder matchedPathsTail = null ; MultistepExprHolder meh = head ; while ( null != meh ) { if ( ( meh != testee ) && ( null != meh . m_exprOwner ) ) { WalkingIterator iter2 = ( WalkingIterator ) meh . m_exprOwner . getExpression ( ) ; if ( stepsEqual ( iter1 , iter2 , lengthToTest ) ) { if ( null == matchedPaths ) { try { matchedPaths = ( MultistepExprHolder ) testee . clone ( ) ; testee . m_exprOwner = null ; } catch ( CloneNotSupportedException cnse ) { } matchedPathsTail = matchedPaths ; matchedPathsTail . m_next = null ; } try { matchedPathsTail . m_next = ( MultistepExprHolder ) meh . clone ( ) ; meh . m_exprOwner = null ; } catch ( CloneNotSupportedException cnse ) { } matchedPathsTail = matchedPathsTail . m_next ; matchedPathsTail . m_next = null ; } } meh = meh . m_next ; } int matchCount = 0 ; if ( null != matchedPaths ) { ElemTemplateElement root = isGlobal ? varScope : findCommonAncestor ( matchedPaths ) ; WalkingIterator sharedIter = ( WalkingIterator ) matchedPaths . m_exprOwner . getExpression ( ) ; WalkingIterator newIter = createIteratorFromSteps ( sharedIter , lengthToTest ) ; ElemVariable var = createPsuedoVarDecl ( root , newIter , isGlobal ) ; if ( DIAGNOSE_MULTISTEPLIST ) System . err . println ( "Created var: " + var . getName ( ) + ( isGlobal ? "(Global)" : "" ) ) ; while ( null != matchedPaths ) { ExpressionOwner owner = matchedPaths . m_exprOwner ; WalkingIterator iter = ( WalkingIterator ) owner . getExpression ( ) ; if ( DIAGNOSE_MULTISTEPLIST ) diagnoseLineNumber ( iter ) ; LocPathIterator newIter2 = changePartToRef ( var . getName ( ) , iter , lengthToTest , isGlobal ) ; owner . setExpression ( newIter2 ) ; matchedPaths = matchedPaths . m_next ; } } if ( DIAGNOSE_MULTISTEPLIST ) diagnoseMultistepList ( matchCount , lengthToTest , isGlobal ) ; return head ; } boolean partialIsVariable ( MultistepExprHolder testee , int lengthToTest ) { if ( 1 == lengthToTest ) { WalkingIterator wi = ( WalkingIterator ) testee . m_exprOwner . getExpression ( ) ; if ( wi . getFirstWalker ( ) instanceof FilterExprWalker ) return true ; } return false ; } protected void diagnoseLineNumber ( Expression expr ) { ElemTemplateElement e = getElemFromExpression ( expr ) ; System . err . println ( "   " + e . getSystemId ( ) + " Line " + e . getLineNumber ( ) ) ; } protected ElemTemplateElement findCommonAncestor ( MultistepExprHolder head ) { int numExprs = head . getLength ( ) ; ElemTemplateElement [ ] elems = new ElemTemplateElement [ numExprs ] ; int [ ] ancestorCounts = new int [ numExprs ] ; MultistepExprHolder next = head ; int shortestAncestorCount = 10000 ; for ( int i = 0 ; i < numExprs ; i ++ ) { ElemTemplateElement elem = getElemFromExpression ( next . m_exprOwner . getExpression ( ) ) ; elems [ i ] = elem ; int numAncestors = countAncestors ( elem ) ; ancestorCounts [ i ] = numAncestors ; if ( numAncestors < shortestAncestorCount ) { shortestAncestorCount = numAncestors ; } next = next . m_next ; } for ( int i = 0 ; i < numExprs ; i ++ ) { if ( ancestorCounts [ i ] > shortestAncestorCount ) { int numStepCorrection = ancestorCounts [ i ] - shortestAncestorCount ; for ( int j = 0 ; j < numStepCorrection ; j ++ ) { elems [ i ] = elems [ i ] . getParentElem ( ) ; } } } ElemTemplateElement first = null ; while ( shortestAncestorCount -- >= 0 ) { boolean areEqual = true ; first = elems [ 0 ] ; for ( int i = 1 ; i < numExprs ; i ++ ) { if ( first != elems [ i ] ) { areEqual = false ; break ; } } if ( areEqual && isNotSameAsOwner ( head , first ) && first . canAcceptVariables ( ) ) { if ( DIAGNOSE_MULTISTEPLIST ) { System . err . print ( first . getClass ( ) . getName ( ) ) ; System . err . println ( " at   " + first . getSystemId ( ) + " Line " + first . getLineNumber ( ) ) ; } return first ; } for ( int i = 0 ; i < numExprs ; i ++ ) { elems [ i ] = elems [ i ] . getParentElem ( ) ; } } assertion ( false , "Could not find common ancestor!!!" ) ; return null ; } protected boolean isNotSameAsOwner ( MultistepExprHolder head , ElemTemplateElement ete ) { MultistepExprHolder next = head ; while ( null != next ) { ElemTemplateElement elemOwner = getElemFromExpression ( next . m_exprOwner . getExpression ( ) ) ; if ( elemOwner == ete ) return false ; next = next . m_next ; } return true ; } protected int countAncestors ( ElemTemplateElement elem ) { int count = 0 ; while ( null != elem ) { count ++ ; elem = elem . getParentElem ( ) ; } return count ; } protected void diagnoseMultistepList ( int matchCount , int lengthToTest , boolean isGlobal ) { if ( matchCount > 0 ) { System . err . print ( "Found multistep matches: " + matchCount + ", " + lengthToTest + " length" ) ; if ( isGlobal ) System . err . println ( " (global)" ) ; else System . err . println ( ) ; } } protected LocPathIterator changePartToRef ( final QName uniquePsuedoVarName , WalkingIterator wi , final int numSteps , final boolean isGlobal ) { Variable var = new Variable ( ) ; var . setQName ( uniquePsuedoVarName ) ; var . setIsGlobal ( isGlobal ) ; if ( isGlobal ) { ElemTemplateElement elem = getElemFromExpression ( wi ) ; StylesheetRoot root = elem . getStylesheetRoot ( ) ; Vector vars = root . getVariablesAndParamsComposed ( ) ; var . setIndex ( vars . size ( ) - 1 ) ; } AxesWalker walker = wi . getFirstWalker ( ) ; for ( int i = 0 ; i < numSteps ; i ++ ) { assertion ( null != walker , "Walker should not be null!" ) ; walker = walker . getNextWalker ( ) ; } if ( null != walker ) { FilterExprWalker few = new FilterExprWalker ( wi ) ; few . setInnerExpression ( var ) ; few . exprSetParent ( wi ) ; few . setNextWalker ( walker ) ; walker . setPrevWalker ( few ) ; wi . setFirstWalker ( few ) ; return wi ; } else { FilterExprIteratorSimple feis = new FilterExprIteratorSimple ( var ) ; feis . exprSetParent ( wi . exprGetParent ( ) ) ; return feis ; } } protected WalkingIterator createIteratorFromSteps ( final WalkingIterator wi , int numSteps ) { WalkingIterator newIter = new WalkingIterator ( wi . getPrefixResolver ( ) ) ; try { AxesWalker walker = ( AxesWalker ) wi . getFirstWalker ( ) . clone ( ) ; newIter . setFirstWalker ( walker ) ; walker . setLocPathIterator ( newIter ) ; for ( int i = 1 ; i < numSteps ; i ++ ) { AxesWalker next = ( AxesWalker ) walker . getNextWalker ( ) . clone ( ) ; walker . setNextWalker ( next ) ; next . setLocPathIterator ( newIter ) ; walker = next ; } walker . setNextWalker ( null ) ; } catch ( CloneNotSupportedException cnse ) { throw new WrappedRuntimeException ( cnse ) ; } return newIter ; } protected boolean stepsEqual ( WalkingIterator iter1 , WalkingIterator iter2 , int numSteps ) { AxesWalker aw1 = iter1 . getFirstWalker ( ) ; AxesWalker aw2 = iter2 . getFirstWalker ( ) ; for ( int i = 0 ; ( i < numSteps ) ; i ++ ) { if ( ( null == aw1 ) || ( null == aw2 ) ) return false ; if ( ! aw1 . deepEquals ( aw2 ) ) return false ; aw1 = aw1 . getNextWalker ( ) ; aw2 = aw2 . getNextWalker ( ) ; } assertion ( ( null != aw1 ) || ( null != aw2 ) , "Total match is incorrect!" ) ; return true ; } protected MultistepExprHolder createMultistepExprList ( Vector paths ) { MultistepExprHolder first = null ; int n = paths . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner eo = ( ExpressionOwner ) paths . elementAt ( i ) ; if ( null == eo ) continue ; LocPathIterator lpi = ( LocPathIterator ) eo . getExpression ( ) ; int numPaths = countSteps ( lpi ) ; if ( numPaths > 1 ) { if ( null == first ) first = new MultistepExprHolder ( eo , numPaths , null ) ; else first = first . addInSortedOrder ( eo , numPaths ) ; } } if ( ( null == first ) || ( first . getLength ( ) <= 1 ) ) return null ; else return first ; } protected int findAndEliminateRedundant ( int start , int firstOccuranceIndex , ExpressionOwner firstOccuranceOwner , ElemTemplateElement psuedoVarRecipient , Vector paths ) throws org . w3c . dom . DOMException { MultistepExprHolder head = null ; MultistepExprHolder tail = null ; int numPathsFound = 0 ; int n = paths . size ( ) ; Expression expr1 = firstOccuranceOwner . getExpression ( ) ; if ( DEBUG ) assertIsLocPathIterator ( expr1 , firstOccuranceOwner ) ; boolean isGlobal = ( paths == m_absPaths ) ; LocPathIterator lpi = ( LocPathIterator ) expr1 ; int stepCount = countSteps ( lpi ) ; for ( int j = start ; j < n ; j ++ ) { ExpressionOwner owner2 = ( ExpressionOwner ) paths . elementAt ( j ) ; if ( null != owner2 ) { Expression expr2 = owner2 . getExpression ( ) ; boolean isEqual = expr2 . deepEquals ( lpi ) ; if ( isEqual ) { LocPathIterator lpi2 = ( LocPathIterator ) expr2 ; if ( null == head ) { head = new MultistepExprHolder ( firstOccuranceOwner , stepCount , null ) ; tail = head ; numPathsFound ++ ; } tail . m_next = new MultistepExprHolder ( owner2 , stepCount , null ) ; tail = tail . m_next ; paths . setElementAt ( null , j ) ; numPathsFound ++ ; } } } if ( ( 0 == numPathsFound ) && isGlobal ) { head = new MultistepExprHolder ( firstOccuranceOwner , stepCount , null ) ; numPathsFound ++ ; } if ( null != head ) { ElemTemplateElement root = isGlobal ? psuedoVarRecipient : findCommonAncestor ( head ) ; LocPathIterator sharedIter = ( LocPathIterator ) head . m_exprOwner . getExpression ( ) ; ElemVariable var = createPsuedoVarDecl ( root , sharedIter , isGlobal ) ; if ( DIAGNOSE_MULTISTEPLIST ) System . err . println ( "Created var: " + var . getName ( ) + ( isGlobal ? "(Global)" : "" ) ) ; QName uniquePsuedoVarName = var . getName ( ) ; while ( null != head ) { ExpressionOwner owner = head . m_exprOwner ; if ( DIAGNOSE_MULTISTEPLIST ) diagnoseLineNumber ( owner . getExpression ( ) ) ; changeToVarRef ( uniquePsuedoVarName , owner , paths , root ) ; head = head . m_next ; } paths . setElementAt ( var . getSelect ( ) , firstOccuranceIndex ) ; } return numPathsFound ; } protected int oldFindAndEliminateRedundant ( int start , int firstOccuranceIndex , ExpressionOwner firstOccuranceOwner , ElemTemplateElement psuedoVarRecipient , Vector paths ) throws org . w3c . dom . DOMException { QName uniquePsuedoVarName = null ; boolean foundFirst = false ; int numPathsFound = 0 ; int n = paths . size ( ) ; Expression expr1 = firstOccuranceOwner . getExpression ( ) ; if ( DEBUG ) assertIsLocPathIterator ( expr1 , firstOccuranceOwner ) ; boolean isGlobal = ( paths == m_absPaths ) ; LocPathIterator lpi = ( LocPathIterator ) expr1 ; for ( int j = start ; j < n ; j ++ ) { ExpressionOwner owner2 = ( ExpressionOwner ) paths . elementAt ( j ) ; if ( null != owner2 ) { Expression expr2 = owner2 . getExpression ( ) ; boolean isEqual = expr2 . deepEquals ( lpi ) ; if ( isEqual ) { LocPathIterator lpi2 = ( LocPathIterator ) expr2 ; if ( ! foundFirst ) { foundFirst = true ; ElemVariable var = createPsuedoVarDecl ( psuedoVarRecipient , lpi , isGlobal ) ; if ( null == var ) return 0 ; uniquePsuedoVarName = var . getName ( ) ; changeToVarRef ( uniquePsuedoVarName , firstOccuranceOwner , paths , psuedoVarRecipient ) ; paths . setElementAt ( var . getSelect ( ) , firstOccuranceIndex ) ; numPathsFound ++ ; } changeToVarRef ( uniquePsuedoVarName , owner2 , paths , psuedoVarRecipient ) ; paths . setElementAt ( null , j ) ; numPathsFound ++ ; } } } if ( ( 0 == numPathsFound ) && ( paths == m_absPaths ) ) { ElemVariable var = createPsuedoVarDecl ( psuedoVarRecipient , lpi , true ) ; if ( null == var ) return 0 ; uniquePsuedoVarName = var . getName ( ) ; changeToVarRef ( uniquePsuedoVarName , firstOccuranceOwner , paths , psuedoVarRecipient ) ; paths . setElementAt ( var . getSelect ( ) , firstOccuranceIndex ) ; numPathsFound ++ ; } return numPathsFound ; } protected int countSteps ( LocPathIterator lpi ) { if ( lpi instanceof WalkingIterator ) { WalkingIterator wi = ( WalkingIterator ) lpi ; AxesWalker aw = wi . getFirstWalker ( ) ; int count = 0 ; while ( null != aw ) { count ++ ; aw = aw . getNextWalker ( ) ; } return count ; } else return 1 ; } protected void changeToVarRef ( QName varName , ExpressionOwner owner , Vector paths , ElemTemplateElement psuedoVarRecipient ) { Variable varRef = ( paths == m_absPaths ) ? new VariableSafeAbsRef ( ) : new Variable ( ) ; varRef . setQName ( varName ) ; if ( paths == m_absPaths ) { StylesheetRoot root = ( StylesheetRoot ) psuedoVarRecipient ; Vector globalVars = root . getVariablesAndParamsComposed ( ) ; varRef . setIndex ( globalVars . size ( ) - 1 ) ; varRef . setIsGlobal ( true ) ; } owner . setExpression ( varRef ) ; } protected ElemVariable createPsuedoVarDecl ( ElemTemplateElement psuedoVarRecipient , LocPathIterator lpi , boolean isGlobal ) throws org . w3c . dom . DOMException { QName uniquePsuedoVarName = new QName ( PSUEDOVARNAMESPACE , "#" + m_uniquePsuedoVarID ) ; m_uniquePsuedoVarID ++ ; if ( isGlobal ) { return createGlobalPsuedoVarDecl ( uniquePsuedoVarName , ( StylesheetRoot ) psuedoVarRecipient , lpi ) ; } else return createLocalPsuedoVarDecl ( uniquePsuedoVarName , psuedoVarRecipient , lpi ) ; } protected ElemVariable createGlobalPsuedoVarDecl ( QName uniquePsuedoVarName , StylesheetRoot stylesheetRoot , LocPathIterator lpi ) throws org . w3c . dom . DOMException { ElemVariable psuedoVar = new ElemVariable ( ) ; psuedoVar . setIsTopLevel ( true ) ; XPath xpath = new XPath ( lpi ) ; psuedoVar . setSelect ( xpath ) ; psuedoVar . setName ( uniquePsuedoVarName ) ; Vector globalVars = stylesheetRoot . getVariablesAndParamsComposed ( ) ; psuedoVar . setIndex ( globalVars . size ( ) ) ; globalVars . addElement ( psuedoVar ) ; return psuedoVar ; } protected ElemVariable createLocalPsuedoVarDecl ( QName uniquePsuedoVarName , ElemTemplateElement psuedoVarRecipient , LocPathIterator lpi ) throws org . w3c . dom . DOMException { ElemVariable psuedoVar = new ElemVariablePsuedo ( ) ; XPath xpath = new XPath ( lpi ) ; psuedoVar . setSelect ( xpath ) ; psuedoVar . setName ( uniquePsuedoVarName ) ; ElemVariable var = addVarDeclToElem ( psuedoVarRecipient , lpi , psuedoVar ) ; lpi . exprSetParent ( var ) ; return var ; } protected ElemVariable addVarDeclToElem ( ElemTemplateElement psuedoVarRecipient , LocPathIterator lpi , ElemVariable psuedoVar ) throws org . w3c . dom . DOMException { ElemTemplateElement ete = psuedoVarRecipient . getFirstChildElem ( ) ; lpi . callVisitors ( null , m_varNameCollector ) ; if ( m_varNameCollector . getVarCount ( ) > 0 ) { ElemTemplateElement baseElem = getElemFromExpression ( lpi ) ; ElemVariable varElem = getPrevVariableElem ( baseElem ) ; while ( null != varElem ) { if ( m_varNameCollector . doesOccur ( varElem . getName ( ) ) ) { psuedoVarRecipient = varElem . getParentElem ( ) ; ete = varElem . getNextSiblingElem ( ) ; break ; } varElem = getPrevVariableElem ( varElem ) ; } } if ( ( null != ete ) && ( Constants . ELEMNAME_PARAMVARIABLE == ete . getXSLToken ( ) ) ) { if ( isParam ( lpi ) ) return null ; while ( null != ete ) { ete = ete . getNextSiblingElem ( ) ; if ( ( null != ete ) && Constants . ELEMNAME_PARAMVARIABLE != ete . getXSLToken ( ) ) break ; } } psuedoVarRecipient . insertBefore ( psuedoVar , ete ) ; m_varNameCollector . reset ( ) ; return psuedoVar ; } protected boolean isParam ( ExpressionNode expr ) { while ( null != expr ) { if ( expr instanceof ElemTemplateElement ) break ; expr = expr . exprGetParent ( ) ; } if ( null != expr ) { ElemTemplateElement ete = ( ElemTemplateElement ) expr ; while ( null != ete ) { int type = ete . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_PARAMVARIABLE : return true ; case Constants . ELEMNAME_TEMPLATE : case Constants . ELEMNAME_STYLESHEET : return false ; } ete = ete . getParentElem ( ) ; } } return false ; } protected ElemVariable getPrevVariableElem ( ElemTemplateElement elem ) { while ( null != ( elem = getPrevElementWithinContext ( elem ) ) ) { int type = elem . getXSLToken ( ) ; if ( ( Constants . ELEMNAME_VARIABLE == type ) || ( Constants . ELEMNAME_PARAMVARIABLE == type ) ) { return ( ElemVariable ) elem ; } } return null ; } protected ElemTemplateElement getPrevElementWithinContext ( ElemTemplateElement elem ) { ElemTemplateElement prev = elem . getPreviousSiblingElem ( ) ; if ( null == prev ) prev = elem . getParentElem ( ) ; if ( null != prev ) { int type = prev . getXSLToken ( ) ; if ( ( Constants . ELEMNAME_FOREACH == type ) || ( Constants . ELEMNAME_TEMPLATE == type ) || ( Constants . ELEMNAME_STYLESHEET == type ) ) { prev = null ; } } return prev ; } protected ElemTemplateElement getElemFromExpression ( Expression expr ) { ExpressionNode parent = expr . exprGetParent ( ) ; while ( null != parent ) { if ( parent instanceof ElemTemplateElement ) return ( ElemTemplateElement ) parent ; parent = parent . exprGetParent ( ) ; } throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ASSERT_NO_TEMPLATE_PARENT , null ) ) ; } public boolean isAbsolute ( LocPathIterator path ) { int analysis = path . getAnalysisBits ( ) ; boolean isAbs = ( WalkerFactory . isSet ( analysis , WalkerFactory . BIT_ROOT ) || WalkerFactory . isSet ( analysis , WalkerFactory . BIT_ANY_DESCENDANT_FROM_ROOT ) ) ; if ( isAbs ) { isAbs = m_absPathChecker . checkAbsolute ( path ) ; } return isAbs ; } public boolean visitLocationPath ( ExpressionOwner owner , LocPathIterator path ) { if ( path instanceof SelfIteratorNoPredicate ) { return true ; } else if ( path instanceof WalkingIterator ) { WalkingIterator wi = ( WalkingIterator ) path ; AxesWalker aw = wi . getFirstWalker ( ) ; if ( ( aw instanceof FilterExprWalker ) && ( null == aw . getNextWalker ( ) ) ) { FilterExprWalker few = ( FilterExprWalker ) aw ; Expression exp = few . getInnerExpression ( ) ; if ( exp instanceof Variable ) return true ; } } if ( isAbsolute ( path ) && ( null != m_absPaths ) ) { if ( DEBUG ) validateNewAddition ( m_absPaths , owner , path ) ; m_absPaths . addElement ( owner ) ; } else if ( m_isSameContext && ( null != m_paths ) ) { if ( DEBUG ) validateNewAddition ( m_paths , owner , path ) ; m_paths . addElement ( owner ) ; } return true ; } public boolean visitPredicate ( ExpressionOwner owner , Expression pred ) { boolean savedIsSame = m_isSameContext ; m_isSameContext = false ; pred . callVisitors ( owner , this ) ; m_isSameContext = savedIsSame ; return false ; } boolean visitTopLevelInstruction ( ElemTemplateElement elem ) { int type = elem . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEMPLATE : return visitInstruction ( elem ) ; default : return true ; } } boolean visitInstruction ( ElemTemplateElement elem ) { int type = elem . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_CALLTEMPLATE : case Constants . ELEMNAME_TEMPLATE : case Constants . ELEMNAME_FOREACH : { if ( type == Constants . ELEMNAME_FOREACH ) { ElemForEach efe = ( ElemForEach ) elem ; Expression select = efe . getSelect ( ) ; select . callVisitors ( efe , this ) ; } Vector savedPaths = m_paths ; m_paths = new Vector ( ) ; elem . callChildVisitors ( this , false ) ; eleminateRedundentLocals ( elem ) ; m_paths = savedPaths ; return false ; } case Constants . ELEMNAME_NUMBER : case Constants . ELEMNAME_SORT : boolean savedIsSame = m_isSameContext ; m_isSameContext = false ; elem . callChildVisitors ( this ) ; m_isSameContext = savedIsSame ; return false ; default : return true ; } } protected void diagnoseNumPaths ( Vector paths , int numPathsEliminated , int numUniquePathsEliminated ) { if ( numPathsEliminated > 0 ) { if ( paths == m_paths ) { System . err . println ( "Eliminated " + numPathsEliminated + " total paths!" ) ; System . err . println ( "Consolodated " + numUniquePathsEliminated + " redundent paths!" ) ; } else { System . err . println ( "Eliminated " + numPathsEliminated + " total global paths!" ) ; System . err . println ( "Consolodated " + numUniquePathsEliminated + " redundent global paths!" ) ; } } } private final void assertIsLocPathIterator ( Expression expr1 , ExpressionOwner eo ) throws RuntimeException { if ( ! ( expr1 instanceof LocPathIterator ) ) { String errMsg ; if ( expr1 instanceof Variable ) { errMsg = "Programmer's assertion: expr1 not an iterator: " + ( ( Variable ) expr1 ) . getQName ( ) ; } else { errMsg = "Programmer's assertion: expr1 not an iterator: " + expr1 . getClass ( ) . getName ( ) ; } throw new RuntimeException ( errMsg + ", " + eo . getClass ( ) . getName ( ) + " " + expr1 . exprGetParent ( ) ) ; } } private static void validateNewAddition ( Vector paths , ExpressionOwner owner , LocPathIterator path ) throws RuntimeException { assertion ( owner . getExpression ( ) == path , "owner.getExpression() != path!!!" ) ; int n = paths . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ExpressionOwner ew = ( ExpressionOwner ) paths . elementAt ( i ) ; assertion ( ew != owner , "duplicate owner on the list!!!" ) ; assertion ( ew . getExpression ( ) != path , "duplicate expression on the list!!!" ) ; } } protected static void assertion ( boolean b , String msg ) { if ( ! b ) { throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR , new Object [ ] { msg } ) ) ; } } class MultistepExprHolder implements Cloneable { ExpressionOwner m_exprOwner ; final int m_stepCount ; MultistepExprHolder m_next ; public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } MultistepExprHolder ( ExpressionOwner exprOwner , int stepCount , MultistepExprHolder next ) { m_exprOwner = exprOwner ; assertion ( null != m_exprOwner , "exprOwner can not be null!" ) ; m_stepCount = stepCount ; m_next = next ; } MultistepExprHolder addInSortedOrder ( ExpressionOwner exprOwner , int stepCount ) { MultistepExprHolder first = this ; MultistepExprHolder next = this ; MultistepExprHolder prev = null ; while ( null != next ) { if ( stepCount >= next . m_stepCount ) { MultistepExprHolder newholder = new MultistepExprHolder ( exprOwner , stepCount , next ) ; if ( null == prev ) first = newholder ; else prev . m_next = newholder ; return first ; } prev = next ; next = next . m_next ; } prev . m_next = new MultistepExprHolder ( exprOwner , stepCount , null ) ; return first ; } MultistepExprHolder unlink ( MultistepExprHolder itemToRemove ) { MultistepExprHolder first = this ; MultistepExprHolder next = this ; MultistepExprHolder prev = null ; while ( null != next ) { if ( next == itemToRemove ) { if ( null == prev ) first = next . m_next ; else prev . m_next = next . m_next ; next . m_next = null ; return first ; } prev = next ; next = next . m_next ; } assertion ( false , "unlink failed!!!" ) ; return null ; } int getLength ( ) { int count = 0 ; MultistepExprHolder next = this ; while ( null != next ) { count ++ ; next = next . m_next ; } return count ; } protected void diagnose ( ) { System . err . print ( "Found multistep iterators: " + this . getLength ( ) + "  " ) ; MultistepExprHolder next = this ; while ( null != next ) { System . err . print ( "" + next . m_stepCount ) ; next = next . m_next ; if ( null != next ) System . err . print ( ", " ) ; } System . err . println ( ) ; } } } 	0
package org . apache . xml . utils . synthetic . reflection ; import org . apache . xml . utils . synthetic . SynthesisException ; public class Method extends EntryPoint implements Member { public Method ( String name , org . apache . xml . utils . synthetic . Class declaringclass ) { super ( declaringclass ) ; this . name = name ; } public Method ( java . lang . reflect . Method ctor , org . apache . xml . utils . synthetic . Class declaringclass ) { super ( ctor , declaringclass ) ; } public Method ( java . lang . reflect . Method realmethod ) { super ( realmethod ) ; } public int hashCode ( ) { return getDeclaringClass ( ) . getName ( ) . hashCode ( ) ^ getName ( ) . hashCode ( ) ; } public Object invoke ( Object obj , Object args [ ] ) throws IllegalAccessException , IllegalArgumentException , java . lang . reflect . InvocationTargetException { if ( realep != null ) return ( ( java . lang . reflect . Method ) realep ) . invoke ( obj , args ) ; else throw new IllegalAccessException ( "Un-reified org.apache.xml.utils.synthetic.Class doesn't yet support invocation" ) ; } public void setReturnType ( org . apache . xml . utils . synthetic . Class returntype ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . returntype = returntype ; } } 	1
package org . apache . xalan . lib . sql ; import java . sql . SQLException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; public class SQLErrorDocument extends DTMDocument { private static final String S_EXT_ERROR = "ext-error" ; private static final String S_SQL_ERROR = "sql-error" ; private static final String S_MESSAGE = "message" ; private static final String S_CODE = "code" ; private int m_ErrorExt_TypeID = DTM . NULL ; private int m_Message_TypeID = DTM . NULL ; private int m_Code_TypeID = DTM . NULL ; private int m_SQLError_TypeID = DTM . NULL ; private int m_rootID = DTM . NULL ; private int m_extErrorID = DTM . NULL ; private int m_MainMessageID = DTM . NULL ; public SQLErrorDocument ( DTMManager mgr , int ident , SQLException error ) { super ( mgr , ident ) ; createExpandedNameTable ( ) ; buildBasicStructure ( error ) ; int sqlError = addElement ( 2 , m_SQLError_TypeID , m_extErrorID , m_MainMessageID ) ; int element = DTM . NULL ; element = addElementWithData ( new Integer ( error . getErrorCode ( ) ) , 3 , m_Code_TypeID , sqlError , element ) ; element = addElementWithData ( error . getLocalizedMessage ( ) , 3 , m_Message_TypeID , sqlError , element ) ; } public SQLErrorDocument ( DTMManager mgr , int ident , Exception error ) { super ( mgr , ident ) ; createExpandedNameTable ( ) ; buildBasicStructure ( error ) ; } private void buildBasicStructure ( Exception e ) { m_rootID = addElement ( 0 , m_Document_TypeID , DTM . NULL , DTM . NULL ) ; m_extErrorID = addElement ( 1 , m_ErrorExt_TypeID , m_rootID , DTM . NULL ) ; m_MainMessageID = addElementWithData ( e . getLocalizedMessage ( ) , 2 , m_Message_TypeID , m_extErrorID , DTM . NULL ) ; } protected void createExpandedNameTable ( ) { super . createExpandedNameTable ( ) ; m_ErrorExt_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_EXT_ERROR , DTM . ELEMENT_NODE ) ; m_SQLError_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SQL_ERROR , DTM . ELEMENT_NODE ) ; m_Message_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_MESSAGE , DTM . ELEMENT_NODE ) ; m_Code_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_CODE , DTM . ELEMENT_NODE ) ; } } 	0
package org . apache . xml . utils ; import java . io . File ; import org . w3c . dom . Comment ; import org . w3c . dom . Element ; import org . w3c . dom . EntityReference ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . LocatorImpl ; public class TreeWalker { private ContentHandler m_contentHandler = null ; protected DOMHelper m_dh ; private LocatorImpl m_locator = new LocatorImpl ( ) ; public ContentHandler getContentHandler ( ) { return m_contentHandler ; } public void setContentHandler ( ContentHandler ch ) { m_contentHandler = ch ; } public TreeWalker ( ContentHandler contentHandler , DOMHelper dh , String systemId ) { this . m_contentHandler = contentHandler ; m_contentHandler . setDocumentLocator ( m_locator ) ; if ( systemId != null ) m_locator . setSystemId ( systemId ) ; else { try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) + File . separator + "dummy.xsl" ) ; } catch ( SecurityException se ) { m_locator . setSystemId ( "" ) ; } } m_dh = dh ; } public TreeWalker ( ContentHandler contentHandler , DOMHelper dh ) { this . m_contentHandler = contentHandler ; m_contentHandler . setDocumentLocator ( m_locator ) ; try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) + File . separator + "dummy.xsl" ) ; } catch ( SecurityException se ) { m_locator . setSystemId ( "" ) ; } m_dh = dh ; } public TreeWalker ( ContentHandler contentHandler ) { this . m_contentHandler = contentHandler ; if ( m_contentHandler != null ) m_contentHandler . setDocumentLocator ( m_locator ) ; try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) + File . separator + "dummy.xsl" ) ; } catch ( SecurityException se ) { m_locator . setSystemId ( "" ) ; } m_dh = new DOM2Helper ( ) ; } public void traverse ( Node pos ) throws org . xml . sax . SAXException { this . m_contentHandler . startDocument ( ) ; Node top = pos ; while ( null != pos ) { startNode ( pos ) ; Node nextNode = pos . getFirstChild ( ) ; while ( null == nextNode ) { endNode ( pos ) ; if ( top . equals ( pos ) ) break ; nextNode = pos . getNextSibling ( ) ; if ( null == nextNode ) { pos = pos . getParentNode ( ) ; if ( ( null == pos ) || ( top . equals ( pos ) ) ) { if ( null != pos ) endNode ( pos ) ; nextNode = null ; break ; } } } pos = nextNode ; } this . m_contentHandler . endDocument ( ) ; } public void traverse ( Node pos , Node top ) throws org . xml . sax . SAXException { this . m_contentHandler . startDocument ( ) ; while ( null != pos ) { startNode ( pos ) ; Node nextNode = pos . getFirstChild ( ) ; while ( null == nextNode ) { endNode ( pos ) ; if ( ( null != top ) && top . equals ( pos ) ) break ; nextNode = pos . getNextSibling ( ) ; if ( null == nextNode ) { pos = pos . getParentNode ( ) ; if ( ( null == pos ) || ( ( null != top ) && top . equals ( pos ) ) ) { nextNode = null ; break ; } } } pos = nextNode ; } this . m_contentHandler . endDocument ( ) ; } boolean nextIsRaw = false ; private final void dispatachChars ( Node node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler ) { ( ( org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler ) m_contentHandler ) . characters ( node ) ; } else { String data = ( ( Text ) node ) . getData ( ) ; this . m_contentHandler . characters ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } protected void startNode ( Node node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof NodeConsumer ) { ( ( NodeConsumer ) m_contentHandler ) . setOriginatingNode ( node ) ; } if ( node instanceof Locator ) { Locator loc = ( Locator ) node ; m_locator . setColumnNumber ( loc . getColumnNumber ( ) ) ; m_locator . setLineNumber ( loc . getLineNumber ( ) ) ; m_locator . setPublicId ( loc . getPublicId ( ) ) ; m_locator . setSystemId ( loc . getSystemId ( ) ) ; } else { m_locator . setColumnNumber ( 0 ) ; m_locator . setLineNumber ( 0 ) ; } switch ( node . getNodeType ( ) ) { case Node . COMMENT_NODE : { String data = ( ( Comment ) node ) . getData ( ) ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } break ; case Node . DOCUMENT_FRAGMENT_NODE : break ; case Node . DOCUMENT_NODE : break ; case Node . ELEMENT_NODE : NamedNodeMap atts = ( ( Element ) node ) . getAttributes ( ) ; int nAttrs = atts . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { Node attr = atts . item ( i ) ; String attrName = attr . getNodeName ( ) ; if ( attrName . equals ( "xmlns" ) || attrName . startsWith ( "xmlns:" ) ) { int index ; String prefix = ( index = attrName . indexOf ( ":" ) ) < 0 ? "" : attrName . substring ( index + 1 ) ; this . m_contentHandler . startPrefixMapping ( prefix , attr . getNodeValue ( ) ) ; } } String ns = m_dh . getNamespaceOfNode ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . startElement ( ns , m_dh . getLocalNameOfNode ( node ) , node . getNodeName ( ) , new AttList ( atts , m_dh ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : { ProcessingInstruction pi = ( ProcessingInstruction ) node ; String name = pi . getNodeName ( ) ; if ( name . equals ( "xslt-next-is-raw" ) ) { nextIsRaw = true ; } else { this . m_contentHandler . processingInstruction ( pi . getNodeName ( ) , pi . getData ( ) ) ; } } break ; case Node . CDATA_SECTION_NODE : { boolean isLexH = ( m_contentHandler instanceof LexicalHandler ) ; LexicalHandler lh = isLexH ? ( ( LexicalHandler ) this . m_contentHandler ) : null ; if ( isLexH ) { lh . startCDATA ( ) ; } dispatachChars ( node ) ; { if ( isLexH ) { lh . endCDATA ( ) ; } } } break ; case Node . TEXT_NODE : { if ( nextIsRaw ) { nextIsRaw = false ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; dispatachChars ( node ) ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { dispatachChars ( node ) ; } } break ; case Node . ENTITY_REFERENCE_NODE : { EntityReference eref = ( EntityReference ) node ; if ( m_contentHandler instanceof LexicalHandler ) { ( ( LexicalHandler ) this . m_contentHandler ) . startEntity ( eref . getNodeName ( ) ) ; } else { } } break ; default : } } protected void endNode ( Node node ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_NODE : break ; case Node . ELEMENT_NODE : String ns = m_dh . getNamespaceOfNode ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . endElement ( ns , m_dh . getLocalNameOfNode ( node ) , node . getNodeName ( ) ) ; NamedNodeMap atts = ( ( Element ) node ) . getAttributes ( ) ; int nAttrs = atts . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { Node attr = atts . item ( i ) ; String attrName = attr . getNodeName ( ) ; if ( attrName . equals ( "xmlns" ) || attrName . startsWith ( "xmlns:" ) ) { int index ; String prefix = ( index = attrName . indexOf ( ":" ) ) < 0 ? "" : attrName . substring ( index + 1 ) ; this . m_contentHandler . endPrefixMapping ( prefix ) ; } } break ; case Node . CDATA_SECTION_NODE : break ; case Node . ENTITY_REFERENCE_NODE : { EntityReference eref = ( EntityReference ) node ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . endEntity ( eref . getNodeName ( ) ) ; } } break ; default : } } } 	1
package org . apache . xml . res ; public class XMLErrorResources_sv extends XMLErrorResources { public static final int MAX_CODE = 61 ; public static final int MAX_WARNING = 0 ; public static final int MAX_OTHERS = 4 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ER0000" , "{0}" } , { ER_FUNCTION_NOT_SUPPORTED , "Funktion inte understdd:" } , { ER_CANNOT_OVERWRITE_CAUSE , "Kan inte skriva ver orsak" } , { ER_NO_DEFAULT_IMPL , "Standardimplementering saknas i:" } , { ER_CHUNKEDINTARRAY_NOT_SUPPORTED , "ChunkedIntArray({0}) understds fr nrvarande inte" } , { ER_OFFSET_BIGGER_THAN_SLOT , "Offset strre n fack" } , { ER_COROUTINE_NOT_AVAIL , "Sidorutin inte tillgnglig, id={0}" } , { ER_COROUTINE_CO_EXIT , "CoroutineManager mottog co_exit()-frfrgan" } , { ER_COJOINROUTINESET_FAILED , "co_joinCoroutineSet() misslyckades" } , { ER_COROUTINE_PARAM , "Sidorutin fick parameterfel ({0})" } , { ER_PARSER_DOTERMINATE_ANSWERS , "\nOVNTAT: Parser doTerminate-svar {0}" } , { ER_NO_PARSE_CALL_WHILE_PARSING , "parse fr inte anropas medan tolkning sker" } , { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED , "Fel: typad upprepare fr axel {0} inte implementerad" } , { ER_ITERATOR_AXIS_NOT_IMPLEMENTED , "Fel: upprepare fr axel {0} inte implementerad" } , { ER_ITERATOR_CLONE_NOT_SUPPORTED , "Uppreparklon understds inte" } , { ER_UNKNOWN_AXIS_TYPE , "Oknd axeltraverstyp: {0}" } , { ER_AXIS_NOT_SUPPORTED , "Axeltravers understds inte: {0}" } , { ER_NO_DTMIDS_AVAIL , "Inga fler DTM-IDs r tillgngliga" } , { ER_NOT_SUPPORTED , "Understds inte: {0}" } , { ER_NODE_NON_NULL , "Nod mste vara icke-null fr getDTMHandleFromNode" } , { ER_COULD_NOT_RESOLVE_NODE , "Kunde inte lsa nod till ett handtag" } , { ER_STARTPARSE_WHILE_PARSING , "startParse fr inte anropas medan tolkning sker" } , { ER_STARTPARSE_NEEDS_SAXPARSER , "startParse behver en SAXParser som r icke-null" } , { ER_COULD_NOT_INIT_PARSER , "kunde inte initialisera tolk med" } , { ER_EXCEPTION_CREATING_POOL , "undantag skapar ny instans fr pool" } , { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE , "Vg innehller ogiltig flyktsekvens" } , { ER_SCHEME_REQUIRED , "Schema krvs!" } , { ER_NO_SCHEME_IN_URI , "Schema saknas i URI: {0}" } , { ER_NO_SCHEME_INURI , "Schema saknas i URI" } , { ER_PATH_INVALID_CHAR , "Vg innehller ogiltigt tecken: {0}" } , { ER_SCHEME_FROM_NULL_STRING , "Kan inte stta schema frn null-strng" } , { ER_SCHEME_NOT_CONFORMANT , "Schemat r inte likformigt." } , { ER_HOST_ADDRESS_NOT_WELLFORMED , "Vrd r inte en vlformulerad adress" } , { ER_PORT_WHEN_HOST_NULL , "Port kan inte sttas nr vrd r null" } , { ER_INVALID_PORT , "Ogiltigt portnummer" } , { ER_FRAG_FOR_GENERIC_URI , "Fragment kan bara sttas fr en allmn URI" } , { ER_FRAG_WHEN_PATH_NULL , "Fragment kan inte sttas nr vg r null" } , { ER_FRAG_INVALID_CHAR , "Fragment innehller ogiltigt tecken" } , { ER_PARSER_IN_USE , "Tolk anvnds redan" } , { ER_CANNOT_CHANGE_WHILE_PARSING , "Kan inte ndra {0} {1} medan tolkning sker" } , { ER_SELF_CAUSATION_NOT_PERMITTED , "Sjlvorsakande inte tillten" } , { ER_NO_USERINFO_IF_NO_HOST , "Userinfo fr inte anges om vrden inte r angiven" } , { ER_NO_PORT_IF_NO_HOST , "Port fr inte anges om vrden inte r angiven" } , { ER_NO_QUERY_STRING_IN_PATH , "Frfrgan-strng kan inte anges i vg och frfrgan-strng" } , { ER_NO_FRAGMENT_STRING_IN_PATH , "Fragment kan inte anges i bde vgen och fragmentet" } , { ER_CANNOT_INIT_URI_EMPTY_PARMS , "Kan inte initialisera URI med tomma parametrar" } , { ER_METHOD_NOT_SUPPORTED , "Metod nnu inte understdd " } , { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , "IncrementalSAXSource_Filter kan fr nrvarande inte startas om" } , { ER_XMLRDR_NOT_BEFORE_STARTPARSE , "XMLReader inte innan startParse-begran" } , { ER_AXIS_TRAVERSER_NOT_SUPPORTED , "Det gr inte att vnda axeln: {0}" } , { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER , "ListingErrorHandler skapad med null PrintWriter!" } , { ER_SYSTEMID_UNKNOWN , "SystemId oknt" } , { ER_LOCATION_UNKNOWN , "Platsen fr felet r oknd" } , { ER_PREFIX_MUST_RESOLVE , "Prefix must resolve to a namespace: {0}" } , { ER_CREATEDOCUMENT_NOT_SUPPORTED , "createDocument() understds inte av XPathContext!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT , "Attributbarn saknar gardokument!" } , { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , "Attributbarn saknar gardokumentelement!" } , { ER_CANT_OUTPUT_TEXT_BEFORE_DOC , "Varning: kan inte skriva ut text innan dokumentelement!  Ignorerar..." } , { ER_CANT_HAVE_MORE_THAN_ONE_ROOT , "Kan inte ha mer n en rot p en DOM!" } , { ER_ARG_LOCALNAME_NULL , "Argument 'localName' r null" } , { ER_ARG_LOCALNAME_INVALID , "Localname i QNAME br vara ett giltigt NCName" } , { ER_ARG_PREFIX_INVALID , "Prefixet i QNAME br vara ett giltigt NCName" } , { "BAD_CODE" , "Parameter till createMessage ligger utanfr tilltet intervall" } , { "FORMAT_FAILED" , "Undantag utlst vid messageFormat-anrop" } , { "line" , "Rad #" } , { "column" , "Kolumn #" } } ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	0
package org . apache . xalan . processor ; public class ProcessorStylesheetDoc extends XSLTElementProcessor { } 	1
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DUP ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . SWITCH ; import org . apache . bcel . generic . TargetLostException ; import org . apache . bcel . util . InstructionFinder ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NamedMethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class Mode implements Constants { private final QName _name ; private final Stylesheet _stylesheet ; private final String _methodName ; private Vector _templates ; private Vector _childNodeGroup = null ; private TestSeq _childNodeTestSeq = null ; private Vector _attribNodeGroup = null ; private TestSeq _attribNodeTestSeq = null ; private Vector _idxGroup = null ; private TestSeq _idxTestSeq = null ; private Vector [ ] _patternGroups ; private TestSeq [ ] _testSeq ; private Hashtable _preCompiled = new Hashtable ( ) ; private Hashtable _neededTemplates = new Hashtable ( ) ; private Hashtable _namedTemplates = new Hashtable ( ) ; private Hashtable _templateIHs = new Hashtable ( ) ; private Hashtable _templateILs = new Hashtable ( ) ; private LocationPathPattern _rootPattern = null ; private Hashtable _importLevels = null ; private Hashtable _keys = null ; private int _currentIndex ; public Mode ( QName name , Stylesheet stylesheet , String suffix ) { _name = name ; _stylesheet = stylesheet ; _methodName = APPLY_TEMPLATES + suffix ; _templates = new Vector ( ) ; _patternGroups = new Vector [ 32 ] ; } public String functionName ( ) { return _methodName ; } public String functionName ( int min , int max ) { if ( _importLevels == null ) { _importLevels = new Hashtable ( ) ; } _importLevels . put ( new Integer ( max ) , new Integer ( min ) ) ; return _methodName + '_' + max ; } public void addInstructionList ( Pattern pattern , InstructionList ilist ) { _preCompiled . put ( pattern , ilist ) ; } public InstructionList getInstructionList ( Pattern pattern ) { return ( InstructionList ) _preCompiled . get ( pattern ) ; } private String getClassName ( ) { return _stylesheet . getClassName ( ) ; } public Stylesheet getStylesheet ( ) { return _stylesheet ; } public void addTemplate ( Template template ) { _templates . addElement ( template ) ; } private Vector quicksort ( Vector templates , int p , int r ) { if ( p < r ) { final int q = partition ( templates , p , r ) ; quicksort ( templates , p , q ) ; quicksort ( templates , q + 1 , r ) ; } return templates ; } private int partition ( Vector templates , int p , int r ) { final Template x = ( Template ) templates . elementAt ( p ) ; int i = p - 1 ; int j = r + 1 ; while ( true ) { while ( x . compareTo ( ( Template ) templates . elementAt ( -- j ) ) > 0 ) ; while ( x . compareTo ( ( Template ) templates . elementAt ( ++ i ) ) < 0 ) ; if ( i < j ) { templates . set ( j , templates . set ( i , templates . elementAt ( j ) ) ) ; } else { return j ; } } } public void processPatterns ( Hashtable keys ) { _keys = keys ; _templates = quicksort ( _templates , 0 , _templates . size ( ) - 1 ) ; final Enumeration templates = _templates . elements ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; if ( template . isNamed ( ) && ! template . disabled ( ) ) { _namedTemplates . put ( template , this ) ; } final Pattern pattern = template . getPattern ( ) ; if ( pattern != null ) { flattenAlternative ( pattern , template , keys ) ; } } prepareTestSequences ( ) ; } private void flattenAlternative ( Pattern pattern , Template template , Hashtable keys ) { if ( pattern instanceof IdKeyPattern ) { final IdKeyPattern idkey = ( IdKeyPattern ) pattern ; idkey . setTemplate ( template ) ; if ( _idxGroup == null ) _idxGroup = new Vector ( ) ; _idxGroup . add ( pattern ) ; } else if ( pattern instanceof AlternativePattern ) { final AlternativePattern alt = ( AlternativePattern ) pattern ; flattenAlternative ( alt . getLeft ( ) , template , keys ) ; flattenAlternative ( alt . getRight ( ) , template , keys ) ; } else if ( pattern instanceof LocationPathPattern ) { final LocationPathPattern lpp = ( LocationPathPattern ) pattern ; lpp . setTemplate ( template ) ; addPatternToGroup ( lpp ) ; } } private void addPatternToGroup ( final LocationPathPattern lpp ) { if ( lpp instanceof IdKeyPattern ) { addPattern ( - 1 , lpp ) ; } else { final StepPattern kernel = lpp . getKernelPattern ( ) ; if ( kernel != null ) { addPattern ( kernel . getNodeType ( ) , lpp ) ; } else if ( _rootPattern == null || lpp . noSmallerThan ( _rootPattern ) ) { _rootPattern = lpp ; } } } private void addPattern ( int kernelType , LocationPathPattern pattern ) { final int oldLength = _patternGroups . length ; if ( kernelType >= oldLength ) { Vector [ ] newGroups = new Vector [ kernelType * 2 ] ; System . arraycopy ( _patternGroups , 0 , newGroups , 0 , oldLength ) ; _patternGroups = newGroups ; } Vector patterns ; if ( kernelType == DOM . NO_TYPE ) { if ( pattern . getAxis ( ) == Axis . ATTRIBUTE ) { patterns = ( _attribNodeGroup == null ) ? ( _attribNodeGroup = new Vector ( 2 ) ) : _attribNodeGroup ; } else { patterns = ( _childNodeGroup == null ) ? ( _childNodeGroup = new Vector ( 2 ) ) : _childNodeGroup ; } } else { patterns = ( _patternGroups [ kernelType ] == null ) ? ( _patternGroups [ kernelType ] = new Vector ( 2 ) ) : _patternGroups [ kernelType ] ; } if ( patterns . size ( ) == 0 ) { patterns . addElement ( pattern ) ; } else { boolean inserted = false ; for ( int i = 0 ; i < patterns . size ( ) ; i ++ ) { final LocationPathPattern lppToCompare = ( LocationPathPattern ) patterns . elementAt ( i ) ; if ( pattern . noSmallerThan ( lppToCompare ) ) { inserted = true ; patterns . insertElementAt ( pattern , i ) ; break ; } } if ( inserted == false ) { patterns . addElement ( pattern ) ; } } } private void completeTestSequences ( int nodeType , Vector patterns ) { if ( patterns != null ) { if ( _patternGroups [ nodeType ] == null ) { _patternGroups [ nodeType ] = patterns ; } else { final int m = patterns . size ( ) ; for ( int j = 0 ; j < m ; j ++ ) { addPattern ( nodeType , ( LocationPathPattern ) patterns . elementAt ( j ) ) ; } } } } private void prepareTestSequences ( ) { final Vector starGroup = _patternGroups [ DTM . ELEMENT_NODE ] ; final Vector atStarGroup = _patternGroups [ DTM . ATTRIBUTE_NODE ] ; completeTestSequences ( DTM . TEXT_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . ELEMENT_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . PROCESSING_INSTRUCTION_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . COMMENT_NODE , _childNodeGroup ) ; completeTestSequences ( DTM . ATTRIBUTE_NODE , _attribNodeGroup ) ; final Vector names = _stylesheet . getXSLTC ( ) . getNamesIndex ( ) ; if ( starGroup != null || atStarGroup != null || _childNodeGroup != null || _attribNodeGroup != null ) { final int n = _patternGroups . length ; for ( int i = DTM . NTYPES ; i < n ; i ++ ) { if ( _patternGroups [ i ] == null ) continue ; final String name = ( String ) names . elementAt ( i - DTM . NTYPES ) ; if ( isAttributeName ( name ) ) { completeTestSequences ( i , atStarGroup ) ; completeTestSequences ( i , _attribNodeGroup ) ; } else { completeTestSequences ( i , starGroup ) ; completeTestSequences ( i , _childNodeGroup ) ; } } } _testSeq = new TestSeq [ DTM . NTYPES + names . size ( ) ] ; final int n = _patternGroups . length ; for ( int i = 0 ; i < n ; i ++ ) { final Vector patterns = _patternGroups [ i ] ; if ( patterns != null ) { final TestSeq testSeq = new TestSeq ( patterns , i , this ) ; testSeq . reduce ( ) ; _testSeq [ i ] = testSeq ; testSeq . findTemplates ( _neededTemplates ) ; } } if ( _childNodeGroup != null && _childNodeGroup . size ( ) > 0 ) { _childNodeTestSeq = new TestSeq ( _childNodeGroup , - 1 , this ) ; _childNodeTestSeq . reduce ( ) ; _childNodeTestSeq . findTemplates ( _neededTemplates ) ; } if ( _idxGroup != null && _idxGroup . size ( ) > 0 ) { _idxTestSeq = new TestSeq ( _idxGroup , this ) ; _idxTestSeq . reduce ( ) ; _idxTestSeq . findTemplates ( _neededTemplates ) ; } if ( _rootPattern != null ) { _neededTemplates . put ( _rootPattern . getTemplate ( ) , this ) ; } } private void compileNamedTemplate ( Template template , ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; String methodName = Util . escape ( template . getName ( ) . toString ( ) ) ; final NamedMethodGenerator methodGen = new NamedMethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) , org . apache . bcel . generic . Type . INT } , new String [ ] { DOCUMENT_PNAME , ITERATOR_PNAME , TRANSLET_OUTPUT_PNAME , NODE_PNAME } , methodName , getClassName ( ) , il , cpg ) ; il . append ( template . compile ( classGen , methodGen ) ) ; il . append ( RETURN ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; } private void compileTemplates ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next ) { Enumeration templates = _namedTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; compileNamedTemplate ( template , classGen ) ; } templates = _neededTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; if ( template . hasContents ( ) ) { InstructionList til = template . compile ( classGen , methodGen ) ; til . append ( new GOTO_W ( next ) ) ; _templateILs . put ( template , til ) ; _templateIHs . put ( template , til . getStart ( ) ) ; } else { _templateIHs . put ( template , next ) ; } } } private void appendTemplateCode ( InstructionList body ) { final Enumeration templates = _neededTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Object iList = _templateILs . get ( templates . nextElement ( ) ) ; if ( iList != null ) { body . append ( ( InstructionList ) iList ) ; } } } private void appendTestSequences ( InstructionList body ) { final int n = _testSeq . length ; for ( int i = 0 ; i < n ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( testSeq != null ) { InstructionList il = testSeq . getInstructionList ( ) ; if ( il != null ) body . append ( il ) ; } } } public static void compileGetChildren ( ClassGenerator classGen , MethodGenerator methodGen , int node ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , GET_CHILDREN , GET_CHILDREN_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( node ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; } private InstructionList compileDefaultRecursion ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final String applyTemplatesSig = classGen . getApplyTemplatesSig ( ) ; final int git = cpg . addInterfaceMethodref ( DOM_INTF , GET_CHILDREN , GET_CHILDREN_SIG ) ; final int applyTemplates = cpg . addMethodref ( getClassName ( ) , functionName ( ) , applyTemplatesSig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( _currentIndex ) ) ; il . append ( new INVOKEINTERFACE ( git , 2 ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; il . append ( new GOTO_W ( next ) ) ; return il ; } private InstructionList compileDefaultText ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final int chars = cpg . addInterfaceMethodref ( DOM_INTF , CHARACTERS , CHARACTERS_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( _currentIndex ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( chars , 3 ) ) ; il . append ( new GOTO_W ( next ) ) ; return il ; } private InstructionList compileNamespaces ( ClassGenerator classGen , MethodGenerator methodGen , boolean [ ] isNamespace , boolean [ ] isAttribute , boolean attrFlag , InstructionHandle defaultTarget ) { final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final Vector namespaces = xsltc . getNamespaceIndex ( ) ; final Vector names = xsltc . getNamesIndex ( ) ; final int namespaceCount = namespaces . size ( ) + 1 ; final int namesCount = names . size ( ) ; final InstructionList il = new InstructionList ( ) ; final int [ ] types = new int [ namespaceCount ] ; final InstructionHandle [ ] targets = new InstructionHandle [ types . length ] ; if ( namespaceCount > 0 ) { boolean compiled = false ; for ( int i = 0 ; i < namespaceCount ; i ++ ) { targets [ i ] = defaultTarget ; types [ i ] = i ; } for ( int i = DTM . NTYPES ; i < ( DTM . NTYPES + namesCount ) ; i ++ ) { if ( ( isNamespace [ i ] ) && ( isAttribute [ i ] == attrFlag ) ) { String name = ( String ) names . elementAt ( i - DTM . NTYPES ) ; String namespace = name . substring ( 0 , name . lastIndexOf ( ':' ) ) ; final int type = xsltc . registerNamespace ( namespace ) ; if ( ( i < _testSeq . length ) && ( _testSeq [ i ] != null ) ) { targets [ type ] = ( _testSeq [ i ] ) . compile ( classGen , methodGen , defaultTarget ) ; compiled = true ; } } } if ( ! compiled ) return ( null ) ; final int getNS = cpg . addInterfaceMethodref ( DOM_INTF , "getNamespaceType" , "(I)I" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new ILOAD ( _currentIndex ) ) ; il . append ( new INVOKEINTERFACE ( getNS , 2 ) ) ; il . append ( new SWITCH ( types , targets , defaultTarget ) ) ; return ( il ) ; } else { return ( null ) ; } } public void compileApplyTemplates ( ClassGenerator classGen ) { final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final Vector names = xsltc . getNamesIndex ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; final String [ ] argNames = new String [ 3 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = ITERATOR_PNAME ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; final InstructionList mainIL = new InstructionList ( ) ; final MethodGenerator methodGen = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . VOID , argTypes , argNames , functionName ( ) , getClassName ( ) , mainIL , classGen . getConstantPool ( ) ) ; methodGen . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current ; current = methodGen . addLocalVariable2 ( "current" , org . apache . bcel . generic . Type . INT , mainIL . getEnd ( ) ) ; _currentIndex = current . getIndex ( ) ; final InstructionList body = new InstructionList ( ) ; body . append ( NOP ) ; final InstructionList ilLoop = new InstructionList ( ) ; ilLoop . append ( methodGen . loadIterator ( ) ) ; ilLoop . append ( methodGen . nextNode ( ) ) ; ilLoop . append ( DUP ) ; ilLoop . append ( new ISTORE ( _currentIndex ) ) ; final BranchHandle ifeq = ilLoop . append ( new IFLT ( null ) ) ; final BranchHandle loop = ilLoop . append ( new GOTO_W ( null ) ) ; ifeq . setTarget ( ilLoop . append ( RETURN ) ) ; final InstructionHandle ihLoop = ilLoop . getStart ( ) ; InstructionList ilRecurse = compileDefaultRecursion ( classGen , methodGen , ihLoop ) ; InstructionHandle ihRecurse = ilRecurse . getStart ( ) ; InstructionList ilText = compileDefaultText ( classGen , methodGen , ihLoop ) ; InstructionHandle ihText = ilText . getStart ( ) ; final int [ ] types = new int [ DTM . NTYPES + names . size ( ) ] ; for ( int i = 0 ; i < types . length ; i ++ ) { types [ i ] = i ; } final boolean [ ] isAttribute = new boolean [ types . length ] ; final boolean [ ] isNamespace = new boolean [ types . length ] ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { final String name = ( String ) names . elementAt ( i ) ; isAttribute [ i + DTM . NTYPES ] = isAttributeName ( name ) ; isNamespace [ i + DTM . NTYPES ] = isNamespaceName ( name ) ; } compileTemplates ( classGen , methodGen , ihLoop ) ; final TestSeq elemTest = _testSeq [ DTM . ELEMENT_NODE ] ; InstructionHandle ihElem = ihRecurse ; if ( elemTest != null ) ihElem = elemTest . compile ( classGen , methodGen , ihRecurse ) ; final TestSeq attrTest = _testSeq [ DTM . ATTRIBUTE_NODE ] ; InstructionHandle ihAttr = ihText ; if ( attrTest != null ) ihAttr = attrTest . compile ( classGen , methodGen , ihAttr ) ; InstructionList ilKey = null ; if ( _idxTestSeq != null ) { loop . setTarget ( _idxTestSeq . compile ( classGen , methodGen , body . getStart ( ) ) ) ; ilKey = _idxTestSeq . getInstructionList ( ) ; } else { loop . setTarget ( body . getStart ( ) ) ; } if ( _childNodeTestSeq != null ) { double nodePrio = _childNodeTestSeq . getPriority ( ) ; int nodePos = _childNodeTestSeq . getPosition ( ) ; double elemPrio = ( 0 - Double . MAX_VALUE ) ; int elemPos = Integer . MIN_VALUE ; if ( elemTest != null ) { elemPrio = elemTest . getPriority ( ) ; elemPos = elemTest . getPosition ( ) ; } if ( elemPrio == Double . NaN || elemPrio < nodePrio || ( elemPrio == nodePrio && elemPos < nodePos ) ) { ihElem = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; } final TestSeq textTest = _testSeq [ DTM . TEXT_NODE ] ; double textPrio = ( 0 - Double . MAX_VALUE ) ; int textPos = Integer . MIN_VALUE ; if ( textTest != null ) { textPrio = textTest . getPriority ( ) ; textPos = textTest . getPosition ( ) ; } if ( textPrio == Double . NaN || textPrio < nodePrio || ( textPrio == nodePrio && textPos < nodePos ) ) { ihText = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; _testSeq [ DTM . TEXT_NODE ] = _childNodeTestSeq ; } } InstructionHandle elemNamespaceHandle = ihElem ; InstructionList nsElem = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , false , ihElem ) ; if ( nsElem != null ) elemNamespaceHandle = nsElem . getStart ( ) ; InstructionHandle attrNamespaceHandle = ihAttr ; InstructionList nsAttr = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , true , ihAttr ) ; if ( nsAttr != null ) attrNamespaceHandle = nsAttr . getStart ( ) ; final InstructionHandle [ ] targets = new InstructionHandle [ types . length ] ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( isNamespace [ i ] ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else if ( testSeq != null ) { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } else { targets [ i ] = ihLoop ; } } targets [ DTM . ROOT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . DOCUMENT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . TEXT_NODE ] = _testSeq [ DTM . TEXT_NODE ] != null ? _testSeq [ DTM . TEXT_NODE ] . compile ( classGen , methodGen , ihText ) : ihText ; targets [ DTM . NAMESPACE_NODE ] = ihLoop ; targets [ DTM . ELEMENT_NODE ] = elemNamespaceHandle ; targets [ DTM . ATTRIBUTE_NODE ] = attrNamespaceHandle ; InstructionHandle ihPI = ihLoop ; if ( _childNodeTestSeq != null ) ihPI = ihElem ; if ( _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] != null ) targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] . compile ( classGen , methodGen , ihPI ) ; else targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = ihPI ; InstructionHandle ihComment = ihLoop ; if ( _childNodeTestSeq != null ) ihComment = ihElem ; targets [ DTM . COMMENT_NODE ] = _testSeq [ DTM . COMMENT_NODE ] != null ? _testSeq [ DTM . COMMENT_NODE ] . compile ( classGen , methodGen , ihComment ) : ihComment ; targets [ DTM . CDATA_SECTION_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_FRAGMENT_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_TYPE_NODE ] = ihLoop ; targets [ DTM . ENTITY_NODE ] = ihLoop ; targets [ DTM . ENTITY_REFERENCE_NODE ] = ihLoop ; targets [ DTM . NOTATION_NODE ] = ihLoop ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( ( testSeq == null ) || ( isNamespace [ i ] ) ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } } if ( ilKey != null ) body . insert ( ilKey ) ; final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; body . append ( methodGen . loadDOM ( ) ) ; body . append ( new ILOAD ( _currentIndex ) ) ; body . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; InstructionHandle disp = body . append ( new SWITCH ( types , targets , ihLoop ) ) ; appendTestSequences ( body ) ; appendTemplateCode ( body ) ; if ( nsElem != null ) body . append ( nsElem ) ; if ( nsAttr != null ) body . append ( nsAttr ) ; body . append ( ilRecurse ) ; body . append ( ilText ) ; mainIL . append ( new GOTO_W ( ihLoop ) ) ; mainIL . append ( body ) ; mainIL . append ( ilLoop ) ; peepHoleOptimization ( methodGen ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; if ( _importLevels != null ) { Enumeration levels = _importLevels . keys ( ) ; while ( levels . hasMoreElements ( ) ) { Integer max = ( Integer ) levels . nextElement ( ) ; Integer min = ( Integer ) _importLevels . get ( max ) ; compileApplyImports ( classGen , min . intValue ( ) , max . intValue ( ) ) ; } } } private void compileTemplateCalls ( ClassGenerator classGen , MethodGenerator methodGen , InstructionHandle next , int min , int max ) { Enumeration templates = _neededTemplates . keys ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; final int prec = template . getImportPrecedence ( ) ; if ( ( prec >= min ) && ( prec < max ) ) { if ( template . hasContents ( ) ) { InstructionList til = template . compile ( classGen , methodGen ) ; til . append ( new GOTO_W ( next ) ) ; _templateILs . put ( template , til ) ; _templateIHs . put ( template , til . getStart ( ) ) ; } else { _templateIHs . put ( template , next ) ; } } } } public void compileApplyImports ( ClassGenerator classGen , int min , int max ) { final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final Vector names = xsltc . getNamesIndex ( ) ; _namedTemplates = new Hashtable ( ) ; _neededTemplates = new Hashtable ( ) ; _templateIHs = new Hashtable ( ) ; _templateILs = new Hashtable ( ) ; _patternGroups = new Vector [ 32 ] ; _rootPattern = null ; Vector oldTemplates = _templates ; _templates = new Vector ( ) ; final Enumeration templates = oldTemplates . elements ( ) ; while ( templates . hasMoreElements ( ) ) { final Template template = ( Template ) templates . nextElement ( ) ; final int prec = template . getImportPrecedence ( ) ; if ( ( prec >= min ) && ( prec < max ) ) addTemplate ( template ) ; } processPatterns ( _keys ) ; final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; final String [ ] argNames = new String [ 3 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = ITERATOR_PNAME ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; final InstructionList mainIL = new InstructionList ( ) ; final MethodGenerator methodGen = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . VOID , argTypes , argNames , functionName ( ) + '_' + max , getClassName ( ) , mainIL , classGen . getConstantPool ( ) ) ; methodGen . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current ; current = methodGen . addLocalVariable2 ( "current" , org . apache . bcel . generic . Type . INT , mainIL . getEnd ( ) ) ; _currentIndex = current . getIndex ( ) ; final InstructionList body = new InstructionList ( ) ; body . append ( NOP ) ; final InstructionList ilLoop = new InstructionList ( ) ; ilLoop . append ( methodGen . loadIterator ( ) ) ; ilLoop . append ( methodGen . nextNode ( ) ) ; ilLoop . append ( DUP ) ; ilLoop . append ( new ISTORE ( _currentIndex ) ) ; final BranchHandle ifeq = ilLoop . append ( new IFLT ( null ) ) ; final BranchHandle loop = ilLoop . append ( new GOTO_W ( null ) ) ; ifeq . setTarget ( ilLoop . append ( RETURN ) ) ; final InstructionHandle ihLoop = ilLoop . getStart ( ) ; InstructionList ilRecurse = compileDefaultRecursion ( classGen , methodGen , ihLoop ) ; InstructionHandle ihRecurse = ilRecurse . getStart ( ) ; InstructionList ilText = compileDefaultText ( classGen , methodGen , ihLoop ) ; InstructionHandle ihText = ilText . getStart ( ) ; final int [ ] types = new int [ DTM . NTYPES + names . size ( ) ] ; for ( int i = 0 ; i < types . length ; i ++ ) { types [ i ] = i ; } final boolean [ ] isAttribute = new boolean [ types . length ] ; final boolean [ ] isNamespace = new boolean [ types . length ] ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { final String name = ( String ) names . elementAt ( i ) ; isAttribute [ i + DTM . NTYPES ] = isAttributeName ( name ) ; isNamespace [ i + DTM . NTYPES ] = isNamespaceName ( name ) ; } compileTemplateCalls ( classGen , methodGen , ihLoop , min , max ) ; final TestSeq elemTest = _testSeq [ DTM . ELEMENT_NODE ] ; InstructionHandle ihElem = ihRecurse ; if ( elemTest != null ) { ihElem = elemTest . compile ( classGen , methodGen , ihLoop ) ; } final TestSeq attrTest = _testSeq [ DTM . ATTRIBUTE_NODE ] ; InstructionHandle ihAttr = ihLoop ; if ( attrTest != null ) { ihAttr = attrTest . compile ( classGen , methodGen , ihAttr ) ; } InstructionList ilKey = null ; if ( _idxTestSeq != null ) { loop . setTarget ( _idxTestSeq . compile ( classGen , methodGen , body . getStart ( ) ) ) ; ilKey = _idxTestSeq . getInstructionList ( ) ; } else { loop . setTarget ( body . getStart ( ) ) ; } if ( _childNodeTestSeq != null ) { double nodePrio = _childNodeTestSeq . getPriority ( ) ; int nodePos = _childNodeTestSeq . getPosition ( ) ; double elemPrio = ( 0 - Double . MAX_VALUE ) ; int elemPos = Integer . MIN_VALUE ; if ( elemTest != null ) { elemPrio = elemTest . getPriority ( ) ; elemPos = elemTest . getPosition ( ) ; } if ( elemPrio == Double . NaN || elemPrio < nodePrio || ( elemPrio == nodePrio && elemPos < nodePos ) ) { ihElem = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; } final TestSeq textTest = _testSeq [ DTM . TEXT_NODE ] ; double textPrio = ( 0 - Double . MAX_VALUE ) ; int textPos = Integer . MIN_VALUE ; if ( textTest != null ) { textPrio = textTest . getPriority ( ) ; textPos = textTest . getPosition ( ) ; } if ( textPrio == Double . NaN || textPrio < nodePrio || ( textPrio == nodePrio && textPos < nodePos ) ) { ihText = _childNodeTestSeq . compile ( classGen , methodGen , ihLoop ) ; _testSeq [ DTM . TEXT_NODE ] = _childNodeTestSeq ; } } InstructionHandle elemNamespaceHandle = ihElem ; InstructionList nsElem = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , false , ihElem ) ; if ( nsElem != null ) elemNamespaceHandle = nsElem . getStart ( ) ; InstructionList nsAttr = compileNamespaces ( classGen , methodGen , isNamespace , isAttribute , true , ihAttr ) ; InstructionHandle attrNamespaceHandle = ihAttr ; if ( nsAttr != null ) attrNamespaceHandle = nsAttr . getStart ( ) ; final InstructionHandle [ ] targets = new InstructionHandle [ types . length ] ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( isNamespace [ i ] ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else if ( testSeq != null ) { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } else { targets [ i ] = ihLoop ; } } targets [ DTM . ROOT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . DOCUMENT_NODE ] = _rootPattern != null ? getTemplateInstructionHandle ( _rootPattern . getTemplate ( ) ) : ihRecurse ; targets [ DTM . TEXT_NODE ] = _testSeq [ DTM . TEXT_NODE ] != null ? _testSeq [ DTM . TEXT_NODE ] . compile ( classGen , methodGen , ihText ) : ihText ; targets [ DTM . NAMESPACE_NODE ] = ihLoop ; targets [ DTM . ELEMENT_NODE ] = elemNamespaceHandle ; targets [ DTM . ATTRIBUTE_NODE ] = attrNamespaceHandle ; InstructionHandle ihPI = ihLoop ; if ( _childNodeTestSeq != null ) ihPI = ihElem ; if ( _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] != null ) { targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = _testSeq [ DTM . PROCESSING_INSTRUCTION_NODE ] . compile ( classGen , methodGen , ihPI ) ; } else { targets [ DTM . PROCESSING_INSTRUCTION_NODE ] = ihPI ; } InstructionHandle ihComment = ihLoop ; if ( _childNodeTestSeq != null ) ihComment = ihElem ; targets [ DTM . COMMENT_NODE ] = _testSeq [ DTM . COMMENT_NODE ] != null ? _testSeq [ DTM . COMMENT_NODE ] . compile ( classGen , methodGen , ihComment ) : ihComment ; targets [ DTM . CDATA_SECTION_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_FRAGMENT_NODE ] = ihLoop ; targets [ DTM . DOCUMENT_TYPE_NODE ] = ihLoop ; targets [ DTM . ENTITY_NODE ] = ihLoop ; targets [ DTM . ENTITY_REFERENCE_NODE ] = ihLoop ; targets [ DTM . NOTATION_NODE ] = ihLoop ; for ( int i = DTM . NTYPES ; i < targets . length ; i ++ ) { final TestSeq testSeq = _testSeq [ i ] ; if ( ( testSeq == null ) || ( isNamespace [ i ] ) ) { if ( isAttribute [ i ] ) targets [ i ] = attrNamespaceHandle ; else targets [ i ] = elemNamespaceHandle ; } else { if ( isAttribute [ i ] ) targets [ i ] = testSeq . compile ( classGen , methodGen , attrNamespaceHandle ) ; else targets [ i ] = testSeq . compile ( classGen , methodGen , elemNamespaceHandle ) ; } } if ( ilKey != null ) body . insert ( ilKey ) ; final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; body . append ( methodGen . loadDOM ( ) ) ; body . append ( new ILOAD ( _currentIndex ) ) ; body . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; InstructionHandle disp = body . append ( new SWITCH ( types , targets , ihLoop ) ) ; appendTestSequences ( body ) ; appendTemplateCode ( body ) ; if ( nsElem != null ) body . append ( nsElem ) ; if ( nsAttr != null ) body . append ( nsAttr ) ; body . append ( ilRecurse ) ; body . append ( ilText ) ; mainIL . append ( new GOTO_W ( ihLoop ) ) ; mainIL . append ( body ) ; mainIL . append ( ilLoop ) ; peepHoleOptimization ( methodGen ) ; methodGen . stripAttributes ( true ) ; methodGen . setMaxLocals ( ) ; methodGen . setMaxStack ( ) ; methodGen . removeNOPs ( ) ; classGen . addMethod ( methodGen . getMethod ( ) ) ; _templates = oldTemplates ; } private void peepHoleOptimization ( MethodGenerator methodGen ) { InstructionList il = methodGen . getInstructionList ( ) ; InstructionFinder find = new InstructionFinder ( il ) ; InstructionHandle ih ; String pattern ; pattern = "`ALOAD'`POP'`Instruction'" ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { if ( ( ! match [ 0 ] . hasTargeters ( ) ) && ( ! match [ 1 ] . hasTargeters ( ) ) ) { il . delete ( match [ 0 ] , match [ 1 ] ) ; } } catch ( TargetLostException e ) { } } pattern = "`ILOAD'`ALOAD'`SWAP'`Instruction'" ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { org . apache . bcel . generic . Instruction iload ; org . apache . bcel . generic . Instruction aload ; if ( ( ! match [ 0 ] . hasTargeters ( ) ) && ( ! match [ 1 ] . hasTargeters ( ) ) && ( ! match [ 2 ] . hasTargeters ( ) ) ) { iload = match [ 0 ] . getInstruction ( ) ; aload = match [ 1 ] . getInstruction ( ) ; il . insert ( match [ 0 ] , aload ) ; il . insert ( match [ 0 ] , iload ) ; il . delete ( match [ 0 ] , match [ 2 ] ) ; } } catch ( TargetLostException e ) { } } pattern = "`ALOAD_1'`ALOAD_1'`Instruction'" ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { org . apache . bcel . generic . Instruction iload ; org . apache . bcel . generic . Instruction aload ; if ( ( ! match [ 0 ] . hasTargeters ( ) ) && ( ! match [ 1 ] . hasTargeters ( ) ) ) { il . insert ( match [ 1 ] , new DUP ( ) ) ; il . delete ( match [ 1 ] ) ; } } catch ( TargetLostException e ) { } } } public InstructionHandle getTemplateInstructionHandle ( Template template ) { return ( InstructionHandle ) _templateIHs . get ( template ) ; } private static boolean isAttributeName ( String qname ) { final int col = qname . lastIndexOf ( ':' ) + 1 ; return ( qname . charAt ( col ) == '@' ) ; } private static boolean isNamespaceName ( String qname ) { final int col = qname . lastIndexOf ( ':' ) ; return ( col > - 1 && qname . charAt ( qname . length ( ) - 1 ) == '*' ) ; } } 	0
package org . apache . xalan . templates ; import java . io . Serializable ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . UnImplNode ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . WhitespaceStrippingElementMatcher ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . helpers . NamespaceSupport ; public class ElemTemplateElement extends UnImplNode implements PrefixResolver , Serializable , ExpressionNode , WhitespaceStrippingElementMatcher , XSLTVisitable { public ElemTemplateElement ( ) { } public boolean isCompiledTemplate ( ) { return false ; } public int getXSLToken ( ) { return Constants . ELEMNAME_UNDEFINED ; } public String getNodeName ( ) { return "Unknown XSLT Element" ; } public String getLocalName ( ) { return getNodeName ( ) ; } public void runtimeInit ( TransformerImpl transformer ) throws TransformerException { } public void execute ( TransformerImpl transformer ) throws TransformerException { } public StylesheetComposed getStylesheetComposed ( ) { return m_parentNode . getStylesheetComposed ( ) ; } public Stylesheet getStylesheet ( ) { return ( null == m_parentNode ) ? null : m_parentNode . getStylesheet ( ) ; } public StylesheetRoot getStylesheetRoot ( ) { return m_parentNode . getStylesheetRoot ( ) ; } public void recompose ( StylesheetRoot root ) throws TransformerException { } public void compose ( StylesheetRoot sroot ) throws TransformerException { resolvePrefixTables ( ) ; ElemTemplateElement t = getFirstChildElem ( ) ; m_hasTextLitOnly = ( ( t != null ) && ( t . getXSLToken ( ) == Constants . ELEMNAME_TEXTLITERALRESULT ) && ( t . getNextSiblingElem ( ) == null ) ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; cstate . pushStackMark ( ) ; } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; cstate . popStackMark ( ) ; } protected boolean isValidNCName ( String s ) { int len = s . length ( ) ; char c = s . charAt ( 0 ) ; if ( ! ( Character . isLetter ( c ) || ( c == '_' ) ) ) return false ; if ( len > 0 ) { for ( int i = 1 ; i < len ; i ++ ) { c = s . charAt ( i ) ; if ( ! ( Character . isLetterOrDigit ( c ) || ( c == '_' ) || ( c == '-' ) || ( c == '.' ) ) ) return false ; } } return true ; } public void error ( String msg , Object [ ] args ) { String themsg = XSLMessages . createMessage ( msg , args ) ; throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ELEMTEMPLATEELEM_ERR , new Object [ ] { themsg } ) ) ; } public void error ( String msg ) { error ( msg , null ) ; } public Node appendChild ( Node newChild ) throws DOMException { if ( null == newChild ) { error ( XSLTErrorResources . ER_NULL_CHILD , null ) ; } ElemTemplateElement elem = ( ElemTemplateElement ) newChild ; if ( null == m_firstChild ) { m_firstChild = elem ; } else { ElemTemplateElement last = ( ElemTemplateElement ) getLastChild ( ) ; last . m_nextSibling = elem ; } elem . m_parentNode = this ; return newChild ; } public ElemTemplateElement appendChild ( ElemTemplateElement elem ) { if ( null == elem ) { error ( XSLTErrorResources . ER_NULL_CHILD , null ) ; } if ( null == m_firstChild ) { m_firstChild = elem ; } else { ElemTemplateElement last = getLastChildElem ( ) ; last . m_nextSibling = elem ; } elem . setParentElem ( this ) ; return elem ; } public boolean hasChildNodes ( ) { return ( null != m_firstChild ) ; } public short getNodeType ( ) { return org . w3c . dom . Node . ELEMENT_NODE ; } public NodeList getChildNodes ( ) { return this ; } public ElemTemplateElement removeChild ( ElemTemplateElement childETE ) { if ( childETE == null || childETE . m_parentNode != this ) return null ; if ( childETE == m_firstChild ) m_firstChild = childETE . m_nextSibling ; else { ElemTemplateElement prev = childETE . getPreviousSiblingElem ( ) ; prev . m_nextSibling = childETE . m_nextSibling ; } childETE . m_parentNode = null ; childETE . m_nextSibling = null ; return childETE ; } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { if ( oldChild == null || oldChild . getParentNode ( ) != this ) return null ; ElemTemplateElement newChildElem = ( ( ElemTemplateElement ) newChild ) ; ElemTemplateElement oldChildElem = ( ( ElemTemplateElement ) oldChild ) ; ElemTemplateElement prev = ( ElemTemplateElement ) oldChildElem . getPreviousSibling ( ) ; if ( null != prev ) prev . m_nextSibling = newChildElem ; if ( m_firstChild == oldChildElem ) m_firstChild = newChildElem ; newChildElem . m_parentNode = this ; oldChildElem . m_parentNode = null ; newChildElem . m_nextSibling = oldChildElem . m_nextSibling ; oldChildElem . m_nextSibling = null ; return newChildElem ; } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { if ( null == refChild ) { appendChild ( newChild ) ; return newChild ; } if ( newChild == refChild ) { return newChild ; } Node node = m_firstChild ; Node prev = null ; boolean foundit = false ; while ( null != node ) { if ( newChild == node ) { if ( null != prev ) ( ( ElemTemplateElement ) prev ) . m_nextSibling = ( ElemTemplateElement ) node . getNextSibling ( ) ; else m_firstChild = ( ElemTemplateElement ) node . getNextSibling ( ) ; node = node . getNextSibling ( ) ; continue ; } if ( refChild == node ) { if ( null != prev ) { ( ( ElemTemplateElement ) prev ) . m_nextSibling = ( ElemTemplateElement ) newChild ; } else { m_firstChild = ( ElemTemplateElement ) newChild ; } ( ( ElemTemplateElement ) newChild ) . m_nextSibling = ( ElemTemplateElement ) refChild ; ( ( ElemTemplateElement ) newChild ) . setParentElem ( this ) ; prev = newChild ; node = node . getNextSibling ( ) ; foundit = true ; continue ; } prev = node ; node = node . getNextSibling ( ) ; } if ( ! foundit ) throw new DOMException ( DOMException . NOT_FOUND_ERR , "refChild was not found in insertBefore method!" ) ; else return newChild ; } public ElemTemplateElement replaceChild ( ElemTemplateElement newChildElem , ElemTemplateElement oldChildElem ) { if ( oldChildElem == null || oldChildElem . getParentElem ( ) != this ) return null ; ElemTemplateElement prev = oldChildElem . getPreviousSiblingElem ( ) ; if ( null != prev ) prev . m_nextSibling = newChildElem ; if ( m_firstChild == oldChildElem ) m_firstChild = newChildElem ; newChildElem . m_parentNode = this ; oldChildElem . m_parentNode = null ; newChildElem . m_nextSibling = oldChildElem . m_nextSibling ; oldChildElem . m_nextSibling = null ; return newChildElem ; } public int getLength ( ) { int count = 0 ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { count ++ ; } return count ; } public Node item ( int index ) { ElemTemplateElement node = m_firstChild ; for ( int i = 0 ; i < index && node != null ; i ++ ) { node = node . m_nextSibling ; } return node ; } public Document getOwnerDocument ( ) { return getStylesheet ( ) ; } public ElemTemplate getOwnerXSLTemplate ( ) { ElemTemplateElement el = this ; int type = el . getXSLToken ( ) ; while ( ( null != el ) && ( type != Constants . ELEMNAME_TEMPLATE ) ) { el = el . getParentElem ( ) ; if ( null != el ) type = el . getXSLToken ( ) ; } return ( ElemTemplate ) el ; } public String getTagName ( ) { return getNodeName ( ) ; } public boolean hasTextLitOnly ( ) { return m_hasTextLitOnly ; } public String getBaseIdentifier ( ) { return this . getSystemId ( ) ; } private int m_lineNumber ; public int getLineNumber ( ) { return m_lineNumber ; } private int m_columnNumber ; public int getColumnNumber ( ) { return m_columnNumber ; } public String getPublicId ( ) { return ( null != m_parentNode ) ? m_parentNode . getPublicId ( ) : null ; } public String getSystemId ( ) { Stylesheet sheet = getStylesheet ( ) ; return ( sheet == null ) ? null : sheet . getHref ( ) ; } public void setLocaterInfo ( SourceLocator locator ) { m_lineNumber = locator . getLineNumber ( ) ; m_columnNumber = locator . getColumnNumber ( ) ; } private boolean m_defaultSpace = true ; private boolean m_hasTextLitOnly = false ; protected boolean m_hasVariableDecl = false ; public boolean hasVariableDecl ( ) { return m_hasVariableDecl ; } public void setXmlSpace ( int v ) { m_defaultSpace = ( ( Constants . ATTRVAL_STRIP == v ) ? true : false ) ; } public boolean getXmlSpace ( ) { return m_defaultSpace ; } private Vector m_declaredPrefixes ; public Vector getDeclaredPrefixes ( ) { return m_declaredPrefixes ; } public void setPrefixes ( NamespaceSupport nsSupport ) throws TransformerException { setPrefixes ( nsSupport , false ) ; } public void setPrefixes ( NamespaceSupport nsSupport , boolean excludeXSLDecl ) throws TransformerException { Enumeration decls = nsSupport . getDeclaredPrefixes ( ) ; while ( decls . hasMoreElements ( ) ) { String prefix = ( String ) decls . nextElement ( ) ; if ( null == m_declaredPrefixes ) m_declaredPrefixes = new Vector ( ) ; String uri = nsSupport . getURI ( prefix ) ; if ( excludeXSLDecl && uri . equals ( Constants . S_XSLNAMESPACEURL ) ) continue ; XMLNSDecl decl = new XMLNSDecl ( prefix , uri , false ) ; m_declaredPrefixes . addElement ( decl ) ; } } public String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) { this . error ( XSLTErrorResources . ER_CANT_RESOLVE_NSPREFIX , null ) ; return null ; } public String getNamespaceForPrefix ( String prefix ) { Vector nsDecls = m_declaredPrefixes ; if ( null != nsDecls ) { int n = nsDecls . size ( ) ; if ( prefix . equals ( Constants . ATTRVAL_DEFAULT_PREFIX ) ) { prefix = "" ; } for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) nsDecls . elementAt ( i ) ; if ( prefix . equals ( decl . getPrefix ( ) ) ) return decl . getURI ( ) ; } } if ( null != m_parentNode ) return m_parentNode . getNamespaceForPrefix ( prefix ) ; if ( "xml" . equals ( prefix ) ) return "http://www.w3.org/XML/1998/namespace" ; return null ; } Vector m_prefixTable ; public Vector getPrefixes ( ) { return m_prefixTable ; } public boolean containsExcludeResultPrefix ( String prefix , String uri ) { ElemTemplateElement parent = this . getParentElem ( ) ; if ( null != parent ) return parent . containsExcludeResultPrefix ( prefix , uri ) ; return false ; } private boolean excludeResultNSDecl ( String prefix , String uri ) throws TransformerException { if ( uri != null ) { if ( uri . equals ( Constants . S_XSLNAMESPACEURL ) || getStylesheet ( ) . containsExtensionElementURI ( uri ) || uri . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) || uri . equals ( Constants . S_BUILTIN_OLD_EXTENSIONS_URL ) ) return true ; if ( containsExcludeResultPrefix ( prefix , uri ) ) return true ; } return false ; } public void resolvePrefixTables ( ) throws TransformerException { m_prefixTable = null ; if ( null != this . m_declaredPrefixes ) { StylesheetRoot stylesheet = this . getStylesheetRoot ( ) ; int n = m_declaredPrefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) m_declaredPrefixes . elementAt ( i ) ; String prefix = decl . getPrefix ( ) ; String uri = decl . getURI ( ) ; if ( null == uri ) uri = "" ; boolean shouldExclude = excludeResultNSDecl ( prefix , uri ) ; if ( null == m_prefixTable ) m_prefixTable = new Vector ( ) ; NamespaceAlias nsAlias = stylesheet . getNamespaceAliasComposed ( uri ) ; if ( null != nsAlias ) { decl = new XMLNSDecl ( nsAlias . getStylesheetPrefix ( ) , nsAlias . getResultNamespace ( ) , shouldExclude ) ; } else decl = new XMLNSDecl ( prefix , uri , shouldExclude ) ; m_prefixTable . addElement ( decl ) ; } } ElemTemplateElement parent = this . getParentNodeElem ( ) ; if ( null != parent ) { Vector prefixes = parent . m_prefixTable ; if ( null == m_prefixTable && ! needToCheckExclude ( ) ) { this . m_prefixTable = parent . m_prefixTable ; } else { int n = prefixes . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) prefixes . elementAt ( i ) ; boolean shouldExclude = excludeResultNSDecl ( decl . getPrefix ( ) , decl . getURI ( ) ) ; if ( shouldExclude != decl . getIsExcluded ( ) ) { decl = new XMLNSDecl ( decl . getPrefix ( ) , decl . getURI ( ) , shouldExclude ) ; } addOrReplaceDecls ( decl ) ; } } } else if ( null == m_prefixTable ) { m_prefixTable = new Vector ( ) ; } } void addOrReplaceDecls ( XMLNSDecl newDecl ) { int n = m_prefixTable . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( decl . getPrefix ( ) . equals ( newDecl . getPrefix ( ) ) ) { return ; } } m_prefixTable . addElement ( newDecl ) ; } boolean needToCheckExclude ( ) { return false ; } void executeNSDecls ( TransformerImpl transformer ) throws TransformerException { executeNSDecls ( transformer , null ) ; } void executeNSDecls ( TransformerImpl transformer , String ignorePrefix ) throws TransformerException { try { if ( null != m_prefixTable ) { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; int n = m_prefixTable . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( ! decl . getIsExcluded ( ) && ! ( null != ignorePrefix && decl . getPrefix ( ) . equals ( ignorePrefix ) ) ) { rhandler . startPrefixMapping ( decl . getPrefix ( ) , decl . getURI ( ) , true ) ; } } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } void unexecuteNSDecls ( TransformerImpl transformer ) throws TransformerException { unexecuteNSDecls ( transformer , null ) ; } void unexecuteNSDecls ( TransformerImpl transformer , String ignorePrefix ) throws TransformerException { try { if ( null != m_prefixTable ) { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; int n = m_prefixTable . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { XMLNSDecl decl = ( XMLNSDecl ) m_prefixTable . elementAt ( i ) ; if ( ! decl . getIsExcluded ( ) && ! ( null != ignorePrefix && decl . getPrefix ( ) . equals ( ignorePrefix ) ) ) { rhandler . endPrefixMapping ( decl . getPrefix ( ) ) ; } } } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } protected int m_docOrderNumber = - 1 ; public void setUid ( int i ) { m_docOrderNumber = i ; } public int getUid ( ) { return m_docOrderNumber ; } protected ElemTemplateElement m_parentNode ; public Node getParentNode ( ) { return m_parentNode ; } public ElemTemplateElement getParentElem ( ) { return m_parentNode ; } public void setParentElem ( ElemTemplateElement p ) { m_parentNode = p ; } ElemTemplateElement m_nextSibling ; public Node getNextSibling ( ) { return m_nextSibling ; } public Node getPreviousSibling ( ) { Node walker = getParentNode ( ) , prev = null ; if ( walker != null ) for ( walker = walker . getFirstChild ( ) ; walker != null ; prev = walker , walker = walker . getNextSibling ( ) ) { if ( walker == this ) return prev ; } return null ; } public ElemTemplateElement getPreviousSiblingElem ( ) { ElemTemplateElement walker = getParentNodeElem ( ) ; ElemTemplateElement prev = null ; if ( walker != null ) for ( walker = walker . getFirstChildElem ( ) ; walker != null ; prev = walker , walker = walker . getNextSiblingElem ( ) ) { if ( walker == this ) return prev ; } return null ; } public ElemTemplateElement getNextSiblingElem ( ) { return m_nextSibling ; } public ElemTemplateElement getParentNodeElem ( ) { return m_parentNode ; } ElemTemplateElement m_firstChild ; public Node getFirstChild ( ) { return m_firstChild ; } public ElemTemplateElement getFirstChildElem ( ) { return m_firstChild ; } public Node getLastChild ( ) { ElemTemplateElement lastChild = null ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { lastChild = node ; } return lastChild ; } public ElemTemplateElement getLastChildElem ( ) { ElemTemplateElement lastChild = null ; for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { lastChild = node ; } return lastChild ; } transient private org . w3c . dom . Node m_DOMBackPointer ; public org . w3c . dom . Node getDOMBackPointer ( ) { return m_DOMBackPointer ; } public void setDOMBackPointer ( org . w3c . dom . Node n ) { m_DOMBackPointer = n ; } public int compareTo ( Object o ) throws ClassCastException { ElemTemplateElement ro = ( ElemTemplateElement ) o ; int roPrecedence = ro . getStylesheetComposed ( ) . getImportCountComposed ( ) ; int myPrecedence = this . getStylesheetComposed ( ) . getImportCountComposed ( ) ; if ( myPrecedence < roPrecedence ) return - 1 ; else if ( myPrecedence > roPrecedence ) return 1 ; else return this . getUid ( ) - ro . getUid ( ) ; } public boolean shouldStripWhiteSpace ( org . apache . xpath . XPathContext support , org . w3c . dom . Element targetElement ) throws TransformerException { StylesheetRoot sroot = this . getStylesheetRoot ( ) ; return ( null != sroot ) ? sroot . shouldStripWhiteSpace ( support , targetElement ) : false ; } public boolean canStripWhiteSpace ( ) { StylesheetRoot sroot = this . getStylesheetRoot ( ) ; return ( null != sroot ) ? sroot . canStripWhiteSpace ( ) : false ; } public boolean canAcceptVariables ( ) { return true ; } public void exprSetParent ( ExpressionNode n ) { setParentElem ( ( ElemTemplateElement ) n ) ; } public ExpressionNode exprGetParent ( ) { return getParentElem ( ) ; } public void exprAddChild ( ExpressionNode n , int i ) { appendChild ( ( ElemTemplateElement ) n ) ; } public ExpressionNode exprGetChild ( int i ) { return ( ExpressionNode ) item ( i ) ; } public int exprGetNumChildren ( ) { return getLength ( ) ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitInstruction ( this ) ; } public void callVisitors ( XSLTVisitor visitor ) { if ( accept ( visitor ) ) { callChildVisitors ( visitor ) ; } } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttributes ) { for ( ElemTemplateElement node = m_firstChild ; node != null ; node = node . m_nextSibling ) { node . callVisitors ( visitor ) ; } } protected void callChildVisitors ( XSLTVisitor visitor ) { callChildVisitors ( visitor , true ) ; } public boolean handlesNullPrefixes ( ) { return false ; } } 	1
package org . apache . xalan . templates ; import java . io . Serializable ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . patterns . StepPattern ; class TemplateSubPatternAssociation implements Serializable , Cloneable { StepPattern m_stepPattern ; private String m_pattern ; private ElemTemplate m_template ; private TemplateSubPatternAssociation m_next = null ; private boolean m_wild ; private String m_targetString ; TemplateSubPatternAssociation ( ElemTemplate template , StepPattern pattern , String pat ) { m_pattern = pat ; m_template = template ; m_stepPattern = pattern ; m_targetString = m_stepPattern . getTargetString ( ) ; m_wild = m_targetString . equals ( "*" ) ; } public Object clone ( ) throws CloneNotSupportedException { TemplateSubPatternAssociation tspa = ( TemplateSubPatternAssociation ) super . clone ( ) ; tspa . m_next = null ; return tspa ; } public final String getTargetString ( ) { return m_targetString ; } public void setTargetString ( String key ) { m_targetString = key ; } boolean matchMode ( QName m1 ) { return matchModes ( m1 , m_template . getMode ( ) ) ; } private boolean matchModes ( QName m1 , QName m2 ) { return ( ( ( null == m1 ) && ( null == m2 ) ) || ( ( null != m1 ) && ( null != m2 ) && m1 . equals ( m2 ) ) ) ; } public boolean matches ( XPathContext xctxt , int targetNode , QName mode ) throws TransformerException { double score = m_stepPattern . getMatchScore ( xctxt , targetNode ) ; return ( XPath . MATCH_SCORE_NONE != score ) && matchModes ( mode , m_template . getMode ( ) ) ; } public final boolean isWild ( ) { return m_wild ; } public final StepPattern getStepPattern ( ) { return m_stepPattern ; } public final String getPattern ( ) { return m_pattern ; } public int getDocOrderPos ( ) { return m_template . getUid ( ) ; } public final int getImportLevel ( ) { return m_template . getStylesheetComposed ( ) . getImportCountComposed ( ) ; } public final ElemTemplate getTemplate ( ) { return m_template ; } public final TemplateSubPatternAssociation getNext ( ) { return m_next ; } public void setNext ( TemplateSubPatternAssociation mp ) { m_next = mp ; } } 	0
package org . apache . xml . utils ; import java . util . EmptyStackException ; public class IntStack extends IntVector { public IntStack ( ) { super ( ) ; } public IntStack ( int blocksize ) { super ( blocksize ) ; } public IntStack ( IntStack v ) { super ( v ) ; } public int push ( int i ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = i ; m_firstFree ++ ; return i ; } public final int pop ( ) { return m_map [ -- m_firstFree ] ; } public final void quickPop ( int n ) { m_firstFree -= n ; } public final int peek ( ) { try { return m_map [ m_firstFree - 1 ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public int peek ( int n ) { try { return m_map [ m_firstFree - ( 1 + n ) ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public void setTop ( int val ) { try { m_map [ m_firstFree - 1 ] = val ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public boolean empty ( ) { return m_firstFree == 0 ; } public int search ( int o ) { int i = lastIndexOf ( o ) ; if ( i >= 0 ) { return size ( ) - i ; } return - 1 ; } public Object clone ( ) throws CloneNotSupportedException { return ( IntStack ) super . clone ( ) ; } } 	1
package org . apache . xpath . operations ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XObject ; public abstract class UnaryOperation extends Expression implements ExpressionOwner { protected Expression m_right ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_right . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { if ( null != m_right && m_right . canTraverseOutsideSubtree ( ) ) return true ; return false ; } public void setRight ( Expression r ) { m_right = r ; r . exprSetParent ( this ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return operate ( m_right . execute ( xctxt ) ) ; } public abstract XObject operate ( XObject right ) throws javax . xml . transform . TransformerException ; public Expression getOperand ( ) { return m_right ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitUnaryOperation ( owner , this ) ) { m_right . callVisitors ( this , visitor ) ; } } public Expression getExpression ( ) { return m_right ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_right = exp ; } public boolean deepEquals ( Expression expr ) { if ( ! isSameClass ( expr ) ) return false ; if ( ! m_right . deepEquals ( ( ( UnaryOperation ) expr ) . m_right ) ) return false ; return true ; } } 	0
package org . apache . xalan . lib . sql ; import java . sql . Connection ; import java . sql . SQLException ; import java . util . Properties ; public interface ConnectionPool { public boolean isEnabled ( ) ; public void setDriver ( String d ) ; public void setURL ( String url ) ; public void freeUnused ( ) ; public boolean hasActiveConnections ( ) ; public void setPassword ( String p ) ; public void setUser ( String u ) ; public void setMinConnections ( int n ) ; public boolean testConnection ( ) ; public Connection getConnection ( ) throws SQLException ; public void releaseConnection ( Connection con ) throws SQLException ; public void releaseConnectionOnError ( Connection con ) throws SQLException ; public void setPoolEnabled ( final boolean flag ) ; public void setProtocol ( Properties p ) ; } 	1
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemTemplateElement ; class ProcessorGlobalParamDecl extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { handler . pushElemTemplateElement ( elem ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ElemParam v = ( ElemParam ) handler . getElemTemplateElement ( ) ; handler . getStylesheet ( ) . appendChild ( v ) ; handler . getStylesheet ( ) . setParam ( v ) ; super . endElement ( handler , uri , localName , rawName ) ; } } 	0
package org . apache . xpath ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . DOM2Helper ; import org . apache . xpath . axes . ContextNodeList ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeFilter ; import org . w3c . dom . traversal . NodeIterator ; public class NodeSet implements NodeList , NodeIterator , Cloneable , ContextNodeList { public NodeSet ( ) { m_blocksize = 32 ; m_mapSize = 0 ; } public NodeSet ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = 0 ; } public NodeSet ( NodeList nodelist ) { this ( 32 ) ; addNodes ( nodelist ) ; } public NodeSet ( NodeSet nodelist ) { this ( 32 ) ; addNodes ( ( NodeIterator ) nodelist ) ; } public NodeSet ( NodeIterator ni ) { this ( 32 ) ; addNodes ( ni ) ; } public NodeSet ( Node node ) { this ( 32 ) ; addNode ( node ) ; } public Node getRoot ( ) { return null ; } public NodeIterator cloneWithReset ( ) throws CloneNotSupportedException { NodeSet clone = ( NodeSet ) clone ( ) ; clone . reset ( ) ; return clone ; } public void reset ( ) { m_next = 0 ; } public int getWhatToShow ( ) { return NodeFilter . SHOW_ALL & ~ NodeFilter . SHOW_ENTITY_REFERENCE ; } public NodeFilter getFilter ( ) { return null ; } public boolean getExpandEntityReferences ( ) { return true ; } public Node nextNode ( ) throws DOMException { if ( ( m_next ) < this . size ( ) ) { Node next = this . elementAt ( m_next ) ; m_next ++ ; return next ; } else return null ; } public Node previousNode ( ) throws DOMException { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_ITERATE , null ) ) ; if ( ( m_next - 1 ) > 0 ) { m_next -- ; return this . elementAt ( m_next ) ; } else return null ; } public void detach ( ) { } public boolean isFresh ( ) { return ( m_next == 0 ) ; } public void runTo ( int index ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_INDEX , null ) ) ; if ( ( index >= 0 ) && ( m_next < m_firstFree ) ) m_next = index ; else m_next = m_firstFree - 1 ; } public Node item ( int index ) { runTo ( index ) ; return ( Node ) this . elementAt ( index ) ; } public int getLength ( ) { runTo ( - 1 ) ; return this . size ( ) ; } public void addNode ( Node n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; this . addElement ( n ) ; } public void insertNode ( Node n , int pos ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; insertElementAt ( n , pos ) ; } public void removeNode ( Node n ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; this . removeElement ( n ) ; } public void addNodes ( NodeList nodelist ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null != nodelist ) { int nChildren = nodelist . getLength ( ) ; for ( int i = 0 ; i < nChildren ; i ++ ) { Node obj = nodelist . item ( i ) ; if ( null != obj ) { addElement ( obj ) ; } } } } public void addNodes ( NodeSet ns ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; addNodes ( ( NodeIterator ) ns ) ; } public void addNodes ( NodeIterator iterator ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null != iterator ) { Node obj ; while ( null != ( obj = iterator . nextNode ( ) ) ) { addElement ( obj ) ; } } } public void addNodesInDocOrder ( NodeList nodelist , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; int nChildren = nodelist . getLength ( ) ; for ( int i = 0 ; i < nChildren ; i ++ ) { Node node = nodelist . item ( i ) ; if ( null != node ) { addNodeInDocOrder ( node , support ) ; } } } public void addNodesInDocOrder ( NodeIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; Node node ; while ( null != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } } private boolean addNodesInDocOrder ( int start , int end , int testIndex , NodeList nodelist , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; boolean foundit = false ; int i ; Node node = nodelist . item ( testIndex ) ; for ( i = end ; i >= start ; i -- ) { Node child = ( Node ) elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } if ( ! DOM2Helper . isNodeAfter ( node , child ) ) { insertElementAt ( node , i + 1 ) ; testIndex -- ; if ( testIndex > 0 ) { boolean foundPrev = addNodesInDocOrder ( 0 , i , testIndex , nodelist , support ) ; if ( ! foundPrev ) { addNodesInDocOrder ( i , size ( ) - 1 , testIndex , nodelist , support ) ; } } break ; } } if ( i == - 1 ) { insertElementAt ( node , 0 ) ; } return foundit ; } public int addNodeInDocOrder ( Node node , boolean test , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; int insertIndex = - 1 ; if ( test ) { int size = size ( ) , i ; for ( i = size - 1 ; i >= 0 ; i -- ) { Node child = ( Node ) elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } if ( ! DOM2Helper . isNodeAfter ( node , child ) ) { break ; } } if ( i != - 2 ) { insertIndex = i + 1 ; insertElementAt ( node , insertIndex ) ; } } else { insertIndex = this . size ( ) ; boolean foundit = false ; for ( int i = 0 ; i < insertIndex ; i ++ ) { if ( this . item ( i ) . equals ( node ) ) { foundit = true ; break ; } } if ( ! foundit ) addElement ( node ) ; } return insertIndex ; } public int addNodeInDocOrder ( Node node , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; return addNodeInDocOrder ( node , true , support ) ; } transient protected int m_next = 0 ; public int getCurrentPos ( ) { return m_next ; } public void setCurrentPos ( int i ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_INDEX , null ) ) ; m_next = i ; } public Node getCurrentNode ( ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_INDEX , null ) ) ; int saved = m_next ; Node n = ( m_next < m_firstFree ) ? elementAt ( m_next ) : null ; m_next = saved ; return n ; } transient protected boolean m_mutable = true ; transient protected boolean m_cacheNodes = true ; public boolean getShouldCacheNodes ( ) { return m_cacheNodes ; } public void setShouldCacheNodes ( boolean b ) { if ( ! isFresh ( ) ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANNOT_CALL_SETSHOULDCACHENODE , null ) ) ; m_cacheNodes = b ; m_mutable = true ; } transient private int m_last = 0 ; public int getLast ( ) { return m_last ; } public void setLast ( int last ) { m_last = last ; } private int m_blocksize ; Node m_map [ ] ; protected int m_firstFree = 0 ; private int m_mapSize ; public Object clone ( ) throws CloneNotSupportedException { NodeSet clone = ( NodeSet ) super . clone ( ) ; if ( ( null != this . m_map ) && ( this . m_map == clone . m_map ) ) { clone . m_map = new Node [ this . m_map . length ] ; System . arraycopy ( this . m_map , 0 , clone . m_map , 0 , this . m_map . length ) ; } return clone ; } public int size ( ) { return m_firstFree ; } public void addElement ( Node value ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( ( m_firstFree + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void push ( Node value ) { int ff = m_firstFree ; if ( ( ff + 1 ) >= m_mapSize ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , ff + 1 ) ; m_map = newMap ; } } m_map [ ff ] = value ; ff ++ ; m_firstFree = ff ; } public final Node pop ( ) { m_firstFree -- ; Node n = m_map [ m_firstFree ] ; m_map [ m_firstFree ] = null ; return n ; } public final Node popAndTop ( ) { m_firstFree -- ; m_map [ m_firstFree ] = null ; return ( m_firstFree == 0 ) ? null : m_map [ m_firstFree - 1 ] ; } public final void popQuick ( ) { m_firstFree -- ; m_map [ m_firstFree ] = null ; } public final Node peepOrNull ( ) { return ( ( null != m_map ) && ( m_firstFree > 0 ) ) ? m_map [ m_firstFree - 1 ] : null ; } public final void pushPair ( Node v1 , Node v2 ) { if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else { if ( ( m_firstFree + 2 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree ) ; m_map = newMap ; } } m_map [ m_firstFree ] = v1 ; m_map [ m_firstFree + 1 ] = v2 ; m_firstFree += 2 ; } public final void popPair ( ) { m_firstFree -= 2 ; m_map [ m_firstFree ] = null ; m_map [ m_firstFree + 1 ] = null ; } public final void setTail ( Node n ) { m_map [ m_firstFree - 1 ] = n ; } public final void setTailSub1 ( Node n ) { m_map [ m_firstFree - 2 ] = n ; } public final Node peepTail ( ) { return m_map [ m_firstFree - 1 ] ; } public final Node peepTailSub1 ( ) { return m_map [ m_firstFree - 2 ] ; } public void insertElementAt ( Node value , int at ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } else if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public void appendNodes ( NodeSet nodes ) { int nNodes = nodes . size ( ) ; if ( null == m_map ) { m_mapSize = nNodes + m_blocksize ; m_map = new Node [ m_mapSize ] ; } else if ( ( m_firstFree + nNodes ) >= m_mapSize ) { m_mapSize += ( nNodes + m_blocksize ) ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + nNodes ) ; m_map = newMap ; } System . arraycopy ( nodes . m_map , 0 , m_map , m_firstFree , nNodes ) ; m_firstFree += nNodes ; } public void removeAllElements ( ) { if ( null == m_map ) return ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = null ; } m_firstFree = 0 ; } public boolean removeElement ( Node s ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = null ; m_firstFree -- ; return true ; } } return false ; } public void removeElementAt ( int i ) { if ( null == m_map ) return ; if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = null ; } public void setElementAt ( Node node , int index ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; if ( null == m_map ) { m_map = new Node [ m_blocksize ] ; m_mapSize = m_blocksize ; } m_map [ index ] = node ; } public Node elementAt ( int i ) { if ( null == m_map ) return null ; return m_map [ i ] ; } public boolean contains ( Node s ) { runTo ( - 1 ) ; if ( null == m_map ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) return true ; } return false ; } public int indexOf ( Node elem , int index ) { runTo ( - 1 ) ; if ( null == m_map ) return - 1 ; for ( int i = index ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( elem ) ) return i ; } return - 1 ; } public int indexOf ( Node elem ) { runTo ( - 1 ) ; if ( null == m_map ) return - 1 ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { Node node = m_map [ i ] ; if ( ( null != node ) && node . equals ( elem ) ) return i ; } return - 1 ; } } 	1
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; class ProcessorTemplate extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { super . appendAndPush ( handler , elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; handler . getStylesheet ( ) . setTemplate ( ( ElemTemplate ) elem ) ; } } 	0
package org . apache . xalan . xsltc . compiler ; import java . io . File ; import java . io . IOException ; import java . io . StringReader ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import java_cup . runtime . Symbol ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . runtime . AttributeList ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; public class Parser implements Constants , ContentHandler { private static final String XSL = "xsl" ; private static final String TRANSLET = "translet" ; private Locator _locator = null ; private XSLTC _xsltc ; private XPathParser _xpathParser ; private Vector _errors ; private Vector _warnings ; private Hashtable _instructionClasses ; private Hashtable _instructionAttrs ; ; private Hashtable _qNames ; private Hashtable _namespaces ; private QName _useAttributeSets ; private QName _excludeResultPrefixes ; private QName _extensionElementPrefixes ; private Hashtable _variableScope ; private Stylesheet _currentStylesheet ; private SymbolTable _symbolTable ; private Output _output ; private Template _template ; private boolean _rootNamespaceDef ; private SyntaxTreeNode _root ; private String _target ; private int _currentImportPrecedence ; public Parser ( XSLTC xsltc ) { _xsltc = xsltc ; } public void init ( ) { _qNames = new Hashtable ( 512 ) ; _namespaces = new Hashtable ( ) ; _instructionClasses = new Hashtable ( ) ; _instructionAttrs = new Hashtable ( ) ; _variableScope = new Hashtable ( ) ; _template = null ; _errors = new Vector ( ) ; _warnings = new Vector ( ) ; _symbolTable = new SymbolTable ( ) ; _xpathParser = new XPathParser ( this ) ; _currentStylesheet = null ; _output = null ; _root = null ; _rootNamespaceDef = false ; _currentImportPrecedence = 1 ; initStdClasses ( ) ; initInstructionAttrs ( ) ; initExtClasses ( ) ; initSymbolTable ( ) ; _useAttributeSets = getQName ( XSLT_URI , XSL , "use-attribute-sets" ) ; _excludeResultPrefixes = getQName ( XSLT_URI , XSL , "exclude-result-prefixes" ) ; _extensionElementPrefixes = getQName ( XSLT_URI , XSL , "extension-element-prefixes" ) ; } public void setOutput ( Output output ) { if ( _output != null ) { if ( _output . getImportPrecedence ( ) <= output . getImportPrecedence ( ) ) { String cdata = _output . getCdata ( ) ; output . mergeCdata ( cdata ) ; _output . disable ( ) ; _output = output ; } else { output . disable ( ) ; } } else { _output = output ; } } public Output getOutput ( ) { return _output ; } public Properties getOutputProperties ( ) { return getTopLevelStylesheet ( ) . getOutputProperties ( ) ; } public void addVariable ( Variable var ) { addVariableOrParam ( var ) ; } public void addParameter ( Param param ) { addVariableOrParam ( param ) ; } private void addVariableOrParam ( VariableBase var ) { Object existing = _variableScope . get ( var . getName ( ) ) ; if ( existing != null ) { if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; stack . push ( var ) ; } else if ( existing instanceof VariableBase ) { Stack stack = new Stack ( ) ; stack . push ( existing ) ; stack . push ( var ) ; _variableScope . put ( var . getName ( ) , stack ) ; } } else { _variableScope . put ( var . getName ( ) , var ) ; } } public void removeVariable ( QName name ) { Object existing = _variableScope . get ( name ) ; if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; if ( ! stack . isEmpty ( ) ) stack . pop ( ) ; if ( ! stack . isEmpty ( ) ) return ; } _variableScope . remove ( name ) ; } public VariableBase lookupVariable ( QName name ) { Object existing = _variableScope . get ( name ) ; if ( existing instanceof VariableBase ) { return ( ( VariableBase ) existing ) ; } else if ( existing instanceof Stack ) { Stack stack = ( Stack ) existing ; return ( ( VariableBase ) stack . peek ( ) ) ; } return ( null ) ; } public void setXSLTC ( XSLTC xsltc ) { _xsltc = xsltc ; } public XSLTC getXSLTC ( ) { return _xsltc ; } public int getCurrentImportPrecedence ( ) { return _currentImportPrecedence ; } public int getNextImportPrecedence ( ) { return ++ _currentImportPrecedence ; } public void setCurrentStylesheet ( Stylesheet stylesheet ) { _currentStylesheet = stylesheet ; } public Stylesheet getCurrentStylesheet ( ) { return _currentStylesheet ; } public Stylesheet getTopLevelStylesheet ( ) { return _xsltc . getStylesheet ( ) ; } public QName getQNameSafe ( final String stringRep ) { final int colon = stringRep . lastIndexOf ( ':' ) ; if ( colon != - 1 ) { final String prefix = stringRep . substring ( 0 , colon ) ; final String localname = stringRep . substring ( colon + 1 ) ; String namespace = null ; if ( prefix . equals ( XMLNS_PREFIX ) == false ) { namespace = _symbolTable . lookupNamespace ( prefix ) ; if ( namespace == null ) namespace = EMPTYSTRING ; } return getQName ( namespace , prefix , localname ) ; } else { final String uri = stringRep . equals ( XMLNS_PREFIX ) ? null : _symbolTable . lookupNamespace ( EMPTYSTRING ) ; return getQName ( uri , null , stringRep ) ; } } public QName getQName ( final String stringRep ) { return getQName ( stringRep , true , false ) ; } public QName getQNameIgnoreDefaultNs ( final String stringRep ) { return getQName ( stringRep , true , true ) ; } public QName getQName ( final String stringRep , boolean reportError ) { return getQName ( stringRep , reportError , false ) ; } private QName getQName ( final String stringRep , boolean reportError , boolean ignoreDefaultNs ) { final int colon = stringRep . lastIndexOf ( ':' ) ; if ( colon != - 1 ) { final String prefix = stringRep . substring ( 0 , colon ) ; final String localname = stringRep . substring ( colon + 1 ) ; String namespace = null ; if ( prefix . equals ( XMLNS_PREFIX ) == false ) { namespace = _symbolTable . lookupNamespace ( prefix ) ; if ( namespace == null && reportError ) { final int line = _locator . getLineNumber ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . NAMESPACE_UNDEF_ERR , line , prefix ) ; reportError ( ERROR , err ) ; } } return getQName ( namespace , prefix , localname ) ; } else { if ( stringRep . equals ( XMLNS_PREFIX ) ) { ignoreDefaultNs = true ; } final String defURI = ignoreDefaultNs ? null : _symbolTable . lookupNamespace ( EMPTYSTRING ) ; return getQName ( defURI , null , stringRep ) ; } } public QName getQName ( String namespace , String prefix , String localname ) { if ( namespace == null || namespace . equals ( EMPTYSTRING ) ) { QName name = ( QName ) _qNames . get ( localname ) ; if ( name == null ) { name = new QName ( null , prefix , localname ) ; _qNames . put ( localname , name ) ; } return name ; } else { Dictionary space = ( Dictionary ) _namespaces . get ( namespace ) ; if ( space == null ) { final QName name = new QName ( namespace , prefix , localname ) ; _namespaces . put ( namespace , space = new Hashtable ( ) ) ; space . put ( localname , name ) ; return name ; } else { QName name = ( QName ) space . get ( localname ) ; if ( name == null ) { name = new QName ( namespace , prefix , localname ) ; space . put ( localname , name ) ; } return name ; } } } public QName getQName ( String scope , String name ) { return getQName ( scope + name ) ; } public QName getQName ( QName scope , QName name ) { return getQName ( scope . toString ( ) + name . toString ( ) ) ; } public QName getUseAttributeSets ( ) { return _useAttributeSets ; } public QName getExtensionElementPrefixes ( ) { return _extensionElementPrefixes ; } public QName getExcludeResultPrefixes ( ) { return _excludeResultPrefixes ; } public Stylesheet makeStylesheet ( SyntaxTreeNode element ) throws CompilerException { try { Stylesheet stylesheet ; if ( element instanceof Stylesheet ) { stylesheet = ( Stylesheet ) element ; } else { stylesheet = new Stylesheet ( ) ; stylesheet . setSimplified ( ) ; stylesheet . addElement ( element ) ; stylesheet . setAttributes ( element . getAttributes ( ) ) ; if ( element . lookupNamespace ( EMPTYSTRING ) == null ) { element . addPrefixMapping ( EMPTYSTRING , EMPTYSTRING ) ; } } stylesheet . setParser ( this ) ; return stylesheet ; } catch ( ClassCastException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . NOT_STYLESHEET_ERR , element ) ; throw new CompilerException ( err . toString ( ) ) ; } } public void createAST ( Stylesheet stylesheet ) { try { if ( stylesheet != null ) { stylesheet . parseContents ( this ) ; final int precedence = stylesheet . getImportPrecedence ( ) ; final Enumeration elements = stylesheet . elements ( ) ; while ( elements . hasMoreElements ( ) ) { Object child = elements . nextElement ( ) ; if ( child instanceof Text ) { final int l = _locator . getLineNumber ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_TEXT_NODE_ERR , l , null ) ; reportError ( ERROR , err ) ; } } if ( ! errorsFound ( ) ) { stylesheet . typeCheck ( _symbolTable ) ; } } } catch ( TypeCheckError e ) { reportError ( ERROR , new ErrorMsg ( e ) ) ; } } public SyntaxTreeNode parse ( XMLReader reader , InputSource input ) { try { reader . setContentHandler ( this ) ; reader . parse ( input ) ; return ( SyntaxTreeNode ) getStylesheet ( _root ) ; } catch ( IOException e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e ) ) ; } catch ( SAXException e ) { Throwable ex = e . getException ( ) ; if ( _xsltc . debug ( ) ) { e . printStackTrace ( ) ; if ( ex != null ) ex . printStackTrace ( ) ; } reportError ( ERROR , new ErrorMsg ( e ) ) ; } catch ( CompilerException e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e ) ) ; } catch ( Exception e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( e ) ) ; } return null ; } public SyntaxTreeNode parse ( InputSource input ) { try { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { factory . setFeature ( Constants . NAMESPACE_FEATURE , true ) ; } catch ( Exception e ) { factory . setNamespaceAware ( true ) ; } final SAXParser parser = factory . newSAXParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; return ( parse ( reader , input ) ) ; } catch ( ParserConfigurationException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . SAX_PARSER_CONFIG_ERR ) ; reportError ( ERROR , err ) ; } catch ( SAXParseException e ) { reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) , e . getLineNumber ( ) ) ) ; } catch ( SAXException e ) { reportError ( ERROR , new ErrorMsg ( e . getMessage ( ) ) ) ; } return null ; } public SyntaxTreeNode getDocumentRoot ( ) { return _root ; } private String _PImedia = null ; private String _PItitle = null ; private String _PIcharset = null ; protected void setPIParameters ( String media , String title , String charset ) { _PImedia = media ; _PItitle = title ; _PIcharset = charset ; } private SyntaxTreeNode getStylesheet ( SyntaxTreeNode root ) throws CompilerException { if ( _target == null ) { if ( ! _rootNamespaceDef ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . MISSING_XSLT_URI_ERR ) ; throw new CompilerException ( msg . toString ( ) ) ; } return ( root ) ; } if ( _target . charAt ( 0 ) == '#' ) { SyntaxTreeNode element = findStylesheet ( root , _target . substring ( 1 ) ) ; if ( element == null ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . MISSING_XSLT_TARGET_ERR , _target , root ) ; throw new CompilerException ( msg . toString ( ) ) ; } return ( element ) ; } else { return ( loadExternalStylesheet ( _target ) ) ; } } private SyntaxTreeNode findStylesheet ( SyntaxTreeNode root , String href ) { if ( root == null ) return null ; if ( root instanceof Stylesheet ) { String id = root . getAttribute ( "id" ) ; if ( id . equals ( href ) ) return root ; } Vector children = root . getContents ( ) ; if ( children != null ) { final int count = children . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) children . elementAt ( i ) ; SyntaxTreeNode node = findStylesheet ( child , href ) ; if ( node != null ) return node ; } } return null ; } private SyntaxTreeNode loadExternalStylesheet ( String location ) throws CompilerException { InputSource source ; if ( ( new File ( location ) ) . exists ( ) ) source = new InputSource ( "file:" + location ) ; else source = new InputSource ( location ) ; SyntaxTreeNode external = ( SyntaxTreeNode ) parse ( source ) ; return ( external ) ; } private void initAttrTable ( String elementName , String [ ] attrs ) { _instructionAttrs . put ( getQName ( XSLT_URI , XSL , elementName ) , attrs ) ; } private void initInstructionAttrs ( ) { initAttrTable ( "template" , new String [ ] { "match" , "name" , "priority" , "mode" } ) ; initAttrTable ( "stylesheet" , new String [ ] { "id" , "version" , "extension-element-prefixes" , "exclude-result-prefixes" } ) ; initAttrTable ( "transform" , new String [ ] { "id" , "version" , "extension-element-prefixes" , "exclude-result-prefixes" } ) ; initAttrTable ( "text" , new String [ ] { "disable-output-escaping" } ) ; initAttrTable ( "if" , new String [ ] { "test" } ) ; initAttrTable ( "choose" , new String [ ] { } ) ; initAttrTable ( "when" , new String [ ] { "test" } ) ; initAttrTable ( "otherwise" , new String [ ] { } ) ; initAttrTable ( "for-each" , new String [ ] { "select" } ) ; initAttrTable ( "message" , new String [ ] { "terminate" } ) ; initAttrTable ( "number" , new String [ ] { "level" , "count" , "from" , "value" , "format" , "lang" , "letter-value" , "grouping-separator" , "grouping-size" } ) ; initAttrTable ( "comment" , new String [ ] { } ) ; initAttrTable ( "copy" , new String [ ] { "use-attribute-sets" } ) ; initAttrTable ( "copy-of" , new String [ ] { "select" } ) ; initAttrTable ( "param" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "with-param" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "variable" , new String [ ] { "name" , "select" } ) ; initAttrTable ( "output" , new String [ ] { "method" , "version" , "encoding" , "omit-xml-declaration" , "standalone" , "doctype-public" , "doctype-system" , "cdata-section-elements" , "indent" , "media-type" } ) ; initAttrTable ( "sort" , new String [ ] { "select" , "order" , "case-order" , "lang" , "data-type" } ) ; initAttrTable ( "key" , new String [ ] { "name" , "match" , "use" } ) ; initAttrTable ( "fallback" , new String [ ] { } ) ; initAttrTable ( "attribute" , new String [ ] { "name" , "namespace" } ) ; initAttrTable ( "attribute-set" , new String [ ] { "name" , "use-attribute-sets" } ) ; initAttrTable ( "value-of" , new String [ ] { "select" , "disable-output-escaping" } ) ; initAttrTable ( "element" , new String [ ] { "name" , "namespace" , "use-attribute-sets" } ) ; initAttrTable ( "call-template" , new String [ ] { "name" } ) ; initAttrTable ( "apply-templates" , new String [ ] { "select" , "mode" } ) ; initAttrTable ( "apply-imports" , new String [ ] { } ) ; initAttrTable ( "decimal-format" , new String [ ] { "name" , "decimal-separator" , "grouping-separator" , "infinity" , "minus-sign" , "NaN" , "percent" , "per-mille" , "zero-digit" , "digit" , "pattern-separator" } ) ; initAttrTable ( "import" , new String [ ] { "href" } ) ; initAttrTable ( "include" , new String [ ] { "href" } ) ; initAttrTable ( "strip-space" , new String [ ] { "elements" } ) ; initAttrTable ( "preserve-space" , new String [ ] { "elements" } ) ; initAttrTable ( "processing-instruction" , new String [ ] { "name" } ) ; initAttrTable ( "namespace-alias" , new String [ ] { "stylesheet-prefix" , "result-prefix" } ) ; } private void initStdClasses ( ) { initStdClass ( "template" , "Template" ) ; initStdClass ( "stylesheet" , "Stylesheet" ) ; initStdClass ( "transform" , "Stylesheet" ) ; initStdClass ( "text" , "Text" ) ; initStdClass ( "if" , "If" ) ; initStdClass ( "choose" , "Choose" ) ; initStdClass ( "when" , "When" ) ; initStdClass ( "otherwise" , "Otherwise" ) ; initStdClass ( "for-each" , "ForEach" ) ; initStdClass ( "message" , "Message" ) ; initStdClass ( "number" , "Number" ) ; initStdClass ( "comment" , "Comment" ) ; initStdClass ( "copy" , "Copy" ) ; initStdClass ( "copy-of" , "CopyOf" ) ; initStdClass ( "param" , "Param" ) ; initStdClass ( "with-param" , "WithParam" ) ; initStdClass ( "variable" , "Variable" ) ; initStdClass ( "output" , "Output" ) ; initStdClass ( "sort" , "Sort" ) ; initStdClass ( "key" , "Key" ) ; initStdClass ( "fallback" , "Fallback" ) ; initStdClass ( "attribute" , "XslAttribute" ) ; initStdClass ( "attribute-set" , "AttributeSet" ) ; initStdClass ( "value-of" , "ValueOf" ) ; initStdClass ( "element" , "XslElement" ) ; initStdClass ( "call-template" , "CallTemplate" ) ; initStdClass ( "apply-templates" , "ApplyTemplates" ) ; initStdClass ( "apply-imports" , "ApplyImports" ) ; initStdClass ( "decimal-format" , "DecimalFormatting" ) ; initStdClass ( "import" , "Import" ) ; initStdClass ( "include" , "Include" ) ; initStdClass ( "strip-space" , "Whitespace" ) ; initStdClass ( "preserve-space" , "Whitespace" ) ; initStdClass ( "processing-instruction" , "ProcessingInstruction" ) ; initStdClass ( "namespace-alias" , "NamespaceAlias" ) ; } private void initStdClass ( String elementName , String className ) { _instructionClasses . put ( getQName ( XSLT_URI , XSL , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } public boolean elementSupported ( String namespace , String localName ) { return ( _instructionClasses . get ( getQName ( namespace , XSL , localName ) ) != null ) ; } public boolean functionSupported ( String fname ) { return ( _symbolTable . lookupPrimop ( fname ) != null ) ; } private void initExtClasses ( ) { initExtClass ( "output" , "TransletOutput" ) ; initExtClass ( REDIRECT_URI , "write" , "TransletOutput" ) ; } private void initExtClass ( String elementName , String className ) { _instructionClasses . put ( getQName ( TRANSLET_URI , TRANSLET , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } private void initExtClass ( String namespace , String elementName , String className ) { _instructionClasses . put ( getQName ( namespace , TRANSLET , elementName ) , COMPILER_PACKAGE + '.' + className ) ; } private void initSymbolTable ( ) { MethodType I_V = new MethodType ( Type . Int , Type . Void ) ; MethodType I_R = new MethodType ( Type . Int , Type . Real ) ; MethodType I_S = new MethodType ( Type . Int , Type . String ) ; MethodType I_D = new MethodType ( Type . Int , Type . NodeSet ) ; MethodType R_I = new MethodType ( Type . Real , Type . Int ) ; MethodType R_V = new MethodType ( Type . Real , Type . Void ) ; MethodType R_R = new MethodType ( Type . Real , Type . Real ) ; MethodType R_D = new MethodType ( Type . Real , Type . NodeSet ) ; MethodType R_O = new MethodType ( Type . Real , Type . Reference ) ; MethodType I_I = new MethodType ( Type . Int , Type . Int ) ; MethodType D_O = new MethodType ( Type . NodeSet , Type . Reference ) ; MethodType D_V = new MethodType ( Type . NodeSet , Type . Void ) ; MethodType D_S = new MethodType ( Type . NodeSet , Type . String ) ; MethodType D_D = new MethodType ( Type . NodeSet , Type . NodeSet ) ; MethodType A_V = new MethodType ( Type . Node , Type . Void ) ; MethodType S_V = new MethodType ( Type . String , Type . Void ) ; MethodType S_S = new MethodType ( Type . String , Type . String ) ; MethodType S_A = new MethodType ( Type . String , Type . Node ) ; MethodType S_D = new MethodType ( Type . String , Type . NodeSet ) ; MethodType S_O = new MethodType ( Type . String , Type . Reference ) ; MethodType B_O = new MethodType ( Type . Boolean , Type . Reference ) ; MethodType B_V = new MethodType ( Type . Boolean , Type . Void ) ; MethodType B_B = new MethodType ( Type . Boolean , Type . Boolean ) ; MethodType B_S = new MethodType ( Type . Boolean , Type . String ) ; MethodType D_X = new MethodType ( Type . NodeSet , Type . Object ) ; MethodType R_RR = new MethodType ( Type . Real , Type . Real , Type . Real ) ; MethodType I_II = new MethodType ( Type . Int , Type . Int , Type . Int ) ; MethodType B_RR = new MethodType ( Type . Boolean , Type . Real , Type . Real ) ; MethodType B_II = new MethodType ( Type . Boolean , Type . Int , Type . Int ) ; MethodType S_SS = new MethodType ( Type . String , Type . String , Type . String ) ; MethodType S_DS = new MethodType ( Type . String , Type . Real , Type . String ) ; MethodType S_SR = new MethodType ( Type . String , Type . String , Type . Real ) ; MethodType D_SS = new MethodType ( Type . NodeSet , Type . String , Type . String ) ; MethodType D_SD = new MethodType ( Type . NodeSet , Type . String , Type . NodeSet ) ; MethodType B_BB = new MethodType ( Type . Boolean , Type . Boolean , Type . Boolean ) ; MethodType B_SS = new MethodType ( Type . Boolean , Type . String , Type . String ) ; MethodType S_SD = new MethodType ( Type . String , Type . String , Type . NodeSet ) ; MethodType S_DSS = new MethodType ( Type . String , Type . Real , Type . String , Type . String ) ; MethodType S_SRR = new MethodType ( Type . String , Type . String , Type . Real , Type . Real ) ; MethodType S_SSS = new MethodType ( Type . String , Type . String , Type . String , Type . String ) ; _symbolTable . addPrimop ( "current" , A_V ) ; _symbolTable . addPrimop ( "last" , I_V ) ; _symbolTable . addPrimop ( "position" , I_V ) ; _symbolTable . addPrimop ( "true" , B_V ) ; _symbolTable . addPrimop ( "false" , B_V ) ; _symbolTable . addPrimop ( "not" , B_B ) ; _symbolTable . addPrimop ( "name" , S_V ) ; _symbolTable . addPrimop ( "name" , S_A ) ; _symbolTable . addPrimop ( "generate-id" , S_V ) ; _symbolTable . addPrimop ( "generate-id" , S_A ) ; _symbolTable . addPrimop ( "ceiling" , R_R ) ; _symbolTable . addPrimop ( "floor" , R_R ) ; _symbolTable . addPrimop ( "round" , R_R ) ; _symbolTable . addPrimop ( "contains" , B_SS ) ; _symbolTable . addPrimop ( "number" , R_O ) ; _symbolTable . addPrimop ( "number" , R_V ) ; _symbolTable . addPrimop ( "boolean" , B_O ) ; _symbolTable . addPrimop ( "string" , S_O ) ; _symbolTable . addPrimop ( "string" , S_V ) ; _symbolTable . addPrimop ( "translate" , S_SSS ) ; _symbolTable . addPrimop ( "string-length" , I_V ) ; _symbolTable . addPrimop ( "string-length" , I_S ) ; _symbolTable . addPrimop ( "starts-with" , B_SS ) ; _symbolTable . addPrimop ( "format-number" , S_DS ) ; _symbolTable . addPrimop ( "format-number" , S_DSS ) ; _symbolTable . addPrimop ( "unparsed-entity-uri" , S_S ) ; _symbolTable . addPrimop ( "key" , D_SS ) ; _symbolTable . addPrimop ( "key" , D_SD ) ; _symbolTable . addPrimop ( "id" , D_S ) ; _symbolTable . addPrimop ( "id" , D_D ) ; _symbolTable . addPrimop ( "namespace-uri" , S_V ) ; _symbolTable . addPrimop ( "function-available" , B_S ) ; _symbolTable . addPrimop ( "element-available" , B_S ) ; _symbolTable . addPrimop ( "document" , D_S ) ; _symbolTable . addPrimop ( "document" , D_V ) ; _symbolTable . addPrimop ( "count" , I_D ) ; _symbolTable . addPrimop ( "sum" , R_D ) ; _symbolTable . addPrimop ( "local-name" , S_V ) ; _symbolTable . addPrimop ( "local-name" , S_D ) ; _symbolTable . addPrimop ( "namespace-uri" , S_V ) ; _symbolTable . addPrimop ( "namespace-uri" , S_D ) ; _symbolTable . addPrimop ( "substring" , S_SR ) ; _symbolTable . addPrimop ( "substring" , S_SRR ) ; _symbolTable . addPrimop ( "substring-after" , S_SS ) ; _symbolTable . addPrimop ( "substring-before" , S_SS ) ; _symbolTable . addPrimop ( "normalize-space" , S_V ) ; _symbolTable . addPrimop ( "normalize-space" , S_S ) ; _symbolTable . addPrimop ( "system-property" , S_S ) ; _symbolTable . addPrimop ( "nodeset" , D_O ) ; _symbolTable . addPrimop ( "objectType" , S_O ) ; _symbolTable . addPrimop ( "+" , R_RR ) ; _symbolTable . addPrimop ( "-" , R_RR ) ; _symbolTable . addPrimop ( "*" , R_RR ) ; _symbolTable . addPrimop ( "/" , R_RR ) ; _symbolTable . addPrimop ( "%" , R_RR ) ; _symbolTable . addPrimop ( "+" , I_II ) ; _symbolTable . addPrimop ( "-" , I_II ) ; _symbolTable . addPrimop ( "*" , I_II ) ; _symbolTable . addPrimop ( "<" , B_RR ) ; _symbolTable . addPrimop ( "<=" , B_RR ) ; _symbolTable . addPrimop ( ">" , B_RR ) ; _symbolTable . addPrimop ( ">=" , B_RR ) ; _symbolTable . addPrimop ( "<" , B_II ) ; _symbolTable . addPrimop ( "<=" , B_II ) ; _symbolTable . addPrimop ( ">" , B_II ) ; _symbolTable . addPrimop ( ">=" , B_II ) ; _symbolTable . addPrimop ( "<" , B_BB ) ; _symbolTable . addPrimop ( "<=" , B_BB ) ; _symbolTable . addPrimop ( ">" , B_BB ) ; _symbolTable . addPrimop ( ">=" , B_BB ) ; _symbolTable . addPrimop ( "or" , B_BB ) ; _symbolTable . addPrimop ( "and" , B_BB ) ; _symbolTable . addPrimop ( "u-" , R_R ) ; _symbolTable . addPrimop ( "u-" , I_I ) ; } public SymbolTable getSymbolTable ( ) { return _symbolTable ; } public Template getTemplate ( ) { return _template ; } public void setTemplate ( Template template ) { _template = template ; } private int _templateIndex = 0 ; public int getTemplateIndex ( ) { return ( _templateIndex ++ ) ; } private boolean versionIsOne = true ; public SyntaxTreeNode makeInstance ( String uri , String prefix , String local , Attributes attributes ) { SyntaxTreeNode node = null ; QName qname = getQName ( uri , prefix , local ) ; String className = ( String ) _instructionClasses . get ( qname ) ; if ( className != null ) { try { final Class clazz = Class . forName ( className ) ; node = ( SyntaxTreeNode ) clazz . newInstance ( ) ; node . setQName ( qname ) ; node . setParser ( this ) ; if ( _locator != null ) { node . setLineNumber ( _locator . getLineNumber ( ) ) ; } if ( node instanceof Stylesheet ) { _xsltc . setStylesheet ( ( Stylesheet ) node ) ; } checkForSuperfluousAttributes ( node , attributes ) ; } catch ( ClassNotFoundException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CLASS_NOT_FOUND_ERR , node ) ; reportError ( ERROR , err ) ; } catch ( Exception e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INTERNAL_ERR , e . getMessage ( ) , node ) ; reportError ( FATAL , err ) ; } } else { if ( uri != null ) { if ( uri . equals ( XSLT_URI ) ) { node = new UnsupportedElement ( uri , prefix , local ) ; UnsupportedElement element = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_XSL_ERR , _locator . getLineNumber ( ) , local ) ; element . setErrorMessage ( msg ) ; } else if ( uri . equals ( TRANSLET_URI ) ) { node = new UnsupportedElement ( uri , prefix , local ) ; UnsupportedElement element = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_EXT_ERR , _locator . getLineNumber ( ) , local ) ; element . setErrorMessage ( msg ) ; } else { Stylesheet sheet = _xsltc . getStylesheet ( ) ; if ( ( sheet != null ) && ( sheet . isExtension ( uri ) ) ) { if ( sheet != ( SyntaxTreeNode ) _parentStack . peek ( ) ) { node = new UnsupportedElement ( uri , prefix , local ) ; UnsupportedElement elem = ( UnsupportedElement ) node ; ErrorMsg msg = new ErrorMsg ( ErrorMsg . UNSUPPORTED_EXT_ERR , _locator . getLineNumber ( ) , prefix + ":" + local ) ; elem . setErrorMessage ( msg ) ; } } } } if ( node == null ) node = new LiteralElement ( ) ; } if ( ( node != null ) && ( node instanceof LiteralElement ) ) { ( ( LiteralElement ) node ) . setQName ( qname ) ; } return ( node ) ; } private void checkForSuperfluousAttributes ( SyntaxTreeNode node , Attributes attrs ) { QName qname = node . getQName ( ) ; boolean isStylesheet = ( node instanceof Stylesheet ) ; String [ ] legal = ( String [ ] ) _instructionAttrs . get ( qname ) ; if ( versionIsOne && legal != null ) { int j ; final int n = attrs . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final String attrQName = attrs . getQName ( i ) ; if ( isStylesheet && attrQName . equals ( "version" ) ) { versionIsOne = attrs . getValue ( i ) . equals ( "1.0" ) ; } if ( attrQName . startsWith ( "xml" ) || attrQName . indexOf ( ':' ) > 0 ) continue ; for ( j = 0 ; j < legal . length ; j ++ ) { if ( attrQName . equalsIgnoreCase ( legal [ j ] ) ) { break ; } } if ( j == legal . length ) { final ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_ATTRIBUTE_ERR , attrQName , node ) ; reportError ( WARNING , err ) ; } } } } public Expression parseExpression ( SyntaxTreeNode parent , String exp ) { return ( Expression ) parseTopLevel ( parent , "<EXPRESSION>" + exp , null ) ; } public Expression parseExpression ( SyntaxTreeNode parent , String attr , String def ) { String exp = parent . getAttribute ( attr ) ; if ( ( exp . length ( ) == 0 ) && ( def != null ) ) exp = def ; return ( Expression ) parseTopLevel ( parent , "<EXPRESSION>" + exp , exp ) ; } public Pattern parsePattern ( SyntaxTreeNode parent , String pattern ) { return ( Pattern ) parseTopLevel ( parent , "<PATTERN>" + pattern , pattern ) ; } public Pattern parsePattern ( SyntaxTreeNode parent , String attr , String def ) { String pattern = parent . getAttribute ( attr ) ; if ( ( pattern . length ( ) == 0 ) && ( def != null ) ) pattern = def ; return ( Pattern ) parseTopLevel ( parent , "<PATTERN>" + pattern , pattern ) ; } private SyntaxTreeNode parseTopLevel ( SyntaxTreeNode parent , String text , String expression ) { int line = 0 ; if ( _locator != null ) line = _locator . getLineNumber ( ) ; try { _xpathParser . setScanner ( new XPathLexer ( new StringReader ( text ) ) ) ; Symbol result = _xpathParser . parse ( expression , line ) ; if ( result != null ) { final SyntaxTreeNode node = ( SyntaxTreeNode ) result . value ; if ( node != null ) { node . setParser ( this ) ; node . setParent ( parent ) ; node . setLineNumber ( line ) ; return node ; } } reportError ( ERROR , new ErrorMsg ( ErrorMsg . XPATH_PARSER_ERR , expression , parent ) ) ; } catch ( Exception e ) { if ( _xsltc . debug ( ) ) e . printStackTrace ( ) ; reportError ( ERROR , new ErrorMsg ( ErrorMsg . XPATH_PARSER_ERR , expression , parent ) ) ; } SyntaxTreeNode . Dummy . setParser ( this ) ; return SyntaxTreeNode . Dummy ; } public boolean errorsFound ( ) { return _errors . size ( ) > 0 ; } public void printErrors ( ) { final int size = _errors . size ( ) ; if ( size > 0 ) { System . err . println ( new ErrorMsg ( ErrorMsg . COMPILER_ERROR_KEY ) ) ; for ( int i = 0 ; i < size ; i ++ ) { System . err . println ( "  " + _errors . elementAt ( i ) ) ; } } } public void printWarnings ( ) { final int size = _warnings . size ( ) ; if ( size > 0 ) { System . err . println ( new ErrorMsg ( ErrorMsg . COMPILER_WARNING_KEY ) ) ; for ( int i = 0 ; i < size ; i ++ ) { System . err . println ( "  " + _warnings . elementAt ( i ) ) ; } } } public void reportError ( final int category , final ErrorMsg error ) { switch ( category ) { case Constants . INTERNAL : _errors . addElement ( error ) ; break ; case Constants . UNSUPPORTED : _errors . addElement ( error ) ; break ; case Constants . FATAL : _errors . addElement ( error ) ; break ; case Constants . ERROR : _errors . addElement ( error ) ; break ; case Constants . WARNING : _warnings . addElement ( error ) ; break ; } } public Vector getErrors ( ) { return _errors ; } public Vector getWarnings ( ) { return _warnings ; } private Stack _parentStack = null ; private Hashtable _prefixMapping = null ; public void startDocument ( ) { _root = null ; _target = null ; _prefixMapping = null ; _parentStack = new Stack ( ) ; } public void endDocument ( ) { } public void startPrefixMapping ( String prefix , String uri ) { if ( _prefixMapping == null ) { _prefixMapping = new Hashtable ( ) ; } _prefixMapping . put ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) { } public void startElement ( String uri , String localname , String qname , Attributes attributes ) throws SAXException { final int col = qname . lastIndexOf ( ':' ) ; final String prefix = ( col == - 1 ) ? null : qname . substring ( 0 , col ) ; SyntaxTreeNode element = makeInstance ( uri , prefix , localname , attributes ) ; if ( element == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ELEMENT_PARSE_ERR , prefix + ':' + localname ) ; throw new SAXException ( err . toString ( ) ) ; } if ( _root == null ) { if ( ( _prefixMapping == null ) || ( _prefixMapping . containsValue ( Constants . XSLT_URI ) == false ) ) _rootNamespaceDef = false ; else _rootNamespaceDef = true ; _root = element ; } else { SyntaxTreeNode parent = ( SyntaxTreeNode ) _parentStack . peek ( ) ; parent . addElement ( element ) ; element . setParent ( parent ) ; } element . setAttributes ( ( Attributes ) new AttributeList ( attributes ) ) ; element . setPrefixMapping ( _prefixMapping ) ; if ( element instanceof Stylesheet ) { getSymbolTable ( ) . setCurrentNode ( element ) ; ( ( Stylesheet ) element ) . excludeExtensionPrefixes ( this ) ; } _prefixMapping = null ; _parentStack . push ( element ) ; } public void endElement ( String uri , String localname , String qname ) { _parentStack . pop ( ) ; } public void characters ( char [ ] ch , int start , int length ) { String string = new String ( ch , start , length ) ; SyntaxTreeNode parent = ( SyntaxTreeNode ) _parentStack . peek ( ) ; if ( string . length ( ) == 0 ) return ; if ( parent instanceof Text ) { ( ( Text ) parent ) . setText ( string ) ; return ; } if ( parent instanceof Stylesheet ) return ; SyntaxTreeNode bro = parent . lastChild ( ) ; if ( ( bro != null ) && ( bro instanceof Text ) ) { Text text = ( Text ) bro ; if ( ! text . isTextElement ( ) ) { if ( ( length > 1 ) || ( ( ( int ) ch [ 0 ] ) < 0x100 ) ) { text . setText ( string ) ; return ; } } } parent . addElement ( new Text ( string ) ) ; } private String getTokenValue ( String token ) { final int start = token . indexOf ( '"' ) ; final int stop = token . lastIndexOf ( '"' ) ; return token . substring ( start + 1 , stop ) ; } public void processingInstruction ( String name , String value ) { if ( ( _target == null ) && ( name . equals ( "xml-stylesheet" ) ) ) { String href = null ; String media = null ; String title = null ; String charset = null ; StringTokenizer tokens = new StringTokenizer ( value ) ; while ( tokens . hasMoreElements ( ) ) { String token = ( String ) tokens . nextElement ( ) ; if ( token . startsWith ( "href" ) ) href = getTokenValue ( token ) ; else if ( token . startsWith ( "media" ) ) media = getTokenValue ( token ) ; else if ( token . startsWith ( "title" ) ) title = getTokenValue ( token ) ; else if ( token . startsWith ( "charset" ) ) charset = getTokenValue ( token ) ; } if ( ( ( _PImedia == null ) || ( _PImedia . equals ( media ) ) ) && ( ( _PItitle == null ) || ( _PImedia . equals ( title ) ) ) && ( ( _PIcharset == null ) || ( _PImedia . equals ( charset ) ) ) ) { _target = href ; } } } public void ignorableWhitespace ( char [ ] ch , int start , int length ) { } public void skippedEntity ( String name ) { } public void setDocumentLocator ( Locator locator ) { _locator = locator ; } } 	1
package org . apache . xalan . xsltc . compiler ; final class IdPattern extends IdKeyPattern { public IdPattern ( String id ) { super ( "##id" , id ) ; } } 	0
package org . apache . xalan . lib ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xpath . NodeSet ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . xml . sax . SAXNotSupportedException ; public class ExsltDynamic extends ExsltBase { public static final String EXSL_URI = "http://exslt.org/common" ; public static double max ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return Double . NaN ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; double maxValue = - Double . MAX_VALUE ; for ( int i = 0 ; i < contextNodes . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; double result = 0 ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; result = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) . num ( ) ; } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return Double . NaN ; } xctxt . popCurrentNode ( ) ; if ( result > maxValue ) maxValue = result ; } xctxt . popContextNodeList ( ) ; return maxValue ; } public static double min ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return Double . NaN ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; double minValue = Double . MAX_VALUE ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; double result = 0 ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; result = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) . num ( ) ; } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return Double . NaN ; } xctxt . popCurrentNode ( ) ; if ( result < minValue ) minValue = result ; } xctxt . popContextNodeList ( ) ; return minValue ; } public static double sum ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return Double . NaN ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; double sum = 0 ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; double result = 0 ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; result = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) . num ( ) ; } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return Double . NaN ; } xctxt . popCurrentNode ( ) ; sum = sum + result ; } xctxt . popContextNodeList ( ) ; return sum ; } public static NodeList map ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; Document lDoc = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return new NodeSet ( ) ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; NodeSet resultSet = new NodeSet ( ) ; resultSet . setShouldCacheNodes ( true ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; XObject object = null ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; object = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) ; if ( object instanceof XNodeSet ) { NodeList nodelist = null ; nodelist = ( ( XNodeSet ) object ) . nodelist ( ) ; for ( int k = 0 ; k < nodelist . getLength ( ) ; k ++ ) { Node n = nodelist . item ( k ) ; if ( ! resultSet . contains ( n ) ) resultSet . addNode ( n ) ; } } else { if ( lDoc == null ) { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; lDoc = db . newDocument ( ) ; } Element element = null ; if ( object instanceof XNumber ) element = lDoc . createElementNS ( EXSL_URI , "exsl:number" ) ; else if ( object instanceof XBoolean ) element = lDoc . createElementNS ( EXSL_URI , "exsl:boolean" ) ; else element = lDoc . createElementNS ( EXSL_URI , "exsl:string" ) ; Text textNode = lDoc . createTextNode ( object . str ( ) ) ; element . appendChild ( textNode ) ; resultSet . addNode ( element ) ; } } catch ( Exception e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return new NodeSet ( ) ; } xctxt . popCurrentNode ( ) ; } xctxt . popContextNodeList ( ) ; return resultSet ; } public static XObject evaluate ( ExpressionContext myContext , String xpathExpr ) throws SAXNotSupportedException { if ( myContext instanceof XPathContext . XPathExpressionContext ) { XPathContext xctxt = null ; try { xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; XPath dynamicXPath = new XPath ( xpathExpr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; return dynamicXPath . execute ( xctxt , myContext . getContextNode ( ) , xctxt . getNamespaceContext ( ) ) ; } catch ( TransformerException e ) { return new XNodeSet ( xctxt . getDTMManager ( ) ) ; } } else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; } public static NodeList closure ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return new NodeSet ( ) ; NodeSet closureSet = new NodeSet ( ) ; closureSet . setShouldCacheNodes ( true ) ; NodeList iterationList = nl ; do { NodeSet iterationSet = new NodeSet ( ) ; NodeSetDTM contextNodes = new NodeSetDTM ( iterationList , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; for ( int i = 0 ; i < iterationList . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; XObject object = null ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; object = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) ; if ( object instanceof XNodeSet ) { NodeList nodelist = null ; nodelist = ( ( XNodeSet ) object ) . nodelist ( ) ; for ( int k = 0 ; k < nodelist . getLength ( ) ; k ++ ) { Node n = nodelist . item ( k ) ; if ( ! iterationSet . contains ( n ) ) iterationSet . addNode ( n ) ; } } else { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return new NodeSet ( ) ; } } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return new NodeSet ( ) ; } xctxt . popCurrentNode ( ) ; } xctxt . popContextNodeList ( ) ; iterationList = iterationSet ; for ( int i = 0 ; i < iterationList . getLength ( ) ; i ++ ) { Node n = iterationList . item ( i ) ; if ( ! closureSet . contains ( n ) ) closureSet . addNode ( n ) ; } } while ( iterationList . getLength ( ) > 0 ) ; return closureSet ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class AbsoluteLocationPath extends Expression { private Expression _path ; public AbsoluteLocationPath ( ) { _path = null ; } public AbsoluteLocationPath ( Expression path ) { _path = path ; if ( path != null ) { _path . setParent ( this ) ; } } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _path != null ) { _path . setParser ( parser ) ; } } public Expression getPath ( ) { return ( _path ) ; } public String toString ( ) { return "AbsoluteLocationPath(" + ( _path != null ? _path . toString ( ) : "null" ) + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _path != null ) { final Type ptype = _path . typeCheck ( stable ) ; if ( ptype instanceof NodeType ) { _path = new CastExpr ( _path , Type . NodeSet ) ; } } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _path != null ) { final int initAI = cpg . addMethodref ( ABSOLUTE_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( ABSOLUTE_ITERATOR ) ) ) ; il . append ( DUP ) ; _path . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initAI ) ) ; } else { final int gitr = cpg . addInterfaceMethodref ( DOM_INTF , "getIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKEINTERFACE ( gitr , 1 ) ) ; } } } 	0
package org . apache . xalan . templates ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathFactory ; import org . apache . xpath . compiler . XPathParser ; import org . apache . xpath . objects . XObject ; public class AVTPartXPath extends AVTPart { private XPath m_xpath ; public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_xpath . fixupVariables ( vars , globalsSize ) ; } public boolean canTraverseOutsideSubtree ( ) { return m_xpath . getExpression ( ) . canTraverseOutsideSubtree ( ) ; } public AVTPartXPath ( XPath xpath ) { m_xpath = xpath ; } public AVTPartXPath ( String val , org . apache . xml . utils . PrefixResolver nsNode , XPathParser xpathProcessor , XPathFactory factory , XPathContext liaison ) throws javax . xml . transform . TransformerException { m_xpath = new XPath ( val , null , nsNode , XPath . SELECT , liaison . getErrorListener ( ) ) ; } public String getSimpleString ( ) { return "{" + m_xpath . getPatternString ( ) + "}" ; } public void evaluate ( XPathContext xctxt , FastStringBuffer buf , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException { XObject xobj = m_xpath . execute ( xctxt , context , nsNode ) ; if ( null != xobj ) { xobj . appendToFsb ( buf ) ; } } public void callVisitors ( XSLTVisitor visitor ) { m_xpath . getExpression ( ) . callVisitors ( m_xpath , visitor ) ; } } 	1
package org . apache . xalan . transformer ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . ObjectStack ; public class StackGuard { public static int m_recursionLimit = - 1 ; TransformerImpl m_transformer ; public int getRecursionLimit ( ) { return m_recursionLimit ; } public void setRecursionLimit ( int limit ) { m_recursionLimit = limit ; } public StackGuard ( TransformerImpl transformerImpl ) { m_transformer = transformerImpl ; } public int countLikeTemplates ( ElemTemplate templ , int pos ) { ObjectStack elems = m_transformer . getCurrentTemplateElements ( ) ; int count = 1 ; for ( int i = pos - 1 ; i >= 0 ; i -- ) { if ( ( ElemTemplateElement ) elems . elementAt ( i ) == templ ) count ++ ; } return count ; } private ElemTemplate getNextMatchOrNamedTemplate ( int pos ) { ObjectStack elems = m_transformer . getCurrentTemplateElements ( ) ; for ( int i = pos ; i >= 0 ; i -- ) { ElemTemplateElement elem = ( ElemTemplateElement ) elems . elementAt ( i ) ; if ( null != elem ) { if ( elem . getXSLToken ( ) == Constants . ELEMNAME_TEMPLATE ) { return ( ElemTemplate ) elem ; } } } return null ; } public void checkForInfinateLoop ( ) throws TransformerException { int nTemplates = m_transformer . getCurrentTemplateElementsCount ( ) ; if ( nTemplates < m_recursionLimit ) return ; if ( m_recursionLimit <= 0 ) return ; for ( int i = ( nTemplates - 1 ) ; i >= m_recursionLimit ; i -- ) { ElemTemplate template = getNextMatchOrNamedTemplate ( i ) ; if ( null == template ) break ; int loopCount = countLikeTemplates ( template , i ) ; if ( loopCount >= m_recursionLimit ) { String idIs = XSLMessages . createMessage ( ( ( null != template . getName ( ) ) ? "nameIs" : "matchPatternIs" ) , null ) ; Object [ ] msgArgs = new Object [ ] { new Integer ( loopCount ) , idIs , ( ( null != template . getName ( ) ) ? template . getName ( ) . toString ( ) : template . getMatch ( ) . getPatternString ( ) ) } ; String msg = XSLMessages . createMessage ( "recursionTooDeep" , msgArgs ) ; throw new TransformerException ( msg ) ; } } } } 	0
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . Type ; public final class NamedMethodGenerator extends MethodGenerator { protected static int CURRENT_INDEX = 4 ; public NamedMethodGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; } public int getLocalIndex ( String name ) { if ( name . equals ( "current" ) ) { return CURRENT_INDEX ; } return super . getLocalIndex ( name ) ; } } 	1
package org . apache . xml . utils ; public interface DOMOrder { public int getUid ( ) ; } 	0
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . OpCodes ; import org . apache . xpath . patterns . NodeTest ; public class DescendantIterator extends LocPathIterator { DescendantIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int stepType = compiler . getOp ( firstStepPos ) ; boolean orSelf = ( OpCodes . FROM_DESCENDANTS_OR_SELF == stepType ) ; boolean fromRoot = false ; if ( OpCodes . FROM_SELF == stepType ) { orSelf = true ; } else if ( OpCodes . FROM_ROOT == stepType ) { fromRoot = true ; int nextStepPos = compiler . getNextStepPos ( firstStepPos ) ; if ( compiler . getOp ( nextStepPos ) == OpCodes . FROM_DESCENDANTS_OR_SELF ) orSelf = true ; } int nextStepPos = firstStepPos ; while ( true ) { nextStepPos = compiler . getNextStepPos ( nextStepPos ) ; if ( nextStepPos > 0 ) { int stepOp = compiler . getOp ( nextStepPos ) ; if ( OpCodes . ENDOP != stepOp ) firstStepPos = nextStepPos ; else break ; } else break ; } if ( ( analysis & WalkerFactory . BIT_CHILD ) != 0 ) orSelf = false ; if ( fromRoot ) { if ( orSelf ) m_axis = Axis . DESCENDANTSORSELFFROMROOT ; else m_axis = Axis . DESCENDANTSFROMROOT ; } else if ( orSelf ) m_axis = Axis . DESCENDANTORSELF ; else m_axis = Axis . DESCENDANT ; int whatToShow = compiler . getWhatToShow ( firstStepPos ) ; if ( ( 0 == ( whatToShow & ( DTMFilter . SHOW_ATTRIBUTE | DTMFilter . SHOW_ELEMENT | DTMFilter . SHOW_PROCESSING_INSTRUCTION ) ) ) || ( whatToShow == DTMFilter . SHOW_ALL ) ) initNodeTest ( whatToShow ) ; else { initNodeTest ( whatToShow , compiler . getStepNS ( firstStepPos ) , compiler . getStepLocalName ( firstStepPos ) ) ; } initPredicateInfo ( compiler , firstStepPos ) ; } public DescendantIterator ( ) { super ( null ) ; m_axis = Axis . DESCENDANTSORSELFFROMROOT ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { DescendantIterator clone = ( DescendantIterator ) super . cloneWithReset ( ) ; clone . m_traverser = m_traverser ; clone . resetProximityPositions ( ) ; return clone ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; if ( DTM . NULL == m_lastFetched ) { resetProximityPositions ( ) ; } int next ; org . apache . xpath . VariableStack vars ; int savedStart ; if ( - 1 != m_stackFrame ) { vars = m_execContext . getVarStack ( ) ; savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; } else { vars = null ; savedStart = 0 ; } try { do { if ( 0 == m_extendedTypeID ) { next = m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; } else { next = m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context , m_extendedTypeID ) : m_traverser . next ( m_context , m_lastFetched , m_extendedTypeID ) ; } if ( DTM . NULL != next ) { if ( DTMIterator . FILTER_ACCEPT == acceptNode ( next ) ) break ; else continue ; } else break ; } while ( next != DTM . NULL ) ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } finally { if ( - 1 != m_stackFrame ) { vars . setStackFrame ( savedStart ) ; } } } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_axis ) ; String localName = getLocalName ( ) ; String namespace = getNamespace ( ) ; int what = m_whatToShow ; if ( DTMFilter . SHOW_ALL == what || localName == NodeTest . WILD || namespace == NodeTest . WILD ) { m_extendedTypeID = 0 ; } else { int type = getNodeTypeTest ( what ) ; m_extendedTypeID = m_cdtm . getExpandedTypeID ( namespace , localName , type ) ; } } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( getPredicateCount ( ) > 0 ) return super . asNode ( xctxt ) ; int current = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( current ) ; DTMAxisTraverser traverser = dtm . getAxisTraverser ( m_axis ) ; String localName = getLocalName ( ) ; String namespace = getNamespace ( ) ; int what = m_whatToShow ; if ( DTMFilter . SHOW_ALL == what || localName == NodeTest . WILD || namespace == NodeTest . WILD ) { return traverser . first ( current ) ; } else { int type = getNodeTypeTest ( what ) ; int extendedType = dtm . getExpandedTypeID ( namespace , localName , type ) ; return traverser . first ( current , extendedType ) ; } } public void detach ( ) { m_traverser = null ; m_extendedTypeID = 0 ; super . detach ( ) ; } public int getAxis ( ) { return m_axis ; } transient protected DTMAxisTraverser m_traverser ; protected int m_axis ; protected int m_extendedTypeID ; public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( DescendantIterator ) expr ) . m_axis ) return false ; return true ; } } 	1
package org . apache . xml . serializer ; public class EncodingInfo extends Object { final String name ; final String javaName ; final int lastPrintable ; public EncodingInfo ( String name , String javaName , int lastPrintable ) { this . name = name ; this . javaName = javaName ; this . lastPrintable = lastPrintable ; } } 	0
package org . apache . xpath . functions ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncSubstringAfter extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XMLString s1 = m_arg0 . execute ( xctxt ) . xstr ( ) ; XMLString s2 = m_arg1 . execute ( xctxt ) . xstr ( ) ; int index = s1 . indexOf ( s2 ) ; return ( - 1 == index ) ? XString . EMPTYSTRING : ( XString ) s1 . substring ( index + s2 . length ( ) ) ; } } 	1
package org . apache . xalan . xsltc . dom ; public final class EmptyFilter implements Filter { public boolean test ( int node ) { return true ; } } 	0
package org . apache . xpath . res ; public class XPATHErrorResources_ja extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "current() " } , { ER_CURRENT_TAKES_NO_ARGS , "current() " } , { ER_DOCUMENT_REPLACED , "document()  org.apache.xalan.xslt.FuncDocument " } , { ER_CONTEXT_HAS_NO_OWNERDOC , "" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() " } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() " } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() " } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() " } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() " } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() " } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() " } , { ER_TRANSLATE_TAKES_3_ARGS , "translate()  3 " } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "unparsed-entity-uri  1 " } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "" } , { ER_UNKNOWN_AXIS , ": {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "" } , { ER_INCORRECT_ARG_LENGTH , "processing-instruction() " } , { ER_CANT_CONVERT_TO_NUMBER , "{0} " } , { ER_CANT_CONVERT_TO_NODELIST , "{0}  NodeList " } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0}  NodeSetDTM " } , { ER_CANT_CONVERT_TO_TYPE , "{0}  type//{1} " } , { ER_EXPECTED_MATCH_PATTERN , "getMatchScore " } , { ER_COULDNOT_GET_VAR_NAMED , "{0} " } , { ER_UNKNOWN_OPCODE , ": {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , ": {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "... " } , { ER_EXPECTED_SINGLE_QUOTE , "... " } , { ER_EMPTY_EXPRESSION , "" } , { ER_EXPECTED_BUT_FOUND , "{0} {1} " } , { ER_INCORRECT_PROGRAMMER_ASSERTION , " - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "19990709 XPath boolean(...) " } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "',' " } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "',' " } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]'  '.[predicate]'  'self::node()[predicate]' " } , { ER_ILLEGAL_AXIS_NAME , ": {0}" } , { ER_UNKNOWN_NODETYPE , ": {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , " ({0}) " } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} " } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "XML TransformerFactory Liaison : {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "xpath  (-select) " } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "OP_LOCATIONPATH  ENDOP " } , { ER_ERROR_OCCURED , "" } , { ER_ILLEGAL_VARIABLE_REFERENCE , " VariableReference Name = {0}" } , { ER_AXES_NOT_ALLOWED , "child::  attribute::  = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() " } , { ER_COUNT_TAKES_1_ARG , "count  1 " } , { ER_COULDNOT_FIND_FUNCTION , " {0} " } , { ER_UNSUPPORTED_ENCODING , ": {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "getNextSibling  DTM ... " } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , ": EmptyNodeList " } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory  XPathContext " } , { ER_PREFIX_MUST_RESOLVE , ": {0}" } , { ER_PARSE_NOT_SUPPORTED , " (InputSource )  XPathContext {0} " } , { ER_SAX_API_NOT_HANDLED , "SAX API characters(char ch[]...  DTM " } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]...  DTM " } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison  {0} " } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper  {0} " } , { ER_XERCES_PARSE_ERROR_DETAILS , "DOM2Helper.parse : SystemID - {0}  - {1}" } , { ER_XERCES_PARSE_ERROR , "DOM2Helper.parse " } , { ER_INVALID_UTF16_SURROGATE , " UTF-16 : {0} ?" } , { ER_OIERROR , "" } , { ER_CANNOT_CREATE_URL , "{0}  URL " } , { ER_XPATH_READOBJECT , "XPath.readObject : {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "" } , { ER_CANNOT_DEAL_XPATH_TYPE , "XPath  {0} " } , { ER_NODESET_NOT_MUTABLE , " NodeSet " } , { ER_NODESETDTM_NOT_MUTABLE , " NodeSetDTM " } , { ER_VAR_NOT_RESOLVABLE , ": {0}" } , { ER_NULL_ERROR_HANDLER , "null " } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , ": : {0}" } , { ER_ZERO_OR_ONE , "0  1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf()  XRTreeFragSelectWrapper " } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator()  XRTreeFragSelectWrapper " } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "XStringForChars  fsb() " } , { ER_COULD_NOT_FIND_VAR , "{0} " } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars " } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "FastStringBuffer  null " } , { ER_TWO_OR_THREE , "2  3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB !" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! ! walker  null !!!" } , { ER_NODESETDTM_CANNOT_ITERATE , " NodeSetDTM !" } , { ER_NODESET_CANNOT_ITERATE , " NodeSet !" } , { ER_NODESETDTM_CANNOT_INDEX , " NodeSetDTM !" } , { ER_NODESET_CANNOT_INDEX , " NodeSet !" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "nextNode  setShouldCacheNodes !" } , { ER_ONLY_ALLOWS , "{0}  {1} " } , { ER_UNKNOWN_STEP , "getNextStepPos :  stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , " '/'  '//' " } , { ER_EXPECTED_LOC_PATH , ":  {0}" } , { ER_EXPECTED_LOC_STEP , " '/'  '//' " } , { ER_EXPECTED_NODE_TEST , "NCName:*  QName " } , { ER_EXPECTED_STEP_PATTERN , " '/' " } , { ER_EXPECTED_REL_PATH_PATTERN , "" } , { ER_CANT_CONVERT_TO_BOOLEAN , "{0}  boolean " } , { ER_CANT_CONVERT_TO_SINGLENODE , "{0} ANY_UNORDERED_NODE_TYPE  FIRST_ORDERED_NODE_TYPE " } , { ER_CANT_GET_SNAPSHOT_LENGTH , " {0} UNORDERED_NODE_SNAPSHOT_TYPE  ORDERED_NODE_SNAPSHOT_TYPE " } , { ER_NON_ITERATOR_TYPE , " iterator  {0} " } , { ER_DOC_MUTATED , "" } , { ER_INVALID_XPATH_TYPE , " XPath : {0}" } , { ER_EMPTY_XPATH_RESULT , " XPath " } , { ER_INCOMPATIBLE_TYPES , " {0}  {1} " } , { ER_NULL_RESOLVER , " null " } , { ER_CANT_CONVERT_TO_STRING , "{0} " } , { ER_NON_SNAPSHOT_TYPE , " {0}  snapshotItem UNORDERED_NODE_SNAPSHOT_TYPE  ORDERED_NODE_SNAPSHOT_TYPE " } , { ER_WRONG_DOCUMENT , " XPathEvaluator " } , { ER_WRONG_NODETYPE , "" } , { ER_XPATH_ERROR , "XPath " } , { WG_LOCALE_NAME_NOT_HANDLED , "format-number " } , { WG_PROPERTY_NOT_SUPPORTED , "XSL : {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , " {0}  {1} " } , { WG_SECURITY_EXCEPTION , "XSL  SecurityException : {0}" } , { WG_QUO_NO_LONGER_DEFINED , ": quo(...)  XPath " } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath  nodeTest " } , { WG_FUNCTION_TOKEN_NOT_FOUND , "" } , { WG_COULDNOT_FIND_FUNCTION , " {0} " } , { WG_CANNOT_MAKE_URL_FROM , " URL : {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "DTM  -E " } , { WG_ILLEGAL_VARIABLE_REFERENCE , " VariableReference Name = {0}" } , { WG_UNSUPPORTED_ENCODING , ": {0}" } , { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "BAD_CODE" , "createMessage " } , { "FORMAT_FAILED" , "messageFormat " } , { "version" , ">>>>>>> Xalan  " } , { "version2" , "<<<<<<<" } , { "yes" , "" } , { "line" , " //" } , { "column" , " //" } , { "xsldone" , "XSLProcessor: " } , { "xpath_option" , "xpath : " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath ]" } , { "optionMatch" , "   [-match  ()]" } , { "optionAnyExpr" , " xpath " } , { "noParsermsg1" , "XSL " } , { "noParsermsg2" , "**  **" } , { "noParsermsg3" , "" } , { "noParsermsg4" , "Java  IBM  XML " } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Warning: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATTERN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1
package org . apache . xalan . xsltc . runtime ; import org . apache . xalan . xsltc . DOM ; import org . xml . sax . AttributeList ; public final class Attributes implements AttributeList { private int _element ; private DOM _document ; public Attributes ( DOM document , int element ) { _element = element ; _document = document ; } public int getLength ( ) { return 0 ; } public String getName ( int i ) { return null ; } public String getType ( int i ) { return null ; } public String getType ( String name ) { return null ; } public String getValue ( int i ) { return null ; } public String getValue ( String name ) { return null ; } } 	0
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncCeiling extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( Math . ceil ( m_arg0 . execute ( xctxt ) . num ( ) ) ) ; } } 	1
package org . apache . xalan . templates ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class XUnresolvedVariableSimple extends XObject { public XUnresolvedVariableSimple ( ElemVariable obj ) { super ( obj ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { Expression expr = ( ( ElemVariable ) m_obj ) . getSelect ( ) . getExpression ( ) ; XObject xobj = expr . execute ( xctxt ) ; xobj . allowDetachToRelease ( false ) ; return xobj ; } public int getType ( ) { return CLASS_UNRESOLVEDVARIABLE ; } public String getTypeString ( ) { return "XUnresolvedVariableSimple (" + object ( ) . getClass ( ) . getName ( ) + ")" ; } } 	0
package org . apache . xalan . templates ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . XPathContext ; public abstract class AVTPart implements java . io . Serializable , XSLTVisitable { public AVTPart ( ) { } public abstract String getSimpleString ( ) ; public abstract void evaluate ( XPathContext xctxt , FastStringBuffer buf , int context , org . apache . xml . utils . PrefixResolver nsNode ) throws javax . xml . transform . TransformerException ; public void setXPathSupport ( XPathContext support ) { } public boolean canTraverseOutsideSubtree ( ) { return false ; } public abstract void fixupVariables ( java . util . Vector vars , int globalsSize ) ; } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class BooleanExpr extends Expression { private boolean _value ; public BooleanExpr ( boolean value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _type = Type . Boolean ; return _type ; } public String toString ( ) { return _value ? "true()" : "false()" ; } public boolean getValue ( ) { return _value ; } public boolean contextDependent ( ) { return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( _value ) { il . append ( NOP ) ; } else { _falseList . add ( il . append ( new GOTO ( null ) ) ) ; } } } 	0
package org . apache . xalan . transformer ; import java . text . CollationKey ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class NodeSorter { XPathContext m_execContext ; Vector m_keys ; public NodeSorter ( XPathContext p ) { m_execContext = p ; } public void sort ( DTMIterator v , Vector keys , XPathContext support ) throws javax . xml . transform . TransformerException { m_keys = keys ; int n = v . getLength ( ) ; Vector nodes = new Vector ( ) ; for ( int i = 0 ; i < n ; i ++ ) { NodeCompareElem elem = new NodeCompareElem ( v . item ( i ) ) ; nodes . addElement ( elem ) ; } Vector scratchVector = new Vector ( ) ; mergesort ( nodes , scratchVector , 0 , n - 1 , support ) ; for ( int i = 0 ; i < n ; i ++ ) { v . setItem ( ( ( NodeCompareElem ) nodes . elementAt ( i ) ) . m_node , i ) ; } v . setCurrentPos ( 0 ) ; } int compare ( NodeCompareElem n1 , NodeCompareElem n2 , int kIndex , XPathContext support ) throws TransformerException { int result = 0 ; NodeSortKey k = ( NodeSortKey ) m_keys . elementAt ( kIndex ) ; if ( k . m_treatAsNumbers ) { double n1Num , n2Num ; if ( kIndex == 0 ) { n1Num = ( ( Double ) n1 . m_key1Value ) . doubleValue ( ) ; n2Num = ( ( Double ) n2 . m_key1Value ) . doubleValue ( ) ; } else if ( kIndex == 1 ) { n1Num = ( ( Double ) n1 . m_key2Value ) . doubleValue ( ) ; n2Num = ( ( Double ) n2 . m_key2Value ) . doubleValue ( ) ; } else { XObject r1 = k . m_selectPat . execute ( m_execContext , n1 . m_node , k . m_namespaceContext ) ; XObject r2 = k . m_selectPat . execute ( m_execContext , n2 . m_node , k . m_namespaceContext ) ; n1Num = r1 . num ( ) ; n2Num = r2 . num ( ) ; } if ( ( n1Num == n2Num ) && ( ( kIndex + 1 ) < m_keys . size ( ) ) ) { result = compare ( n1 , n2 , kIndex + 1 , support ) ; } else { double diff ; if ( Double . isNaN ( n1Num ) ) { if ( Double . isNaN ( n2Num ) ) diff = 0.0 ; else diff = - 1 ; } else if ( Double . isNaN ( n2Num ) ) diff = 1 ; else diff = n1Num - n2Num ; result = ( int ) ( ( diff < 0.0 ) ? ( k . m_descending ? 1 : - 1 ) : ( diff > 0.0 ) ? ( k . m_descending ? - 1 : 1 ) : 0 ) ; } } else { CollationKey n1String , n2String ; if ( kIndex == 0 ) { n1String = ( CollationKey ) n1 . m_key1Value ; n2String = ( CollationKey ) n2 . m_key1Value ; } else if ( kIndex == 1 ) { n1String = ( CollationKey ) n1 . m_key2Value ; n2String = ( CollationKey ) n2 . m_key2Value ; } else { XObject r1 = k . m_selectPat . execute ( m_execContext , n1 . m_node , k . m_namespaceContext ) ; XObject r2 = k . m_selectPat . execute ( m_execContext , n2 . m_node , k . m_namespaceContext ) ; n1String = k . m_col . getCollationKey ( r1 . str ( ) ) ; n2String = k . m_col . getCollationKey ( r2 . str ( ) ) ; } result = n1String . compareTo ( n2String ) ; if ( k . m_caseOrderUpper ) { String tempN1 = n1String . getSourceString ( ) . toLowerCase ( ) ; String tempN2 = n2String . getSourceString ( ) . toLowerCase ( ) ; if ( tempN1 . equals ( tempN2 ) ) { result = result == 0 ? 0 : - result ; } } if ( k . m_descending ) { result = - result ; } } if ( 0 == result ) { if ( ( kIndex + 1 ) < m_keys . size ( ) ) { result = compare ( n1 , n2 , kIndex + 1 , support ) ; } } if ( 0 == result ) { DTM dtm = support . getDTM ( n1 . m_node ) ; result = dtm . isNodeAfter ( n1 . m_node , n2 . m_node ) ? - 1 : 1 ; } return result ; } void mergesort ( Vector a , Vector b , int l , int r , XPathContext support ) throws TransformerException { if ( ( r - l ) > 0 ) { int m = ( r + l ) / 2 ; mergesort ( a , b , l , m , support ) ; mergesort ( a , b , m + 1 , r , support ) ; int i , j , k ; for ( i = m ; i >= l ; i -- ) { if ( i >= b . size ( ) ) b . insertElementAt ( a . elementAt ( i ) , i ) ; else b . setElementAt ( a . elementAt ( i ) , i ) ; } i = l ; for ( j = ( m + 1 ) ; j <= r ; j ++ ) { if ( r + m + 1 - j >= b . size ( ) ) b . insertElementAt ( a . elementAt ( j ) , r + m + 1 - j ) ; else b . setElementAt ( a . elementAt ( j ) , r + m + 1 - j ) ; } j = r ; int compVal ; for ( k = l ; k <= r ; k ++ ) { if ( i == j ) compVal = - 1 ; else compVal = compare ( ( NodeCompareElem ) b . elementAt ( i ) , ( NodeCompareElem ) b . elementAt ( j ) , 0 , support ) ; if ( compVal < 0 ) { a . setElementAt ( b . elementAt ( i ) , k ) ; i ++ ; } else if ( compVal > 0 ) { a . setElementAt ( b . elementAt ( j ) , k ) ; j -- ; } } } } class NodeCompareElem { int m_node ; int maxkey = 2 ; Object m_key1Value ; Object m_key2Value ; NodeCompareElem ( int node ) throws javax . xml . transform . TransformerException { boolean tryNextKey = true ; m_node = node ; if ( ! m_keys . isEmpty ( ) ) { NodeSortKey k1 = ( NodeSortKey ) m_keys . elementAt ( 0 ) ; XObject r = k1 . m_selectPat . execute ( m_execContext , node , k1 . m_namespaceContext ) ; if ( r == null ) tryNextKey = false ; double d ; if ( k1 . m_treatAsNumbers ) { d = r . num ( ) ; m_key1Value = new Double ( d ) ; } else { m_key1Value = k1 . m_col . getCollationKey ( r . str ( ) ) ; } if ( r . getType ( ) == XObject . CLASS_NODESET ) { DTMIterator ni = ( ( XNodeSet ) r ) . iterRaw ( ) ; int current = ni . getCurrentNode ( ) ; if ( DTM . NULL == current ) current = ni . nextNode ( ) ; tryNextKey = ( DTM . NULL != current ) ; } if ( m_keys . size ( ) > 1 ) { NodeSortKey k2 = ( NodeSortKey ) m_keys . elementAt ( 1 ) ; if ( ! tryNextKey ) { if ( k2 . m_treatAsNumbers ) m_key2Value = new Double ( 0.0 ) ; else m_key2Value = k2 . m_col . getCollationKey ( "" ) ; } else { XObject r2 = k2 . m_selectPat . execute ( m_execContext , node , k2 . m_namespaceContext ) ; if ( k2 . m_treatAsNumbers ) { d = r2 . num ( ) ; m_key2Value = new Double ( d ) ; } else m_key2Value = k2 . m_col . getCollationKey ( r2 . str ( ) ) ; } } } } } } 	1
package org . apache . xalan . templates ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . functions . FuncCurrent ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . functions . Function ; import org . apache . xpath . operations . Variable ; public class AbsPathChecker extends XPathVisitor { private boolean m_isAbs = true ; public boolean checkAbsolute ( LocPathIterator path ) { m_isAbs = true ; path . callVisitors ( null , this ) ; return m_isAbs ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { if ( ( func instanceof FuncCurrent ) || ( func instanceof FuncExtFunction ) ) m_isAbs = false ; return true ; } public boolean visitVariableRef ( ExpressionOwner owner , Variable var ) { m_isAbs = false ; return true ; } } 	0
package org . apache . xpath . domapi ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . events . Event ; import org . w3c . dom . events . EventListener ; import org . w3c . dom . events . EventTarget ; import org . w3c . dom . traversal . NodeIterator ; import org . w3c . dom . xpath . XPathException ; import org . w3c . dom . xpath . XPathResult ; public class XPathResultImpl implements XPathResult , EventListener { private XObject m_resultObj ; private short m_resultType = ANY_TYPE ; private boolean m_isInvalidIteratorState = false ; private Node m_contextNode ; private NodeIterator m_iterator = null ; private NodeList m_list = null ; XPathResultImpl ( short type , XObject result , Node contextNode ) { if ( ! isValidType ( type ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INVALID_XPATH_TYPE , new Object [ ] { new Integer ( type ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } if ( null == result ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_EMPTY_XPATH_RESULT , null ) ; throw new XPathException ( XPathException . INVALID_EXPRESSION_ERR , fmsg ) ; } this . m_resultObj = result ; this . m_contextNode = contextNode ; if ( type == ANY_TYPE ) { this . m_resultType = getTypeFromXObject ( result ) ; } else { this . m_resultType = type ; } if ( ( ( m_resultType == XPathResult . ORDERED_NODE_ITERATOR_TYPE ) || ( m_resultType == XPathResult . UNORDERED_NODE_ITERATOR_TYPE ) ) && ( contextNode instanceof EventTarget ) ) { ( ( EventTarget ) contextNode ) . addEventListener ( "MutationEvents" , this , true ) ; } if ( ( m_resultType == ORDERED_NODE_ITERATOR_TYPE ) || ( m_resultType == UNORDERED_NODE_ITERATOR_TYPE ) || ( m_resultType == ANY_UNORDERED_NODE_TYPE ) || ( m_resultType == FIRST_ORDERED_NODE_TYPE ) ) { try { m_iterator = m_resultObj . nodeset ( ) ; } catch ( TransformerException te ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCOMPATIBLE_TYPES , new Object [ ] { getTypeString ( getTypeFromXObject ( m_resultObj ) ) , getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } } else if ( ( m_resultType == UNORDERED_NODE_SNAPSHOT_TYPE ) || ( m_resultType == ORDERED_NODE_SNAPSHOT_TYPE ) ) { try { m_list = m_resultObj . nodelist ( ) ; } catch ( TransformerException te ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCOMPATIBLE_TYPES , new Object [ ] { getTypeString ( getTypeFromXObject ( m_resultObj ) ) , getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } } } public short getResultType ( ) { return m_resultType ; } public double getNumberValue ( ) throws XPathException { if ( getResultType ( ) != NUMBER_TYPE ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_NUMBER , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } else { try { return m_resultObj . num ( ) ; } catch ( Exception e ) { throw new XPathException ( XPathException . TYPE_ERR , e . getMessage ( ) ) ; } } } public String getStringValue ( ) throws XPathException { if ( getResultType ( ) != STRING_TYPE ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_STRING , new Object [ ] { m_resultObj . getTypeString ( ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } else { try { return m_resultObj . str ( ) ; } catch ( Exception e ) { throw new XPathException ( XPathException . TYPE_ERR , e . getMessage ( ) ) ; } } } public boolean getBooleanValue ( ) throws XPathException { if ( getResultType ( ) != BOOLEAN_TYPE ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_BOOLEAN , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } else { try { return m_resultObj . bool ( ) ; } catch ( TransformerException e ) { throw new XPathException ( XPathException . TYPE_ERR , e . getMessage ( ) ) ; } } } public Node getSingleNodeValue ( ) throws XPathException { if ( ( m_resultType != ANY_UNORDERED_NODE_TYPE ) && ( m_resultType != FIRST_ORDERED_NODE_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_CONVERT_TO_SINGLENODE , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } NodeIterator result = null ; try { result = m_resultObj . nodeset ( ) ; } catch ( TransformerException te ) { throw new XPathException ( XPathException . TYPE_ERR , te . getMessage ( ) ) ; } if ( null == result ) return null ; Node node = result . nextNode ( ) ; if ( isNamespaceNode ( node ) ) { return new XPathNamespaceImpl ( node ) ; } else { return node ; } } public boolean getInvalidIteratorState ( ) { return m_isInvalidIteratorState ; } public int getSnapshotLength ( ) throws XPathException { if ( ( m_resultType != UNORDERED_NODE_SNAPSHOT_TYPE ) && ( m_resultType != ORDERED_NODE_SNAPSHOT_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANT_GET_SNAPSHOT_LENGTH , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } return m_list . getLength ( ) ; } public Node iterateNext ( ) throws XPathException , DOMException { if ( ( m_resultType != UNORDERED_NODE_ITERATOR_TYPE ) && ( m_resultType != ORDERED_NODE_ITERATOR_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NON_ITERATOR_TYPE , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } if ( getInvalidIteratorState ( ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_DOC_MUTATED , null ) ; throw new DOMException ( DOMException . INVALID_STATE_ERR , fmsg ) ; } Node node = m_iterator . nextNode ( ) ; if ( isNamespaceNode ( node ) ) { return new XPathNamespaceImpl ( node ) ; } else { return node ; } } public Node snapshotItem ( int index ) throws XPathException { if ( ( m_resultType != UNORDERED_NODE_SNAPSHOT_TYPE ) && ( m_resultType != ORDERED_NODE_SNAPSHOT_TYPE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NON_SNAPSHOT_TYPE , new Object [ ] { getTypeString ( m_resultType ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } Node node = m_list . item ( index ) ; if ( isNamespaceNode ( node ) ) { return new XPathNamespaceImpl ( node ) ; } else { return node ; } } public static boolean isValidType ( short type ) { switch ( type ) { case ANY_TYPE : case NUMBER_TYPE : case STRING_TYPE : case BOOLEAN_TYPE : case UNORDERED_NODE_ITERATOR_TYPE : case ORDERED_NODE_ITERATOR_TYPE : case UNORDERED_NODE_SNAPSHOT_TYPE : case ORDERED_NODE_SNAPSHOT_TYPE : case ANY_UNORDERED_NODE_TYPE : case FIRST_ORDERED_NODE_TYPE : return true ; default : return false ; } } public void handleEvent ( Event event ) { if ( event . getType ( ) . equals ( "MutationEvents" ) ) { m_isInvalidIteratorState = true ; ( ( EventTarget ) m_contextNode ) . removeEventListener ( "MutationEvents" , this , true ) ; } } public String getTypeString ( int type ) { switch ( type ) { case ANY_TYPE : return "ANY_TYPE" ; case ANY_UNORDERED_NODE_TYPE : return "ANY_UNORDERED_NODE_TYPE" ; case BOOLEAN_TYPE : return "BOOLEAN" ; case FIRST_ORDERED_NODE_TYPE : return "FIRST_ORDERED_NODE_TYPE" ; case NUMBER_TYPE : return "NUMBER_TYPE" ; case ORDERED_NODE_ITERATOR_TYPE : return "ORDERED_NODE_ITERATOR_TYPE" ; case ORDERED_NODE_SNAPSHOT_TYPE : return "ORDERED_NODE_SNAPSHOT_TYPE" ; case STRING_TYPE : return "STRING_TYPE" ; case UNORDERED_NODE_ITERATOR_TYPE : return "UNORDERED_NODE_ITERATOR_TYPE" ; case UNORDERED_NODE_SNAPSHOT_TYPE : return "UNORDERED_NODE_SNAPSHOT_TYPE" ; default : return "#UNKNOWN" ; } } private short getTypeFromXObject ( XObject object ) { switch ( object . getType ( ) ) { case XObject . CLASS_BOOLEAN : return BOOLEAN_TYPE ; case XObject . CLASS_NODESET : return UNORDERED_NODE_ITERATOR_TYPE ; case XObject . CLASS_NUMBER : return NUMBER_TYPE ; case XObject . CLASS_STRING : return STRING_TYPE ; case XObject . CLASS_RTREEFRAG : return UNORDERED_NODE_ITERATOR_TYPE ; case XObject . CLASS_NULL : return ANY_TYPE ; default : return ANY_TYPE ; } } private boolean isNamespaceNode ( Node node ) { if ( ( null != node ) && ( node . getNodeType ( ) == Node . ATTRIBUTE_NODE ) && ( node . getNodeName ( ) . startsWith ( "xmlns:" ) || node . getNodeName ( ) . equals ( "xmlns" ) ) ) { return true ; } else { return false ; } } } 	1
package org . apache . xalan . xsltc . runtime . output ; interface OutputBuffer { public String close ( ) ; public OutputBuffer append ( char ch ) ; public OutputBuffer append ( String s ) ; public OutputBuffer append ( char [ ] s , int from , int to ) ; } 	0
package org . apache . xpath . res ; public class XPATHErrorResources_de extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Funktion current() in einem Muster nicht zulssig!" } , { ER_CURRENT_TAKES_NO_ARGS , "Funktion current() hat keine Argumente!" } , { ER_DOCUMENT_REPLACED , "Die Implementierung der Funktion document() wurde durch org.apache.xalan.xslt.FuncDocument ersetzt!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "Kontext hat kein Eigentmer-Dokument!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() hat zu viele Argumente." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() hat zu viele Argumente." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() hat zu viele Argumente." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() hat zu viele Argumente." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() hat zu viele Argumente." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() hat zu viele Argumente." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() hat zu viele Argumente." } , { ER_TRANSLATE_TAKES_3_ARGS , "Funktion translate() hat drei Argumente!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "Funktion unparsed-entity-uri hat ein Argument!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "Namensraum-Achse noch nicht implementiert!" } , { ER_UNKNOWN_AXIS , "Unbekannte Achse: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "Unbekannte Match-Operation!" } , { ER_INCORRECT_ARG_LENGTH , "Argumentlnge beim Test des Knotens processing-instruction() ist nicht korrekt!" } , { ER_CANT_CONVERT_TO_NUMBER , "{0} kann nicht in Zahl konvertiert werden" } , { ER_CANT_CONVERT_TO_NODELIST , "{0} kann nicht in NodeList konvertiert werden!" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "{0} kann nicht in NodeSetDTM konvertiert werden!" } , { ER_CANT_CONVERT_TO_TYPE , "{0} kann nicht in type//{1} konvertiert werden" } , { ER_EXPECTED_MATCH_PATTERN , "Muster in getMatchScore erwartet!" } , { ER_COULDNOT_GET_VAR_NAMED , "Variable mit Namen {0} konnte nicht abgerufen werden" } , { ER_UNKNOWN_OPCODE , "FEHLER! Unbekannter Opcode: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Zustzliche unzulssige Token: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "Literalwert mit falschen Anfhrungszeichen... doppelte Anfhrungszeichen erwartet!" } , { ER_EXPECTED_SINGLE_QUOTE , "Literalwert mit falschen Anfhrungszeichen... einfache Anfhrungszeichen erwartet!" } , { ER_EMPTY_EXPRESSION , "Leerer Ausdruck!" } , { ER_EXPECTED_BUT_FOUND , "{0} erwartet, gefunden: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Programmierannahme ist falsch! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "Boolesches Argument (...) ist bei Xpath-Draft 19990709 nicht mehr optional." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "',' gefunden, aber davor kein Argument!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "',' gefunden, aber danach kein Argument!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "Syntax '..[predicate]' oder '.[predicate]' nicht zulssig. Verwenden Sie statt dessen 'self::node()[Prdikat]'." } , { ER_ILLEGAL_AXIS_NAME , "Unzulssiger Achsenname: {0}" } , { ER_UNKNOWN_NODETYPE , "Unbekannter nodetype: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Musterliteralwert ({0}) muss in Anfhrungszeichen eingeschlossen werden!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} konnte nicht als Zahl formatiert werden!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "XML TransformerFactory Liaison konnte nicht erstellt werden: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Fehler! 'select'-Ausdruck bei xpath nicht gefunden (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "FEHLER! ENDOP nach OP_LOCATIONPATH nicht gefunden" } , { ER_ERROR_OCCURED , "Fehler!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "VariableReference fr eine Variable auerhalb des Kontexts oder ohne Definition angegeben!  Name = {0}" } , { ER_AXES_NOT_ALLOWED , "Nur die Achsen child:: und attribute:: sind in Mustern zulssig! Regel verletzende Achse = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() mit falscher Anzahl von Argumenten." } , { ER_COUNT_TAKES_1_ARG , "Funktion count hat ein Argument!" } , { ER_COULDNOT_FIND_FUNCTION , "Funktion nicht gefunden: {0}" } , { ER_UNSUPPORTED_ENCODING , "Codierung nicht untersttzt: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Problem bei DTM in getNextSibling... Wiederherstellung wird versucht" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Programmierfehler: In EmptyNodeList kann nicht geschrieben werden." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory wird von XpathContext nicht untersttzt!" } , { ER_PREFIX_MUST_RESOLVE , "Prfix muss sich in Namensraum auflsen lassen: {0}" } , { ER_PARSE_NOT_SUPPORTED , "Parsen von (InputSource Quelle) in XpathContext nicht untersttzt! {0} kann nicht geffnet werden" } , { ER_SAX_API_NOT_HANDLED , "SAX API-Zeichen (char ch[]... werden vom DTM nicht bearbeitet!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... wird vom DTM nicht bearbeitet!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison kann Knoten vom Typ {0} nicht bearbeiten" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper kann Knoten vom Typ {0} nicht bearbeiten" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Fehler bei DOM2Helper.parse: SystemID - {0} Zeile - {1}" } , { ER_XERCES_PARSE_ERROR , "Fehler bei DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Ungltiges UTF-16-Surrogat erkannt: {0} ?" } , { ER_OIERROR , "IO-Fehler" } , { ER_CANNOT_CREATE_URL , "URL kann nicht erstellt werden fr: {0}" } , { ER_XPATH_READOBJECT , "In XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "Funktions-Token nicht gefunden." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Bearbeitung nicht mglich von XPath vom Typ: {0}" } , { ER_NODESET_NOT_MUTABLE , "Dieses NodeSet ist nicht mutierbar" } , { ER_NODESETDTM_NOT_MUTABLE , "Dieses NodeSetDTM ist nicht mutierbar" } , { ER_VAR_NOT_RESOLVABLE , "Variable nicht auflsbar: {0}" } , { ER_NULL_ERROR_HANDLER , "Ungltiger Error-Handler" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Programmierannahme: Unbekannter Opcode: {0}" } , { ER_ZERO_OR_ONE , "0 oder 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() nicht untersttzt von XRTreeFragSelectWrapper" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() nicht untersttzt von XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() nicht untersttzt von XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Variable mit Namen {0} kann nicht gefunden werden" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars kann keine Zeichenkette als Argument haben" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "Das FastStringBuffer-Argument darf nicht Null sein" } , { ER_TWO_OR_THREE , "2 oder 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Zugriff auf Variable vor deren Bindung!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB darf keine Zeichenkette als Argument bergeben werden!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Fehler! Ausgangspunkt fr Walker wird auf Null gesetzt!!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Dieses NodeSetDTM-Element kann nicht zu einem vorausgegangenen Knoten iterieren!" } , { ER_NODESET_CANNOT_ITERATE , "Dieses NodeSet-Element kann nicht zu einem vorausgegangenen Knoten iterieren!" } , { ER_NODESETDTM_CANNOT_INDEX , "Dieses NodeSetDTM-Element kann keine Indizierung oder Zhlung durchfhren!" } , { ER_NODESET_CANNOT_INDEX , "Dieses NodeSet-Element kann keine Indizierung oder Zhlung durchfhren!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "setShouldCacheNodes kann nicht nach dem Aufruf von nextNode aufgerufen werden!" } , { ER_ONLY_ALLOWS , "Fr {0} sind nur {1} Argumente zulssig." } , { ER_UNKNOWN_STEP , "Programmierannahme in getNextStepPos: unbekannter stepType: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Nach dem Token '/' bzw. '//' wurde ein relativer Pfad zum Speicherort erwartet." } , { ER_EXPECTED_LOC_PATH , "Es wurde ein Pfad zum Speicherort erwartet. Vorgefunden wurde jedoch der folgende Token:  {0}" } , { ER_EXPECTED_LOC_STEP , "Nach dem Token '/' bzw. '//' wurde ein Schritt zum Speicherort erwartet." } , { ER_EXPECTED_NODE_TEST , "Es wurde ein Knotentest erwartet, der entweder NCName:* oder QName entspricht." } , { ER_EXPECTED_STEP_PATTERN , "Es wurde ein Schrittmuster erwartet. Vorgefunden wurde jedoch das Zeichen '/'." } , { ER_EXPECTED_REL_PATH_PATTERN , "Es wurde ein relatives Pfadmuster erwartet." } , { ER_CANT_CONVERT_TO_BOOLEAN , "{0} kann nicht in Datentyp ''boolean'' konvertiert werden." } , { ER_CANT_CONVERT_TO_SINGLENODE , "{0} kann nicht in einen einzelnen Knoten konvertiert werden. Diese Abruffunktion ist fr die Typen ANY_UNORDERED_NODE_TYPE und FIRST_ORDERED_NODE_TYPE bestimmt." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Die Snapshot-Lnge fr diesen Typ kann nicht ermittelt werden: {0}. Diese Abruffunktion ist fr die Typen UNORDERED_NODE_SNAPSHOT_TYPE und ORDERED_NODE_SNAPSHOT_TYPE bestimmt." } , { ER_NON_ITERATOR_TYPE , "Es kann keine Iteration ber einen nicht-iterativen Typ durchgefhrt werden: {0}" } , { ER_DOC_MUTATED , "Das Dokument wurde gendert, nachdem das Ergebnis zurckgegeben wurde. Der Iterator ist ungltig." } , { ER_INVALID_XPATH_TYPE , "Ungltiges XPath-Typargument: {0}" } , { ER_EMPTY_XPATH_RESULT , "Leeres XPath-Ergebnisobjekt" } , { ER_INCOMPATIBLE_TYPES , "Der zurckgegebene Typ {0} kann nicht in den angegebenen Typ umgewandelt werden: {1}" } , { ER_NULL_RESOLVER , "Prfix kann nicht aufgelst werden, wenn Prfix-Resolver Null ist." } , { ER_CANT_CONVERT_TO_STRING , "{0} kann nicht in eine Zeichenkette konvertiert werden." } , { ER_NON_SNAPSHOT_TYPE , "snapshotItem kann nicht fr diesen Typ aufgerufen werden: {0}. Diese Methode ist fr die Typen UNORDERED_NODE_SNAPSHOT_TYPE und ORDERED_NODE_SNAPSHOT_TYPE bestimmt." } , { ER_WRONG_DOCUMENT , "Der Kontextknoten gehrt nicht zu dem Dokument, das an dieses XPathEvaluator-Element gebunden ist." } , { ER_WRONG_NODETYPE , "Der Kontextknotentyp wird nicht untersttzt." } , { ER_XPATH_ERROR , "Unbekannter Fehler in XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "Name von locale in der Funktion format-number noch nicht bearbeitet!" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL Property nicht untersttzt: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Zurzeit nichts tun mit Namensraum {0} in Eigenschaft: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException beim Versuch des Zugriffs auf XSL-Systemeigenschaft: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Alte Syntax: quo(...) ist in XPath nicht mehr definiert." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath bentigt ein abgeleitetes Objekt zum Implementieren von nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "Funktions-Token nicht gefunden." } , { WG_COULDNOT_FIND_FUNCTION , "Funktion nicht gefunden: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "URL kann nicht erstellt werden aus: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Option -E fr DTM-Parser nicht untersttzt" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference fr Variable auerhalb des Kontexts oder ohne Definition angegeben!  Name = {0}" } , { WG_UNSUPPORTED_ENCODING , "Nicht untersttzte Codierung: {0}" } , { "ui_language" , "de" } , { "help_language" , "de" } , { "language" , "de" } , { "BAD_CODE" , "Parameter fr createMessage auerhalb der Grenzwerte" } , { "FORMAT_FAILED" , "Ausnahme bei Aufruf von messageFormat" } , { "version" , ">>>>>>> Xalan Version " } , { "version2" , "<<<<<<<" } , { "yes" , "ja" } , { "line" , "Zeile //" } , { "column" , "Spalte //" } , { "xsldone" , "XSLProcessor: fertig" } , { "xpath_option" , "xpath-Optionen: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [-select xpath-Ausdruck]" } , { "optionMatch" , "   [-match Muster (fr Trefferdiagnose)]" } , { "optionAnyExpr" , "Oder irgendein xpath-Ausdruck fhrt einen Diagnose-Dump aus" } , { "noParsermsg1" , "XSL Process fehlgeschlagen." } , { "noParsermsg2" , "** Parser nicht gefunden**" } , { "noParsermsg3" , "Prfen Sie Ihren classpath." } , { "noParsermsg4" , "Wenn Sie IBMs XML Parser for Java nicht haben, knnen Sie ihn von folgender Adresse herunterladen" } , { "noParsermsg5" , "IBMs AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//Fehler" ; public static final String ERROR_HEADER = "Fehler: " ; public static final String WARNING_HEADER = "Warnung: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "MUSTER " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1
package org . apache . xml . dtm . ref ; import javax . xml . transform . SourceLocator ; public class NodeLocator implements SourceLocator { protected String m_publicId ; protected String m_systemId ; protected int m_lineNumber ; protected int m_columnNumber ; public NodeLocator ( String publicId , String systemId , int lineNumber , int columnNumber ) { this . m_publicId = publicId ; this . m_systemId = systemId ; this . m_lineNumber = lineNumber ; this . m_columnNumber = columnNumber ; } public String getPublicId ( ) { return m_publicId ; } public String getSystemId ( ) { return m_systemId ; } public int getLineNumber ( ) { return m_lineNumber ; } public int getColumnNumber ( ) { return m_columnNumber ; } public String toString ( ) { return "file '" + m_systemId + "', line #" + m_lineNumber + ", column #" + m_columnNumber ; } } 	0
package org . apache . xalan . extensions ; import java . util . Hashtable ; public abstract class ExtensionHandlerJava extends ExtensionHandler { protected String m_className = "" ; private Hashtable m_cachedMethods = new Hashtable ( ) ; protected ExtensionHandlerJava ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang ) ; m_className = className ; } public Object getFromCache ( Object methodKey , Object objType , Object [ ] methodArgs ) { return m_cachedMethods . get ( methodKey ) ; } public Object putToCache ( Object methodKey , Object objType , Object [ ] methodArgs , Object methodObj ) { return m_cachedMethods . put ( methodKey , methodObj ) ; } } 	1
package org . apache . xml . dtm ; public interface DTMFilter { public static final int SHOW_ALL = 0xFFFFFFFF ; public static final int SHOW_ELEMENT = 0x00000001 ; public static final int SHOW_ATTRIBUTE = 0x00000002 ; public static final int SHOW_TEXT = 0x00000004 ; public static final int SHOW_CDATA_SECTION = 0x00000008 ; public static final int SHOW_ENTITY_REFERENCE = 0x00000010 ; public static final int SHOW_ENTITY = 0x00000020 ; public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040 ; public static final int SHOW_COMMENT = 0x00000080 ; public static final int SHOW_DOCUMENT = 0x00000100 ; public static final int SHOW_DOCUMENT_TYPE = 0x00000200 ; public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400 ; public static final int SHOW_NOTATION = 0x00000800 ; public static final int SHOW_NAMESPACE = 0x00001000 ; public static final int SHOW_BYFUNCTION = 0x00010000 ; public short acceptNode ( int nodeHandle , int whatToShow ) ; public short acceptNode ( int nodeHandle , int whatToShow , int expandedName ) ; } 	0
package org . apache . xalan . xsltc . trax ; import java . io . InputStream ; import java . io . Reader ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . xsltc . compiler . XSLTC ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . w3c . dom . Document ; import org . xml . sax . InputSource ; public final class Util { public static String baseName ( String name ) { return org . apache . xalan . xsltc . compiler . util . Util . baseName ( name ) ; } public static String noExtName ( String name ) { return org . apache . xalan . xsltc . compiler . util . Util . noExtName ( name ) ; } public static String toJavaName ( String name ) { return org . apache . xalan . xsltc . compiler . util . Util . toJavaName ( name ) ; } public static InputSource getInputSource ( XSLTC xsltc , Source source ) throws TransformerConfigurationException { InputSource input = null ; String systemId = source . getSystemId ( ) ; if ( systemId == null ) { systemId = "" ; } try { if ( source instanceof SAXSource ) { final SAXSource sax = ( SAXSource ) source ; input = sax . getInputSource ( ) ; xsltc . setXMLReader ( sax . getXMLReader ( ) ) ; } else if ( source instanceof DOMSource ) { final DOMSource domsrc = ( DOMSource ) source ; final Document dom = ( Document ) domsrc . getNode ( ) ; final DOM2SAX dom2sax = new DOM2SAX ( dom ) ; xsltc . setXMLReader ( dom2sax ) ; input = SAXSource . sourceToInputSource ( source ) ; if ( input == null ) { input = new InputSource ( domsrc . getSystemId ( ) ) ; } } else if ( source instanceof StreamSource ) { final StreamSource stream = ( StreamSource ) source ; final InputStream istream = stream . getInputStream ( ) ; final Reader reader = stream . getReader ( ) ; if ( istream != null ) { input = new InputSource ( istream ) ; } else if ( reader != null ) { input = new InputSource ( reader ) ; } else { input = new InputSource ( systemId ) ; } } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_SOURCE_ERR ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } input . setSystemId ( systemId ) ; } catch ( NullPointerException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_NO_SOURCE_ERR , "TransformerFactory.newTemplates()" ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } catch ( SecurityException e ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . FILE_ACCESS_ERR , systemId ) ; throw new TransformerConfigurationException ( err . toString ( ) ) ; } finally { return input ; } } } 	1
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class NumberCall extends FunctionCall { public NumberCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argumentCount ( ) > 0 ) { argument ( ) . typeCheck ( stable ) ; } return _type = Type . Real ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; Type targ ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; targ = Type . Node ; } else { final Expression arg = argument ( ) ; arg . translate ( classGen , methodGen ) ; arg . startResetIterator ( classGen , methodGen ) ; targ = arg . getType ( ) ; } if ( ! targ . identicalTo ( Type . Real ) ) { targ . translateTo ( classGen , methodGen , Type . Real ) ; } } } 	0
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xpath . Expression ; import org . apache . xpath . compiler . Compiler ; public class OneStepIteratorForward extends ChildTestIterator { protected int m_axis = - 1 ; OneStepIteratorForward ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_axis = WalkerFactory . getAxisFromStep ( compiler , firstStepPos ) ; } public OneStepIteratorForward ( int axis ) { super ( null ) ; m_axis = axis ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_traverser = m_cdtm . getAxisTraverser ( m_axis ) ; } protected int getNextNode ( ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_traverser . first ( m_context ) : m_traverser . next ( m_context , m_lastFetched ) ; return m_lastFetched ; } public int getAxis ( ) { return m_axis ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( OneStepIteratorForward ) expr ) . m_axis ) return false ; return true ; } } 	1
package org . apache . xalan . processor ; import org . apache . xalan . templates . NamespaceAlias ; import org . xml . sax . Attributes ; class ProcessorNamespaceAlias extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { NamespaceAlias na = new NamespaceAlias ( handler . nextUid ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , na ) ; String prefix = na . getStylesheetPrefix ( ) ; if ( prefix . equals ( "#default" ) ) { prefix = "" ; na . setStylesheetPrefix ( prefix ) ; } String stylesheetNS = handler . getNamespaceForPrefix ( prefix ) ; na . setStylesheetNamespace ( stylesheetNS ) ; prefix = na . getResultPrefix ( ) ; if ( prefix . equals ( "#default" ) ) { prefix = "" ; na . setResultPrefix ( prefix ) ; } String resultNS = handler . getNamespaceForPrefix ( prefix ) ; na . setResultNamespace ( resultNS ) ; handler . getStylesheet ( ) . setNamespaceAlias ( na ) ; handler . getStylesheet ( ) . appendChild ( na ) ; } } 	0
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; public class XNull extends XNodeSet { public XNull ( ) { super ( ) ; } public int getType ( ) { return CLASS_NULL ; } public String getTypeString ( ) { return "#CLASS_NULL" ; } public double num ( ) { return 0.0 ; } public boolean bool ( ) { return false ; } public String str ( ) { return "" ; } public int rtf ( XPathContext support ) { return DTM . NULL ; } public boolean equals ( XObject obj2 ) { return obj2 . getType ( ) == CLASS_NULL ; } } 	1
package org . apache . xalan . xsltc . compiler . util ; import java . util . Hashtable ; import java . util . Vector ; public final class MultiHashtable extends Hashtable { public Object put ( Object key , Object value ) { Vector vector = ( Vector ) get ( key ) ; if ( vector == null ) super . put ( key , vector = new Vector ( ) ) ; vector . add ( value ) ; return vector ; } public Object maps ( Object from , Object to ) { if ( from == null ) return null ; final Vector vector = ( Vector ) get ( from ) ; if ( vector != null ) { final int n = vector . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Object item = vector . elementAt ( i ) ; if ( item . equals ( to ) ) { return item ; } } } return null ; } } 	0
package org . apache . xalan . templates ; public class ElemOtherwise extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_OTHERWISE ; } public String getNodeName ( ) { return Constants . ELEMNAME_OTHERWISE_STRING ; } } 	1
package org . apache . xalan . transformer ; public class XalanProperties { public final static String SOURCE_LOCATION = "http://xml.apache.org/xalan/properties/source-location" ; } 	0
package org . apache . xpath . domapi ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . xpath . XPathException ; import org . w3c . dom . xpath . XPathExpression ; import org . w3c . dom . xpath . XPathNamespace ; public class XPathExpressionImpl implements XPathExpression { private PrefixResolver m_resolver ; private XPath m_xpath ; private Document m_doc = null ; XPathExpressionImpl ( XPath xpath , Document doc ) { m_xpath = xpath ; m_doc = doc ; } public Object evaluate ( Node contextNode , short type , Object result ) throws XPathException , DOMException { if ( m_doc != null ) { if ( ( contextNode != m_doc ) && ( ! contextNode . getOwnerDocument ( ) . equals ( m_doc ) ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_WRONG_DOCUMENT , null ) ; throw new DOMException ( DOMException . WRONG_DOCUMENT_ERR , fmsg ) ; } short nodeType = contextNode . getNodeType ( ) ; if ( ( nodeType != Document . DOCUMENT_NODE ) && ( nodeType != Document . ELEMENT_NODE ) && ( nodeType != Document . ATTRIBUTE_NODE ) && ( nodeType != Document . TEXT_NODE ) && ( nodeType != Document . CDATA_SECTION_NODE ) && ( nodeType != Document . COMMENT_NODE ) && ( nodeType != Document . PROCESSING_INSTRUCTION_NODE ) && ( nodeType != XPathNamespace . XPATH_NAMESPACE_NODE ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_WRONG_NODETYPE , null ) ; throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , fmsg ) ; } } if ( ! XPathResultImpl . isValidType ( type ) ) { String fmsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INVALID_XPATH_TYPE , new Object [ ] { new Integer ( type ) } ) ; throw new XPathException ( XPathException . TYPE_ERR , fmsg ) ; } XPathContext xpathSupport = new XPathContext ( ) ; if ( null != m_doc ) { xpathSupport . getDTMHandleFromNode ( m_doc ) ; } XObject xobj = null ; try { xobj = m_xpath . execute ( xpathSupport , contextNode , m_resolver ) ; } catch ( TransformerException te ) { throw new XPathException ( XPathException . INVALID_EXPRESSION_ERR , te . getMessageAndLocation ( ) ) ; } return new XPathResultImpl ( type , xobj , contextNode ) ; } } 	1
package org . apache . xalan . xsltc . runtime ; public interface Operators { public static final int EQ = 0 ; public static final int NE = 1 ; public static final int GT = 2 ; public static final int LT = 3 ; public static final int GE = 4 ; public static final int LE = 5 ; public static final String [ ] names = { "=" , "!=" , ">" , "<" , ">=" , "<=" } ; } 	0
package org . apache . xalan . trace ; public interface TraceListenerEx extends TraceListener { public void selectEnd ( EndSelectionEvent ev ) throws javax . xml . transform . TransformerException ; } 	1
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . Type ; public final class RtMethodGenerator extends MethodGenerator { private static final int HANDLER_INDEX = 2 ; private final Instruction _astoreHandler ; private final Instruction _aloadHandler ; public RtMethodGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; _astoreHandler = new ASTORE ( HANDLER_INDEX ) ; _aloadHandler = new ALOAD ( HANDLER_INDEX ) ; } public int getIteratorIndex ( ) { return INVALID_INDEX ; } public final Instruction storeHandler ( ) { return _astoreHandler ; } public final Instruction loadHandler ( ) { return _aloadHandler ; } public int getLocalIndex ( String name ) { return INVALID_INDEX ; } } 	0
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncPosition extends Function { private boolean m_isTopLevel ; public void postCompileStep ( Compiler compiler ) { m_isTopLevel = compiler . getLocationPathDepth ( ) == - 1 ; } public int getPositionInContextNodeList ( XPathContext xctxt ) { SubContextList iter = m_isTopLevel ? null : xctxt . getSubContextList ( ) ; if ( null != iter ) { int prox = iter . getProximityPosition ( xctxt ) ; return prox ; } DTMIterator cnl = xctxt . getContextNodeList ( ) ; if ( null != cnl ) { int n = cnl . getCurrentNode ( ) ; if ( n == DTM . NULL ) { if ( cnl . getCurrentPos ( ) == 0 ) return 0 ; try { cnl = cnl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } int currentNode = xctxt . getContextNode ( ) ; while ( DTM . NULL != ( n = cnl . nextNode ( ) ) ) { if ( n == currentNode ) break ; } } return cnl . getCurrentPos ( ) ; } return - 1 ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { double pos = ( double ) getPositionInContextNodeList ( xctxt ) ; return new XNumber ( pos ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	1
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; public interface StripWhitespaceFilter { public boolean stripSpace ( DOM dom , int node , int type ) ; } 	0
package org . apache . xpath . res ; public class XPATHErrorResources_es extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "Esta funcin no se permite en un patrn de bsqueda" } , { ER_CURRENT_TAKES_NO_ARGS , "Esta funcin no acepta argumentos." } , { ER_DOCUMENT_REPLACED , "la implementacin de la funcin del documento() se ha sustituido por org.apache.xalan.xslt.FuncDocument.!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "el contexto no tiene documento propietario!" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "el nombre local tiene demasiados argumentos." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "el URI del espacio de nombre tiene demasiados argumentos." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "el espacio estndar tiene demasiados argumentos." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "el nmero tiene demasiados argumentos." } , { ER_NAME_HAS_TOO_MANY_ARGS , "el nombre tiene demasiados argumentos." } , { ER_STRING_HAS_TOO_MANY_ARGS , "la cadena tiene demasiados argumentos." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "la longitud de la cadena tiene demasiados argumentos." } , { ER_TRANSLATE_TAKES_3_ARGS , "La funcin de traduccin utiliza tres argumentos!" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "La funcin unparsed-entity-uri debera utilizar un argumento!" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "no se ha implementado todava el eje de espacio de nombre!" } , { ER_UNKNOWN_AXIS , "eje desconocido: {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "operacin de bsqueda desconocida!" } , { ER_INCORRECT_ARG_LENGTH , "La longitud de los argumentos de la prueba del nodo de instruccin de procesamiento () es incorrecta!" } , { ER_CANT_CONVERT_TO_NUMBER , "No se puede convertir {0} en un nmero." } , { ER_CANT_CONVERT_TO_NODELIST , "No se puede convertir {0} en una NodeList." } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "No se puede convertir {0} en un NodeSetDTM!." } , { ER_CANT_CONVERT_TO_TYPE , "No se puede convertir {0} en un tipo//{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Patrn de bsqueda esperado en getMatchScore!" } , { ER_COULDNOT_GET_VAR_NAMED , "No se ha podido obtener una variable con el nombre {0}" } , { ER_UNKNOWN_OPCODE , "ERROR! Cdigo de operacin desconocido: {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Tokens adicionales no permitidos: {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "error de entrecomillado... debe usar comillas dobles!" } , { ER_EXPECTED_SINGLE_QUOTE , "error de entrecomillado... debe usar comillas sencillas!" } , { ER_EMPTY_EXPRESSION , "Expresin vaca!" } , { ER_EXPECTED_BUT_FOUND , "Esperados {0}, pero encontrados: {1}" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "El aserto del programador es incorrecto! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "El argumento booleano(...) ya no es opcional con el borrador 19990709 Xpath." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "Se ha encontrado ',' pero no hay ningn argumento anterior!" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "Se ha encontrado ',' pero no hay ningn argumento posterior!" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "La sintaxis '..[predicate]' no es vlida.  Sustituir por 'self::node()[predicate]'." } , { ER_ILLEGAL_AXIS_NAME , "nombre de eje no vlido: {0}" } , { ER_UNKNOWN_NODETYPE , "Tipo de nodo desconocido: {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "La cadena literal del patr ({0}) requiere entrecomillado!" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "No se ha podido dar formato numrico a {0}!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "No se ha podido crear un vnculo XML TransformerFactory: {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Error! No se ha encontrado la expresin de seleccin de xpath (-seleccionar)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERROR! No se ha podido encontra ENDOP despus de OP_LOCATIONPATH." } , { ER_ERROR_OCCURED , "Se ha producido un error!" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "Referencia variable atribuida a una variable fuera de contexto o sin definicin! Nombre = {0}" } , { ER_AXES_NOT_ALLOWED , "Slo se permiten los ejes child:: y attribute:: en los patrones de bsqueda!  Ejes incompatibles = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "El nmero de argumentos de la clave es incorrecto." } , { ER_COUNT_TAKES_1_ARG , "La funcin de cmputo debera utilizar un argumento!" } , { ER_COULDNOT_FIND_FUNCTION , "No se ha podido encontrar la funcin: {0}" } , { ER_UNSUPPORTED_ENCODING , "Codificacin no admitida: {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Se ha producido un error en DTM en getNextSibling... intentando restablecer." } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Error del programador: no se puede escribir en EmptyNodeList." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "XPathContext no admite setDOMFactory!" } , { ER_PREFIX_MUST_RESOLVE , "El prefijo debe convertirse en un espacio de nombre: {0}" } , { ER_PARSE_NOT_SUPPORTED , "anlisis sintctico (fuente InputSource source) no admitido! No se puede abri {0}" } , { ER_SAX_API_NOT_HANDLED , "Caracteres SAX API no manejados por DTM!" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "Espacio en blanco que puede ignorarse no procesado por DTM!" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison no puede manejar nodos de tipo {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper no puede manejar nodos de tipo {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Error DOM2Helper.parse: ID del sistema - {0} lnea - {1}" } , { ER_XERCES_PARSE_ERROR , "Error DOM2Helper.parse." } , { ER_INVALID_UTF16_SURROGATE , "Se ha detectado un sustituto UTF-16 no vlido: {0} ?" } , { ER_OIERROR , "Error de entrada/salida." } , { ER_CANNOT_CREATE_URL , "No se puede crear url para: {0}" } , { ER_XPATH_READOBJECT , "En XPath.readObject: {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "No se ha encontrado el token de funcin." } , { ER_CANNOT_DEAL_XPATH_TYPE , "No puede manejar el tipo XPath: {0}" } , { ER_NODESET_NOT_MUTABLE , "Este NodeSet es inmutable." } , { ER_NODESETDTM_NOT_MUTABLE , " Este NodeSetDTM es inmutable." } , { ER_VAR_NOT_RESOLVABLE , "Variable no convertible: {0}" } , { ER_NULL_ERROR_HANDLER , "Manejador de errores nulo." } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Aserto del programador: cdigo de operacin desconocido: {0}" } , { ER_ZERO_OR_ONE , "0 r 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() no admitido por XRTreeFragSelectWrapper" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() no admitido por XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() no admitido para XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "No se ha podido encontrar variable con el nombre {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars no puede utilizar una cadena para un argumento" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "El argumento FastStringBuffer no puede ser nulo" } , { ER_TWO_OR_THREE , "2 o 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Se ha accedido a la variable antes de vincularla!" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB no puede utilizar una cadena como argumento!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Error! Se est estableciendo la raz de un walker a nulo" } , { ER_NODESETDTM_CANNOT_ITERATE , "Este NodeSetDTM no puede hacer iteraciones a un nodo previo!" } , { ER_NODESET_CANNOT_ITERATE , "Este NodeSet no puede hacer iteraciones a un nodo previo!" } , { ER_NODESETDTM_CANNOT_INDEX , "Este NodeSetDTM no puede generar ndices o funciones de contador!" } , { ER_NODESET_CANNOT_INDEX , "Este NodeSet no puede generar ndices ni funciones de contador!" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "No se puede invocar setShouldCacheNodes despus de haber invocado nextNode" } , { ER_ONLY_ALLOWS , "{0} slo permite {1} argumentos" } , { ER_UNKNOWN_STEP , "Confirmacin del programador en getNextStepPos: stepType desconocido: {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Se esperaba una ruta de destino relativa despus del token '/' o '//'." } , { ER_EXPECTED_LOC_PATH , "Se esperaba una ruta de destino, pero se ha encontrado el siguiente token:  {0}" } , { ER_EXPECTED_LOC_STEP , "Se esperaba un paso de ubicacin despus de '/' o '//'." } , { ER_EXPECTED_NODE_TEST , "Se esperaba una prueba de nodo coincidente con NCName:* o con QName." } , { ER_EXPECTED_STEP_PATTERN , "Se esperaba un patrn de pasos, pero se ha encontrado '/' ." } , { ER_EXPECTED_REL_PATH_PATTERN , "Se esperaba un patrn de pasos relativo." } , { ER_CANT_CONVERT_TO_BOOLEAN , "No se puede convertir {0} en una instancia booleana." } , { ER_CANT_CONVERT_TO_SINGLENODE , "No se puede convertir {0} en un nodo nico. Este mtodo getter se aplica a los tipos ANY_UNORDERED_NODE_TYPE y FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "No se puede obtener la longitud de la snapshot del tipo: {0}. Este mtodo getter se aplica a los tipos UNORDERED_NODE_SNAPSHOT_TYPE y ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "No se puede hacer iteraciones en un tipo que no permite iteraciones: {0}" } , { ER_DOC_MUTATED , "El documento ha cambiado desde que se envi el resultado. La iteracin no es vlida." } , { ER_INVALID_XPATH_TYPE , "Argumento de tipo XPath no vlido: {0}" } , { ER_EMPTY_XPATH_RESULT , "Objeto resultado XPath vaco" } , { ER_INCOMPATIBLE_TYPES , "El tipo devuelto: {0} no se puede transformar en el tipo especificado: {1}" } , { ER_NULL_RESOLVER , "No se puede resolver el prefijo con un convertidor de prefijo nulo." } , { ER_CANT_CONVERT_TO_STRING , "No se puede convertir {0} en una cadena." } , { ER_NON_SNAPSHOT_TYPE , "No se puede invocar snapshotItem en el tipo: {0}. Este mtodo se aplica a los tipos UNORDERED_NODE_SNAPSHOT_TYPE y ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "El nodo de contexto no pertenece al documento vinculado a este XPathEvaluator." } , { ER_WRONG_NODETYPE , "El tipo de nodo de contexto no es compatible." } , { ER_XPATH_ERROR , "Error desconocido en XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "No se ha manejado todava el nombre locale en la funcin!" } , { WG_PROPERTY_NOT_SUPPORTED , "Propiedad XSL no admitida: {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Actualmente el espacio de nombres {0} en propiedad debe dejarse como est: {1}" } , { WG_SECURITY_EXCEPTION , "SecurityException al intentar tener acceso a la propiedad del sistema XSL: {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Sintaxis antigua: quo(...) ya no viene definida enis XPath" } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath requiere un objeto derivado para ejecutar nodeTest!" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "No se ha encontrado el token de la funcin" } , { WG_COULDNOT_FIND_FUNCTION , "No se ha podido encontrar la funcin: {0}" } , { WG_CANNOT_MAKE_URL_FROM , "No se puede crear URL desde: {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "opcin -E no admitida para analizador sintctico DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "VariableReference atribuida a una variable fuera de contexto o sin definicin. Nombre = {0}" } , { ER_UNSUPPORTED_ENCODING , "Codificacin no admitida: {0}" } , { "ui_language" , "es" } , { "help_language" , "es" } , { "language" , "es" } , { "BAD_CODE" , "El parmetro para createMessage estaba fuera de los lmites" } , { "FORMAT_FAILED" , "Excepcin generada la llamada messageFormat" } , { "version" , ">>>>>>> Versin Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "s" } , { "line" , "Lnea //" } , { "column" , "Columna //" } , { "xsldone" , "XSLProcessor: hecho" } , { "xpath_option" , "opciones xpath: " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [- seleccionar expresin xpath]" } , { "optionMatch" , "   [-match coincidir patrn de bsqueda (para diagnsticos de bsqueda)]" } , { "optionAnyExpr" , "O una expresin xpath realizar un volcado de diagnstico" } , { "noParsermsg1" , "Ha fallado el proceso XSLl" } , { "noParsermsg2" , "** No se ha podido encontrar analizador sintctico **" } , { "noParsermsg3" , "Compruebe el classpath" } , { "noParsermsg4" , "Si no tiene el analizador sintctico XML para Java de IBM, puede descargarlo desde" } , { "noParsermsg5" , "AlphaWorks de IBM: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//error" ; public static final String ERROR_HEADER = "Error: " ; public static final String WARNING_HEADER = "Advertencia: " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "PATRN " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class UnaryOpExpr extends Expression { private Expression _left ; public UnaryOpExpr ( Expression left ) { ( _left = left ) . setParent ( this ) ; } public boolean hasPositionCall ( ) { return ( _left . hasPositionCall ( ) ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tleft = _left . typeCheck ( stable ) ; final MethodType ptype = lookupPrimop ( stable , "u-" , new MethodType ( Type . Void , tleft ) ) ; if ( ptype != null ) { final Type arg1 = ( Type ) ptype . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) { _left = new CastExpr ( _left , arg1 ) ; } return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public String toString ( ) { return "u-" + '(' + _left + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; il . append ( _type . NEG ( ) ) ; } } 	0
package org . apache . xpath . res ; public class XPATHErrorResources_en extends XPATHErrorResources { } 	1
package org . apache . xalan . xsltc . runtime ; final public class TransletLoader { ClassLoader _loader = null ; public TransletLoader ( ) { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; final String loaderName = loader . getClass ( ) . getName ( ) ; if ( loaderName . equals ( "sun.misc.Launcher$ExtClassLoader" ) ) { loader = ClassLoader . getSystemClassLoader ( ) ; } _loader = loader ; } public Class loadClass ( String name ) throws ClassNotFoundException { return ( Class . forName ( name , false , _loader ) ) ; } public Class loadTranslet ( String name ) throws ClassNotFoundException { return ( Class . forName ( name , true , _loader ) ) ; } } 	0
package org . apache . xalan . extensions ; import java . io . IOException ; import java . lang . reflect . Method ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . functions . FuncExtFunction ; public abstract class ExtensionHandler { protected String m_namespaceUri ; protected String m_scriptLang ; private static final Object NO_OBJS [ ] = new Object [ 0 ] ; private static Method getCCL ; static { try { getCCL = Thread . class . getMethod ( "getContextClassLoader" , new Class [ 0 ] ) ; } catch ( Exception e ) { getCCL = null ; } } public static Class getClassForName ( String className ) throws ClassNotFoundException { Class result = null ; if ( className . equals ( "org.apache.xalan.xslt.extensions.Redirect" ) ) className = "org.apache.xalan.lib.Redirect" ; if ( getCCL != null ) { try { ClassLoader contextClassLoader = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; result = contextClassLoader . loadClass ( className ) ; } catch ( ClassNotFoundException cnfe ) { result = Class . forName ( className ) ; } catch ( Exception e ) { getCCL = null ; result = Class . forName ( className ) ; } } else result = Class . forName ( className ) ; return result ; } protected ExtensionHandler ( String namespaceUri , String scriptLang ) { m_namespaceUri = namespaceUri ; m_scriptLang = scriptLang ; } public abstract boolean isFunctionAvailable ( String function ) ; public abstract boolean isElementAvailable ( String element ) ; public abstract Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException ; public abstract Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException ; public abstract void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException ; } 	1
package org . apache . xpath ; public interface ExpressionOwner { public Expression getExpression ( ) ; public void setExpression ( Expression exp ) ; } 	0
package org . apache . xalan . extensions ; import java . io . IOException ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . ExpressionNode ; import org . apache . xpath . XPathContext ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class ExtensionHandlerExsltFunction extends ExtensionHandler { private String m_namespace ; private StylesheetRoot m_stylesheet ; private static final QName RESULTQNAME = new QName ( Constants . S_EXSLT_FUNCTIONS_URL , Constants . EXSLT_ELEMNAME_FUNCRESULT_STRING ) ; public ExtensionHandlerExsltFunction ( String ns , StylesheetRoot stylesheet ) { super ( ns , "xml" ) ; m_namespace = ns ; m_stylesheet = stylesheet ; } public void processElement ( String localPart , ElemTemplateElement element , TransformerImpl transformer , Stylesheet stylesheetTree , Object methodKey ) throws TransformerException , IOException { } public ElemExsltFunction getFunction ( String funcName ) { QName qname = new QName ( m_namespace , funcName ) ; ElemTemplate templ = m_stylesheet . getTemplateComposed ( qname ) ; if ( templ != null && templ instanceof ElemExsltFunction ) return ( ElemExsltFunction ) templ ; else return null ; } public boolean isFunctionAvailable ( String funcName ) { return getFunction ( funcName ) != null ; } public boolean isElementAvailable ( String elemName ) { if ( ! ( new QName ( m_namespace , elemName ) . equals ( RESULTQNAME ) ) ) { return false ; } else { ElemTemplateElement elem = m_stylesheet . getFirstChildElem ( ) ; while ( elem != null && elem != m_stylesheet ) { if ( elem instanceof ElemExsltFuncResult && ancestorIsFunction ( elem ) ) return true ; ElemTemplateElement nextElem = elem . getFirstChildElem ( ) ; if ( nextElem == null ) nextElem = elem . getNextSiblingElem ( ) ; if ( nextElem == null ) nextElem = elem . getParentElem ( ) ; elem = nextElem ; } } return false ; } private boolean ancestorIsFunction ( ElemTemplateElement child ) { while ( child . getParentElem ( ) != null && ! ( child . getParentElem ( ) instanceof StylesheetRoot ) ) { if ( child . getParentElem ( ) instanceof ElemExsltFunction ) return true ; child = child . getParentElem ( ) ; } return false ; } public Object callFunction ( String funcName , Vector args , Object methodKey , ExpressionContext exprContext ) throws TransformerException { throw new TransformerException ( "This method should not be called." ) ; } public Object callFunction ( FuncExtFunction extFunction , Vector args , ExpressionContext exprContext ) throws TransformerException { ExpressionNode parent = extFunction . exprGetParent ( ) ; while ( parent != null && ! ( parent instanceof ElemTemplate ) ) { parent = parent . exprGetParent ( ) ; } ElemTemplate callerTemplate = ( parent != null ) ? ( ElemTemplate ) parent : null ; XObject [ ] methodArgs ; methodArgs = new XObject [ args . size ( ) ] ; try { for ( int i = 0 ; i < methodArgs . length ; i ++ ) { methodArgs [ i ] = XObject . create ( args . elementAt ( i ) ) ; } ElemExsltFunction elemFunc = getFunction ( extFunction . getFunctionName ( ) ) ; XPathContext context = exprContext . getXPathContext ( ) ; TransformerImpl transformer = ( TransformerImpl ) context . getOwnerObject ( ) ; if ( callerTemplate != null ) elemFunc . setCallerFrameSize ( callerTemplate . m_frameSize ) ; else elemFunc . setCallerFrameSize ( 0 ) ; elemFunc . execute ( transformer , methodArgs ) ; XObject val = new XString ( "" ) ; if ( elemFunc . isResultSet ( ) ) { val = elemFunc . getResult ( ) ; elemFunc . clearResult ( ) ; } return val ; } catch ( TransformerException e ) { throw e ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } } } 	1
package org . apache . xml . dtm . ref . sax2dtm ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import org . apache . xml . dtm . * ; import org . apache . xml . dtm . ref . * ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . IntVector ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . SuballocatedIntVector ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . WrappedRuntimeException ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . xml . sax . * ; import org . xml . sax . ext . * ; public class SAX2DTM extends DTMDefaultBaseIterators implements EntityResolver , DTDHandler , ContentHandler , ErrorHandler , DeclHandler , LexicalHandler { private static final boolean DEBUG = false ; private IncrementalSAXSource m_incrementalSAXSource = null ; protected FastStringBuffer m_chars ; protected SuballocatedIntVector m_data ; transient protected IntStack m_parents ; transient protected int m_previous = 0 ; transient protected java . util . Vector m_prefixMappings = new java . util . Vector ( ) ; transient protected IntStack m_contextIndexes ; transient protected int m_textType = DTM . TEXT_NODE ; transient protected int m_coalescedTextType = DTM . TEXT_NODE ; transient protected Locator m_locator = null ; transient private String m_systemId = null ; transient protected boolean m_insideDTD = false ; protected DTMTreeWalker m_walker = new DTMTreeWalker ( ) ; protected DTMStringPool m_valuesOrPrefixes ; protected boolean m_endDocumentOccured = false ; protected SuballocatedIntVector m_dataOrQName ; protected Hashtable m_idAttributes = new Hashtable ( ) ; static final String [ ] m_fixednames = { null , null , null , "#text" , "#cdata_section" , null , null , null , "#comment" , "#document" , null , "#document-fragment" , null } ; private Vector m_entities = null ; private static final int ENTITY_FIELD_PUBLICID = 0 ; private static final int ENTITY_FIELD_SYSTEMID = 1 ; private static final int ENTITY_FIELD_NOTATIONNAME = 2 ; private static final int ENTITY_FIELD_NAME = 3 ; private static final int ENTITY_FIELDS_PER = 4 ; protected int m_textPendingStart = - 1 ; protected boolean m_useSourceLocationProperty = false ; protected static boolean m_source_location = false ; protected StringVector m_sourceSystemId ; protected IntVector m_sourceLine ; protected IntVector m_sourceColumn ; public SAX2DTM ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { this ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , DEFAULT_BLOCKSIZE , true ) ; } public SAX2DTM ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib ) ; if ( blocksize <= 64 ) { m_data = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS_SMALL ) ; m_dataOrQName = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS_SMALL ) ; m_valuesOrPrefixes = new DTMStringPool ( 16 ) ; m_chars = new FastStringBuffer ( 7 , 10 ) ; m_contextIndexes = new IntStack ( 4 ) ; m_parents = new IntStack ( 4 ) ; } else { m_data = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS ) ; m_dataOrQName = new SuballocatedIntVector ( blocksize , DEFAULT_NUMBLOCKS ) ; m_valuesOrPrefixes = new DTMStringPool ( ) ; m_chars = new FastStringBuffer ( 10 , 13 ) ; m_contextIndexes = new IntStack ( ) ; m_parents = new IntStack ( ) ; } m_data . addElement ( 0 ) ; m_useSourceLocationProperty = m_source_location ; m_sourceSystemId = ( m_useSourceLocationProperty ) ? new StringVector ( ) : null ; m_sourceLine = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; m_sourceColumn = ( m_useSourceLocationProperty ) ? new IntVector ( ) : null ; } public static void setUseSourceLocation ( boolean useSourceLocation ) { m_source_location = useSourceLocation ; } protected int _dataOrQName ( int identity ) { if ( identity < m_size ) return m_dataOrQName . elementAt ( identity ) ; while ( true ) { boolean isMore = nextNode ( ) ; if ( ! isMore ) return NULL ; else if ( identity < m_size ) return m_dataOrQName . elementAt ( identity ) ; } } public void clearCoRoutine ( ) { clearCoRoutine ( true ) ; } public void clearCoRoutine ( boolean callDoTerminate ) { if ( null != m_incrementalSAXSource ) { if ( callDoTerminate ) m_incrementalSAXSource . deliverMoreNodes ( false ) ; m_incrementalSAXSource = null ; } } public void setIncrementalSAXSource ( IncrementalSAXSource incrementalSAXSource ) { m_incrementalSAXSource = incrementalSAXSource ; incrementalSAXSource . setContentHandler ( this ) ; incrementalSAXSource . setLexicalHandler ( this ) ; incrementalSAXSource . setDTDHandler ( this ) ; } public ContentHandler getContentHandler ( ) { if ( m_incrementalSAXSource instanceof IncrementalSAXSource_Filter ) return ( ContentHandler ) m_incrementalSAXSource ; else return this ; } public LexicalHandler getLexicalHandler ( ) { if ( m_incrementalSAXSource instanceof IncrementalSAXSource_Filter ) return ( LexicalHandler ) m_incrementalSAXSource ; else return this ; } public EntityResolver getEntityResolver ( ) { return this ; } public DTDHandler getDTDHandler ( ) { return this ; } public ErrorHandler getErrorHandler ( ) { return this ; } public DeclHandler getDeclHandler ( ) { return this ; } public boolean needsTwoThreads ( ) { return null != m_incrementalSAXSource ; } public void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws SAXException { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return ; int type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } else { int firstChild = _firstch ( identity ) ; if ( DTM . NULL != firstChild ) { int offset = - 1 ; int length = 0 ; int startNode = identity ; identity = firstChild ; do { type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; if ( - 1 == offset ) { offset = m_data . elementAt ( dataIndex ) ; } length += m_data . elementAt ( dataIndex + 1 ) ; } identity = getNextNodeIdentity ( identity ) ; } while ( DTM . NULL != identity && ( _parent ( identity ) >= startNode ) ) ; if ( length > 0 ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } } else if ( type != DTM . ELEMENT_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } String str = m_valuesOrPrefixes . indexToString ( dataIndex ) ; if ( normalize ) FastStringBuffer . sendNormalizedSAXcharacters ( str . toCharArray ( ) , 0 , str . length ( ) , ch ) ; else ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } } } public String getNodeName ( int nodeHandle ) { int expandedTypeID = getExpandedTypeID ( nodeHandle ) ; int namespaceID = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; if ( 0 == namespaceID ) { int type = getNodeType ( nodeHandle ) ; if ( type == DTM . NAMESPACE_NODE ) { if ( null == m_expandedNameTable . getLocalName ( expandedTypeID ) ) return "xmlns" ; else return "xmlns:" + m_expandedNameTable . getLocalName ( expandedTypeID ) ; } else if ( 0 == m_expandedNameTable . getLocalNameID ( expandedTypeID ) ) { return m_fixednames [ type ] ; } else return m_expandedNameTable . getLocalName ( expandedTypeID ) ; } else { int qnameIndex = m_dataOrQName . elementAt ( makeNodeIdentity ( nodeHandle ) ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public String getNodeNameX ( int nodeHandle ) { int expandedTypeID = getExpandedTypeID ( nodeHandle ) ; int namespaceID = m_expandedNameTable . getNamespaceID ( expandedTypeID ) ; if ( 0 == namespaceID ) { String name = m_expandedNameTable . getLocalName ( expandedTypeID ) ; if ( name == null ) return "" ; else return name ; } else { int qnameIndex = m_dataOrQName . elementAt ( makeNodeIdentity ( nodeHandle ) ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public boolean isAttributeSpecified ( int attributeHandle ) { return true ; } public String getDocumentTypeDeclarationSystemIdentifier ( ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } protected int getNextNodeIdentity ( int identity ) { identity += 1 ; while ( identity >= m_size ) { if ( null == m_incrementalSAXSource ) return DTM . NULL ; nextNode ( ) ; } return identity ; } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { DTMTreeWalker treeWalker = m_walker ; ContentHandler prevCH = treeWalker . getcontentHandler ( ) ; if ( null != prevCH ) { treeWalker = new DTMTreeWalker ( ) ; } treeWalker . setcontentHandler ( ch ) ; treeWalker . setDTM ( this ) ; try { treeWalker . traverse ( nodeHandle ) ; } finally { treeWalker . setcontentHandler ( null ) ; } } public int getNumberOfNodes ( ) { return m_size ; } protected boolean nextNode ( ) { if ( null == m_incrementalSAXSource ) return false ; if ( m_endDocumentOccured ) { clearCoRoutine ( ) ; return false ; } Object gotMore = m_incrementalSAXSource . deliverMoreNodes ( true ) ; if ( ! ( gotMore instanceof Boolean ) ) { if ( gotMore instanceof RuntimeException ) { throw ( RuntimeException ) gotMore ; } else if ( gotMore instanceof Exception ) { throw new WrappedRuntimeException ( ( Exception ) gotMore ) ; } clearCoRoutine ( ) ; return false ; } if ( gotMore != Boolean . TRUE ) { clearCoRoutine ( ) ; } return true ; } private final boolean isTextType ( int type ) { return ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) ; } protected int addNode ( int type , int expandedTypeID , int parentIndex , int previousSibling , int dataOrPrefix , boolean canHaveFirstChild ) { int nodeIndex = m_size ++ ; if ( m_dtmIdent . size ( ) == ( nodeIndex > > > DTMManager . IDENT_DTM_NODE_BITS ) ) { addNewDTMID ( nodeIndex ) ; } m_firstch . addElement ( canHaveFirstChild ? NOTPROCESSED : DTM . NULL ) ; m_nextsib . addElement ( NOTPROCESSED ) ; m_parent . addElement ( parentIndex ) ; m_exptype . addElement ( expandedTypeID ) ; m_dataOrQName . addElement ( dataOrPrefix ) ; if ( m_prevsib != null ) { m_prevsib . addElement ( previousSibling ) ; } if ( DTM . NULL != previousSibling ) { m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; } if ( m_locator != null && m_useSourceLocationProperty ) { setSourceLocation ( ) ; } switch ( type ) { case DTM . NAMESPACE_NODE : declareNamespaceInContext ( parentIndex , nodeIndex ) ; break ; case DTM . ATTRIBUTE_NODE : break ; default : if ( DTM . NULL == previousSibling && DTM . NULL != parentIndex ) { m_firstch . setElementAt ( nodeIndex , parentIndex ) ; } break ; } return nodeIndex ; } protected void addNewDTMID ( int nodeIndex ) { try { if ( m_mgr == null ) throw new ClassCastException ( ) ; DTMManagerDefault mgrD = ( DTMManagerDefault ) m_mgr ; int id = mgrD . getFirstFreeDTMID ( ) ; mgrD . addDTM ( this , id , nodeIndex ) ; m_dtmIdent . addElement ( id << DTMManager . IDENT_DTM_NODE_BITS ) ; } catch ( ClassCastException e ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } } protected void setSourceLocation ( ) { m_sourceSystemId . addElement ( m_locator . getSystemId ( ) ) ; m_sourceLine . addElement ( m_locator . getLineNumber ( ) ) ; m_sourceColumn . addElement ( m_locator . getColumnNumber ( ) ) ; if ( m_sourceSystemId . size ( ) != m_size ) { System . err . println ( "CODING ERROR in Source Location: " + m_size + " != " + m_sourceSystemId . size ( ) ) ; System . exit ( 1 ) ; } } public String getNodeValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_chars . getString ( offset , length ) ; } else if ( DTM . ELEMENT_NODE == type || DTM . DOCUMENT_FRAGMENT_NODE == type || DTM . DOCUMENT_NODE == type ) { return null ; } else { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } } public String getLocalName ( int nodeHandle ) { return m_expandedNameTable . getLocalName ( _exptype ( makeNodeIdentity ( nodeHandle ) ) ) ; } public String getUnparsedEntityURI ( String name ) { String url = "" ; if ( null == m_entities ) return url ; int n = m_entities . size ( ) ; for ( int i = 0 ; i < n ; i += ENTITY_FIELDS_PER ) { String ename = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_NAME ) ; if ( null != ename && ename . equals ( name ) ) { String nname = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_NOTATIONNAME ) ; if ( null != nname ) { url = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_SYSTEMID ) ; if ( null == url ) { url = ( String ) m_entities . elementAt ( i + ENTITY_FIELD_PUBLICID ) ; } } break ; } } return url ; } public String getPrefix ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type ( identity ) ; if ( DTM . ELEMENT_NODE == type ) { int prefixIndex = _dataOrQName ( identity ) ; if ( 0 == prefixIndex ) return "" ; else { String qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; return getPrefix ( qname , null ) ; } } else if ( DTM . ATTRIBUTE_NODE == type ) { int prefixIndex = _dataOrQName ( identity ) ; if ( prefixIndex < 0 ) { prefixIndex = m_data . elementAt ( - prefixIndex ) ; String qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; return getPrefix ( qname , null ) ; } } return "" ; } public int getAttributeNode ( int nodeHandle , String namespaceURI , String name ) { for ( int attrH = getFirstAttribute ( nodeHandle ) ; DTM . NULL != attrH ; attrH = getNextAttribute ( attrH ) ) { String attrNS = getNamespaceURI ( attrH ) ; String attrName = getLocalName ( attrH ) ; boolean nsMatch = namespaceURI == attrNS || ( namespaceURI != null && namespaceURI . equals ( attrNS ) ) ; if ( nsMatch && name . equals ( attrName ) ) return attrH ; } return DTM . NULL ; } public String getDocumentTypeDeclarationPublicIdentifier ( ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } public String getNamespaceURI ( int nodeHandle ) { return m_expandedNameTable . getNamespace ( _exptype ( makeNodeIdentity ( nodeHandle ) ) ) ; } public XMLString getStringValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type ; if ( identity == DTM . NULL ) type = DTM . NULL ; else type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_xstrf . newstr ( m_chars , offset , length ) ; } else { int firstChild = _firstch ( identity ) ; if ( DTM . NULL != firstChild ) { int offset = - 1 ; int length = 0 ; int startNode = identity ; identity = firstChild ; do { type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; if ( - 1 == offset ) { offset = m_data . elementAt ( dataIndex ) ; } length += m_data . elementAt ( dataIndex + 1 ) ; } identity = getNextNodeIdentity ( identity ) ; } while ( DTM . NULL != identity && ( _parent ( identity ) >= startNode ) ) ; if ( length > 0 ) { return m_xstrf . newstr ( m_chars , offset , length ) ; } } else if ( type != DTM . ELEMENT_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return m_xstrf . newstr ( m_valuesOrPrefixes . indexToString ( dataIndex ) ) ; } } return m_xstrf . emptystr ( ) ; } public boolean isWhitespace ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type ; if ( identity == DTM . NULL ) type = DTM . NULL ; else type = _type ( identity ) ; if ( isTextType ( type ) ) { int dataIndex = _dataOrQName ( identity ) ; int offset = m_data . elementAt ( dataIndex ) ; int length = m_data . elementAt ( dataIndex + 1 ) ; return m_chars . isWhitespace ( offset , length ) ; } return false ; } public int getElementById ( String elementId ) { Integer intObj ; boolean isMore = true ; do { intObj = ( Integer ) m_idAttributes . get ( elementId ) ; if ( null != intObj ) return makeNodeHandle ( intObj . intValue ( ) ) ; if ( ! isMore || m_endDocumentOccured ) break ; isMore = nextNode ( ) ; } while ( null == intObj ) ; return DTM . NULL ; } public String getPrefix ( String qname , String uri ) { String prefix ; int uriIndex = - 1 ; if ( null != uri && uri . length ( ) > 0 ) { do { uriIndex = m_prefixMappings . indexOf ( uri , ++ uriIndex ) ; } while ( ( uriIndex & 0x01 ) == 0 ) ; if ( uriIndex >= 0 ) { prefix = ( String ) m_prefixMappings . elementAt ( uriIndex - 1 ) ; } else if ( null != qname ) { int indexOfNSSep = qname . indexOf ( ':' ) ; if ( qname . equals ( "xmlns" ) ) prefix = "" ; else if ( qname . startsWith ( "xmlns:" ) ) prefix = qname . substring ( indexOfNSSep + 1 ) ; else prefix = ( indexOfNSSep > 0 ) ? qname . substring ( 0 , indexOfNSSep ) : null ; } else { prefix = null ; } } else if ( null != qname ) { int indexOfNSSep = qname . indexOf ( ':' ) ; if ( indexOfNSSep > 0 ) { if ( qname . startsWith ( "xmlns:" ) ) prefix = qname . substring ( indexOfNSSep + 1 ) ; else prefix = qname . substring ( 0 , indexOfNSSep ) ; } else { if ( qname . equals ( "xmlns" ) ) prefix = "" ; else prefix = null ; } } else { prefix = null ; } return prefix ; } public int getIdForNamespace ( String uri ) { return m_valuesOrPrefixes . stringToIndex ( uri ) ; } public String getNamespaceURI ( String prefix ) { String uri = "" ; int prefixIndex = m_contextIndexes . peek ( ) - 1 ; if ( null == prefix ) prefix = "" ; do { prefixIndex = m_prefixMappings . indexOf ( prefix , ++ prefixIndex ) ; } while ( ( prefixIndex >= 0 ) && ( prefixIndex & 0x01 ) == 0x01 ) ; if ( prefixIndex > - 1 ) { uri = ( String ) m_prefixMappings . elementAt ( prefixIndex + 1 ) ; } return uri ; } public void setIDAttribute ( String id , int elem ) { m_idAttributes . put ( id , new Integer ( elem ) ) ; } protected void charactersFlush ( ) { if ( m_textPendingStart >= 0 ) { int length = m_chars . size ( ) - m_textPendingStart ; boolean doStrip = false ; if ( getShouldStripWhitespace ( ) ) { doStrip = m_chars . isWhitespace ( m_textPendingStart , length ) ; } if ( doStrip ) m_chars . setLength ( m_textPendingStart ) ; else { int exName = m_expandedNameTable . getExpandedTypeID ( DTM . TEXT_NODE ) ; int dataIndex = m_data . size ( ) ; m_previous = addNode ( m_coalescedTextType , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; m_data . addElement ( m_textPendingStart ) ; m_data . addElement ( length ) ; } m_textPendingStart = - 1 ; m_textType = m_coalescedTextType = DTM . TEXT_NODE ; } } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException { return null ; } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( null == m_entities ) { m_entities = new Vector ( ) ; } try { systemId = SystemIDResolver . getAbsoluteURI ( systemId , getDocumentBaseURI ( ) ) ; } catch ( Exception e ) { throw new org . xml . sax . SAXException ( e ) ; } m_entities . addElement ( publicId ) ; m_entities . addElement ( systemId ) ; m_entities . addElement ( notationName ) ; m_entities . addElement ( name ) ; } public void setDocumentLocator ( Locator locator ) { m_locator = locator ; m_systemId = locator . getSystemId ( ) ; } public void startDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "startDocument" ) ; int doc = addNode ( DTM . DOCUMENT_NODE , m_expandedNameTable . getExpandedTypeID ( DTM . DOCUMENT_NODE ) , DTM . NULL , DTM . NULL , 0 , true ) ; m_parents . push ( doc ) ; m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endDocument ( ) throws SAXException { if ( DEBUG ) System . out . println ( "endDocument" ) ; charactersFlush ( ) ; m_nextsib . setElementAt ( NULL , 0 ) ; if ( m_firstch . elementAt ( 0 ) == NOTPROCESSED ) m_firstch . setElementAt ( NULL , 0 ) ; if ( DTM . NULL != m_previous ) m_nextsib . setElementAt ( DTM . NULL , m_previous ) ; m_parents = null ; m_prefixMappings = null ; m_contextIndexes = null ; m_endDocumentOccured = true ; m_locator = null ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( DEBUG ) System . out . println ( "startPrefixMapping: prefix: " + prefix + ", uri: " + uri ) ; if ( null == prefix ) prefix = "" ; m_prefixMappings . addElement ( prefix ) ; m_prefixMappings . addElement ( uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { if ( DEBUG ) System . out . println ( "endPrefixMapping: prefix: " + prefix ) ; if ( null == prefix ) prefix = "" ; int index = m_contextIndexes . peek ( ) - 1 ; do { index = m_prefixMappings . indexOf ( prefix , ++ index ) ; } while ( ( index >= 0 ) && ( ( index & 0x01 ) == 0x01 ) ) ; if ( index > - 1 ) { m_prefixMappings . setElementAt ( "%@$#^@#" , index ) ; m_prefixMappings . setElementAt ( "%@$#^@#" , index + 1 ) ; } } protected boolean declAlreadyDeclared ( String prefix ) { int startDecls = m_contextIndexes . peek ( ) ; java . util . Vector prefixMappings = m_prefixMappings ; int nDecls = prefixMappings . size ( ) ; for ( int i = startDecls ; i < nDecls ; i += 2 ) { String prefixDecl = ( String ) prefixMappings . elementAt ( i ) ; if ( prefixDecl == null ) continue ; if ( prefixDecl . equals ( prefix ) ) return true ; } return false ; } boolean m_pastFirstElement = false ; public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( DEBUG ) { System . out . println ( "startElement: uri: " + uri + ", localname: " + localName + ", qname: " + qName + ", atts: " + attributes ) ; boolean DEBUG_ATTRS = true ; if ( DEBUG_ATTRS & attributes != null ) { int n = attributes . getLength ( ) ; if ( n == 0 ) System . out . println ( "\tempty attribute list" ) ; else for ( int i = 0 ; i < n ; i ++ ) System . out . println ( "\t attr: uri: " + attributes . getURI ( i ) + ", localname: " + attributes . getLocalName ( i ) + ", qname: " + attributes . getQName ( i ) + ", type: " + attributes . getType ( i ) + ", value: " + attributes . getValue ( i ) ) ; } } charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( uri , localName , DTM . ELEMENT_NODE ) ; String prefix = getPrefix ( qName , uri ) ; int prefixIndex = ( null != prefix ) ? m_valuesOrPrefixes . stringToIndex ( qName ) : 0 ; int elemNode = addNode ( DTM . ELEMENT_NODE , exName , m_parents . peek ( ) , m_previous , prefixIndex , true ) ; if ( m_indexing ) indexNode ( exName , elemNode ) ; m_parents . push ( elemNode ) ; int startDecls = m_contextIndexes . peek ( ) ; int nDecls = m_prefixMappings . size ( ) ; int prev = DTM . NULL ; if ( ! m_pastFirstElement ) { prefix = "xml" ; String declURL = "http://www.w3.org/XML/1998/namespace" ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; int val = m_valuesOrPrefixes . stringToIndex ( declURL ) ; prev = addNode ( DTM . NAMESPACE_NODE , exName , elemNode , prev , val , false ) ; m_pastFirstElement = true ; } for ( int i = startDecls ; i < nDecls ; i += 2 ) { prefix = ( String ) m_prefixMappings . elementAt ( i ) ; if ( prefix == null ) continue ; String declURL = ( String ) m_prefixMappings . elementAt ( i + 1 ) ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; int val = m_valuesOrPrefixes . stringToIndex ( declURL ) ; prev = addNode ( DTM . NAMESPACE_NODE , exName , elemNode , prev , val , false ) ; } int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String attrUri = attributes . getURI ( i ) ; String attrQName = attributes . getQName ( i ) ; String valString = attributes . getValue ( i ) ; prefix = getPrefix ( attrQName , attrUri ) ; int nodeType ; String attrLocalName = attributes . getLocalName ( i ) ; if ( ( null != attrQName ) && ( attrQName . equals ( "xmlns" ) || attrQName . startsWith ( "xmlns:" ) ) ) { if ( declAlreadyDeclared ( prefix ) ) continue ; nodeType = DTM . NAMESPACE_NODE ; } else { nodeType = DTM . ATTRIBUTE_NODE ; if ( attributes . getType ( i ) . equalsIgnoreCase ( "ID" ) ) setIDAttribute ( valString , elemNode ) ; } if ( null == valString ) valString = "" ; int val = m_valuesOrPrefixes . stringToIndex ( valString ) ; if ( null != prefix ) { prefixIndex = m_valuesOrPrefixes . stringToIndex ( attrQName ) ; int dataIndex = m_data . size ( ) ; m_data . addElement ( prefixIndex ) ; m_data . addElement ( val ) ; val = - dataIndex ; } exName = m_expandedNameTable . getExpandedTypeID ( attrUri , attrLocalName , nodeType ) ; prev = addNode ( nodeType , exName , elemNode , prev , val , false ) ; } if ( DTM . NULL != prev ) m_nextsib . setElementAt ( DTM . NULL , prev ) ; if ( null != m_wsfilter ) { short wsv = m_wsfilter . getShouldStripSpace ( makeNodeHandle ( elemNode ) , this ) ; boolean shouldStrip = ( DTMWSFilter . INHERIT == wsv ) ? getShouldStripWhitespace ( ) : ( DTMWSFilter . STRIP == wsv ) ; pushShouldStripWhitespace ( shouldStrip ) ; } m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( DEBUG ) System . out . println ( "endElement: uri: " + uri + ", localname: " + localName + ", qname: " + qName ) ; charactersFlush ( ) ; m_contextIndexes . quickPop ( 1 ) ; int topContextIndex = m_contextIndexes . peek ( ) ; if ( topContextIndex != m_prefixMappings . size ( ) ) { m_prefixMappings . setSize ( topContextIndex ) ; } int lastNode = m_previous ; m_previous = m_parents . pop ( ) ; if ( DTM . NULL == lastNode ) m_firstch . setElementAt ( DTM . NULL , m_previous ) ; else m_nextsib . setElementAt ( DTM . NULL , lastNode ) ; popShouldStripWhitespace ( ) ; } public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( m_textPendingStart == - 1 ) { m_textPendingStart = m_chars . size ( ) ; m_coalescedTextType = m_textType ; } else if ( m_textType == DTM . TEXT_NODE ) { m_coalescedTextType = DTM . TEXT_NODE ; } m_chars . append ( ch , start , length ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { characters ( ch , start , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { if ( DEBUG ) System . out . println ( "processingInstruction: target: " + target + ", data: " + data ) ; charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( null , target , DTM . PROCESSING_INSTRUCTION_NODE ) ; int dataIndex = m_valuesOrPrefixes . stringToIndex ( data ) ; m_previous = addNode ( DTM . PROCESSING_INSTRUCTION_NODE , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void skippedEntity ( String name ) throws SAXException { } public void warning ( SAXParseException e ) throws SAXException { System . err . println ( e . getMessage ( ) ) ; } public void error ( SAXParseException e ) throws SAXException { throw e ; } public void fatalError ( SAXParseException e ) throws SAXException { throw e ; } public void elementDecl ( String name , String model ) throws SAXException { } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { } public void internalEntityDecl ( String name , String value ) throws SAXException { } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { m_insideDTD = true ; } public void endDTD ( ) throws SAXException { m_insideDTD = false ; } public void startEntity ( String name ) throws SAXException { } public void endEntity ( String name ) throws SAXException { } public void startCDATA ( ) throws SAXException { m_textType = DTM . CDATA_SECTION_NODE ; } public void endCDATA ( ) throws SAXException { m_textType = DTM . TEXT_NODE ; } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( m_insideDTD ) return ; charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( DTM . COMMENT_NODE ) ; int dataIndex = m_valuesOrPrefixes . stringToIndex ( new String ( ch , start , length ) ) ; m_previous = addNode ( DTM . COMMENT_NODE , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void setProperty ( String property , Object value ) { } public SourceLocator getSourceLocatorFor ( int node ) { if ( m_useSourceLocationProperty ) { node = makeNodeIdentity ( node ) ; return new NodeLocator ( null , m_sourceSystemId . elementAt ( node ) , m_sourceLine . elementAt ( node ) , m_sourceColumn . elementAt ( node ) ) ; } else if ( m_locator != null ) { return new NodeLocator ( null , m_locator . getSystemId ( ) , - 1 , - 1 ) ; } else if ( m_systemId != null ) { return new NodeLocator ( null , m_systemId , - 1 , - 1 ) ; } return null ; } } 	0
package org . apache . xpath . res ; public class XPATHErrorResources_fr extends XPATHErrorResources { public static final int MAX_CODE = 108 ; public static final int MAX_WARNING = 11 ; public static final int MAX_OTHERS = 20 ; public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1 ; public static final Object [ ] [ ] contents = { { "ERROR0000" , "{0}" } , { ER_CURRENT_NOT_ALLOWED_IN_MATCH , "La fonction current() nest pas admise dans la correspondance  la forme !" } , { ER_CURRENT_TAKES_NO_ARGS , "La fonction current() nadmet pas les arguments !" } , { ER_DOCUMENT_REPLACED , "La mise en oeuvre de la fonction document () a t remplace par org.apache.xalan.xslt.FuncDocument!" } , { ER_CONTEXT_HAS_NO_OWNERDOC , "le contexte na pas de document propritaire !" } , { ER_LOCALNAME_HAS_TOO_MANY_ARGS , "local-name() a trop darguments." } , { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS , "namespace-uri() a trop darguments." } , { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS , "normalize-space() a trop darguments." } , { ER_NUMBER_HAS_TOO_MANY_ARGS , "number() a trop darguments." } , { ER_NAME_HAS_TOO_MANY_ARGS , "name() a trop darguments." } , { ER_STRING_HAS_TOO_MANY_ARGS , "string() a trop darguments." } , { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS , "string-length() a trop darguments." } , { ER_TRANSLATE_TAKES_3_ARGS , "La fonction translate() a trois arguments !" } , { ER_UNPARSEDENTITYURI_TAKES_1_ARG , "La fonction unparsed-entity-uri ne peut avoir quun seul argument !" } , { ER_NAMESPACEAXIS_NOT_IMPLEMENTED , "l'axe namespace nest pas encore mis en uvre !" } , { ER_UNKNOWN_AXIS , "axe inconnu : {0}" } , { ER_UNKNOWN_MATCH_OPERATION , "opration de correspondance inconnue !" } , { ER_INCORRECT_ARG_LENGTH , "La longueur dargument du test du nud processing-instruction() nest pas correcte !" } , { ER_CANT_CONVERT_TO_NUMBER , "Impossible de convertir {0} en fonction number" } , { ER_CANT_CONVERT_TO_NODELIST , "Impossible de convertir {0} en fonction NodeList !" } , { ER_CANT_CONVERT_TO_MUTABLENODELIST , "Impossible de convertir {0} en fonction NodeSetDTM !" } , { ER_CANT_CONVERT_TO_TYPE , "Impossible de convertir {0} en type//{1}" } , { ER_EXPECTED_MATCH_PATTERN , "Correspondance  la forme attendue dans getMatchScore !" } , { ER_COULDNOT_GET_VAR_NAMED , "Impossible de trouver la variable nomme {0}" } , { ER_UNKNOWN_OPCODE , "ERREUR ! Code dopration inconnu : {0}" } , { ER_EXTRA_ILLEGAL_TOKENS , "Units lexicales supplmentaires non autorises : {0}" } , { ER_EXPECTED_DOUBLE_QUOTE , "libell mal prsent... guillemet attendu !" } , { ER_EXPECTED_SINGLE_QUOTE , "libell mal prsent... apostrophe attendue !" } , { ER_EMPTY_EXPRESSION , "Expression vide !" } , { ER_EXPECTED_BUT_FOUND , "{0} attendu(e), mais : {1} trouv(e)" } , { ER_INCORRECT_PROGRAMMER_ASSERTION , "Assertion de programmeur incorrecte ! - {0}" } , { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL , "Largument boolean(...) nest plus facultatif avec la version brouillon 19990709 XPath ." } , { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG , "',' trouv sans argument avant !" } , { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG , "',' trouv sans argument aprs !" } , { ER_PREDICATE_ILLEGAL_SYNTAX , "'..[predicate]' ou '.[predicate]' constitue une mauvaise syntaxe. Utilisez 'self::node()[predicate]'  la place." } , { ER_ILLEGAL_AXIS_NAME , "nom daxe non autoris : {0}" } , { ER_UNKNOWN_NODETYPE , "Type de nud inconnu : {0}" } , { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED , "Le libell de la forme ({0}) doit tre entre guillemets !" } , { ER_COULDNOT_BE_FORMATTED_TO_NUMBER , "{0} ne peut pas tre format(e) en number!" } , { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON , "Impossible de crer XML TransformerFactory Liaison : {0}" } , { ER_DIDNOT_FIND_XPATH_SELECT_EXP , "Erreur ! Impossible de trouver lexpression de slection xpath (-select)." } , { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH , "ERREUR ! Impossible de trouver ENDOP aprs OP_LOCATIONPATH" } , { ER_ERROR_OCCURED , "Une erreur sest produite !" } , { ER_ILLEGAL_VARIABLE_REFERENCE , "L''lment VariableReference a t fourni pour la variable hors contexte ou sans dfinition !  Nom = {0}" } , { ER_AXES_NOT_ALLOWED , "Seuls les axes child:: et attribute:: sont admis dans les correspondances  la forme !  Axes errons = {0}" } , { ER_KEY_HAS_TOO_MANY_ARGS , "key() dispose dun nombre incorrect darguments." } , { ER_COUNT_TAKES_1_ARG , "La fonction count ne doit avoir quun seul argument !" } , { ER_COULDNOT_FIND_FUNCTION , "Impossible de trouver la fonction : {0}" } , { ER_UNSUPPORTED_ENCODING , "Codage non pris en charge : {0}" } , { ER_PROBLEM_IN_DTM_NEXTSIBLING , "Un incident sest produit au niveau de DTM dans getNextSibling... Tentative de rcupration" } , { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL , "Erreur de programmation : Impossible dcrire dans EmptyNodeList." } , { ER_SETDOMFACTORY_NOT_SUPPORTED , "setDOMFactory nest pas pris en charge par XPathContext!" } , { ER_PREFIX_MUST_RESOLVE , "Le prfixe doit se rsoudre en nom d''espace : {0}" } , { ER_PARSE_NOT_SUPPORTED , "parse (source InputSource) non pris en charge dans XpathContext ! Impossible douvrir {0}" } , { ER_SAX_API_NOT_HANDLED , "Les caractres SAX API (char ch[]... ne sont pas pris en charge par DTM !" } , { ER_IGNORABLE_WHITESPACE_NOT_HANDLED , "ignorableWhitespace(char ch[]... ne sont pas pris en charge par DTM !" } , { ER_DTM_CANNOT_HANDLE_NODES , "DTMLiaison ne peut pas prendre en charge les nuds de type {0}" } , { ER_XERCES_CANNOT_HANDLE_NODES , "DOM2Helper ne peut pas prendre en charge les nuds de type {0}" } , { ER_XERCES_PARSE_ERROR_DETAILS , "Erreur DOM2Helper.parse : ID systme - {0} ligne - {1}" } , { ER_XERCES_PARSE_ERROR , "Erreur DOM2Helper.parse" } , { ER_INVALID_UTF16_SURROGATE , "Substitut UTF-16 incorrect dtect : {0} ?" } , { ER_OIERROR , "Erreur dE/S" } , { ER_CANNOT_CREATE_URL , "Impossible de crer une url pour : {0}" } , { ER_XPATH_READOBJECT , "Dans XPath.readObject : {0}" } , { ER_FUNCTION_TOKEN_NOT_FOUND , "Unit lexicale function introuvable." } , { ER_CANNOT_DEAL_XPATH_TYPE , "Impossible doprer avec le type : {0} XPath" } , { ER_NODESET_NOT_MUTABLE , "Cet lment NodeSet nest pas mutable" } , { ER_NODESETDTM_NOT_MUTABLE , "Cet lment NodeSetDTM nest pas mutable" } , { ER_VAR_NOT_RESOLVABLE , "Variable non rsolue : {0}" } , { ER_NULL_ERROR_HANDLER , "Gestionnaire derreur vide" } , { ER_PROG_ASSERT_UNKNOWN_OPCODE , "Assertion du programmeur : code opration inconnu : {0}" } , { ER_ZERO_OR_ONE , "0 ou 1" } , { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "rtf() nest pas pris en charge par XRTreeFragSelectWrapper" } , { ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , "asNodeIterator() nest pas pris en charge par XRTreeFragSelectWrapper" } , { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , "fsb() nest pas pris en charge pour XStringForChars" } , { ER_COULD_NOT_FIND_VAR , "Impossible de trouver la variable nomme {0}" } , { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , "XStringForChars ne peut pas avoir de chane comme argument" } , { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , "Largument FastStringBuffer ne peut pas tre gal  null" } , { ER_TWO_OR_THREE , "2 ou 3" } , { ER_VARIABLE_ACCESSED_BEFORE_BIND , "Variable accde avant sa limite !" } , { ER_FSB_CANNOT_TAKE_STRING , "XStringForFSB ne peut pas tre une chane pour un argument!" } , { ER_SETTING_WALKER_ROOT_TO_NULL , "\n !!!! Erreur! Attribution d'une valeur null  la racine d'un walker !!!" } , { ER_NODESETDTM_CANNOT_ITERATE , "Ce NodeSetDTM ne peut pas tre rpt  un noeud prcdent !" } , { ER_NODESET_CANNOT_ITERATE , "Ce NodeSet ne peut pas tre rpt vers un noeud prcdent !" } , { ER_NODESETDTM_CANNOT_INDEX , "Ce NodeSetDTM ne peut pas excuter de fonctions d'indexation ou de comptage !" } , { ER_NODESET_CANNOT_INDEX , "Ce NodeSet ne peut pas excuter de fonctions d'indexation ou de comptage !" } , { ER_CANNOT_CALL_SETSHOULDCACHENODE , "Impossible d'appeler setShouldCacheNodes aprs avoir appel nextNode !" } , { ER_ONLY_ALLOWS , "{0} n''admet que les arguments {1} arguments" } , { ER_UNKNOWN_STEP , "Assertion du programmeur dans getNextStepPos : stepType inconnu : {0}" } , { ER_EXPECTED_REL_LOC_PATH , "Un chemin d'accs relatif tait attendu aprs le jeton '/' ou '//'." } , { ER_EXPECTED_LOC_PATH , "Un chemin d'accs tait attendu, mais l'objet suivant a t rencontr:  {0}" } , { ER_EXPECTED_LOC_STEP , "Une tape de positionnement t attendue  la suite de l'objet '/' ou '//'." } , { ER_EXPECTED_NODE_TEST , "Un test de noeud correspondant  NCName:* ou  QName tait attendu." } , { ER_EXPECTED_STEP_PATTERN , "Une forme d'tape tait attendue, mais '/' a t rencontr." } , { ER_EXPECTED_REL_PATH_PATTERN , "Une forme de chemin d'accs relatif tait attendue." } , { ER_CANT_CONVERT_TO_BOOLEAN , "Impossible de convertir {0} en valeur boolenne." } , { ER_CANT_CONVERT_TO_SINGLENODE , "Impossible de convertir {0} en noeud unique. Cette mthode d'obtention s'applique aux  types ANY_UNORDERED_NODE_TYPE et FIRST_ORDERED_NODE_TYPE." } , { ER_CANT_GET_SNAPSHOT_LENGTH , "Impossible d'obtenir une longueur d'instantan du type : {0}. Cette mthode d'obtention s'applique aux types UNORDERED_NODE_SNAPSHOT_TYPE et ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_NON_ITERATOR_TYPE , "Impossible d'itrer sur le type non rptiteur : {0}" } , { ER_DOC_MUTATED , "Le document a mut depuis que le rsultat a t renvoy. L'itrateur est incorrect." } , { ER_INVALID_XPATH_TYPE , "Argument de type XPath incorrect : {0}" } , { ER_EMPTY_XPATH_RESULT , "Objet de rsultat XPath vide" } , { ER_INCOMPATIBLE_TYPES , "Impossible de forcer le type renvoy : {0} dans le fichier : {1}" } , { ER_NULL_RESOLVER , "Impossible de rsoudre le prfixe sans dcomposeur de prfixe." } , { ER_CANT_CONVERT_TO_STRING , "Impossible de convertir {0} en chane ." } , { ER_NON_SNAPSHOT_TYPE , "Impossible d'appeler snapshotItem sur le type : {0}. Cette mthode s'applique aux types UNORDERED_NODE_SNAPSHOT_TYPE et ORDERED_NODE_SNAPSHOT_TYPE." } , { ER_WRONG_DOCUMENT , "Le noeud de contexte n'appartient pas au document associ  ce XPathEvaluator." } , { ER_WRONG_NODETYPE , "Le noeud de contexte n'est pas pris en charge." } , { ER_XPATH_ERROR , "Erreur inconnue dans XPath." } , { WG_LOCALE_NAME_NOT_HANDLED , "Le nom de l'environnement local dans la fonction format-number nest pas encore gr !" } , { WG_PROPERTY_NOT_SUPPORTED , "XSL Property non pris en charge : {0}" } , { WG_DONT_DO_ANYTHING_WITH_NS , "Ne rien faire pour linstant avec le nom d''espace {0} dans la proprit : {1}" } , { WG_SECURITY_EXCEPTION , "Interception de SecurityException ors de la tentative daccs  la proprit systme XSL : {0}" } , { WG_QUO_NO_LONGER_DEFINED , "Lancienne syntaxe: quo(...) nest plus dfinie dans XPath." } , { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST , "XPath requiert un objet driv pour mettre en oeuvre nodeTest !" } , { WG_FUNCTION_TOKEN_NOT_FOUND , "Unit lexicale function introuvable." } , { WG_COULDNOT_FIND_FUNCTION , "Impossible de trouver la fonction : {0}" } , { WG_CANNOT_MAKE_URL_FROM , "Impossible de crer une URL  partir de : {0}" } , { WG_EXPAND_ENTITIES_NOT_SUPPORTED , "Loption -E nest pas pris en charge pour lanalyseur syntaxique DTM" } , { WG_ILLEGAL_VARIABLE_REFERENCE , "L''lment VariableReference a t fourni pour la variable hors contexte ou sans dfinition !  Nom = {0}" } , { ER_UNSUPPORTED_ENCODING , "Codage non pris en charge : {0}" } , { "ui_language" , "fr" } , { "help_language" , "fr" } , { "language" , "fr" } , { "BAD_CODE" , "Paramtre pour createMessage hors limites" } , { "FORMAT_FAILED" , "Exception mise pendant lappel de messageFormat" } , { "version" , ">>>>>>> Version Xalan " } , { "version2" , "<<<<<<<" } , { "yes" , "oui" } , { "line" , "Ligne //" } , { "column" , "Colonne //" } , { "xsldone" , "XSLProcessor: termin" } , { "xpath_option" , "options xpath : " } , { "optionIN" , "   [-in inputXMLURL]" } , { "optionSelect" , "   [expression xpath -select]" } , { "optionMatch" , "   [correspondance  la forme -match (pour les diagnostics de correspondance)]" } , { "optionAnyExpr" , "Ou une expression xpath provoquera un chec de diagnostic" } , { "noParsermsg1" , "Echec de XSL Process." } , { "noParsermsg2" , "** Impossible de trouver lanalyseur syntaxique**" } , { "noParsermsg3" , "Veuillez vrifier votre chemin de classe." } , { "noParsermsg4" , "Si vous ne disposez pas de lanalyseur XML dIBM pour Java, vous pouvez le tlcharger  ladresse suivante" } , { "noParsermsg5" , "IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml" } } ; public static final String BAD_CODE = "BAD_CODE" ; public static final String FORMAT_FAILED = "FORMAT_FAILED" ; public static final String ERROR_RESOURCES = "org.apache.xpath.res.XPATHErrorResources" ; public static final String ERROR_STRING = "//error" ; public static final String ERROR_HEADER = "Erreur : " ; public static final String WARNING_HEADER = "Attention : " ; public static final String XSL_HEADER = "XSL " ; public static final String XML_HEADER = "XML " ; public static final String QUERY_HEADER = "FORME " ; public Object [ ] [ ] getContents ( ) { return contents ; } } 	1
package org . apache . xalan . extensions ; import javax . xml . transform . ErrorListener ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public interface ExpressionContext { public Node getContextNode ( ) ; public NodeIterator getContextNodes ( ) ; public ErrorListener getErrorListener ( ) ; public double toNumber ( Node n ) ; public String toString ( Node n ) ; public XObject getVariableOrParam ( org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException ; public org . apache . xpath . XPathContext getXPathContext ( ) throws javax . xml . transform . TransformerException ; } 	0
package org . apache . xalan . templates ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringWriter ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . SourceTreeManager ; import org . apache . xpath . XPathContext ; import org . apache . xpath . functions . Function2Args ; import org . apache . xpath . functions . WrongNumberArgsException ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class FuncDocument extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int docContext = dtm . getDocumentRoot ( context ) ; XObject arg = ( XObject ) this . getArg0 ( ) . execute ( xctxt ) ; String base = "" ; Expression arg1Expr = this . getArg1 ( ) ; if ( null != arg1Expr ) { XObject arg2 = arg1Expr . execute ( xctxt ) ; if ( XObject . CLASS_NODESET == arg2 . getType ( ) ) { int baseNode = arg2 . iter ( ) . nextNode ( ) ; if ( baseNode == DTM . NULL ) { warn ( xctxt , XSLTErrorResources . WG_EMPTY_SECOND_ARG , null ) ; XNodeSet nodes = new XNodeSet ( xctxt . getDTMManager ( ) ) ; return nodes ; } else { DTM baseDTM = xctxt . getDTM ( baseNode ) ; base = baseDTM . getDocumentBaseURI ( ) ; } } else { base = arg2 . str ( ) ; } } else { assertion ( null != xctxt . getNamespaceContext ( ) , "Namespace context can not be null!" ) ; base = xctxt . getNamespaceContext ( ) . getBaseIdentifier ( ) ; } XNodeSet nodes = new XNodeSet ( xctxt . getDTMManager ( ) ) ; NodeSetDTM mnl = nodes . mutableNodeset ( ) ; DTMIterator iterator = ( XObject . CLASS_NODESET == arg . getType ( ) ) ? arg . iter ( ) : null ; int pos = DTM . NULL ; while ( ( null == iterator ) || ( DTM . NULL != ( pos = iterator . nextNode ( ) ) ) ) { XMLString ref = ( null != iterator ) ? xctxt . getDTM ( pos ) . getStringValue ( pos ) : arg . xstr ( ) ; if ( null == arg1Expr && DTM . NULL != pos ) { DTM baseDTM = xctxt . getDTM ( pos ) ; base = baseDTM . getDocumentBaseURI ( ) ; } if ( null == ref ) continue ; if ( DTM . NULL == docContext ) { error ( xctxt , XSLTErrorResources . ER_NO_CONTEXT_OWNERDOC , null ) ; } int indexOfColon = ref . indexOf ( ':' ) ; int indexOfSlash = ref . indexOf ( '/' ) ; if ( ( indexOfColon != - 1 ) && ( indexOfSlash != - 1 ) && ( indexOfColon < indexOfSlash ) ) { base = null ; } int newDoc = getDoc ( xctxt , context , ref . toString ( ) , base ) ; if ( DTM . NULL != newDoc ) { if ( ! mnl . contains ( newDoc ) ) { mnl . addElement ( newDoc ) ; } } if ( null == iterator || newDoc == DTM . NULL ) break ; } return nodes ; } int getDoc ( XPathContext xctxt , int context , String uri , String base ) throws javax . xml . transform . TransformerException { SourceTreeManager treeMgr = xctxt . getSourceTreeManager ( ) ; Source source ; int newDoc ; try { source = treeMgr . resolveURI ( base , uri , xctxt . getSAXLocator ( ) ) ; newDoc = treeMgr . getNode ( source ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , ( SourceLocator ) xctxt . getSAXLocator ( ) , ioe ) ; } catch ( TransformerException te ) { throw new TransformerException ( te ) ; } if ( DTM . NULL != newDoc ) return newDoc ; if ( uri . length ( ) == 0 ) { uri = xctxt . getNamespaceContext ( ) . getBaseIdentifier ( ) ; try { source = treeMgr . resolveURI ( base , uri , xctxt . getSAXLocator ( ) ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , ( SourceLocator ) xctxt . getSAXLocator ( ) , ioe ) ; } } String diagnosticsString = null ; try { if ( ( null != uri ) && ( uri . toString ( ) . length ( ) > 0 ) ) { newDoc = treeMgr . getSourceTree ( source , xctxt . getSAXLocator ( ) , xctxt ) ; } else warn ( xctxt , XSLTErrorResources . WG_CANNOT_MAKE_URL_FROM , new Object [ ] { ( ( base == null ) ? "" : base ) + uri } ) ; } catch ( Throwable throwable ) { newDoc = DTM . NULL ; while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } if ( ( throwable instanceof NullPointerException ) || ( throwable instanceof ClassCastException ) ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ( Exception ) throwable ) ; } StringWriter sw = new StringWriter ( ) ; PrintWriter diagnosticsWriter = new PrintWriter ( sw ) ; if ( throwable instanceof TransformerException ) { TransformerException spe = ( TransformerException ) throwable ; { Throwable e = spe ; while ( null != e ) { if ( null != e . getMessage ( ) ) { diagnosticsWriter . println ( " (" + e . getClass ( ) . getName ( ) + "): " + e . getMessage ( ) ) ; } if ( e instanceof TransformerException ) { TransformerException spe2 = ( TransformerException ) e ; SourceLocator locator = spe2 . getLocator ( ) ; if ( ( null != locator ) && ( null != locator . getSystemId ( ) ) ) diagnosticsWriter . println ( "   ID: " + locator . getSystemId ( ) + " Line #" + locator . getLineNumber ( ) + " Column #" + locator . getColumnNumber ( ) ) ; e = spe2 . getException ( ) ; if ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } else e = null ; } } } else { diagnosticsWriter . println ( " (" + throwable . getClass ( ) . getName ( ) + "): " + throwable . getMessage ( ) ) ; } diagnosticsString = throwable . getMessage ( ) ; } if ( DTM . NULL == newDoc ) { if ( null != diagnosticsString ) { warn ( xctxt , XSLTErrorResources . WG_CANNOT_LOAD_REQUESTED_DOC , new Object [ ] { diagnosticsString } ) ; } else warn ( xctxt , XSLTErrorResources . WG_CANNOT_LOAD_REQUESTED_DOC , new Object [ ] { uri == null ? ( ( base == null ) ? "" : base ) + uri : uri . toString ( ) } ) ; } else { } return newDoc ; } public void error ( XPathContext xctxt , String msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; TransformerException spe = new TransformerException ( formattedMsg , ( SourceLocator ) xctxt . getSAXLocator ( ) ) ; if ( null != errHandler ) errHandler . error ( spe ) ; else System . out . println ( formattedMsg ) ; } public void warn ( XPathContext xctxt , String msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; TransformerException spe = new TransformerException ( formattedMsg , ( SourceLocator ) xctxt . getSAXLocator ( ) ) ; if ( null != errHandler ) errHandler . warning ( spe ) ; else System . out . println ( formattedMsg ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( ( argNum < 1 ) || ( argNum > 2 ) ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ONE_OR_TWO , null ) ) ; } public boolean isNodesetExpr ( ) { return true ; } } 	1
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . NodeIterator ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; public abstract class NodeIteratorBase implements NodeIterator { protected int _last = - 1 ; protected int _position = 0 ; protected int _markedNode ; protected int _startNode = NodeIterator . END ; protected boolean _includeSelf = false ; protected boolean _isRestartable = true ; public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; } abstract public NodeIterator setStartNode ( int node ) ; public NodeIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _includeSelf ? _startNode + 1 : _startNode ) ; _isRestartable = temp ; return this ; } public NodeIterator includeSelf ( ) { _includeSelf = true ; return this ; } public int getLast ( ) { if ( _last == - 1 ) { final int temp = _position ; setMark ( ) ; reset ( ) ; do { _last ++ ; } while ( next ( ) != END ) ; gotoMark ( ) ; _position = temp ; } return _last ; } public int getPosition ( ) { return _position == 0 ? 1 : _position ; } public boolean isReverse ( ) { return false ; } public NodeIterator cloneIterator ( ) { try { final NodeIteratorBase clone = ( NodeIteratorBase ) super . clone ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } protected final int returnNode ( final int node ) { _position ++ ; return node ; } protected final NodeIterator resetPosition ( ) { _position = 0 ; return this ; } } 	0
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncRound extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( java . lang . Math . floor ( m_arg0 . execute ( xctxt ) . num ( ) + 0.5 ) ) ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; abstract class Instruction extends SyntaxTreeNode { public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . NOT_IMPLEMENTED_ERR , getClass ( ) , this ) ; getParser ( ) . reportError ( FATAL , msg ) ; } } 	0
package org . apache . xalan . trace ; public interface TraceListenerEx2 extends TraceListenerEx { public void traceEnd ( TracerEvent ev ) ; } 	1
package org . w3c . dom . xpath ; public interface XPathNSResolver { public String lookupNamespaceURI ( String prefix ) ; } 	0
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFNULL ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Copy extends Instruction { private UseAttributeSets _useSets ; public void parseContents ( Parser parser ) { final String useSets = getAttribute ( "use-attribute-sets" ) ; if ( useSets . length ( ) > 0 ) { _useSets = new UseAttributeSets ( useSets , parser ) ; } parseChildren ( parser ) ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Copy" ) ; indent ( indent + IndentIncrement ) ; displayContents ( indent + IndentIncrement ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _useSets != null ) { _useSets . typeCheck ( stable ) ; } typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final LocalVariableGen name = methodGen . addLocalVariable2 ( "name" , Util . getJCRefType ( STRING_SIG ) , il . getEnd ( ) ) ; final LocalVariableGen length = methodGen . addLocalVariable2 ( "length" , Util . getJCRefType ( "I" ) , il . getEnd ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; final int cpy = cpg . addInterfaceMethodref ( DOM_INTF , "shallowCopy" , "(" + NODE_SIG + TRANSLET_OUTPUT_SIG + ")" + STRING_SIG ) ; il . append ( new INVOKEINTERFACE ( cpy , 3 ) ) ; il . append ( DUP ) ; il . append ( new ASTORE ( name . getIndex ( ) ) ) ; final BranchHandle ifBlock1 = il . append ( new IFNULL ( null ) ) ; il . append ( new ALOAD ( name . getIndex ( ) ) ) ; final int lengthMethod = cpg . addMethodref ( STRING_CLASS , "length" , "()I" ) ; il . append ( new INVOKEVIRTUAL ( lengthMethod ) ) ; il . append ( new ISTORE ( length . getIndex ( ) ) ) ; if ( _useSets != null ) { final SyntaxTreeNode parent = getParent ( ) ; if ( ( parent instanceof LiteralElement ) || ( parent instanceof LiteralElement ) ) { _useSets . translate ( classGen , methodGen ) ; } else { il . append ( new ILOAD ( length . getIndex ( ) ) ) ; final BranchHandle ifBlock2 = il . append ( new IFEQ ( null ) ) ; _useSets . translate ( classGen , methodGen ) ; ifBlock2 . setTarget ( il . append ( NOP ) ) ; } } translateContents ( classGen , methodGen ) ; il . append ( new ILOAD ( length . getIndex ( ) ) ) ; final BranchHandle ifBlock3 = il . append ( new IFEQ ( null ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new ALOAD ( name . getIndex ( ) ) ) ; il . append ( methodGen . endElement ( ) ) ; final InstructionHandle end = il . append ( NOP ) ; ifBlock1 . setTarget ( end ) ; ifBlock3 . setTarget ( end ) ; methodGen . removeLocalVariable ( name ) ; methodGen . removeLocalVariable ( length ) ; } } 	1
package org . apache . xml . serializer ; import org . xml . sax . SAXException ; public interface ExtendedLexicalHandler extends org . xml . sax . ext . LexicalHandler { public void comment ( String comment ) throws SAXException ; } 	0
package org . apache . xalan . templates ; import org . apache . xpath . XPath ; public class ElemWhen extends ElemTemplateElement { private XPath m_test ; public void setTest ( XPath v ) { m_test = v ; } public XPath getTest ( ) { return m_test ; } public int getXSLToken ( ) { return Constants . ELEMNAME_WHEN ; } public void compose ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_test ) m_test . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public String getNodeName ( ) { return Constants . ELEMNAME_WHEN_STRING ; } public ElemWhen ( ) { } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_test . getExpression ( ) . callVisitors ( m_test , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	1
package org . w3c . dom . xpath ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; public interface XPathNamespace extends Node { public static final short XPATH_NAMESPACE_NODE = 13 ; public Element getOwnerElement ( ) ; } 	0
package org . apache . xpath ; import java . io . Serializable ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . compiler . FunctionTable ; import org . apache . xpath . compiler . XPathParser ; import org . apache . xpath . functions . Function ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class XPath implements Serializable , ExpressionOwner { private Expression m_mainExp ; public Expression getExpression ( ) { return m_mainExp ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { m_mainExp . fixupVariables ( vars , globalsSize ) ; } public void setExpression ( Expression exp ) { if ( null != m_mainExp ) exp . exprSetParent ( m_mainExp . exprGetParent ( ) ) ; m_mainExp = exp ; } public SourceLocator getLocator ( ) { return m_mainExp ; } String m_patternString ; public String getPatternString ( ) { return m_patternString ; } public static final int SELECT = 0 ; public static final int MATCH = 1 ; public XPath ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type , ErrorListener errorListener ) throws javax . xml . transform . TransformerException { if ( null == errorListener ) errorListener = new org . apache . xml . utils . DefaultErrorHandler ( ) ; m_patternString = exprString ; XPathParser parser = new XPathParser ( errorListener , locator ) ; Compiler compiler = new Compiler ( errorListener , locator ) ; if ( SELECT == type ) parser . initXPath ( compiler , exprString , prefixResolver ) ; else if ( MATCH == type ) parser . initMatchPattern ( compiler , exprString , prefixResolver ) ; else throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_CANNOT_DEAL_XPATH_TYPE , new Object [ ] { Integer . toString ( type ) } ) ) ; Expression expr = compiler . compile ( 0 ) ; this . setExpression ( expr ) ; if ( ( null != locator ) && locator instanceof ExpressionNode ) { expr . exprSetParent ( ( ExpressionNode ) locator ) ; } } public XPath ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type ) throws javax . xml . transform . TransformerException { this ( exprString , locator , prefixResolver , type , null ) ; } public XPath ( Expression expr ) { this . setExpression ( expr ) ; } public XObject execute ( XPathContext xctxt , org . w3c . dom . Node contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { return execute ( xctxt , xctxt . getDTMHandleFromNode ( contextNode ) , namespaceContext ) ; } public XObject execute ( XPathContext xctxt , int contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { xctxt . pushNamespaceContext ( namespaceContext ) ; xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; XObject xobj = null ; try { xobj = m_mainExp . execute ( xctxt ) ; } catch ( TransformerException te ) { te . setLocator ( this . getLocator ( ) ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . error ( te ) ; } else throw te ; } catch ( Exception e ) { while ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } String msg = e . getMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { msg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_XPATH_ERROR , null ) ; } TransformerException te = new TransformerException ( msg , getLocator ( ) , e ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . fatalError ( te ) ; } else throw te ; } finally { xctxt . popNamespaceContext ( ) ; xctxt . popCurrentNodeAndExpression ( ) ; } return xobj ; } public boolean bool ( XPathContext xctxt , int contextNode , PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { xctxt . pushNamespaceContext ( namespaceContext ) ; xctxt . pushCurrentNodeAndExpression ( contextNode , contextNode ) ; try { return m_mainExp . bool ( xctxt ) ; } catch ( TransformerException te ) { te . setLocator ( this . getLocator ( ) ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . error ( te ) ; } else throw te ; } catch ( Exception e ) { while ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) { e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } String msg = e . getMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { msg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_XPATH_ERROR , null ) ; } TransformerException te = new TransformerException ( msg , getLocator ( ) , e ) ; ErrorListener el = xctxt . getErrorListener ( ) ; if ( null != el ) { el . fatalError ( te ) ; } else throw te ; } finally { xctxt . popNamespaceContext ( ) ; xctxt . popCurrentNodeAndExpression ( ) ; } return false ; } private static final boolean DEBUG_MATCHES = false ; public double getMatchScore ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { xctxt . pushCurrentNode ( context ) ; xctxt . pushCurrentExpressionNode ( context ) ; try { XObject score = m_mainExp . execute ( xctxt ) ; if ( DEBUG_MATCHES ) { DTM dtm = xctxt . getDTM ( context ) ; System . out . println ( "score: " + score . num ( ) + " for " + dtm . getNodeName ( context ) + " for xpath " + this . getPatternString ( ) ) ; } return score . num ( ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popCurrentExpressionNode ( ) ; } } public void installFunction ( String name , int funcIndex , Function func ) { FunctionTable . installFunction ( func , funcIndex ) ; } public void warn ( XPathContext xctxt , int sourceNode , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { String fmsg = XSLMessages . createXPATHWarning ( msg , args ) ; ErrorListener ehandler = xctxt . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . warning ( new TransformerException ( fmsg , ( SAXSourceLocator ) xctxt . getSAXLocator ( ) ) ) ; } } public void assertion ( boolean b , String msg ) { if ( ! b ) { String fMsg = XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_INCORRECT_PROGRAMMER_ASSERTION , new Object [ ] { msg } ) ; throw new RuntimeException ( fMsg ) ; } } public void error ( XPathContext xctxt , int sourceNode , String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; ErrorListener ehandler = xctxt . getErrorListener ( ) ; if ( null != ehandler ) { ehandler . fatalError ( new TransformerException ( fmsg , ( SAXSourceLocator ) xctxt . getSAXLocator ( ) ) ) ; } else { SourceLocator slocator = xctxt . getSAXLocator ( ) ; System . out . println ( fmsg + "; file " + slocator . getSystemId ( ) + "; line " + slocator . getLineNumber ( ) + "; column " + slocator . getColumnNumber ( ) ) ; } } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { m_mainExp . callVisitors ( this , visitor ) ; } public static final double MATCH_SCORE_NONE = Double . NEGATIVE_INFINITY ; public static final double MATCH_SCORE_QNAME = 0.0 ; public static final double MATCH_SCORE_NSWILD = - 0.25 ; public static final double MATCH_SCORE_NODETEST = - 0.5 ; public static final double MATCH_SCORE_OTHER = 0.5 ; } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class LiteralAttribute extends Instruction { private final String _name ; private final AttributeValue _value ; public LiteralAttribute ( String name , String value , Parser parser ) { _name = name ; _value = AttributeValue . create ( this , value , parser ) ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "LiteralAttribute name=" + _name + " value=" + _value ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _value . typeCheck ( stable ) ; typeCheckContents ( stable ) ; return Type . Void ; } protected boolean contextDependent ( ) { return _value . contextDependent ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _name ) ) ; _value . translate ( classGen , methodGen ) ; il . append ( methodGen . attribute ( ) ) ; } } 	0
package org . apache . xalan . transformer ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . w3c . dom . Node ; public class MsgMgr { public MsgMgr ( TransformerImpl transformer ) { m_transformer = transformer ; } private TransformerImpl m_transformer ; public void message ( SourceLocator srcLctr , String msg , boolean terminate ) throws TransformerException { ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) { errHandler . warning ( new TransformerException ( msg , srcLctr ) ) ; } else { if ( terminate ) throw new TransformerException ( msg , srcLctr ) ; else System . out . println ( msg ) ; } } public void warn ( SourceLocator srcLctr , String msg ) throws TransformerException { warn ( srcLctr , null , null , msg , null ) ; } public void warn ( SourceLocator srcLctr , String msg , Object [ ] args ) throws TransformerException { warn ( srcLctr , null , null , msg , args ) ; } public void warn ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg ) throws TransformerException { warn ( srcLctr , styleNode , sourceNode , msg , null ) ; } public void warn ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg , Object args [ ] ) throws TransformerException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . warning ( new TransformerException ( formattedMsg , srcLctr ) ) ; else System . out . println ( formattedMsg ) ; } public void error ( SourceLocator srcLctr , String msg ) throws TransformerException { error ( srcLctr , null , null , msg , null ) ; } public void error ( SourceLocator srcLctr , String msg , Object [ ] args ) throws TransformerException { error ( srcLctr , null , null , msg , args ) ; } public void error ( SourceLocator srcLctr , String msg , Exception e ) throws TransformerException { error ( srcLctr , msg , null , e ) ; } public void error ( SourceLocator srcLctr , String msg , Object args [ ] , Exception e ) throws TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . fatalError ( new TransformerException ( formattedMsg , srcLctr ) ) ; else throw new TransformerException ( formattedMsg , srcLctr ) ; } public void error ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg ) throws TransformerException { error ( srcLctr , styleNode , sourceNode , msg , null ) ; } public void error ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg , Object args [ ] ) throws TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . fatalError ( new TransformerException ( formattedMsg , srcLctr ) ) ; else throw new TransformerException ( formattedMsg , srcLctr ) ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class AlternativePattern extends Pattern { private final Pattern _left ; private final Pattern _right ; public AlternativePattern ( Pattern left , Pattern right ) { _left = left ; _right = right ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public Pattern getLeft ( ) { return _left ; } public Pattern getRight ( ) { return _right ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _left . typeCheck ( stable ) ; _right . typeCheck ( stable ) ; return null ; } public double getPriority ( ) { double left = _left . getPriority ( ) ; double right = _right . getPriority ( ) ; if ( left < right ) return ( left ) ; else return ( right ) ; } public String toString ( ) { return "alternative(" + _left + ", " + _right + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; final InstructionHandle gotot = il . append ( new GOTO ( null ) ) ; il . append ( methodGen . loadContextNode ( ) ) ; _right . translate ( classGen , methodGen ) ; _left . _trueList . backPatch ( gotot ) ; _left . _falseList . backPatch ( gotot . getNext ( ) ) ; _trueList . append ( _right . _trueList . add ( gotot ) ) ; _falseList . append ( _right . _falseList ) ; } } 	0
package org . apache . xalan . transformer ; import java . util . Locale ; import java . util . NoSuchElementException ; import org . w3c . dom . Element ; class NumeratorFormatter { protected Element m_xslNumberElement ; NumberFormatStringTokenizer m_formatTokenizer ; Locale m_locale ; java . text . NumberFormat m_formatter ; TransformerImpl m_processor ; private final static DecimalToRoman m_romanConvertTable [ ] = { new DecimalToRoman ( 1000 , "M" , 900 , "CM" ) , new DecimalToRoman ( 500 , "D" , 400 , "CD" ) , new DecimalToRoman ( 100L , "C" , 90L , "XC" ) , new DecimalToRoman ( 50L , "L" , 40L , "XL" ) , new DecimalToRoman ( 10L , "X" , 9L , "IX" ) , new DecimalToRoman ( 5L , "V" , 4L , "IV" ) , new DecimalToRoman ( 1L , "I" , 1L , "I" ) } ; private final static char [ ] m_alphaCountTable = { 'Z' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' } ; NumeratorFormatter ( Element xslNumberElement , TransformerImpl processor ) { m_xslNumberElement = xslNumberElement ; m_processor = processor ; } protected String int2alphaCount ( int val , char [ ] table ) { int radix = table . length ; char buf [ ] = new char [ 100 ] ; int charPos = buf . length - 1 ; int lookupIndex = 1 ; int correction = 0 ; do { correction = ( ( lookupIndex == 0 ) || ( correction != 0 && lookupIndex == radix - 1 ) ) ? ( radix - 1 ) : 0 ; lookupIndex = ( val + correction ) % radix ; val = ( val / radix ) ; if ( lookupIndex == 0 && val == 0 ) break ; buf [ charPos -- ] = table [ lookupIndex ] ; } while ( val > 0 ) ; return new String ( buf , charPos + 1 , ( buf . length - charPos - 1 ) ) ; } String long2roman ( long val , boolean prefixesAreOK ) { if ( val <= 0 ) { return "#E(" + val + ")" ; } String roman = "" ; int place = 0 ; if ( val <= 3999L ) { do { while ( val >= m_romanConvertTable [ place ] . m_postValue ) { roman += m_romanConvertTable [ place ] . m_postLetter ; val -= m_romanConvertTable [ place ] . m_postValue ; } if ( prefixesAreOK ) { if ( val >= m_romanConvertTable [ place ] . m_preValue ) { roman += m_romanConvertTable [ place ] . m_preLetter ; val -= m_romanConvertTable [ place ] . m_preValue ; } } place ++ ; } while ( val > 0 ) ; } else { roman = "#error" ; } return roman ; } class NumberFormatStringTokenizer { private int currentPosition ; private int maxPosition ; private String str ; NumberFormatStringTokenizer ( String str ) { this . str = str ; maxPosition = str . length ( ) ; } void reset ( ) { currentPosition = 0 ; } String nextToken ( ) { if ( currentPosition >= maxPosition ) { throw new NoSuchElementException ( ) ; } int start = currentPosition ; while ( ( currentPosition < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) { currentPosition ++ ; } if ( ( start == currentPosition ) && ( ! Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) ) { currentPosition ++ ; } return str . substring ( start , currentPosition ) ; } boolean hasMoreTokens ( ) { return ( currentPosition >= maxPosition ) ? false : true ; } int countTokens ( ) { int count = 0 ; int currpos = currentPosition ; while ( currpos < maxPosition ) { int start = currpos ; while ( ( currpos < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currpos ) ) ) { currpos ++ ; } if ( ( start == currpos ) && ( Character . isLetterOrDigit ( str . charAt ( currpos ) ) == false ) ) { currpos ++ ; } count ++ ; } return count ; } } } 	1
package org . apache . xalan . lib ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public abstract class ExsltBase { protected static String toString ( Node n ) { if ( n instanceof DTMNodeProxy ) return ( ( DTMNodeProxy ) n ) . getStringValue ( ) ; else { String value = n . getNodeValue ( ) ; if ( value == null ) { NodeList nodelist = n . getChildNodes ( ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Node childNode = nodelist . item ( i ) ; buf . append ( toString ( childNode ) ) ; } return buf . toString ( ) ; } else return value ; } } protected static double toNumber ( Node n ) { double d = 0.0 ; String str = toString ( n ) ; try { d = Double . valueOf ( str ) . doubleValue ( ) ; } catch ( NumberFormatException e ) { d = Double . NaN ; } return d ; } } 	0
package org . apache . xml . dtm . ref . sax2dtm ; import org . apache . xml . dtm . * ; import org . apache . xml . dtm . ref . * ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . XMLString ; import org . apache . xml . utils . XMLStringDefault ; import org . apache . xml . utils . XMLStringFactory ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . serializer . SerializationHandler ; import javax . xml . transform . Source ; import java . util . Vector ; import org . xml . sax . * ; public class SAX2DTM2 extends SAX2DTM { public final class ChildrenIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch2 ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode != NULL ) { int node = _currentNode ; _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return END ; } } public final class ParentIterator extends InternalAxisIteratorBase { private int _nodeType = DTM . NULL ; public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; if ( node != DTM . NULL ) _currentNode = _parent2 ( makeNodeIdentity ( node ) ) ; else _currentNode = DTM . NULL ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator setNodeType ( final int type ) { _nodeType = type ; return this ; } public int next ( ) { int result = _currentNode ; if ( result == END ) return DTM . NULL ; if ( _nodeType == NULL ) { _currentNode = END ; return returnNode ( makeNodeHandle ( result ) ) ; } else if ( _nodeType >= DTM . NTYPES ) { if ( _nodeType == _exptype2 ( result ) ) { _currentNode = END ; return returnNode ( makeNodeHandle ( result ) ) ; } } else { if ( _nodeType == _type2 ( result ) ) { _currentNode = END ; return returnNode ( makeNodeHandle ( result ) ) ; } } return DTM . NULL ; } } public final class TypedChildrenIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedChildrenIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = ( node == DTM . NULL ) ? DTM . NULL : _firstch2 ( makeNodeIdentity ( _startNode ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; if ( node == DTM . NULL ) return DTM . NULL ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != DTM . NULL && _exptype2 ( node ) != nodeType ) { node = _nextsib2 ( node ) ; } } else { int eType ; while ( node != DTM . NULL ) { eType = _exptype2 ( node ) ; if ( eType >= DTM . NTYPES ) break ; else node = _nextsib2 ( node ) ; } } if ( node == DTM . NULL ) { _currentNode = DTM . NULL ; return DTM . NULL ; } else { _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } public int getNodeByPosition ( int position ) { if ( position <= 0 ) return DTM . NULL ; int node = _currentNode ; int pos = 0 ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != DTM . NULL ) { if ( _exptype2 ( node ) == nodeType ) { pos ++ ; if ( pos == position ) return makeNodeHandle ( node ) ; } node = _nextsib2 ( node ) ; } return NULL ; } else { while ( node != DTM . NULL ) { if ( _exptype2 ( node ) >= DTM . NTYPES ) { pos ++ ; if ( pos == position ) return makeNodeHandle ( node ) ; } node = _nextsib2 ( node ) ; } return NULL ; } } } public class TypedRootIterator extends RootIterator { private final int _nodeType ; public TypedRootIterator ( int nodeType ) { super ( ) ; _nodeType = nodeType ; } public int next ( ) { if ( _startNode == _currentNode ) return NULL ; final int node = _startNode ; int expType = _exptype2 ( makeNodeIdentity ( node ) ) ; _currentNode = node ; if ( _nodeType >= DTM . NTYPES ) { if ( _nodeType == expType ) { return returnNode ( node ) ; } } else { if ( expType < DTM . NTYPES ) { if ( expType == _nodeType ) { return returnNode ( node ) ; } } else { if ( m_extendedTypes [ expType ] . getNodeType ( ) == _nodeType ) { return returnNode ( node ) ; } } } return NULL ; } } public class FollowingSiblingIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = makeNodeIdentity ( node ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { _currentNode = ( _currentNode == DTM . NULL ) ? DTM . NULL : _nextsib2 ( _currentNode ) ; return returnNode ( makeNodeHandle ( _currentNode ) ) ; } } public final class TypedFollowingSiblingIterator extends FollowingSiblingIterator { private final int _nodeType ; public TypedFollowingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { if ( _currentNode == DTM . NULL ) { return DTM . NULL ; } int node = _currentNode ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( ( node = _nextsib2 ( node ) ) != DTM . NULL && _exptype2 ( node ) != nodeType ) { } } else { while ( ( node = _nextsib2 ( node ) ) != DTM . NULL && _exptype2 ( node ) < DTM . NTYPES ) { } } _currentNode = node ; return ( node == DTM . NULL ) ? DTM . NULL : returnNode ( makeNodeHandle ( node ) ) ; } } public final class AttributeIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; _currentNode = getFirstAttributeIdentity ( makeNodeIdentity ( node ) ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; if ( node != NULL ) { _currentNode = getNextAttributeIdentity ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } return NULL ; } } public final class TypedAttributeIterator extends InternalAxisIteratorBase { private final int _nodeType ; public TypedAttributeIterator ( int nodeType ) { _nodeType = nodeType ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; _currentNode = getTypedAttribute ( node , _nodeType ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { final int node = _currentNode ; _currentNode = NULL ; return returnNode ( node ) ; } } public class PrecedingSiblingIterator extends InternalAxisIteratorBase { protected int _startNodeID ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; node = _startNodeID = makeNodeIdentity ( node ) ; if ( node == NULL ) { _currentNode = node ; return resetPosition ( ) ; } int type = _type2 ( node ) ; if ( ExpandedNameTable . ATTRIBUTE == type || ExpandedNameTable . NAMESPACE == type ) { _currentNode = node ; } else { _currentNode = _parent2 ( node ) ; if ( NULL != _currentNode ) _currentNode = _firstch2 ( _currentNode ) ; else _currentNode = node ; } return resetPosition ( ) ; } return this ; } public int next ( ) { if ( _currentNode == _startNodeID || _currentNode == DTM . NULL ) { return NULL ; } else { final int node = _currentNode ; _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } } public final class TypedPrecedingSiblingIterator extends PrecedingSiblingIterator { private final int _nodeType ; public TypedPrecedingSiblingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; final int nodeType = _nodeType ; final int startNodeID = _startNodeID ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != NULL && node != startNodeID && _exptype2 ( node ) != nodeType ) { node = _nextsib2 ( node ) ; } } else { while ( node != NULL && node != startNodeID && _exptype2 ( node ) < DTM . NTYPES ) { node = _nextsib2 ( node ) ; } } if ( node == DTM . NULL || node == startNodeID ) { _currentNode = NULL ; return NULL ; } else { _currentNode = _nextsib2 ( node ) ; return returnNode ( makeNodeHandle ( node ) ) ; } } public int getLast ( ) { if ( _last != - 1 ) return _last ; setMark ( ) ; int node = _currentNode ; final int nodeType = _nodeType ; final int startNodeID = _startNodeID ; int last = 0 ; if ( nodeType != DTM . ELEMENT_NODE ) { while ( node != NULL && node != startNodeID ) { if ( _exptype2 ( node ) == nodeType ) { last ++ ; } node = _nextsib2 ( node ) ; } } else { while ( node != NULL && node != startNodeID ) { if ( _exptype2 ( node ) >= DTM . NTYPES ) { last ++ ; } node = _nextsib2 ( node ) ; } } gotoMark ( ) ; return ( _last = last ) ; } } public class PrecedingIterator extends InternalAxisIteratorBase { private final int _maxAncestors = 8 ; protected int [ ] _stack = new int [ _maxAncestors ] ; protected int _sp , _oldsp ; protected int _markedsp , _markedNode , _markedDescendant ; public boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final PrecedingIterator clone = ( PrecedingIterator ) super . clone ( ) ; final int [ ] stackCopy = new int [ _stack . length ] ; System . arraycopy ( _stack , 0 , stackCopy , 0 , _stack . length ) ; clone . _stack = stackCopy ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; int parent , index ; if ( _type2 ( node ) == DTM . ATTRIBUTE_NODE ) node = _parent2 ( node ) ; _startNode = node ; _stack [ index = 0 ] = node ; parent = node ; while ( ( parent = _parent2 ( parent ) ) != NULL ) { if ( ++ index == _stack . length ) { final int [ ] stack = new int [ index * 2 ] ; System . arraycopy ( _stack , 0 , stack , 0 , index ) ; _stack = stack ; } _stack [ index ] = parent ; } if ( index > 0 ) -- index ; _currentNode = _stack [ index ] ; _oldsp = _sp = index ; return resetPosition ( ) ; } return this ; } public int next ( ) { for ( ++ _currentNode ; _sp >= 0 ; ++ _currentNode ) { if ( _currentNode < _stack [ _sp ] ) { int type = _type2 ( _currentNode ) ; if ( type != ATTRIBUTE_NODE && type != NAMESPACE_NODE ) return returnNode ( makeNodeHandle ( _currentNode ) ) ; } else -- _sp ; } return NULL ; } public DTMAxisIterator reset ( ) { _sp = _oldsp ; return resetPosition ( ) ; } public void setMark ( ) { _markedsp = _sp ; _markedNode = _currentNode ; _markedDescendant = _stack [ 0 ] ; } public void gotoMark ( ) { _sp = _markedsp ; _currentNode = _markedNode ; } } public final class TypedPrecedingIterator extends PrecedingIterator { private final int _nodeType ; public TypedPrecedingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int node = _currentNode ; final int nodeType = _nodeType ; if ( nodeType >= DTM . NTYPES ) { while ( true ) { node ++ ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else if ( _exptype2 ( node ) == nodeType ) { break ; } } } else { int expType ; while ( true ) { node ++ ; if ( _sp < 0 ) { node = NULL ; break ; } else if ( node >= _stack [ _sp ] ) { if ( -- _sp < 0 ) { node = NULL ; break ; } } else { expType = _exptype2 ( node ) ; if ( expType < DTM . NTYPES ) { if ( expType == nodeType ) { break ; } } else { if ( m_extendedTypes [ expType ] . getNodeType ( ) == nodeType ) { break ; } } } } } _currentNode = node ; return ( node == NULL ) ? NULL : returnNode ( makeNodeHandle ( node ) ) ; } } public class FollowingIterator extends InternalAxisIteratorBase { public FollowingIterator ( ) { } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { _startNode = node ; node = makeNodeIdentity ( node ) ; int first ; int type = _type2 ( node ) ; if ( ( DTM . ATTRIBUTE_NODE == type ) || ( DTM . NAMESPACE_NODE == type ) ) { node = _parent2 ( node ) ; first = _firstch2 ( node ) ; if ( NULL != first ) { _currentNode = makeNodeHandle ( first ) ; return resetPosition ( ) ; } } do { first = _nextsib2 ( node ) ; if ( NULL == first ) node = _parent2 ( node ) ; } while ( NULL == first && NULL != node ) ; _currentNode = makeNodeHandle ( first ) ; return resetPosition ( ) ; } return this ; } public int next ( ) { int node = _currentNode ; int current = makeNodeIdentity ( node ) ; while ( true ) { current ++ ; int type = _type2 ( current ) ; if ( NULL == type ) { _currentNode = NULL ; return returnNode ( node ) ; } if ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) continue ; _currentNode = makeNodeHandle ( current ) ; return returnNode ( node ) ; } } } public final class TypedFollowingIterator extends FollowingIterator { private final int _nodeType ; public TypedFollowingIterator ( int type ) { _nodeType = type ; } public int next ( ) { int current ; int node ; int type ; final int nodeType = _nodeType ; int currentNodeID = makeNodeIdentity ( _currentNode ) ; if ( nodeType >= DTM . NTYPES ) { do { node = currentNodeID ; current = node ; do { current ++ ; type = _type2 ( current ) ; } while ( type != NULL && ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) ) ; currentNodeID = ( type != NULL ) ? current : NULL ; } while ( node != DTM . NULL && _exptype2 ( node ) != nodeType ) ; } else { do { node = currentNodeID ; current = node ; do { current ++ ; type = _type2 ( current ) ; } while ( type != NULL && ( ATTRIBUTE_NODE == type || NAMESPACE_NODE == type ) ) ; currentNodeID = ( type != NULL ) ? current : NULL ; } while ( node != DTM . NULL && ( _exptype2 ( node ) != nodeType && _type2 ( node ) != nodeType ) ) ; } _currentNode = makeNodeHandle ( currentNodeID ) ; return ( node == DTM . NULL ? DTM . NULL : returnNode ( makeNodeHandle ( node ) ) ) ; } } public class AncestorIterator extends InternalAxisIteratorBase { private static final int m_blocksize = 32 ; int [ ] m_ancestors = new int [ m_blocksize ] ; int m_size = 0 ; int m_ancestorsPos ; int m_markedPos ; int m_realStartNode ; public int getStartNode ( ) { return m_realStartNode ; } public final boolean isReverse ( ) { return true ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final AncestorIterator clone = ( AncestorIterator ) super . clone ( ) ; clone . _startNode = _startNode ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; if ( nodeID == DTM . NULL ) { _currentNode = DTM . NULL ; m_ancestorsPos = 0 ; return this ; } if ( ! _includeSelf ) { nodeID = _parent2 ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } _startNode = node ; while ( nodeID != END ) { if ( m_size >= m_ancestors . length ) { int [ ] newAncestors = new int [ m_size * 2 ] ; System . arraycopy ( m_ancestors , 0 , newAncestors , 0 , m_ancestors . length ) ; m_ancestors = newAncestors ; } m_ancestors [ m_size ++ ] = node ; nodeID = _parent2 ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } m_ancestorsPos = m_size - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { m_ancestorsPos = m_size - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return resetPosition ( ) ; } public int next ( ) { int next = _currentNode ; int pos = -- m_ancestorsPos ; _currentNode = ( pos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return returnNode ( next ) ; } public void setMark ( ) { m_markedPos = m_ancestorsPos ; } public void gotoMark ( ) { m_ancestorsPos = m_markedPos ; _currentNode = m_ancestorsPos >= 0 ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; } } public final class TypedAncestorIterator extends AncestorIterator { private final int _nodeType ; public TypedAncestorIterator ( int type ) { _nodeType = type ; } public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; m_realStartNode = node ; if ( _isRestartable ) { int nodeID = makeNodeIdentity ( node ) ; if ( nodeID == DTM . NULL ) { _currentNode = DTM . NULL ; m_ancestorsPos = 0 ; return this ; } final int nodeType = _nodeType ; if ( ! _includeSelf ) { nodeID = _parent2 ( nodeID ) ; node = makeNodeHandle ( nodeID ) ; } _startNode = node ; if ( nodeType >= DTM . NTYPES ) { while ( nodeID != END ) { int eType = _exptype2 ( nodeID ) ; if ( eType == nodeType ) { if ( m_size >= m_ancestors . length ) { int [ ] newAncestors = new int [ m_size * 2 ] ; System . arraycopy ( m_ancestors , 0 , newAncestors , 0 , m_ancestors . length ) ; m_ancestors = newAncestors ; } m_ancestors [ m_size ++ ] = makeNodeHandle ( nodeID ) ; } nodeID = _parent2 ( nodeID ) ; } } else { while ( nodeID != END ) { int eType = _exptype2 ( nodeID ) ; if ( ( eType < DTM . NTYPES && eType == nodeType ) || ( eType >= DTM . NTYPES && m_extendedTypes [ eType ] . getNodeType ( ) == nodeType ) ) { if ( m_size >= m_ancestors . length ) { int [ ] newAncestors = new int [ m_size * 2 ] ; System . arraycopy ( m_ancestors , 0 , newAncestors , 0 , m_ancestors . length ) ; m_ancestors = newAncestors ; } m_ancestors [ m_size ++ ] = makeNodeHandle ( nodeID ) ; } nodeID = _parent2 ( nodeID ) ; } } m_ancestorsPos = m_size - 1 ; _currentNode = ( m_ancestorsPos >= 0 ) ? m_ancestors [ m_ancestorsPos ] : DTM . NULL ; return resetPosition ( ) ; } return this ; } public int getNodeByPosition ( int position ) { if ( position > 0 && position <= m_size ) { return m_ancestors [ position - 1 ] ; } else return DTM . NULL ; } public int getLast ( ) { return m_size ; } } public class DescendantIterator extends InternalAxisIteratorBase { public DTMAxisIterator setStartNode ( int node ) { if ( node == DTMDefaultBase . ROOTNODE ) node = getDocument ( ) ; if ( _isRestartable ) { node = makeNodeIdentity ( node ) ; _startNode = node ; if ( _includeSelf ) node -- ; _currentNode = node ; return resetPosition ( ) ; } return this ; } protected final boolean isDescendant ( int identity ) { return ( _parent2 ( identity ) >= _startNode ) || ( _startNode == identity ) ; } public int next ( ) { final int startNode = _startNode ; if ( startNode == NULL ) { return NULL ; } if ( _includeSelf && ( _currentNode + 1 ) == startNode ) return returnNode ( makeNodeHandle ( ++ _currentNode ) ) ; int node = _currentNode ; int type ; if ( startNode == ROOTNODE ) { int eType ; do { node ++ ; eType = _exptype2 ( node ) ; if ( NULL == eType ) { _currentNode = NULL ; return END ; } } while ( eType == TEXT_NODE || ( type = m_extendedTypes [ eType ] . getNodeType ( ) ) == ATTRIBUTE_NODE || type == NAMESPACE_NODE ) ; } else { do { node ++ ; type = _type2 ( node ) ; if ( NULL == type || ! isDescendant ( node ) ) { _currentNode = NULL ; return END ; } } while ( ATTRIBUTE_NODE == type || TEXT_NODE == type || NAMESPACE_NODE == type ) ; } _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } public DTMAxisIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( makeNodeHandle ( _startNode ) ) ; _isRestartable = temp ; return this ; } } public final class TypedDescendantIterator extends DescendantIterator { private final int _nodeType ; public TypedDescendantIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int startNode = _startNode ; if ( _startNode == NULL ) { return NULL ; } int node = _currentNode ; int expType ; final int nodeType = _nodeType ; if ( nodeType != DTM . ELEMENT_NODE ) { do { node ++ ; expType = _exptype2 ( node ) ; if ( NULL == expType || _parent2 ( node ) < startNode && startNode != node ) { _currentNode = NULL ; return END ; } } while ( expType != nodeType ) ; } else if ( startNode == DTMDefaultBase . ROOTNODE ) { do { node ++ ; expType = _exptype2 ( node ) ; if ( NULL == expType ) { _currentNode = NULL ; return END ; } } while ( expType < DTM . NTYPES || m_extendedTypes [ expType ] . getNodeType ( ) != DTM . ELEMENT_NODE ) ; } else { do { node ++ ; expType = _exptype2 ( node ) ; if ( NULL == expType || _parent2 ( node ) < startNode && startNode != node ) { _currentNode = NULL ; return END ; } } while ( expType < DTM . NTYPES || m_extendedTypes [ expType ] . getNodeType ( ) != DTM . ELEMENT_NODE ) ; } _currentNode = node ; return returnNode ( makeNodeHandle ( node ) ) ; } } public final class TypedSingletonIterator extends SingletonIterator { private final int _nodeType ; public TypedSingletonIterator ( int nodeType ) { _nodeType = nodeType ; } public int next ( ) { final int result = _currentNode ; if ( result == END ) return DTM . NULL ; _currentNode = END ; if ( _nodeType >= DTM . NTYPES ) { if ( _exptype2 ( makeNodeIdentity ( result ) ) == _nodeType ) { return returnNode ( result ) ; } } else { if ( _type2 ( makeNodeIdentity ( result ) ) == _nodeType ) { return returnNode ( result ) ; } } return NULL ; } } private int [ ] m_exptype_map0 ; private int [ ] m_nextsib_map0 ; private int [ ] m_firstch_map0 ; private int [ ] m_parent_map0 ; private int [ ] [ ] m_exptype_map ; private int [ ] [ ] m_nextsib_map ; private int [ ] [ ] m_firstch_map ; private int [ ] [ ] m_parent_map ; protected ExtendedType [ ] m_extendedTypes ; protected Vector m_values ; private int m_valueIndex = 0 ; private int m_maxNodeIndex ; protected int m_SHIFT ; protected int m_MASK ; protected int m_blocksize ; protected final static int TEXT_LENGTH_BITS = 10 ; protected final static int TEXT_OFFSET_BITS = 21 ; protected final static int TEXT_LENGTH_MAX = ( 1 << TEXT_LENGTH_BITS ) - 1 ; protected final static int TEXT_OFFSET_MAX = ( 1 << TEXT_OFFSET_BITS ) - 1 ; protected boolean m_buildIdIndex = true ; private static final String EMPTY_STR = "" ; private static final XMLString EMPTY_XML_STR = new XMLStringDefault ( "" ) ; public SAX2DTM2 ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing ) { this ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , DEFAULT_BLOCKSIZE , true , true ) ; } public SAX2DTM2 ( DTMManager mgr , Source source , int dtmIdentity , DTMWSFilter whiteSpaceFilter , XMLStringFactory xstringfactory , boolean doIndexing , int blocksize , boolean usePrevsib , boolean buildIdIndex ) { super ( mgr , source , dtmIdentity , whiteSpaceFilter , xstringfactory , doIndexing , blocksize , usePrevsib ) ; int shift ; for ( shift = 0 ; ( blocksize >>>= 1 ) != 0 ; ++ shift ) ; m_blocksize = 1 << shift ; m_SHIFT = shift ; m_MASK = m_blocksize - 1 ; m_buildIdIndex = buildIdIndex ; m_values = new Vector ( 32 , 512 ) ; m_maxNodeIndex = 1 << DTMManager . IDENT_DTM_NODE_BITS ; m_exptype_map0 = m_exptype . getMap0 ( ) ; m_nextsib_map0 = m_nextsib . getMap0 ( ) ; m_firstch_map0 = m_firstch . getMap0 ( ) ; m_parent_map0 = m_parent . getMap0 ( ) ; } public final int _exptype ( int identity ) { return m_exptype . elementAt ( identity ) ; } public final int _exptype2 ( int identity ) { if ( identity < m_blocksize ) return m_exptype_map0 [ identity ] ; else return m_exptype_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _nextsib2 ( int identity ) { if ( identity < m_blocksize ) return m_nextsib_map0 [ identity ] ; else return m_nextsib_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _firstch2 ( int identity ) { if ( identity < m_blocksize ) return m_firstch_map0 [ identity ] ; else return m_firstch_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _parent2 ( int identity ) { if ( identity < m_blocksize ) return m_parent_map0 [ identity ] ; else return m_parent_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; } public final int _type2 ( int identity ) { int eType ; if ( identity < m_blocksize ) eType = m_exptype_map0 [ identity ] ; else eType = m_exptype_map [ identity > > > m_SHIFT ] [ identity & m_MASK ] ; if ( NULL != eType ) return m_extendedTypes [ eType ] . getNodeType ( ) ; else return NULL ; } public final int getExpandedTypeID2 ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( nodeID != NULL ) { if ( nodeID < m_blocksize ) return m_exptype_map0 [ nodeID ] ; else return m_exptype_map [ nodeID > > > m_SHIFT ] [ nodeID & m_MASK ] ; } else return NULL ; } public final int _exptype2Type ( int exptype ) { if ( NULL != exptype ) return m_extendedTypes [ exptype ] . getNodeType ( ) ; else return NULL ; } public int getIdForNamespace ( String uri ) { int index = m_values . indexOf ( uri ) ; if ( index < 0 ) { m_values . addElement ( uri ) ; return m_valueIndex ++ ; } else return index ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { charactersFlush ( ) ; int exName = m_expandedNameTable . getExpandedTypeID ( uri , localName , DTM . ELEMENT_NODE ) ; int prefixIndex = ( qName . length ( ) != localName . length ( ) ) ? m_valuesOrPrefixes . stringToIndex ( qName ) : 0 ; int elemNode = addNode ( DTM . ELEMENT_NODE , exName , m_parents . peek ( ) , m_previous , prefixIndex , true ) ; if ( m_indexing ) indexNode ( exName , elemNode ) ; m_parents . push ( elemNode ) ; int startDecls = m_contextIndexes . peek ( ) ; int nDecls = m_prefixMappings . size ( ) ; String prefix ; if ( ! m_pastFirstElement ) { prefix = "xml" ; String declURL = "http://www.w3.org/XML/1998/namespace" ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; m_values . addElement ( declURL ) ; int val = m_valueIndex ++ ; addNode ( DTM . NAMESPACE_NODE , exName , elemNode , DTM . NULL , val , false ) ; m_pastFirstElement = true ; } for ( int i = startDecls ; i < nDecls ; i += 2 ) { prefix = ( String ) m_prefixMappings . elementAt ( i ) ; if ( prefix == null ) continue ; String declURL = ( String ) m_prefixMappings . elementAt ( i + 1 ) ; exName = m_expandedNameTable . getExpandedTypeID ( null , prefix , DTM . NAMESPACE_NODE ) ; m_values . addElement ( declURL ) ; int val = m_valueIndex ++ ; addNode ( DTM . NAMESPACE_NODE , exName , elemNode , DTM . NULL , val , false ) ; } int n = attributes . getLength ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String attrUri = attributes . getURI ( i ) ; String attrQName = attributes . getQName ( i ) ; String valString = attributes . getValue ( i ) ; int nodeType ; String attrLocalName = attributes . getLocalName ( i ) ; if ( ( null != attrQName ) && ( attrQName . equals ( "xmlns" ) || attrQName . startsWith ( "xmlns:" ) ) ) { prefix = getPrefix ( attrQName , attrUri ) ; if ( declAlreadyDeclared ( prefix ) ) continue ; nodeType = DTM . NAMESPACE_NODE ; } else { nodeType = DTM . ATTRIBUTE_NODE ; if ( m_buildIdIndex && attributes . getType ( i ) . equalsIgnoreCase ( "ID" ) ) setIDAttribute ( valString , elemNode ) ; } if ( null == valString ) valString = "" ; m_values . addElement ( valString ) ; int val = m_valueIndex ++ ; if ( attrLocalName . length ( ) != attrQName . length ( ) ) { prefixIndex = m_valuesOrPrefixes . stringToIndex ( attrQName ) ; int dataIndex = m_data . size ( ) ; m_data . addElement ( prefixIndex ) ; m_data . addElement ( val ) ; val = - dataIndex ; } exName = m_expandedNameTable . getExpandedTypeID ( attrUri , attrLocalName , nodeType ) ; addNode ( nodeType , exName , elemNode , DTM . NULL , val , false ) ; } if ( null != m_wsfilter ) { short wsv = m_wsfilter . getShouldStripSpace ( makeNodeHandle ( elemNode ) , this ) ; boolean shouldStrip = ( DTMWSFilter . INHERIT == wsv ) ? getShouldStripWhitespace ( ) : ( DTMWSFilter . STRIP == wsv ) ; pushShouldStripWhitespace ( shouldStrip ) ; } m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { charactersFlush ( ) ; m_contextIndexes . quickPop ( 1 ) ; int topContextIndex = m_contextIndexes . peek ( ) ; if ( topContextIndex != m_prefixMappings . size ( ) ) { m_prefixMappings . setSize ( topContextIndex ) ; } m_previous = m_parents . pop ( ) ; popShouldStripWhitespace ( ) ; } public void comment ( char ch [ ] , int start , int length ) throws SAXException { if ( m_insideDTD ) return ; charactersFlush ( ) ; m_values . addElement ( new String ( ch , start , length ) ) ; int dataIndex = m_valueIndex ++ ; m_previous = addNode ( DTM . COMMENT_NODE , DTM . COMMENT_NODE , m_parents . peek ( ) , m_previous , dataIndex , false ) ; } public void startDocument ( ) throws SAXException { int doc = addNode ( DTM . DOCUMENT_NODE , DTM . DOCUMENT_NODE , DTM . NULL , DTM . NULL , 0 , true ) ; m_parents . push ( doc ) ; m_previous = DTM . NULL ; m_contextIndexes . push ( m_prefixMappings . size ( ) ) ; } public void endDocument ( ) throws SAXException { super . endDocument ( ) ; m_exptype . addElement ( NULL ) ; m_parent . addElement ( NULL ) ; m_nextsib . addElement ( NULL ) ; m_firstch . addElement ( NULL ) ; m_extendedTypes = m_expandedNameTable . getExtendedTypes ( ) ; m_exptype_map = m_exptype . getMap ( ) ; m_nextsib_map = m_nextsib . getMap ( ) ; m_firstch_map = m_firstch . getMap ( ) ; m_parent_map = m_parent . getMap ( ) ; } protected final int addNode ( int type , int expandedTypeID , int parentIndex , int previousSibling , int dataOrPrefix , boolean canHaveFirstChild ) { int nodeIndex = m_size ++ ; if ( nodeIndex == m_maxNodeIndex ) { addNewDTMID ( nodeIndex ) ; m_maxNodeIndex += ( 1 << DTMManager . IDENT_DTM_NODE_BITS ) ; } m_firstch . addElement ( DTM . NULL ) ; m_nextsib . addElement ( DTM . NULL ) ; m_parent . addElement ( parentIndex ) ; m_exptype . addElement ( expandedTypeID ) ; m_dataOrQName . addElement ( dataOrPrefix ) ; if ( m_prevsib != null ) { m_prevsib . addElement ( previousSibling ) ; } if ( m_locator != null && m_useSourceLocationProperty ) { setSourceLocation ( ) ; } switch ( type ) { case DTM . NAMESPACE_NODE : declareNamespaceInContext ( parentIndex , nodeIndex ) ; break ; case DTM . ATTRIBUTE_NODE : break ; default : if ( DTM . NULL != previousSibling ) { m_nextsib . setElementAt ( nodeIndex , previousSibling ) ; } else if ( DTM . NULL != parentIndex ) { m_firstch . setElementAt ( nodeIndex , parentIndex ) ; } break ; } return nodeIndex ; } protected final void charactersFlush ( ) { if ( m_textPendingStart >= 0 ) { int length = m_chars . size ( ) - m_textPendingStart ; boolean doStrip = false ; if ( getShouldStripWhitespace ( ) ) { doStrip = m_chars . isWhitespace ( m_textPendingStart , length ) ; } if ( doStrip ) m_chars . setLength ( m_textPendingStart ) ; else { if ( length <= TEXT_LENGTH_MAX && m_textPendingStart <= TEXT_OFFSET_MAX ) { m_previous = addNode ( m_coalescedTextType , DTM . TEXT_NODE , m_parents . peek ( ) , m_previous , length + ( m_textPendingStart << TEXT_LENGTH_BITS ) , false ) ; } else { int dataIndex = m_data . size ( ) ; m_previous = addNode ( m_coalescedTextType , DTM . TEXT_NODE , m_parents . peek ( ) , m_previous , - dataIndex , false ) ; m_data . addElement ( m_textPendingStart ) ; m_data . addElement ( length ) ; } } m_textPendingStart = - 1 ; m_textType = m_coalescedTextType = DTM . TEXT_NODE ; } } public void processingInstruction ( String target , String data ) throws SAXException { charactersFlush ( ) ; int dataIndex = m_data . size ( ) ; m_previous = addNode ( DTM . PROCESSING_INSTRUCTION_NODE , DTM . PROCESSING_INSTRUCTION_NODE , m_parents . peek ( ) , m_previous , - dataIndex , false ) ; m_data . addElement ( m_valuesOrPrefixes . stringToIndex ( target ) ) ; m_values . addElement ( data ) ; m_data . addElement ( m_valueIndex ++ ) ; } public final int getFirstAttribute ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( nodeID == DTM . NULL ) return DTM . NULL ; int type = _type2 ( nodeID ) ; if ( DTM . ELEMENT_NODE == type ) { while ( true ) { nodeID ++ ; type = _type2 ( nodeID ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return makeNodeHandle ( nodeID ) ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } protected int getFirstAttributeIdentity ( int identity ) { int type = _type2 ( identity ) ; if ( DTM . ELEMENT_NODE == type ) { while ( true ) { identity ++ ; type = _type2 ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return identity ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } protected int getNextAttributeIdentity ( int identity ) { while ( true ) { identity ++ ; int type = _type2 ( identity ) ; if ( type == DTM . ATTRIBUTE_NODE ) { return identity ; } else if ( type != DTM . NAMESPACE_NODE ) { break ; } } return DTM . NULL ; } protected final int getTypedAttribute ( int nodeHandle , int attType ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; if ( nodeID == DTM . NULL ) return DTM . NULL ; int type = _type2 ( nodeID ) ; if ( DTM . ELEMENT_NODE == type ) { int expType ; while ( true ) { nodeID ++ ; expType = _exptype2 ( nodeID ) ; if ( expType != DTM . NULL ) type = m_extendedTypes [ expType ] . getNodeType ( ) ; else return DTM . NULL ; if ( type == DTM . ATTRIBUTE_NODE ) { if ( expType == attType ) return makeNodeHandle ( nodeID ) ; } else if ( DTM . NAMESPACE_NODE != type ) { break ; } } } return DTM . NULL ; } public String getLocalName ( int nodeHandle ) { int expType = _exptype ( makeNodeIdentity ( nodeHandle ) ) ; if ( expType == DTM . PROCESSING_INSTRUCTION_NODE ) { int dataIndex = _dataOrQName ( makeNodeIdentity ( nodeHandle ) ) ; dataIndex = m_data . elementAt ( - dataIndex ) ; return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } else return m_expandedNameTable . getLocalName ( expType ) ; } public final String getNodeNameX ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; int eType = _exptype2 ( nodeID ) ; if ( eType == DTM . PROCESSING_INSTRUCTION_NODE ) { int dataIndex = _dataOrQName ( nodeID ) ; dataIndex = m_data . elementAt ( - dataIndex ) ; return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } final ExtendedType extType = m_extendedTypes [ eType ] ; if ( extType . getNamespace ( ) . length ( ) == 0 ) { return extType . getLocalName ( ) ; } else { int qnameIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( qnameIndex == 0 ) return extType . getLocalName ( ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public String getNodeName ( int nodeHandle ) { int nodeID = makeNodeIdentity ( nodeHandle ) ; int eType = _exptype2 ( nodeID ) ; final ExtendedType extType = m_extendedTypes [ eType ] ; if ( extType . getNamespace ( ) . length ( ) == 0 ) { int type = extType . getNodeType ( ) ; String localName = extType . getLocalName ( ) ; if ( type == DTM . NAMESPACE_NODE ) { if ( localName . length ( ) == 0 ) return "xmlns" ; else return "xmlns:" + localName ; } else if ( type == DTM . PROCESSING_INSTRUCTION_NODE ) { int dataIndex = _dataOrQName ( nodeID ) ; dataIndex = m_data . elementAt ( - dataIndex ) ; return m_valuesOrPrefixes . indexToString ( dataIndex ) ; } else if ( localName . length ( ) == 0 ) { return m_fixednames [ type ] ; } else return localName ; } else { int qnameIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( qnameIndex == 0 ) return extType . getLocalName ( ) ; if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } return m_valuesOrPrefixes . indexToString ( qnameIndex ) ; } } public XMLString getStringValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return EMPTY_XML_STR ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - 1 ; int length = 0 ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( - 1 == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - 1 == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + 1 ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > 0 ) { if ( m_xstrf != null ) return m_xstrf . newstr ( m_chars , offset , length ) ; else return new XMLStringDefault ( m_chars . getString ( offset , length ) ) ; } else return EMPTY_XML_STR ; } else return EMPTY_XML_STR ; } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( m_xstrf != null ) return m_xstrf . newstr ( m_chars , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else return new XMLStringDefault ( m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ) ; } else { if ( m_xstrf != null ) return m_xstrf . newstr ( m_chars , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; else return new XMLStringDefault ( m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } if ( m_xstrf != null ) return m_xstrf . newstr ( ( String ) m_values . elementAt ( dataIndex ) ) ; else return new XMLStringDefault ( ( String ) m_values . elementAt ( dataIndex ) ) ; } } public final String getStringValueX ( final int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return EMPTY_STR ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - 1 ; int length = 0 ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( - 1 == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - 1 == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + 1 ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > 0 ) { return m_chars . getString ( offset , length ) ; } else return EMPTY_STR ; } else return EMPTY_STR ; } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { return m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { return m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return ( String ) m_values . elementAt ( dataIndex ) ; } } public String getStringValue ( ) { int child = _firstch2 ( ROOTNODE ) ; if ( child == DTM . NULL ) return EMPTY_STR ; if ( ( _exptype2 ( child ) == DTM . TEXT_NODE ) && ( _nextsib2 ( child ) == DTM . NULL ) ) { int dataIndex = m_dataOrQName . elementAt ( child ) ; if ( dataIndex > 0 ) return m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else return m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } else return getStringValueX ( getDocument ( ) ) ; } public final void dispatchCharactersEvents ( int nodeHandle , ContentHandler ch , boolean normalize ) throws SAXException { int identity = makeNodeIdentity ( nodeHandle ) ; if ( identity == DTM . NULL ) return ; int type = _type2 ( identity ) ; if ( type == DTM . ELEMENT_NODE || type == DTM . DOCUMENT_NODE ) { int startNode = identity ; identity = _firstch2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - 1 ; int length = 0 ; do { type = _exptype2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( - 1 == offset ) { offset = dataIndex > > > TEXT_LENGTH_BITS ; } length += dataIndex & TEXT_LENGTH_MAX ; } else { if ( - 1 == offset ) { offset = m_data . elementAt ( - dataIndex ) ; } length += m_data . elementAt ( - dataIndex + 1 ) ; } } identity ++ ; } while ( _parent2 ( identity ) >= startNode ) ; if ( length > 0 ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , offset , length ) ; else m_chars . sendSAXcharacters ( ch , offset , length ) ; } } } else if ( DTM . TEXT_NODE == type || DTM . CDATA_SECTION_NODE == type ) { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex > 0 ) { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; else m_chars . sendSAXcharacters ( ch , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { if ( normalize ) m_chars . sendNormalizedSAXcharacters ( ch , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; else m_chars . sendSAXcharacters ( ch , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } String str = ( String ) m_values . elementAt ( dataIndex ) ; if ( normalize ) FastStringBuffer . sendNormalizedSAXcharacters ( str . toCharArray ( ) , 0 , str . length ( ) , ch ) ; else ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } } public String getNodeValue ( int nodeHandle ) { int identity = makeNodeIdentity ( nodeHandle ) ; int type = _type2 ( identity ) ; if ( type == DTM . TEXT_NODE || type == DTM . CDATA_SECTION_NODE ) { int dataIndex = _dataOrQName ( identity ) ; if ( dataIndex > 0 ) { return m_chars . getString ( dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { return m_chars . getString ( m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } else if ( DTM . ELEMENT_NODE == type || DTM . DOCUMENT_FRAGMENT_NODE == type || DTM . DOCUMENT_NODE == type ) { return null ; } else { int dataIndex = m_dataOrQName . elementAt ( identity ) ; if ( dataIndex < 0 ) { dataIndex = - dataIndex ; dataIndex = m_data . elementAt ( dataIndex + 1 ) ; } return ( String ) m_values . elementAt ( dataIndex ) ; } } protected final void copyTextNode ( final int nodeID , SerializationHandler handler ) throws SAXException { if ( nodeID != DTM . NULL ) { int dataIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( dataIndex > 0 ) { m_chars . sendSAXcharacters ( handler , dataIndex > > > TEXT_LENGTH_BITS , dataIndex & TEXT_LENGTH_MAX ) ; } else { m_chars . sendSAXcharacters ( handler , m_data . elementAt ( - dataIndex ) , m_data . elementAt ( - dataIndex + 1 ) ) ; } } } protected final String copyElement ( int nodeID , int exptype , SerializationHandler handler ) throws SAXException { final ExtendedType extType = m_extendedTypes [ exptype ] ; String uri = extType . getNamespace ( ) ; String name = extType . getLocalName ( ) ; if ( uri . length ( ) == 0 ) { handler . startElement ( name ) ; return name ; } else { int qnameIndex = m_dataOrQName . elementAt ( nodeID ) ; if ( qnameIndex == 0 ) { handler . startElement ( name ) ; handler . namespaceAfterStartElement ( EMPTY_STR , uri ) ; return name ; } if ( qnameIndex < 0 ) { qnameIndex = - qnameIndex ; qnameIndex = m_data . elementAt ( qnameIndex ) ; } String qName = m_valuesOrPrefixes . indexToString ( qnameIndex ) ; handler . startElement ( qName ) ; int prefixIndex = qName . indexOf ( ':' ) ; String prefix ; if ( prefixIndex > 0 ) { prefix = qName . substring ( 0 , prefixIndex ) ; } else { prefix = null ; } handler . namespaceAfterStartElement ( prefix , uri ) ; return qName ; } } protected final void copyAttribute ( int nodeID , int exptype , SerializationHandler handler ) throws SAXException { final ExtendedType extType = m_extendedTypes [ exptype ] ; final String uri = extType . getNamespace ( ) ; final String localName = extType . getLocalName ( ) ; String prefix = null ; String qname = null ; int dataIndex = _dataOrQName ( nodeID ) ; int valueIndex = dataIndex ; if ( uri . length ( ) != 0 ) { if ( dataIndex <= 0 ) { int prefixIndex = m_data . elementAt ( - dataIndex ) ; valueIndex = m_data . elementAt ( - dataIndex + 1 ) ; qname = m_valuesOrPrefixes . indexToString ( prefixIndex ) ; int colonIndex = qname . indexOf ( ':' ) ; if ( colonIndex > 0 ) { prefix = qname . substring ( 0 , colonIndex ) ; } } handler . namespaceAfterStartElement ( prefix , uri ) ; } String nodeName = ( prefix != null ) ? qname : localName ; String nodeValue = ( String ) m_values . elementAt ( valueIndex ) ; handler . addAttribute ( nodeName , nodeValue ) ; } } 	1
package org . apache . xalan . transformer ; import java . util . Vector ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; public class KeyManager { private transient Vector m_key_tables = null ; public XNodeSet getNodeSetDTMByKey ( XPathContext xctxt , int doc , QName name , XMLString ref , PrefixResolver nscontext ) throws javax . xml . transform . TransformerException { XNodeSet nl = null ; ElemTemplateElement template = ( ElemTemplateElement ) nscontext ; if ( ( null != template ) && null != template . getStylesheetRoot ( ) . getKeysComposed ( ) ) { boolean foundDoc = false ; if ( null == m_key_tables ) { m_key_tables = new Vector ( 4 ) ; } else { int nKeyTables = m_key_tables . size ( ) ; for ( int i = 0 ; i < nKeyTables ; i ++ ) { KeyTable kt = ( KeyTable ) m_key_tables . elementAt ( i ) ; if ( kt . getKeyTableName ( ) . equals ( name ) && doc == kt . getDocKey ( ) ) { nl = kt . getNodeSetDTMByKey ( name , ref ) ; if ( nl != null ) { foundDoc = true ; break ; } } } } if ( ( null == nl ) && ! foundDoc ) { KeyTable kt = new KeyTable ( doc , nscontext , name , template . getStylesheetRoot ( ) . getKeysComposed ( ) , xctxt ) ; m_key_tables . addElement ( kt ) ; if ( doc == kt . getDocKey ( ) ) { foundDoc = true ; nl = kt . getNodeSetDTMByKey ( name , ref ) ; } } } return nl ; } } 	0
package org . apache . xalan . templates ; import java . util . Hashtable ; import org . apache . xalan . transformer . KeyManager ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . UnionPathIterator ; import org . apache . xpath . functions . Function2Args ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class FuncKey extends Function2Args { static private Boolean ISTRUE = new Boolean ( true ) ; public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { TransformerImpl transformer = ( TransformerImpl ) xctxt . getOwnerObject ( ) ; XNodeSet nodes = null ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int docContext = dtm . getDocumentRoot ( context ) ; if ( DTM . NULL == docContext ) { } String xkeyname = getArg0 ( ) . execute ( xctxt ) . str ( ) ; QName keyname = new QName ( xkeyname , xctxt . getNamespaceContext ( ) ) ; XObject arg = getArg1 ( ) . execute ( xctxt ) ; boolean argIsNodeSetDTM = ( XObject . CLASS_NODESET == arg . getType ( ) ) ; KeyManager kmgr = transformer . getKeyManager ( ) ; if ( argIsNodeSetDTM ) { XNodeSet ns = ( XNodeSet ) arg ; ns . setShouldCacheNodes ( true ) ; int len = ns . getLength ( ) ; if ( len <= 1 ) argIsNodeSetDTM = false ; } if ( argIsNodeSetDTM ) { Hashtable usedrefs = null ; DTMIterator ni = arg . iter ( ) ; int pos ; UnionPathIterator upi = new UnionPathIterator ( ) ; upi . exprSetParent ( this ) ; while ( DTM . NULL != ( pos = ni . nextNode ( ) ) ) { dtm = xctxt . getDTM ( pos ) ; XMLString ref = dtm . getStringValue ( pos ) ; if ( null == ref ) continue ; if ( null == usedrefs ) usedrefs = new Hashtable ( ) ; if ( usedrefs . get ( ref ) != null ) { continue ; } else { usedrefs . put ( ref , ISTRUE ) ; } XNodeSet nl = kmgr . getNodeSetDTMByKey ( xctxt , docContext , keyname , ref , xctxt . getNamespaceContext ( ) ) ; nl . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; upi . addIterator ( nl ) ; } int current = xctxt . getCurrentNode ( ) ; upi . setRoot ( current , xctxt ) ; nodes = new XNodeSet ( upi ) ; } else { XMLString ref = arg . xstr ( ) ; nodes = kmgr . getNodeSetDTMByKey ( xctxt , docContext , keyname , ref , xctxt . getNamespaceContext ( ) ) ; nodes . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; } return nodes ; } } 	1
package org . apache . xml . utils ; import org . w3c . dom . Node ; public interface NodeConsumer { public void setOriginatingNode ( Node n ) ; } 	0
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; public final class WriterToUTF8Buffered extends Writer { private static final int buf_length = 16 * 1024 ; private final OutputStream m_os ; private final byte buf [ ] ; private int count ; public WriterToUTF8Buffered ( OutputStream out ) throws UnsupportedEncodingException { m_os = out ; buf = new byte [ buf_length + 3 ] ; count = 0 ; } public void write ( final int c ) throws IOException { if ( count >= buf_length ) flushBuffer ( ) ; if ( c < 0x80 ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } private final void writeDirect ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { final OutputStream os = m_os ; final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) os . write ( c ) ; else if ( c < 0x800 ) { os . write ( 0xc0 + ( c > > 6 ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } else { os . write ( 0xe0 + ( c > > 12 ) ) ; os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } } } private final void writeDirect ( final String s ) throws IOException { final int n = s . length ( ) ; final OutputStream os = m_os ; for ( int i = 0 ; i < n ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) os . write ( c ) ; else if ( c < 0x800 ) { os . write ( 0xc0 + ( c > > 6 ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } else { os . write ( 0xe0 + ( c > > 12 ) ) ; os . write ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; os . write ( 0x80 + ( c & 0x3f ) ) ; } } } public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { int lengthx3 = ( length << 1 ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; writeDirect ( chars , start , length ) ; return ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } final OutputStream os = m_os ; final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } } public void write ( final String s ) throws IOException { final int length = s . length ( ) ; int lengthx3 = ( length << 1 ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; writeDirect ( s ) ; return ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } final OutputStream os = m_os ; for ( int i = 0 ; i < length ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } } public void flushBuffer ( ) throws IOException { if ( count > 0 ) { m_os . write ( buf , 0 , count ) ; count = 0 ; } } public void flush ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . flush ( ) ; } public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; } public OutputStream getOutputStream ( ) { return m_os ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Otherwise extends Instruction { public void display ( int indent ) { indent ( indent ) ; Util . println ( "Otherwise" ) ; indent ( indent + IndentIncrement ) ; displayContents ( indent + IndentIncrement ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Parser parser = getParser ( ) ; final ErrorMsg err = new ErrorMsg ( ErrorMsg . STRAY_OTHERWISE_ERR , this ) ; parser . reportError ( Constants . ERROR , err ) ; } } 	0
package org . apache . xalan . client ; import java . applet . Applet ; import java . awt . Graphics ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringReader ; import java . io . StringWriter ; import java . net . MalformedURLException ; import java . net . URL ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public class XSLTProcessorApplet extends Applet { TransformerFactory m_tfactory = null ; private String m_styleURL ; private String m_documentURL ; private final String PARAM_styleURL = "styleURL" ; private final String PARAM_documentURL = "documentURL" ; private String m_styleURLOfCached = null ; private String m_documentURLOfCached = null ; private URL m_codeBase = null ; private String m_treeURL = null ; private URL m_documentBase = null ; transient private Thread m_callThread = null ; transient private TrustedAgent m_trustedAgent = null ; transient private Thread m_trustedWorker = null ; transient private String m_htmlText = null ; transient private String m_sourceText = null ; transient private String m_nameOfIDAttrOfElemToModify = null ; transient private String m_elemIdToModify = null ; transient private String m_attrNameToSet = null ; transient private String m_attrValueToSet = null ; public XSLTProcessorApplet ( ) { } public String getAppletInfo ( ) { return "Name: XSLTProcessorApplet\r\n" + "Author: Scott Boag" ; } public String [ ] [ ] getParameterInfo ( ) { String [ ] [ ] info = { { PARAM_styleURL , "String" , "URL to an XSL stylesheet" } , { PARAM_documentURL , "String" , "URL to an XML document" } , } ; return info ; } public void init ( ) { String param ; param = getParameter ( PARAM_styleURL ) ; if ( param != null ) setStyleURL ( param ) ; param = getParameter ( PARAM_documentURL ) ; if ( param != null ) setDocumentURL ( param ) ; m_codeBase = this . getCodeBase ( ) ; m_documentBase = this . getDocumentBase ( ) ; resize ( 320 , 240 ) ; } public void start ( ) { m_trustedAgent = new TrustedAgent ( ) ; Thread currentThread = Thread . currentThread ( ) ; m_trustedWorker = new Thread ( currentThread . getThreadGroup ( ) , m_trustedAgent ) ; m_trustedWorker . start ( ) ; try { m_tfactory = TransformerFactory . newInstance ( ) ; this . showStatus ( "Causing Transformer and Parser to Load and JIT..." ) ; StringReader xmlbuf = new StringReader ( "<?xml version='1.0'?><foo/>" ) ; StringReader xslbuf = new StringReader ( "<?xml version='1.0'?><xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'><xsl:template match='foo'><out/></xsl:template></xsl:stylesheet>" ) ; PrintWriter pw = new PrintWriter ( new StringWriter ( ) ) ; synchronized ( m_tfactory ) { Templates templates = m_tfactory . newTemplates ( new StreamSource ( xslbuf ) ) ; Transformer transformer = templates . newTransformer ( ) ; transformer . transform ( new StreamSource ( xmlbuf ) , new StreamResult ( pw ) ) ; } System . out . println ( "Primed the pump!" ) ; this . showStatus ( "Ready to go!" ) ; } catch ( Exception e ) { this . showStatus ( "Could not prime the pump!" ) ; System . out . println ( "Could not prime the pump!" ) ; e . printStackTrace ( ) ; } } public void paint ( Graphics g ) { } public void stop ( ) { if ( null != m_trustedWorker ) { m_trustedWorker . stop ( ) ; m_trustedWorker = null ; } m_styleURLOfCached = null ; m_documentURLOfCached = null ; } public void destroy ( ) { if ( null != m_trustedWorker ) { m_trustedWorker . stop ( ) ; m_trustedWorker = null ; } m_styleURLOfCached = null ; m_documentURLOfCached = null ; } public void setStyleURL ( String urlString ) { m_styleURL = urlString ; } public void setDocumentURL ( String urlString ) { m_documentURL = urlString ; } public void freeCache ( ) { m_styleURLOfCached = null ; m_documentURLOfCached = null ; } public void setStyleSheetAttribute ( String nameOfIDAttrOfElemToModify , String elemId , String attrName , String value ) { m_nameOfIDAttrOfElemToModify = nameOfIDAttrOfElemToModify ; m_elemIdToModify = elemId ; m_attrNameToSet = attrName ; m_attrValueToSet = value ; } transient String m_key ; transient String m_expression ; public void setStylesheetParam ( String key , String expr ) { m_key = key ; m_expression = expr ; } public String escapeString ( String s ) { StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char ch = s . charAt ( i ) ; if ( '<' == ch ) { sb . append ( "&lt;" ) ; } else if ( '>' == ch ) { sb . append ( "&gt;" ) ; } else if ( '&' == ch ) { sb . append ( "&amp;" ) ; } else if ( 0xd800 <= ch && ch < 0xdc00 ) { int next ; if ( i + 1 >= length ) { throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) } ) ) ; } else { next = s . charAt ( ++ i ) ; if ( ! ( 0xdc00 <= next && next < 0xe000 ) ) throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_UTF16_SURROGATE , new Object [ ] { Integer . toHexString ( ch ) + " " + Integer . toHexString ( next ) } ) ) ; next = ( ( ch - 0xd800 ) << 10 ) + next - 0xdc00 + 0x00010000 ; } sb . append ( "&#x" ) ; sb . append ( Integer . toHexString ( next ) ) ; sb . append ( ";" ) ; } else { sb . append ( ch ) ; } } return sb . toString ( ) ; } public String getHtmlText ( ) { m_trustedAgent . m_getData = true ; m_callThread = Thread . currentThread ( ) ; try { synchronized ( m_callThread ) { m_callThread . wait ( ) ; } } catch ( InterruptedException ie ) { System . out . println ( ie . getMessage ( ) ) ; } return m_htmlText ; } public String getTreeAsText ( String treeURL ) throws IOException { m_treeURL = treeURL ; m_trustedAgent . m_getData = true ; m_trustedAgent . m_getSource = true ; m_callThread = Thread . currentThread ( ) ; try { synchronized ( m_callThread ) { m_callThread . wait ( ) ; } } catch ( InterruptedException ie ) { System . out . println ( ie . getMessage ( ) ) ; } return m_sourceText ; } private String getSource ( ) throws TransformerException { StringWriter osw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( osw , false ) ; String text = "" ; try { URL docURL = new URL ( m_documentBase , m_treeURL ) ; synchronized ( m_tfactory ) { Transformer transformer = m_tfactory . newTransformer ( ) ; StreamSource source = new StreamSource ( docURL . toString ( ) ) ; StreamResult result = new StreamResult ( pw ) ; transformer . transform ( source , result ) ; text = osw . toString ( ) ; } } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } catch ( Exception any_error ) { any_error . printStackTrace ( ) ; } return text ; } public String getSourceTreeAsText ( ) throws Exception { return getTreeAsText ( m_documentURL ) ; } public String getStyleTreeAsText ( ) throws Exception { return getTreeAsText ( m_styleURL ) ; } public String getResultTreeAsText ( ) throws Exception { return escapeString ( getHtmlText ( ) ) ; } public String transformToHtml ( String doc , String style ) { if ( null != doc ) { m_documentURL = doc ; } if ( null != style ) { m_styleURL = style ; } return getHtmlText ( ) ; } public String transformToHtml ( String doc ) { if ( null != doc ) { m_documentURL = doc ; } m_styleURL = null ; return getHtmlText ( ) ; } private String processTransformation ( ) throws TransformerException { String htmlData = null ; this . showStatus ( "Waiting for Transformer and Parser to finish loading and JITing..." ) ; synchronized ( m_tfactory ) { URL documentURL = null ; URL styleURL = null ; StringWriter osw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( osw , false ) ; StreamResult result = new StreamResult ( pw ) ; this . showStatus ( "Begin Transformation..." ) ; try { documentURL = new URL ( m_codeBase , m_documentURL ) ; StreamSource xmlSource = new StreamSource ( documentURL . toString ( ) ) ; styleURL = new URL ( m_codeBase , m_styleURL ) ; StreamSource xslSource = new StreamSource ( styleURL . toString ( ) ) ; Transformer transformer = m_tfactory . newTransformer ( xslSource ) ; if ( null != m_key ) transformer . setParameter ( m_key , m_expression ) ; transformer . transform ( xmlSource , result ) ; } catch ( TransformerConfigurationException tfe ) { tfe . printStackTrace ( ) ; System . exit ( - 1 ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } this . showStatus ( "Transformation Done!" ) ; htmlData = osw . toString ( ) ; } return htmlData ; } class TrustedAgent implements Runnable { public boolean m_getData = false ; public boolean m_getSource = false ; public void run ( ) { while ( true ) { m_trustedWorker . yield ( ) ; if ( m_getData ) { try { m_getData = false ; m_htmlText = null ; m_sourceText = null ; if ( m_getSource ) { m_getSource = false ; m_sourceText = getSource ( ) ; } else m_htmlText = processTransformation ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { synchronized ( m_callThread ) { m_callThread . notify ( ) ; } } } else { try { m_trustedWorker . sleep ( 50 ) ; } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } } } } } } 	1
package org . apache . xpath ; public interface XPathVisitable { public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) ; } 	0
package org . apache . xalan . xslt ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . PrintWriter ; import java . io . StringReader ; import java . util . Properties ; import java . util . ResourceBundle ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Source ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . TransformerFactoryConfigurationError ; import javax . xml . transform . URIResolver ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . processor . XSLProcessorVersion ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . trace . PrintTraceListener ; import org . apache . xalan . trace . TraceManager ; import org . apache . xalan . transformer . XalanProperties ; import org . apache . xml . utils . DefaultErrorHandler ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class Process { protected static void printArgOptions ( ResourceBundle resbundle ) { System . out . println ( resbundle . getString ( "xslProc_option" ) ) ; System . out . println ( "\n\t\t\t" + resbundle . getString ( "xslProc_common_options" ) + "\n" ) ; System . out . println ( resbundle . getString ( "optionXSLTC" ) ) ; System . out . println ( resbundle . getString ( "optionIN" ) ) ; System . out . println ( resbundle . getString ( "optionXSL" ) ) ; System . out . println ( resbundle . getString ( "optionOUT" ) ) ; System . out . println ( resbundle . getString ( "optionV" ) ) ; System . out . println ( resbundle . getString ( "optionEDUMP" ) ) ; System . out . println ( resbundle . getString ( "optionXML" ) ) ; System . out . println ( resbundle . getString ( "optionTEXT" ) ) ; System . out . println ( resbundle . getString ( "optionHTML" ) ) ; System . out . println ( resbundle . getString ( "optionPARAM" ) ) ; System . out . println ( resbundle . getString ( "optionMEDIA" ) ) ; System . out . println ( resbundle . getString ( "optionFLAVOR" ) ) ; System . out . println ( resbundle . getString ( "optionDIAG" ) ) ; System . out . println ( resbundle . getString ( "optionURIRESOLVER" ) ) ; System . out . println ( resbundle . getString ( "optionENTITYRESOLVER" ) ) ; waitForReturnKey ( resbundle ) ; System . out . println ( resbundle . getString ( "optionCONTENTHANDLER" ) ) ; System . out . println ( "\n\t\t\t" + resbundle . getString ( "xslProc_xalan_options" ) + "\n" ) ; System . out . println ( resbundle . getString ( "optionQC" ) ) ; System . out . println ( resbundle . getString ( "optionTT" ) ) ; System . out . println ( resbundle . getString ( "optionTG" ) ) ; System . out . println ( resbundle . getString ( "optionTS" ) ) ; System . out . println ( resbundle . getString ( "optionTTC" ) ) ; System . out . println ( resbundle . getString ( "optionTCLASS" ) ) ; System . out . println ( resbundle . getString ( "optionLINENUMBERS" ) ) ; System . out . println ( resbundle . getString ( "optionINCREMENTAL" ) ) ; System . out . println ( resbundle . getString ( "optionNOOPTIMIMIZE" ) ) ; System . out . println ( resbundle . getString ( "optionRL" ) ) ; System . out . println ( "\n\t\t\t" + resbundle . getString ( "xslProc_xsltc_options" ) + "\n" ) ; System . out . println ( resbundle . getString ( "optionXO" ) ) ; System . out . println ( resbundle . getString ( "optionXD" ) ) ; waitForReturnKey ( resbundle ) ; System . out . println ( resbundle . getString ( "optionXJ" ) ) ; System . out . println ( resbundle . getString ( "optionXP" ) ) ; System . out . println ( resbundle . getString ( "optionXN" ) ) ; System . out . println ( resbundle . getString ( "optionXX" ) ) ; System . out . println ( resbundle . getString ( "optionXT" ) ) ; } public static void main ( String argv [ ] ) { boolean doStackDumpOnError = false ; boolean setQuietMode = false ; boolean doDiag = false ; java . io . PrintWriter diagnosticsWriter = new PrintWriter ( System . err , true ) ; java . io . PrintWriter dumpWriter = diagnosticsWriter ; ResourceBundle resbundle = ( XSLMessages . loadResourceBundle ( org . apache . xml . utils . res . XResourceBundle . ERROR_RESOURCES ) ) ; String flavor = "s2s" ; if ( argv . length < 1 ) { printArgOptions ( resbundle ) ; } else { boolean useXSLTC = false ; for ( int i = 0 ; i < argv . length ; i ++ ) { if ( "-XSLTC" . equalsIgnoreCase ( argv [ i ] ) ) { useXSLTC = true ; } } TransformerFactory tfactory ; if ( useXSLTC ) { String key = "javax.xml.transform.TransformerFactory" ; String value = "org.apache.xalan.xsltc.trax.TransformerFactoryImpl" ; Properties props = System . getProperties ( ) ; props . put ( key , value ) ; System . setProperties ( props ) ; } try { tfactory = TransformerFactory . newInstance ( ) ; } catch ( TransformerFactoryConfigurationError pfe ) { pfe . printStackTrace ( dumpWriter ) ; diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUCCESSFUL , null ) ) ; tfactory = null ; doExit ( - 1 ) ; } boolean formatOutput = false ; boolean useSourceLocation = false ; String inFileName = null ; String outFileName = null ; String dumpFileName = null ; String xslFileName = null ; String treedumpFileName = null ; PrintTraceListener tracer = null ; String outputType = null ; String media = null ; Vector params = new Vector ( ) ; boolean quietConflictWarnings = false ; URIResolver uriResolver = null ; EntityResolver entityResolver = null ; ContentHandler contentHandler = null ; int recursionLimit = - 1 ; for ( int i = 0 ; i < argv . length ; i ++ ) { if ( "-XSLTC" . equalsIgnoreCase ( argv [ i ] ) ) { } else if ( "-TT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceTemplates = true ; } else printInvalidXSLTCOption ( "-TT" ) ; } else if ( "-TG" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceGeneration = true ; } else printInvalidXSLTCOption ( "-TG" ) ; } else if ( "-TS" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceSelection = true ; } else printInvalidXSLTCOption ( "-TS" ) ; } else if ( "-TTC" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( null == tracer ) tracer = new PrintTraceListener ( diagnosticsWriter ) ; tracer . m_traceElements = true ; } else printInvalidXSLTCOption ( "-TTC" ) ; } else if ( "-INDENT" . equalsIgnoreCase ( argv [ i ] ) ) { int indentAmount ; if ( ( ( i + 1 ) < argv . length ) && ( argv [ i + 1 ] . charAt ( 0 ) != '-' ) ) { indentAmount = Integer . parseInt ( argv [ ++ i ] ) ; } else { indentAmount = 0 ; } } else if ( "-IN" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) inFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-IN" } ) ) ; } else if ( "-MEDIA" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) media = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-MEDIA" } ) ) ; } else if ( "-OUT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) outFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-OUT" } ) ) ; } else if ( "-XSL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) xslFileName = argv [ ++ i ] ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XSL" } ) ) ; } else if ( "-FLAVOR" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { flavor = argv [ ++ i ] ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-FLAVOR" } ) ) ; } else if ( "-PARAM" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 2 < argv . length ) { String name = argv [ ++ i ] ; params . addElement ( name ) ; String expression = argv [ ++ i ] ; params . addElement ( expression ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-PARAM" } ) ) ; } else if ( "-E" . equalsIgnoreCase ( argv [ i ] ) ) { } else if ( "-V" . equalsIgnoreCase ( argv [ i ] ) ) { diagnosticsWriter . println ( resbundle . getString ( "version" ) + XSLProcessorVersion . S_VERSION + ", " + resbundle . getString ( "version2" ) ) ; } else if ( "-QC" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) quietConflictWarnings = true ; else printInvalidXSLTCOption ( "-QC" ) ; } else if ( "-Q" . equalsIgnoreCase ( argv [ i ] ) ) { setQuietMode = true ; } else if ( "-DIAG" . equalsIgnoreCase ( argv [ i ] ) ) { doDiag = true ; } else if ( "-XML" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "xml" ; } else if ( "-TEXT" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "text" ; } else if ( "-HTML" . equalsIgnoreCase ( argv [ i ] ) ) { outputType = "html" ; } else if ( "-EDUMP" . equalsIgnoreCase ( argv [ i ] ) ) { doStackDumpOnError = true ; if ( ( ( i + 1 ) < argv . length ) && ( argv [ i + 1 ] . charAt ( 0 ) != '-' ) ) { dumpFileName = argv [ ++ i ] ; } } else if ( "-URIRESOLVER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { uriResolver = ( URIResolver ) Class . forName ( argv [ ++ i ] , true , ClassLoader . getSystemClassLoader ( ) ) . newInstance ( ) ; tfactory . setURIResolver ( uriResolver ) ; } catch ( Exception cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-URIResolver" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-URIResolver" } ) ) ; doExit ( - 1 ) ; } } else if ( "-ENTITYRESOLVER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { entityResolver = ( EntityResolver ) Class . forName ( argv [ ++ i ] , true , ClassLoader . getSystemClassLoader ( ) ) . newInstance ( ) ; } catch ( Exception cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-EntityResolver" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-EntityResolver" } ) ) ; doExit ( - 1 ) ; } } else if ( "-CONTENTHANDLER" . equalsIgnoreCase ( argv [ i ] ) ) { if ( i + 1 < argv . length ) { try { contentHandler = ( ContentHandler ) Class . forName ( argv [ ++ i ] , true , ClassLoader . getSystemClassLoader ( ) ) . newInstance ( ) ; } catch ( Exception cnfe ) { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_CLASS_NOT_FOUND_FOR_OPTION , new Object [ ] { "-ContentHandler" } ) ) ; doExit ( - 1 ) ; } } else { System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-ContentHandler" } ) ) ; doExit ( - 1 ) ; } } else if ( "-L" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) useSourceLocation = true ; else printInvalidXSLTCOption ( "-L" ) ; } else if ( "-INCREMENTAL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) tfactory . setAttribute ( "http://xml.apache.org/xalan/features/incremental" , java . lang . Boolean . TRUE ) ; else printInvalidXSLTCOption ( "-INCREMENTAL" ) ; } else if ( "-NOOPTIMIZE" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) tfactory . setAttribute ( "http://xml.apache.org/xalan/features/optimize" , java . lang . Boolean . FALSE ) ; else printInvalidXSLTCOption ( "-NOOPTIMIZE" ) ; } else if ( "-RL" . equalsIgnoreCase ( argv [ i ] ) ) { if ( ! useXSLTC ) { if ( i + 1 < argv . length ) recursionLimit = Integer . parseInt ( argv [ ++ i ] ) ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-rl" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXSLTCOption ( "-RL" ) ; } } else if ( "-XO" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) { tfactory . setAttribute ( "generate-translet" , "true" ) ; tfactory . setAttribute ( "translet-name" , argv [ ++ i ] ) ; } else tfactory . setAttribute ( "generate-translet" , "true" ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XO" ) ; } } else if ( "-XD" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) tfactory . setAttribute ( "destination-directory" , argv [ ++ i ] ) ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XD" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XD" ) ; } } else if ( "-XJ" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) { tfactory . setAttribute ( "generate-translet" , "true" ) ; tfactory . setAttribute ( "jar-name" , argv [ ++ i ] ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XJ" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XJ" ) ; } } else if ( "-XP" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) tfactory . setAttribute ( "package-name" , argv [ ++ i ] ) ; else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_MISSING_ARG_FOR_OPTION , new Object [ ] { "-XP" } ) ) ; } else { if ( i + 1 < argv . length && argv [ i + 1 ] . charAt ( 0 ) != '-' ) i ++ ; printInvalidXalanOption ( "-XP" ) ; } } else if ( "-XN" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { tfactory . setAttribute ( "enable-inlining" , "true" ) ; } else printInvalidXalanOption ( "-XN" ) ; } else if ( "-XX" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { tfactory . setAttribute ( "debug" , "true" ) ; } else printInvalidXalanOption ( "-XX" ) ; } else if ( "-XT" . equalsIgnoreCase ( argv [ i ] ) ) { if ( useXSLTC ) { tfactory . setAttribute ( "auto-translet" , "true" ) ; } else printInvalidXalanOption ( "-XT" ) ; } else System . err . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_OPTION , new Object [ ] { argv [ i ] } ) ) ; } if ( inFileName == null && xslFileName == null ) { System . err . println ( resbundle . getString ( "xslProc_no_input" ) ) ; doExit ( - 1 ) ; } try { long start = System . currentTimeMillis ( ) ; if ( null != dumpFileName ) { dumpWriter = new PrintWriter ( new FileWriter ( dumpFileName ) ) ; } Templates stylesheet = null ; if ( null != xslFileName ) { if ( flavor . equals ( "d2d" ) ) { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setNamespaceAware ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; Node xslDOM = docBuilder . parse ( new InputSource ( xslFileName ) ) ; stylesheet = tfactory . newTemplates ( new DOMSource ( xslDOM , xslFileName ) ) ; } else { stylesheet = tfactory . newTemplates ( new StreamSource ( xslFileName ) ) ; } } PrintWriter resultWriter ; StreamResult strResult ; if ( null != outFileName ) { strResult = new StreamResult ( new FileOutputStream ( outFileName ) ) ; strResult . setSystemId ( outFileName ) ; } else { strResult = new StreamResult ( System . out ) ; } SAXTransformerFactory stf = ( SAXTransformerFactory ) tfactory ; if ( ! useXSLTC && useSourceLocation ) stf . setAttribute ( XalanProperties . SOURCE_LOCATION , Boolean . TRUE ) ; if ( null == stylesheet ) { Source source = stf . getAssociatedStylesheet ( new StreamSource ( inFileName ) , media , null , null ) ; if ( null != source ) stylesheet = tfactory . newTemplates ( source ) ; else { if ( null != media ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEET_IN_MEDIA , new Object [ ] { inFileName , media } ) ) ; else throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_STYLESHEET_PI , new Object [ ] { inFileName } ) ) ; } } if ( null != stylesheet ) { Transformer transformer = flavor . equals ( "th" ) ? null : stylesheet . newTransformer ( ) ; if ( null != outputType ) { transformer . setOutputProperty ( OutputKeys . METHOD , outputType ) ; } if ( transformer instanceof org . apache . xalan . transformer . TransformerImpl ) { org . apache . xalan . transformer . TransformerImpl impl = ( org . apache . xalan . transformer . TransformerImpl ) transformer ; TraceManager tm = impl . getTraceManager ( ) ; if ( null != tracer ) tm . addTraceListener ( tracer ) ; impl . setQuietConflictWarnings ( quietConflictWarnings ) ; if ( useSourceLocation ) impl . setProperty ( XalanProperties . SOURCE_LOCATION , Boolean . TRUE ) ; if ( recursionLimit > 0 ) impl . setRecursionLimit ( recursionLimit ) ; } int nParams = params . size ( ) ; for ( int i = 0 ; i < nParams ; i += 2 ) { transformer . setParameter ( ( String ) params . elementAt ( i ) , ( String ) params . elementAt ( i + 1 ) ) ; } if ( uriResolver != null ) transformer . setURIResolver ( uriResolver ) ; if ( null != inFileName ) { if ( flavor . equals ( "d2d" ) ) { DocumentBuilderFactory dfactory = DocumentBuilderFactory . newInstance ( ) ; dfactory . setCoalescing ( true ) ; dfactory . setNamespaceAware ( true ) ; DocumentBuilder docBuilder = dfactory . newDocumentBuilder ( ) ; if ( entityResolver != null ) docBuilder . setEntityResolver ( entityResolver ) ; Node xmlDoc = docBuilder . parse ( new InputSource ( inFileName ) ) ; Document doc = docBuilder . newDocument ( ) ; org . w3c . dom . DocumentFragment outNode = doc . createDocumentFragment ( ) ; transformer . transform ( new DOMSource ( xmlDoc , inFileName ) , new DOMResult ( outNode ) ) ; Transformer serializer = stf . newTransformer ( ) ; Properties serializationProps = stylesheet . getOutputProperties ( ) ; serializer . setOutputProperties ( serializationProps ) ; if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; serializer . transform ( new DOMSource ( outNode ) , result ) ; } else serializer . transform ( new DOMSource ( outNode ) , strResult ) ; } else if ( flavor . equals ( "th" ) ) { for ( int i = 0 ; i < 1 ; i ++ ) { XMLReader reader = null ; try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } if ( ! useXSLTC ) stf . setAttribute ( org . apache . xalan . processor . TransformerFactoryImpl . FEATURE_INCREMENTAL , Boolean . TRUE ) ; TransformerHandler th = stf . newTransformerHandler ( stylesheet ) ; reader . setContentHandler ( th ) ; reader . setDTDHandler ( th ) ; if ( th instanceof org . xml . sax . ErrorHandler ) reader . setErrorHandler ( ( org . xml . sax . ErrorHandler ) th ) ; try { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , th ) ; } catch ( org . xml . sax . SAXNotRecognizedException e ) { } catch ( org . xml . sax . SAXNotSupportedException e ) { } try { reader . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } catch ( org . xml . sax . SAXException se ) { } th . setResult ( strResult ) ; reader . parse ( new InputSource ( inFileName ) ) ; } } else { if ( entityResolver != null ) { XMLReader reader = null ; try { javax . xml . parsers . SAXParserFactory factory = javax . xml . parsers . SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; javax . xml . parsers . SAXParser jaxpParser = factory . newSAXParser ( ) ; reader = jaxpParser . getXMLReader ( ) ; } catch ( javax . xml . parsers . ParserConfigurationException ex ) { throw new org . xml . sax . SAXException ( ex ) ; } catch ( javax . xml . parsers . FactoryConfigurationError ex1 ) { throw new org . xml . sax . SAXException ( ex1 . toString ( ) ) ; } catch ( NoSuchMethodError ex2 ) { } catch ( AbstractMethodError ame ) { } if ( null == reader ) { reader = XMLReaderFactory . createXMLReader ( ) ; } reader . setEntityResolver ( entityResolver ) ; if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; transformer . transform ( new SAXSource ( reader , new InputSource ( inFileName ) ) , result ) ; } else { transformer . transform ( new SAXSource ( reader , new InputSource ( inFileName ) ) , strResult ) ; } } else if ( contentHandler != null ) { SAXResult result = new SAXResult ( contentHandler ) ; transformer . transform ( new StreamSource ( inFileName ) , result ) ; } else { transformer . transform ( new StreamSource ( inFileName ) , strResult ) ; } } } else { StringReader reader = new StringReader ( "<?xml version=\"1.0\"?> <doc/>" ) ; transformer . transform ( new StreamSource ( reader ) , strResult ) ; } } else { diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_NOT_SUCCESSFUL , null ) ) ; doExit ( - 1 ) ; } if ( null != outFileName && strResult != null ) { java . io . OutputStream out = strResult . getOutputStream ( ) ; java . io . Writer writer = strResult . getWriter ( ) ; try { if ( out != null ) out . close ( ) ; if ( writer != null ) writer . close ( ) ; } catch ( java . io . IOException ie ) { } } long stop = System . currentTimeMillis ( ) ; long millisecondsDuration = stop - start ; if ( doDiag ) { Object [ ] msgArgs = new Object [ ] { inFileName , xslFileName , new Long ( millisecondsDuration ) } ; String msg = XSLMessages . createMessage ( "diagTiming" , msgArgs ) ; diagnosticsWriter . println ( '\n' ) ; diagnosticsWriter . println ( msg ) ; } } catch ( Throwable throwable ) { while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } if ( ( throwable instanceof NullPointerException ) || ( throwable instanceof ClassCastException ) ) doStackDumpOnError = true ; diagnosticsWriter . println ( ) ; if ( doStackDumpOnError ) throwable . printStackTrace ( dumpWriter ) ; else { DefaultErrorHandler . printLocation ( diagnosticsWriter , throwable ) ; diagnosticsWriter . println ( XSLMessages . createMessage ( XSLTErrorResources . ER_XSLT_ERROR , null ) + " (" + throwable . getClass ( ) . getName ( ) + "): " + throwable . getMessage ( ) ) ; } if ( null != dumpFileName ) { dumpWriter . close ( ) ; } doExit ( - 1 ) ; } if ( null != dumpFileName ) { dumpWriter . close ( ) ; } if ( null != diagnosticsWriter ) { } diagnosticsWriter . println ( "" ) ; } } static void doExit ( int i ) { System . exit ( i ) ; } private static void waitForReturnKey ( ResourceBundle resbundle ) { System . out . println ( resbundle . getString ( "xslProc_return_to_continue" ) ) ; try { while ( System . in . read ( ) != '\n' ) ; } catch ( java . io . IOException e ) { } } private static void printInvalidXSLTCOption ( String option ) { System . err . println ( XSLMessages . createMessage ( "xslProc_invalid_xsltc_option" , new Object [ ] { option } ) ) ; } private static void printInvalidXalanOption ( String option ) { System . err . println ( XSLMessages . createMessage ( "xslProc_invalid_xalan_option" , new Object [ ] { option } ) ) ; } } 	1
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Neg extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( - right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return - ( m_right . num ( xctxt ) ) ; } } 	0
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Param extends VariableBase { public String toString ( ) { return ( "param(" + _name + ")" ) ; } public void display ( int indent ) { indent ( indent ) ; System . out . println ( "param " + _name ) ; if ( _select != null ) { indent ( indent + IndentIncrement ) ; System . out . println ( "select " + _select . toString ( ) ) ; } displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { super . parseContents ( parser ) ; final SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof Stylesheet ) { _isLocal = false ; Param param = parser . getSymbolTable ( ) . lookupParam ( _name ) ; if ( param != null ) { final int us = this . getImportPrecedence ( ) ; final int them = param . getImportPrecedence ( ) ; if ( us == them ) { final String name = _name . toString ( ) ; reportError ( this , parser , ErrorMsg . VARIABLE_REDEF_ERR , name ) ; } else if ( them > us ) { _ignore = true ; return ; } else { param . disable ( ) ; } } ( ( Stylesheet ) parent ) . addParam ( this ) ; parser . getSymbolTable ( ) . addParam ( this ) ; } else if ( parent instanceof Template ) { _isLocal = true ; ( ( Template ) parent ) . hasParams ( true ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { _type = _select . typeCheck ( stable ) ; if ( _type instanceof ReferenceType == false ) { _select = new CastExpr ( _select , Type . Reference ) ; } } else if ( hasContents ( ) ) { typeCheckContents ( stable ) ; } _type = Type . Reference ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _ignore ) return ; _ignore = true ; final String name = getVariable ( ) ; final String signature = _type . toSignature ( ) ; final String className = _type . getClassName ( ) ; if ( isLocal ( ) ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , name ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , true ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , ADD_PARAMETER , ADD_PARAMETER_SIG ) ) ) ; if ( className != EMPTYSTRING ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } _type . translateUnBox ( classGen , methodGen ) ; if ( _refs . isEmpty ( ) ) { il . append ( _type . POP ( ) ) ; _local = null ; } else { _local = methodGen . addLocalVariable2 ( name , _type . toJCType ( ) , il . getEnd ( ) ) ; il . append ( _type . STORE ( _local . getIndex ( ) ) ) ; } } else { if ( classGen . containsField ( name ) == null ) { classGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( name ) , cpg . addUtf8 ( signature ) , null , cpg . getConstantPool ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , name ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , true ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , ADD_PARAMETER , ADD_PARAMETER_SIG ) ) ) ; _type . translateUnBox ( classGen , methodGen ) ; if ( className != EMPTYSTRING ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( classGen . getClassName ( ) , name , signature ) ) ) ; } } } } 	1
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMDOMException ; import org . apache . xml . dtm . DTMIterator ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeFilter ; public class DTMNodeIterator implements org . w3c . dom . traversal . NodeIterator { private DTMIterator dtm_iter ; private boolean valid = true ; public DTMNodeIterator ( DTMIterator dtmIterator ) { try { dtm_iter = ( DTMIterator ) dtmIterator . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } public DTMIterator getDTMIterator ( ) { return dtm_iter ; } public void detach ( ) { valid = false ; } public boolean getExpandEntityReferences ( ) { return false ; } public NodeFilter getFilter ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public Node getRoot ( ) { int handle = dtm_iter . getRoot ( ) ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } public int getWhatToShow ( ) { return dtm_iter . getWhatToShow ( ) ; } public Node nextNode ( ) throws DOMException { if ( ! valid ) throw new DTMDOMException ( DOMException . INVALID_STATE_ERR ) ; int handle = dtm_iter . nextNode ( ) ; if ( handle == DTM . NULL ) return null ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } public Node previousNode ( ) { if ( ! valid ) throw new DTMDOMException ( DOMException . INVALID_STATE_ERR ) ; int handle = dtm_iter . previousNode ( ) ; if ( handle == DTM . NULL ) return null ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } } 	0
package org . apache . xalan . transformer ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . KeyDeclaration ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . axes . OneStepIteratorForward ; public class KeyIterator extends OneStepIteratorForward { private QName m_name ; public QName getName ( ) { return m_name ; } private Vector m_keyDeclarations ; public Vector getKeyDeclarations ( ) { return m_keyDeclarations ; } KeyIterator ( QName name , Vector keyDeclarations ) { super ( Axis . ALL ) ; m_keyDeclarations = keyDeclarations ; m_name = name ; } public short acceptNode ( int testNode ) { boolean foundKey = false ; KeyIterator ki = ( KeyIterator ) m_lpi ; org . apache . xpath . XPathContext xctxt = ki . getXPathContext ( ) ; Vector keys = ki . getKeyDeclarations ( ) ; QName name = ki . getName ( ) ; try { int nDeclarations = keys . size ( ) ; for ( int i = 0 ; i < nDeclarations ; i ++ ) { KeyDeclaration kd = ( KeyDeclaration ) keys . elementAt ( i ) ; if ( ! kd . getName ( ) . equals ( name ) ) continue ; foundKey = true ; XPath matchExpr = kd . getMatch ( ) ; double score = matchExpr . getMatchScore ( xctxt , testNode ) ; if ( score == kd . getMatch ( ) . MATCH_SCORE_NONE ) continue ; return DTMIterator . FILTER_ACCEPT ; } } catch ( TransformerException se ) { } if ( ! foundKey ) throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_XSLKEY_DECLARATION , new Object [ ] { name . getLocalName ( ) } ) ) ; return DTMIterator . FILTER_REJECT ; } } 	1
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . dom . Axis ; import org . apache . xml . dtm . DTM ; final class ParentLocationPath extends RelativeLocationPath { private Expression _step ; private final RelativeLocationPath _path ; private Type stype ; private boolean _orderNodes = false ; private boolean _axisMismatch = false ; public ParentLocationPath ( RelativeLocationPath path , Expression step ) { _path = path ; _step = step ; _path . setParent ( this ) ; _step . setParent ( this ) ; if ( _step instanceof Step ) { _axisMismatch = checkAxisMismatch ( ) ; } } public void setAxis ( int axis ) { _path . setAxis ( axis ) ; } public int getAxis ( ) { return _path . getAxis ( ) ; } public RelativeLocationPath getPath ( ) { return ( _path ) ; } public Expression getStep ( ) { return ( _step ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _step . setParser ( parser ) ; _path . setParser ( parser ) ; } public String toString ( ) { return "ParentLocationPath(" + _path + ", " + _step + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { stype = _step . typeCheck ( stable ) ; _path . typeCheck ( stable ) ; if ( _axisMismatch ) enableNodeOrdering ( ) ; return _type = Type . NodeSet ; } public void enableNodeOrdering ( ) { SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof ParentLocationPath ) ( ( ParentLocationPath ) parent ) . enableNodeOrdering ( ) ; else { _orderNodes = true ; } } public boolean checkAxisMismatch ( ) { int left = _path . getAxis ( ) ; int right = ( ( Step ) _step ) . getAxis ( ) ; if ( ( ( left == Axis . ANCESTOR ) || ( left == Axis . ANCESTORORSELF ) ) && ( ( right == Axis . CHILD ) || ( right == Axis . DESCENDANT ) || ( right == Axis . DESCENDANTORSELF ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) || ( right == Axis . PRECEDINGSIBLING ) ) ) return true ; if ( ( left == Axis . CHILD ) && ( right == Axis . ANCESTOR ) || ( right == Axis . ANCESTORORSELF ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) ) return true ; if ( ( left == Axis . DESCENDANT ) || ( left == Axis . DESCENDANTORSELF ) ) return true ; if ( ( ( left == Axis . FOLLOWING ) || ( left == Axis . FOLLOWINGSIBLING ) ) && ( ( right == Axis . FOLLOWING ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) || ( right == Axis . PRECEDINGSIBLING ) ) ) return true ; if ( ( ( left == Axis . PRECEDING ) || ( left == Axis . PRECEDINGSIBLING ) ) && ( ( right == Axis . DESCENDANT ) || ( right == Axis . DESCENDANTORSELF ) || ( right == Axis . FOLLOWING ) || ( right == Axis . FOLLOWINGSIBLING ) || ( right == Axis . PARENT ) || ( right == Axis . PRECEDING ) || ( right == Axis . PRECEDINGSIBLING ) ) ) return true ; if ( ( right == Axis . FOLLOWING ) && ( left == Axis . CHILD ) ) { if ( _path instanceof Step ) { int type = ( ( Step ) _path ) . getNodeType ( ) ; if ( type == DTM . ATTRIBUTE_NODE ) return true ; } } return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int initSI = cpg . addMethodref ( STEP_ITERATOR_CLASS , "<init>" , "(" + NODE_ITERATOR_SIG + NODE_ITERATOR_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( STEP_ITERATOR_CLASS ) ) ) ; il . append ( DUP ) ; _path . translate ( classGen , methodGen ) ; _step . translate ( classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( initSI ) ) ; Expression stp = _step ; if ( stp instanceof ParentLocationPath ) stp = ( ( ParentLocationPath ) stp ) . getStep ( ) ; if ( ( _path instanceof Step ) && ( stp instanceof Step ) ) { final int path = ( ( Step ) _path ) . getAxis ( ) ; final int step = ( ( Step ) stp ) . getAxis ( ) ; if ( ( path == Axis . DESCENDANTORSELF && step == Axis . CHILD ) || ( path == Axis . PRECEDING && step == Axis . PARENT ) ) { final int incl = cpg . addMethodref ( NODE_ITERATOR_BASE , "includeSelf" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEVIRTUAL ( incl ) ) ; } } if ( _orderNodes ) { final int order = cpg . addInterfaceMethodref ( DOM_INTF , ORDER_ITERATOR , ORDER_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKEINTERFACE ( order , 3 ) ) ; } } } 	0
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncFloor extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( java . lang . Math . floor ( m_arg0 . execute ( xctxt ) . num ( ) ) ) ; } } 	1
package org . apache . xml . serializer ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . StringTokenizer ; public class Encodings extends Object { static final int m_defaultLastPrintable = 0x7F ; static final String ENCODINGS_FILE = "org/apache/xml/serializer/Encodings.properties" ; static final String ENCODINGS_PROP = "org.apache.xalan.serialize.encodings" ; private static final Class [ ] NO_CLASSES = new Class [ 0 ] ; private static final Object [ ] NO_OBJS = new Object [ 0 ] ; public static Writer getWriter ( OutputStream output , String encoding ) throws UnsupportedEncodingException { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { try { return new OutputStreamWriter ( output , _encodings [ i ] . javaName ) ; } catch ( java . lang . IllegalArgumentException iae ) { } catch ( UnsupportedEncodingException usee ) { } } } try { return new OutputStreamWriter ( output , encoding ) ; } catch ( java . lang . IllegalArgumentException iae ) { throw new UnsupportedEncodingException ( encoding ) ; } } public static Object getCharToByteConverter ( String encoding ) { Class charToByteConverterClass = null ; java . lang . reflect . Method getConverterMethod = null ; try { charToByteConverterClass = Class . forName ( "sun.io.CharToByteConverter" ) ; Class argTypes [ ] = new Class [ 1 ] ; argTypes [ 0 ] = String . class ; getConverterMethod = charToByteConverterClass . getMethod ( "getConverter" , argTypes ) ; } catch ( Exception e ) { System . err . println ( "Warning: Could not get charToByteConverterClass!" ) ; return null ; } Object args [ ] = new Object [ 1 ] ; for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { try { args [ 0 ] = _encodings [ i ] . javaName ; Object converter = getConverterMethod . invoke ( null , args ) ; if ( null != converter ) return converter ; } catch ( Exception iae ) { } } } return null ; } public static int getLastPrintable ( String encoding ) { EncodingInfo ei ; String normalizedEncoding = encoding . toUpperCase ( ) ; ei = ( EncodingInfo ) _encodingTableKeyJava . get ( normalizedEncoding ) ; if ( ei == null ) ei = ( EncodingInfo ) _encodingTableKeyMime . get ( normalizedEncoding ) ; if ( ei != null ) return ei . lastPrintable ; return m_defaultLastPrintable ; } public static int getLastPrintable ( ) { return m_defaultLastPrintable ; } public static final String DEFAULT_MIME_ENCODING = "UTF-8" ; public static String getMimeEncoding ( String encoding ) { if ( null == encoding ) { try { encoding = System . getProperty ( "file.encoding" , "UTF8" ) ; if ( null != encoding ) { String jencoding = ( encoding . equalsIgnoreCase ( "Cp1252" ) || encoding . equalsIgnoreCase ( "ISO8859_1" ) || encoding . equalsIgnoreCase ( "8859_1" ) || encoding . equalsIgnoreCase ( "UTF8" ) ) ? DEFAULT_MIME_ENCODING : convertJava2MimeEncoding ( encoding ) ; encoding = ( null != jencoding ) ? jencoding : DEFAULT_MIME_ENCODING ; } else { encoding = DEFAULT_MIME_ENCODING ; } } catch ( SecurityException se ) { encoding = DEFAULT_MIME_ENCODING ; } } else { encoding = convertJava2MimeEncoding ( encoding ) ; } return encoding ; } public static String convertJava2MimeEncoding ( String encoding ) { EncodingInfo enc = ( EncodingInfo ) _encodingTableKeyJava . get ( encoding . toUpperCase ( ) ) ; if ( null != enc ) return enc . name ; return encoding ; } public static String convertMime2JavaEncoding ( String encoding ) { for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { return _encodings [ i ] . javaName ; } } return encoding ; } private static EncodingInfo [ ] loadEncodingInfo ( ) { URL url = null ; try { String urlString = null ; try { urlString = System . getProperty ( ENCODINGS_PROP , "" ) ; } catch ( SecurityException e ) { } if ( urlString != null && urlString . length ( ) > 0 ) url = new URL ( urlString ) ; if ( url == null ) { ClassLoader cl = null ; try { java . lang . reflect . Method getCCL = Thread . class . getMethod ( "getContextClassLoader" , NO_CLASSES ) ; if ( getCCL != null ) { cl = ( ClassLoader ) getCCL . invoke ( Thread . currentThread ( ) , NO_OBJS ) ; } } catch ( Exception e ) { } if ( cl != null ) { url = cl . getResource ( ENCODINGS_FILE ) ; } } if ( url == null ) url = ClassLoader . getSystemResource ( ENCODINGS_FILE ) ; Properties props = new Properties ( ) ; if ( url != null ) { InputStream is = url . openStream ( ) ; props . load ( is ) ; is . close ( ) ; } else { } int totalEntries = props . size ( ) ; int totalMimeNames = 0 ; Enumeration keys = props . keys ( ) ; for ( int i = 0 ; i < totalEntries ; ++ i ) { String javaName = ( String ) keys . nextElement ( ) ; String val = props . getProperty ( javaName ) ; totalMimeNames ++ ; int pos = val . indexOf ( ' ' ) ; for ( int j = 0 ; j < pos ; ++ j ) if ( val . charAt ( j ) == ',' ) totalMimeNames ++ ; } EncodingInfo [ ] ret = new EncodingInfo [ totalMimeNames ] ; int j = 0 ; keys = props . keys ( ) ; for ( int i = 0 ; i < totalEntries ; ++ i ) { String javaName = ( String ) keys . nextElement ( ) ; String val = props . getProperty ( javaName ) ; int pos = val . indexOf ( ' ' ) ; String mimeName ; int lastPrintable ; if ( pos < 0 ) { mimeName = val ; lastPrintable = 0x00FF ; } else { lastPrintable = Integer . decode ( val . substring ( pos ) . trim ( ) ) . intValue ( ) ; StringTokenizer st = new StringTokenizer ( val . substring ( 0 , pos ) , "," ) ; for ( boolean first = true ; st . hasMoreTokens ( ) ; first = false ) { mimeName = st . nextToken ( ) ; ret [ j ] = new EncodingInfo ( mimeName , javaName , lastPrintable ) ; _encodingTableKeyMime . put ( mimeName . toUpperCase ( ) , ret [ j ] ) ; if ( first ) _encodingTableKeyJava . put ( javaName . toUpperCase ( ) , ret [ j ] ) ; j ++ ; } } } return ret ; } catch ( java . net . MalformedURLException mue ) { throw new org . apache . xml . utils . WrappedRuntimeException ( mue ) ; } catch ( java . io . IOException ioe ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ioe ) ; } } private static final Hashtable _encodingTableKeyJava = new Hashtable ( ) ; private static final Hashtable _encodingTableKeyMime = new Hashtable ( ) ; private static final EncodingInfo [ ] _encodings = loadEncodingInfo ( ) ; } 	0
package org . apache . xalan . lib ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMNodeIterator ; import org . apache . xpath . NodeSet ; public class ExsltCommon { public static String objectType ( Object obj ) { if ( obj instanceof String ) return "string" ; else if ( obj instanceof Boolean ) return "boolean" ; else if ( obj instanceof Number ) return "number" ; else if ( obj instanceof DTMNodeIterator ) { DTMIterator dtmI = ( ( DTMNodeIterator ) obj ) . getDTMIterator ( ) ; if ( dtmI instanceof org . apache . xpath . axes . RTFIterator ) return "RTF" ; else return "node-set" ; } else return "unknown" ; } public static NodeSet nodeSet ( ExpressionContext myProcessor , Object rtf ) { return Extensions . nodeset ( myProcessor , rtf ) ; } } 	1
package org . apache . xalan . xsltc . trax ; import javax . xml . transform . Result ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . sax . TransformerHandler ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . dom . DOMWSFilter ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . DefaultHandler ; public class TransformerHandlerImpl implements TransformerHandler , DeclHandler { private TransformerImpl _transformer ; private AbstractTranslet _translet = null ; private String _systemId ; private SAXImpl _dom = null ; private ContentHandler _handler = null ; private LexicalHandler _lexHandler = null ; private DTDHandler _dtdHandler = null ; private DeclHandler _declHandler = null ; private Result _result = null ; private Locator _locator = null ; private boolean _done = false ; private boolean _isIdentity = false ; public TransformerHandlerImpl ( TransformerImpl transformer ) { _transformer = transformer ; if ( transformer . isIdentity ( ) ) { _handler = new DefaultHandler ( ) ; _isIdentity = true ; } else { _translet = _transformer . getTranslet ( ) ; } } public String getSystemId ( ) { return _systemId ; } public void setSystemId ( String id ) { _systemId = id ; } public Transformer getTransformer ( ) { return _transformer ; } public void setResult ( Result result ) throws IllegalArgumentException { _result = result ; if ( _isIdentity ) { try { SerializationHandler outputHandler = _transformer . getOutputHandler ( result ) ; _transformer . transferOutputProperties ( outputHandler ) ; _handler = outputHandler ; _lexHandler = outputHandler ; } catch ( TransformerException e ) { _result = null ; } } else if ( _done ) { try { _transformer . setDOM ( _dom ) ; _transformer . transform ( null , _result ) ; } catch ( TransformerException e ) { throw new IllegalArgumentException ( e . getMessage ( ) ) ; } } } public void characters ( char [ ] ch , int start , int length ) throws SAXException { _handler . characters ( ch , start , length ) ; } public void startDocument ( ) throws SAXException { if ( _result == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_SET_RESULT_ERR ) ; throw new SAXException ( err . toString ( ) ) ; } if ( ! _isIdentity ) { boolean hasIdCall = ( _translet != null ) ? _translet . hasIdCall ( ) : false ; XSLTCDTMManager dtmManager = XSLTCDTMManager . newInstance ( ) ; DTMWSFilter wsFilter ; if ( _translet != null && _translet instanceof StripFilter ) { wsFilter = new DOMWSFilter ( _translet ) ; } else { wsFilter = null ; } _dom = ( SAXImpl ) dtmManager . getDTM ( null , false , wsFilter , true , false , hasIdCall ) ; _handler = _dom . getBuilder ( ) ; _lexHandler = ( LexicalHandler ) _handler ; _dtdHandler = ( DTDHandler ) _handler ; _declHandler = ( DeclHandler ) _handler ; _dom . setDocumentURI ( _systemId ) ; if ( _locator != null ) { _handler . setDocumentLocator ( _locator ) ; } } _handler . startDocument ( ) ; } public void endDocument ( ) throws SAXException { _handler . endDocument ( ) ; if ( ! _isIdentity ) { if ( _result != null ) { try { _transformer . setDOM ( _dom ) ; _transformer . transform ( null , _result ) ; } catch ( TransformerException e ) { throw new SAXException ( e ) ; } } _done = true ; _transformer . setDOM ( _dom ) ; } } public void startElement ( String uri , String localName , String qname , Attributes attributes ) throws SAXException { _handler . startElement ( uri , localName , qname , attributes ) ; } public void endElement ( String namespaceURI , String localName , String qname ) throws SAXException { _handler . endElement ( namespaceURI , localName , qname ) ; } public void processingInstruction ( String target , String data ) throws SAXException { _handler . processingInstruction ( target , data ) ; } public void startCDATA ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endCDATA ( ) ; } } public void comment ( char [ ] ch , int start , int length ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . comment ( ch , start , length ) ; } } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { _handler . ignorableWhitespace ( ch , start , length ) ; } public void setDocumentLocator ( Locator locator ) { _locator = locator ; if ( _handler != null ) { _handler . setDocumentLocator ( locator ) ; } } public void skippedEntity ( String name ) throws SAXException { _handler . skippedEntity ( name ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { _handler . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { _handler . endPrefixMapping ( prefix ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startDTD ( name , publicId , systemId ) ; } } public void endDTD ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endDTD ( ) ; } } public void startEntity ( String name ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startEntity ( name ) ; } } public void endEntity ( String name ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endEntity ( name ) ; } } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( _dtdHandler != null ) { _dtdHandler . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { if ( _dtdHandler != null ) { _dtdHandler . notationDecl ( name , publicId , systemId ) ; } } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( _declHandler != null ) { _declHandler . attributeDecl ( eName , aName , type , valueDefault , value ) ; } } public void elementDecl ( String name , String model ) throws SAXException { if ( _declHandler != null ) { _declHandler . elementDecl ( name , model ) ; } } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( _declHandler != null ) { _declHandler . externalEntityDecl ( name , publicId , systemId ) ; } } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( _declHandler != null ) { _declHandler . internalEntityDecl ( name , value ) ; } } } 	0
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class VariableStack implements Cloneable { public VariableStack ( ) { reset ( ) ; } public synchronized Object clone ( ) throws CloneNotSupportedException { VariableStack vs = ( VariableStack ) super . clone ( ) ; vs . _stackFrames = ( XObject [ ] ) _stackFrames . clone ( ) ; vs . _links = ( int [ ] ) _links . clone ( ) ; return vs ; } XObject [ ] _stackFrames = new XObject [ XPathContext . RECURSIONLIMIT * 2 ] ; int _frameTop ; private int _currentFrameBottom ; int [ ] _links = new int [ XPathContext . RECURSIONLIMIT ] ; int _linksTop ; public XObject elementAt ( final int i ) { return _stackFrames [ i ] ; } public int size ( ) { return _frameTop ; } public void reset ( ) { _frameTop = 0 ; _linksTop = 0 ; _links [ _linksTop ++ ] = 0 ; _stackFrames = new XObject [ _stackFrames . length ] ; } public void setStackFrame ( int sf ) { _currentFrameBottom = sf ; } public int getStackFrame ( ) { return _currentFrameBottom ; } public int link ( final int size ) { _currentFrameBottom = _frameTop ; _frameTop += size ; if ( _frameTop >= _stackFrames . length ) { XObject newsf [ ] = new XObject [ _stackFrames . length + ( 1024 * 4 ) + size ] ; System . arraycopy ( _stackFrames , 0 , newsf , 0 , _stackFrames . length ) ; _stackFrames = newsf ; } if ( _linksTop + 1 >= _links . length ) { int newlinks [ ] = new int [ _links . length + ( 1024 * 2 ) ] ; System . arraycopy ( _links , 0 , newlinks , 0 , _links . length ) ; _links = newlinks ; } _links [ _linksTop ++ ] = _currentFrameBottom ; return _currentFrameBottom ; } public void unlink ( ) { _frameTop = _links [ -- _linksTop ] ; _currentFrameBottom = _links [ _linksTop - 1 ] ; } public void unlink ( int currentFrame ) { _frameTop = _links [ -- _linksTop ] ; _currentFrameBottom = currentFrame ; } public void setLocalVariable ( int index , XObject val ) { _stackFrames [ index + _currentFrameBottom ] = val ; } public void setLocalVariable ( int index , XObject val , int stackFrame ) { _stackFrames [ index + stackFrame ] = val ; } public XObject getLocalVariable ( XPathContext xctxt , int index ) throws TransformerException { index += _currentFrameBottom ; XObject val = _stackFrames [ index ] ; if ( null == val ) throw new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VARIABLE_ACCESSED_BEFORE_BIND , null ) , xctxt . getSAXLocator ( ) ) ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return val ; } public XObject getLocalVariable ( int index , int frame ) throws TransformerException { index += frame ; XObject val = _stackFrames [ index ] ; return val ; } public XObject getLocalVariable ( XPathContext xctxt , int index , boolean destructiveOK ) throws TransformerException { index += _currentFrameBottom ; XObject val = _stackFrames [ index ] ; if ( null == val ) throw new TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VARIABLE_ACCESSED_BEFORE_BIND , null ) , xctxt . getSAXLocator ( ) ) ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return destructiveOK ? val : val . getFresh ( ) ; } public boolean isLocalSet ( int index ) throws TransformerException { return ( _stackFrames [ index + _currentFrameBottom ] != null ) ; } private static XObject [ ] m_nulls = new XObject [ 1024 ] ; public void clearLocalSlots ( int start , int len ) { start += _currentFrameBottom ; System . arraycopy ( m_nulls , 0 , _stackFrames , start , len ) ; } public void setGlobalVariable ( final int index , final XObject val ) { _stackFrames [ index ] = val ; } public XObject getGlobalVariable ( XPathContext xctxt , final int index ) throws TransformerException { XObject val = _stackFrames [ index ] ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return val ; } public XObject getGlobalVariable ( XPathContext xctxt , final int index , boolean destructiveOK ) throws TransformerException { XObject val = _stackFrames [ index ] ; if ( val . getType ( ) == XObject . CLASS_UNRESOLVEDVARIABLE ) return ( _stackFrames [ index ] = val . execute ( xctxt ) ) ; return destructiveOK ? val : val . getFresh ( ) ; } public XObject getVariableOrParam ( XPathContext xctxt , org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException { org . apache . xml . utils . PrefixResolver prefixResolver = xctxt . getNamespaceContext ( ) ; if ( prefixResolver instanceof org . apache . xalan . templates . ElemTemplateElement ) { org . apache . xalan . templates . ElemVariable vvar ; org . apache . xalan . templates . ElemTemplateElement prev = ( org . apache . xalan . templates . ElemTemplateElement ) prefixResolver ; if ( ! ( prev instanceof org . apache . xalan . templates . Stylesheet ) ) { while ( ! ( prev . getParentNode ( ) instanceof org . apache . xalan . templates . Stylesheet ) ) { org . apache . xalan . templates . ElemTemplateElement savedprev = prev ; while ( null != ( prev = prev . getPreviousSiblingElem ( ) ) ) { if ( prev instanceof org . apache . xalan . templates . ElemVariable ) { vvar = ( org . apache . xalan . templates . ElemVariable ) prev ; if ( vvar . getName ( ) . equals ( qname ) ) return getLocalVariable ( xctxt , vvar . getIndex ( ) ) ; } } prev = savedprev . getParentElem ( ) ; } } vvar = prev . getStylesheetRoot ( ) . getVariableOrParamComposed ( qname ) ; if ( null != vvar ) return getGlobalVariable ( xctxt , vvar . getIndex ( ) ) ; } throw new javax . xml . transform . TransformerException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_VAR_NOT_RESOLVABLE , new Object [ ] { qname . toString ( ) } ) ) ; } } 	1
package org . apache . xml . serializer ; public final class Method { public static final String XML = "xml" ; public static final String HTML = "html" ; public static final String XHTML = "xhtml" ; public static final String TEXT = "text" ; public static final String UNKNOWN = "" ; } 	0
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; public class OneStepIterator extends ChildTestIterator { protected int m_axis = - 1 ; protected DTMAxisIterator m_iterator ; OneStepIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; m_axis = WalkerFactory . getAxisFromStep ( compiler , firstStepPos ) ; } public OneStepIterator ( DTMAxisIterator iterator , int axis ) throws javax . xml . transform . TransformerException { super ( null ) ; m_iterator = iterator ; m_axis = axis ; int whatToShow = DTMFilter . SHOW_ALL ; initNodeTest ( whatToShow ) ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; if ( m_axis > - 1 ) m_iterator = m_cdtm . getAxisIterator ( m_axis ) ; m_iterator . setStartNode ( m_context ) ; } public void detach ( ) { if ( m_allowDetach ) { if ( m_axis > - 1 ) m_iterator = null ; super . detach ( ) ; } } protected int getNextNode ( ) { return m_lastFetched = m_iterator . next ( ) ; } public Object clone ( ) throws CloneNotSupportedException { OneStepIterator clone = ( OneStepIterator ) super . clone ( ) ; if ( m_iterator != null ) { clone . m_iterator = m_iterator . cloneIterator ( ) ; } return clone ; } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { OneStepIterator clone = ( OneStepIterator ) super . cloneWithReset ( ) ; clone . m_iterator = m_iterator ; return clone ; } public boolean isReverseAxes ( ) { return m_iterator . isReverse ( ) ; } protected int getProximityPosition ( int predicateIndex ) { if ( ! isReverseAxes ( ) ) return super . getProximityPosition ( predicateIndex ) ; if ( predicateIndex < 0 ) return - 1 ; if ( m_proximityPositions [ predicateIndex ] <= 0 ) { XPathContext xctxt = getXPathContext ( ) ; try { OneStepIterator clone = ( OneStepIterator ) this . clone ( ) ; int root = getRoot ( ) ; xctxt . pushCurrentNode ( root ) ; clone . setRoot ( root , xctxt ) ; clone . m_predCount = predicateIndex ; int count = 1 ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } m_proximityPositions [ predicateIndex ] += count ; } catch ( CloneNotSupportedException cnse ) { } finally { xctxt . popCurrentNode ( ) ; } } return m_proximityPositions [ predicateIndex ] ; } public int getLength ( ) { if ( ! isReverseAxes ( ) ) return super . getLength ( ) ; boolean isPredicateTest = ( this == m_execContext . getSubContextList ( ) ) ; int predCount = getPredicateCount ( ) ; if ( - 1 != m_length && isPredicateTest && m_predicateIndex < 1 ) return m_length ; int count = 0 ; XPathContext xctxt = getXPathContext ( ) ; try { OneStepIterator clone = ( OneStepIterator ) this . cloneWithReset ( ) ; int root = getRoot ( ) ; xctxt . pushCurrentNode ( root ) ; clone . setRoot ( root , xctxt ) ; clone . m_predCount = m_predicateIndex ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } } catch ( CloneNotSupportedException cnse ) { } finally { xctxt . popCurrentNode ( ) ; } if ( isPredicateTest && m_predicateIndex < 1 ) m_length = count ; return count ; } protected void countProximityPosition ( int i ) { if ( ! isReverseAxes ( ) ) super . countProximityPosition ( i ) ; else if ( i < m_proximityPositions . length ) m_proximityPositions [ i ] -- ; } public void reset ( ) { super . reset ( ) ; if ( null != m_iterator ) m_iterator . reset ( ) ; } public int getAxis ( ) { return m_axis ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; if ( m_axis != ( ( OneStepIterator ) expr ) . m_axis ) return false ; return true ; } } 	1
package org . apache . xml . serializer ; import javax . xml . transform . SourceLocator ; import org . xml . sax . SAXException ; public interface ExtendedContentHandler extends org . xml . sax . ContentHandler { public void addAttribute ( String uri , String localName , String rawName , String type , String value ) throws SAXException ; public void addAttributes ( org . xml . sax . Attributes atts ) throws org . xml . sax . SAXException ; public void addAttribute ( String qName , String value ) ; public void characters ( String chars ) throws SAXException ; public void endElement ( String elemName ) throws SAXException ; public void startElement ( String uri , String localName , String qName ) throws org . xml . sax . SAXException ; public void startElement ( String qName ) throws SAXException ; public void namespaceAfterStartElement ( String uri , String prefix ) throws SAXException ; public boolean startPrefixMapping ( String prefix , String uri , boolean shouldFlush ) throws SAXException ; public void entityReference ( String entityName ) throws SAXException ; public NamespaceMappings getNamespaceMappings ( ) ; public String getPrefix ( String uri ) ; public String getNamespaceURI ( String name , boolean isElement ) ; public String getNamespaceURIFromPrefix ( String prefix ) ; public void setSourceLocator ( SourceLocator locator ) ; } 	0
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XRTreeFrag ; import org . apache . xpath . objects . XRTreeFragSelectWrapper ; import org . apache . xpath . objects . XString ; public class ElemVariable extends ElemTemplateElement { public ElemVariable ( ) { } protected int m_index ; int m_frameSize = - 1 ; public void setIndex ( int index ) { m_index = index ; } public int getIndex ( ) { return m_index ; } private XPath m_selectPattern ; public void setSelect ( XPath v ) { m_selectPattern = v ; } public XPath getSelect ( ) { return m_selectPattern ; } protected QName m_qname ; public void setName ( QName v ) { m_qname = v ; } public QName getName ( ) { return m_qname ; } private boolean m_isTopLevel = false ; public void setIsTopLevel ( boolean v ) { m_isTopLevel = v ; } public boolean getIsTopLevel ( ) { return m_isTopLevel ; } public int getXSLToken ( ) { return Constants . ELEMNAME_VARIABLE ; } public String getNodeName ( ) { return Constants . ELEMNAME_VARIABLE_STRING ; } public ElemVariable ( ElemVariable param ) throws TransformerException { m_selectPattern = param . m_selectPattern ; m_qname = param . m_qname ; m_isTopLevel = param . m_isTopLevel ; } public void execute ( TransformerImpl transformer ) throws TransformerException { if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEvent ( this ) ; int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , var ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireTraceEndEvent ( this ) ; } public XObject getValue ( TransformerImpl transformer , int sourceNode ) throws TransformerException { XObject var ; XPathContext xctxt = transformer . getXPathContext ( ) ; xctxt . pushCurrentNode ( sourceNode ) ; try { if ( null != m_selectPattern ) { var = m_selectPattern . execute ( xctxt , sourceNode , this ) ; var . allowDetachToRelease ( false ) ; if ( TransformerImpl . S_DEBUG ) transformer . getTraceManager ( ) . fireSelectedEvent ( sourceNode , this , "select" , m_selectPattern , var ) ; } else if ( null == getFirstChildElem ( ) ) { var = XString . EMPTYSTRING ; } else { int df ; try { if ( m_parentNode instanceof Stylesheet ) df = transformer . transformToGlobalRTF ( this ) ; else df = transformer . transformToRTF ( this ) ; } finally { } var = new XRTreeFrag ( df , xctxt , this ) ; } } finally { xctxt . popCurrentNode ( ) ; } return var ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { if ( null == m_selectPattern && org . apache . xalan . processor . TransformerFactoryImpl . m_optimize ) { XPath newSelect = rewriteChildToExpression ( this ) ; if ( null != newSelect ) m_selectPattern = newSelect ; } StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_selectPattern ) m_selectPattern . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( ! ( m_parentNode instanceof Stylesheet ) && m_qname != null ) { m_index = cstate . addVariableName ( m_qname ) - cstate . getGlobalsSize ( ) ; } else if ( m_parentNode instanceof Stylesheet ) { cstate . resetStackFrameSize ( ) ; } super . compose ( sroot ) ; } public void endCompose ( StylesheetRoot sroot ) throws TransformerException { super . endCompose ( sroot ) ; if ( m_parentNode instanceof Stylesheet ) { StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; m_frameSize = cstate . getFrameSize ( ) ; cstate . resetStackFrameSize ( ) ; } } static XPath rewriteChildToExpression ( ElemTemplateElement varElem ) throws TransformerException { ElemTemplateElement t = varElem . getFirstChildElem ( ) ; if ( null != t && null == t . getNextSiblingElem ( ) ) { int etype = t . getXSLToken ( ) ; if ( Constants . ELEMNAME_VALUEOF == etype ) { ElemValueOf valueof = ( ElemValueOf ) t ; if ( valueof . getDisableOutputEscaping ( ) == false && valueof . getDOMBackPointer ( ) == null ) { varElem . m_firstChild = null ; return new XPath ( new XRTreeFragSelectWrapper ( valueof . getSelect ( ) . getExpression ( ) ) ) ; } } else if ( Constants . ELEMNAME_TEXTLITERALRESULT == etype ) { ElemTextLiteral lit = ( ElemTextLiteral ) t ; if ( lit . getDisableOutputEscaping ( ) == false && lit . getDOMBackPointer ( ) == null ) { String str = lit . getNodeValue ( ) ; XString xstr = new XString ( str ) ; varElem . m_firstChild = null ; return new XPath ( new XRTreeFragSelectWrapper ( xstr ) ) ; } } } return null ; } public void recompose ( StylesheetRoot root ) { root . recomposeVariables ( this ) ; } public void setParentElem ( ElemTemplateElement p ) { super . setParentElem ( p ) ; p . m_hasVariableDecl = true ; } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitVariableOrParamDecl ( this ) ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( null != m_selectPattern ) m_selectPattern . getExpression ( ) . callVisitors ( m_selectPattern , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } public boolean isPsuedoVar ( ) { java . lang . String ns = m_qname . getNamespaceURI ( ) ; if ( ( null != ns ) && ns . equals ( RedundentExprEliminator . PSUEDOVARNAMESPACE ) ) { if ( m_qname . getLocalName ( ) . startsWith ( "#" ) ) return true ; } return false ; } } 	1
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . PrefixResolverDefault ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class XPathAPI { public static Node selectSingleNode ( Node contextNode , String str ) throws TransformerException { return selectSingleNode ( contextNode , str , contextNode ) ; } public static Node selectSingleNode ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { NodeIterator nl = selectNodeIterator ( contextNode , str , namespaceNode ) ; return nl . nextNode ( ) ; } public static NodeIterator selectNodeIterator ( Node contextNode , String str ) throws TransformerException { return selectNodeIterator ( contextNode , str , contextNode ) ; } public static NodeIterator selectNodeIterator ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodeset ( ) ; } public static NodeList selectNodeList ( Node contextNode , String str ) throws TransformerException { return selectNodeList ( contextNode , str , contextNode ) ; } public static NodeList selectNodeList ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XObject list = eval ( contextNode , str , namespaceNode ) ; return list . nodelist ( ) ; } public static XObject eval ( Node contextNode , String str ) throws TransformerException { return eval ( contextNode , str , contextNode ) ; } public static XObject eval ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { XPathContext xpathSupport = new XPathContext ( ) ; PrefixResolverDefault prefixResolver = new PrefixResolverDefault ( ( namespaceNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( ( Document ) namespaceNode ) . getDocumentElement ( ) : namespaceNode ) ; XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } public static XObject eval ( Node contextNode , String str , PrefixResolver prefixResolver ) throws TransformerException { XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; XPathContext xpathSupport = new XPathContext ( ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } } 	0
package org . apache . xalan . xsltc . runtime ; import java . util . ListResourceBundle ; public class ErrorMessages extends ListResourceBundle { private static final Object [ ] [ ] m_errorMessages = { { BasisLibrary . RUN_TIME_INTERNAL_ERR , "Run-time internal error in ''{0}''" } , { BasisLibrary . RUN_TIME_COPY_ERR , "Run-time error when executing <xsl:copy>." } , { BasisLibrary . DATA_CONVERSION_ERR , "Invalid conversion from ''{0}'' to ''{1}''." } , { BasisLibrary . EXTERNAL_FUNC_ERR , "External function ''{0}'' not supported by XSLTC." } , { BasisLibrary . EQUALITY_EXPR_ERR , "Unknown argument type in equality expression." } , { BasisLibrary . INVALID_ARGUMENT_ERR , "Invalid argument type ''{0}'' in call to ''{1}''" } , { BasisLibrary . FORMAT_NUMBER_ERR , "Attempting to format number ''{0}'' using pattern ''{1}''." } , { BasisLibrary . ITERATOR_CLONE_ERR , "Cannot clone iterator ''{0}''." } , { BasisLibrary . AXIS_SUPPORT_ERR , "Iterator for axis ''{0}'' not supported." } , { BasisLibrary . TYPED_AXIS_SUPPORT_ERR , "Iterator for typed axis ''{0}'' not supported." } , { BasisLibrary . STRAY_ATTRIBUTE_ERR , "Attribute ''{0}'' outside of element." } , { BasisLibrary . STRAY_NAMESPACE_ERR , "Namespace declaration ''{0}''=''{1}'' outside of element." } , { BasisLibrary . NAMESPACE_PREFIX_ERR , "Namespace for prefix ''{0}'' has not been declared." } , { BasisLibrary . DOM_ADAPTER_INIT_ERR , "DOMAdapter created using wrong type of source DOM." } , { BasisLibrary . PARSER_DTD_SUPPORT_ERR , "The SAX parser you are using does not handle DTD declaration events." } , { BasisLibrary . NAMESPACES_SUPPORT_ERR , "The SAX parser you are using does not have support for XML Namespaces." } , { BasisLibrary . CANT_RESOLVE_RELATIVE_URI_ERR , "Could not resolve the URI reference ''{0}''." } } ; public Object [ ] [ ] getContents ( ) { return m_errorMessages ; } } 	1
package org . apache . xalan . xsltc . compiler ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xalan . xsltc . compiler . util . MethodType ; final class SymbolTable { private final Hashtable _stylesheets = new Hashtable ( ) ; private final Hashtable _primops = new Hashtable ( ) ; private Hashtable _variables = null ; private Hashtable _templates = null ; private Hashtable _attributeSets = null ; private Hashtable _aliases = null ; private Hashtable _excludedURI = null ; private Hashtable _decimalFormats = null ; public DecimalFormatting getDecimalFormatting ( QName name ) { if ( _decimalFormats == null ) return null ; return ( ( DecimalFormatting ) _decimalFormats . get ( name ) ) ; } public void addDecimalFormatting ( QName name , DecimalFormatting symbols ) { if ( _decimalFormats == null ) _decimalFormats = new Hashtable ( ) ; _decimalFormats . put ( name , symbols ) ; } public Stylesheet addStylesheet ( QName name , Stylesheet node ) { return ( Stylesheet ) _stylesheets . put ( name , node ) ; } public Stylesheet lookupStylesheet ( QName name ) { return ( Stylesheet ) _stylesheets . get ( name ) ; } public Template addTemplate ( Template template ) { final QName name = template . getName ( ) ; if ( _templates == null ) _templates = new Hashtable ( ) ; return ( Template ) _templates . put ( name , template ) ; } public Template lookupTemplate ( QName name ) { if ( _templates == null ) return null ; return ( Template ) _templates . get ( name ) ; } public Variable addVariable ( Variable variable ) { if ( _variables == null ) _variables = new Hashtable ( ) ; final String name = variable . getName ( ) . getStringRep ( ) ; return ( Variable ) _variables . put ( name , variable ) ; } public Param addParam ( Param parameter ) { if ( _variables == null ) _variables = new Hashtable ( ) ; final String name = parameter . getName ( ) . getStringRep ( ) ; return ( Param ) _variables . put ( name , parameter ) ; } public Variable lookupVariable ( QName qname ) { if ( _variables == null ) return null ; final String name = qname . getStringRep ( ) ; final Object obj = _variables . get ( name ) ; return obj instanceof Variable ? ( Variable ) obj : null ; } public Param lookupParam ( QName qname ) { if ( _variables == null ) return null ; final String name = qname . getStringRep ( ) ; final Object obj = _variables . get ( name ) ; return obj instanceof Param ? ( Param ) obj : null ; } public SyntaxTreeNode lookupName ( QName qname ) { if ( _variables == null ) return null ; final String name = qname . getStringRep ( ) ; return ( SyntaxTreeNode ) _variables . get ( name ) ; } public AttributeSet addAttributeSet ( AttributeSet atts ) { if ( _attributeSets == null ) _attributeSets = new Hashtable ( ) ; return ( AttributeSet ) _attributeSets . put ( atts . getName ( ) , atts ) ; } public AttributeSet lookupAttributeSet ( QName name ) { if ( _attributeSets == null ) return null ; return ( AttributeSet ) _attributeSets . get ( name ) ; } public void addPrimop ( String name , MethodType mtype ) { Vector methods = ( Vector ) _primops . get ( name ) ; if ( methods == null ) { _primops . put ( name , methods = new Vector ( ) ) ; } methods . addElement ( mtype ) ; } public Vector lookupPrimop ( String name ) { return ( Vector ) _primops . get ( name ) ; } private int _nsCounter = 0 ; public String generateNamespacePrefix ( ) { return ( new String ( "ns" + ( _nsCounter ++ ) ) ) ; } private SyntaxTreeNode _current = null ; public void setCurrentNode ( SyntaxTreeNode node ) { _current = node ; } public String lookupNamespace ( String prefix ) { if ( _current == null ) return ( Constants . EMPTYSTRING ) ; return ( _current . lookupNamespace ( prefix ) ) ; } public void addPrefixAlias ( String prefix , String alias ) { if ( _aliases == null ) _aliases = new Hashtable ( ) ; _aliases . put ( prefix , alias ) ; } public String lookupPrefixAlias ( String prefix ) { if ( _aliases == null ) return null ; return ( String ) _aliases . get ( prefix ) ; } public void excludeURI ( String uri ) { if ( uri == null ) return ; if ( _excludedURI == null ) _excludedURI = new Hashtable ( ) ; Integer refcnt = ( Integer ) _excludedURI . get ( uri ) ; if ( refcnt == null ) refcnt = new Integer ( 1 ) ; else refcnt = new Integer ( refcnt . intValue ( ) + 1 ) ; _excludedURI . put ( uri , refcnt ) ; } public void excludeNamespaces ( String prefixes ) { if ( prefixes != null ) { StringTokenizer tokens = new StringTokenizer ( prefixes ) ; while ( tokens . hasMoreTokens ( ) ) { final String prefix = tokens . nextToken ( ) ; final String uri ; if ( prefix . equals ( "#default" ) ) uri = lookupNamespace ( Constants . EMPTYSTRING ) ; else uri = lookupNamespace ( prefix ) ; if ( uri != null ) excludeURI ( uri ) ; } } } public boolean isExcludedNamespace ( String uri ) { if ( uri != null && _excludedURI != null ) { final Integer refcnt = ( Integer ) _excludedURI . get ( uri ) ; return ( refcnt != null && refcnt . intValue ( ) > 0 ) ; } return false ; } public void unExcludeNamespaces ( String prefixes ) { if ( _excludedURI == null ) return ; if ( prefixes != null ) { StringTokenizer tokens = new StringTokenizer ( prefixes ) ; while ( tokens . hasMoreTokens ( ) ) { final String prefix = tokens . nextToken ( ) ; final String uri ; if ( prefix . equals ( "#default" ) ) uri = lookupNamespace ( Constants . EMPTYSTRING ) ; else uri = lookupNamespace ( prefix ) ; Integer refcnt = ( Integer ) _excludedURI . get ( uri ) ; if ( refcnt != null ) _excludedURI . put ( uri , new Integer ( refcnt . intValue ( ) - 1 ) ) ; } } } } 	0
package org . apache . xml . utils . res ; public class XResources_ja_JP_HA extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x3042 , 0x3044 , 0x3046 , 0x3048 , 0x304a , 0x304b , 0x304d , 0x304f , 0x3051 , 0x3053 , 0x3055 , 0x3057 , 0x3059 , 0x305b , 0x305d , 0x305f , 0x3061 , 0x3064 , 0x3066 , 0x3068 , 0x306a , 0x306b , 0x306c , 0x306d , 0x306e , 0x306f , 0x3072 , 0x3075 , 0x3078 , 0x307b , 0x307e , 0x307f , 0x3080 , 0x3081 , 0x3082 , 0x3084 , 0x3086 , 0x3088 , 0x3089 , 0x308a , 0x308b , 0x308c , 0x308d , 0x308f , 0x3090 , 0x3091 , 0x3092 , 0x3093 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class GenerateIdCall extends FunctionCall { public GenerateIdCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; } else { argument ( ) . translate ( classGen , methodGen ) ; } final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "generate_idF" , GET_NODE_NAME_SIG ) ) ) ; } } 	0
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . transformer . TransformerImpl ; public class ElemUnknown extends ElemLiteralResult { public void execute ( TransformerImpl transformer ) throws TransformerException { } } 	1
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Div extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) / right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) / m_right . num ( xctxt ) ) ; } } 	0
package org . apache . xml . utils . res ; public class XResources_ja_JP_HI extends XResourceBundle { public Object [ ] [ ] getContents ( ) { return contents ; } static final Object [ ] [ ] contents = { { "ui_language" , "ja" } , { "help_language" , "ja" } , { "language" , "ja" } , { "alphabet" , new char [ ] { 0x3044 , 0x308d , 0x306f , 0x306b , 0x307b , 0x3078 , 0x3068 , 0x3061 , 0x308a , 0x306c , 0x308b , 0x3092 , 0x308f , 0x304b , 0x3088 , 0x305f , 0x308c , 0x305d , 0x3064 , 0x306d , 0x306a , 0x3089 , 0x3080 , 0x3046 , 0x3090 , 0x306e , 0x304a , 0x304f , 0x3084 , 0x307e , 0x3051 , 0x3075 , 0x3053 , 0x3048 , 0x3066 , 0x3042 , 0x3055 , 0x304d , 0x3086 , 0x3081 , 0x307f , 0x3057 , 0x3091 , 0x3072 , 0x3082 , 0x305b , 0x3059 } } , { "tradAlphabet" , new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' } } , { "orientation" , "LeftToRight" } , { "numbering" , "multiplicative-additive" } , { "multiplierOrder" , "follows" } , { "numberGroups" , new int [ ] { 1 } } , { "multiplier" , new long [ ] { Long . MAX_VALUE , Long . MAX_VALUE , 100000000 , 10000 , 1000 , 100 , 10 } } , { "multiplierChar" , new char [ ] { 0x4EAC , 0x5146 , 0x5104 , 0x4E07 , 0x5343 , 0x767e , 0x5341 } } , { "zero" , new char [ 0 ] } , { "digits" , new char [ ] { 0x4E00 , 0x4E8C , 0x4E09 , 0x56DB , 0x4E94 , 0x516D , 0x4E03 , 0x516B , 0x4E5D } } , { "tables" , new String [ ] { "digits" } } } ; } 	1
package org . apache . xpath . axes ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . functions . FuncLast ; import org . apache . xpath . functions . FuncPosition ; import org . apache . xpath . functions . Function ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . operations . Div ; import org . apache . xpath . operations . Minus ; import org . apache . xpath . operations . Mod ; import org . apache . xpath . operations . Mult ; import org . apache . xpath . operations . Plus ; import org . apache . xpath . operations . Quo ; import org . apache . xpath . operations . Variable ; public class HasPositionalPredChecker extends XPathVisitor { private boolean m_hasPositionalPred = false ; private int m_predDepth = 0 ; public static boolean check ( LocPathIterator path ) { HasPositionalPredChecker hppc = new HasPositionalPredChecker ( ) ; path . callVisitors ( null , hppc ) ; return hppc . m_hasPositionalPred ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { if ( ( func instanceof FuncPosition ) || ( func instanceof FuncLast ) ) m_hasPositionalPred = true ; return true ; } public boolean visitPredicate ( ExpressionOwner owner , Expression pred ) { m_predDepth ++ ; if ( m_predDepth == 1 ) { if ( ( pred instanceof Variable ) || ( pred instanceof XNumber ) || ( pred instanceof Div ) || ( pred instanceof Plus ) || ( pred instanceof Minus ) || ( pred instanceof Mod ) || ( pred instanceof Quo ) || ( pred instanceof Mult ) || ( pred instanceof org . apache . xpath . operations . Number ) || ( pred instanceof Function ) ) m_hasPositionalPred = true ; else pred . callVisitors ( owner , this ) ; } m_predDepth -- ; return false ; } } 	0
package org . apache . xpath . compiler ; import org . apache . xpath . functions . Function ; public class FuncLoader { private int m_funcID ; private String m_funcName ; public String getName ( ) { return m_funcName ; } public FuncLoader ( String funcName , int funcID ) { super ( ) ; m_funcID = funcID ; m_funcName = funcName ; } public Function getFunction ( ) throws javax . xml . transform . TransformerException { try { Class function ; if ( m_funcName . indexOf ( "." ) < 0 ) { String classname = "org.apache.xpath.functions." + m_funcName ; function = Class . forName ( classname ) ; } else function = Class . forName ( m_funcName ) ; Function func = ( Function ) function . newInstance ( ) ; return func ; } catch ( ClassNotFoundException e ) { throw new javax . xml . transform . TransformerException ( e ) ; } catch ( IllegalAccessException e ) { throw new javax . xml . transform . TransformerException ( e ) ; } catch ( InstantiationException e ) { throw new javax . xml . transform . TransformerException ( e ) ; } } } 	1
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class NodeCounterGenerator extends ClassGenerator { private Instruction _aloadTranslet ; public NodeCounterGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; } public void setTransletIndex ( int index ) { _aloadTranslet = new ALOAD ( index ) ; } public Instruction loadTranslet ( ) { return _aloadTranslet ; } public boolean isExternal ( ) { return true ; } } 	0
package org . apache . xalan . res ; import java . util . ListResourceBundle ; import org . apache . xpath . res . XPATHMessages ; public class XSLMessages extends XPATHMessages { private static ListResourceBundle XSLTBundle = null ; private static final String XSLT_ERROR_RESOURCES = "org.apache.xalan.res.XSLTErrorResources" ; public static final String createMessage ( String msgKey , Object args [ ] ) { if ( XSLTBundle == null ) XSLTBundle = loadResourceBundle ( XSLT_ERROR_RESOURCES ) ; if ( XSLTBundle != null ) { return createMsg ( XSLTBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } public static final String createWarning ( String msgKey , Object args [ ] ) { if ( XSLTBundle == null ) XSLTBundle = loadResourceBundle ( XSLT_ERROR_RESOURCES ) ; if ( XSLTBundle != null ) { return createMsg ( XSLTBundle , msgKey , args ) ; } else return "Could not load any resource bundles." ; } } 	1
package org . apache . xalan . xsltc . dom ; public interface DOMBuilder extends ExtendedSAX { } 	0
package org . apache . xalan . trace ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class TracerEvent implements java . util . EventListener { public final ElemTemplateElement m_styleNode ; public final TransformerImpl m_processor ; public final Node m_sourceNode ; public final QName m_mode ; public TracerEvent ( TransformerImpl processor , Node sourceNode , QName mode , ElemTemplateElement styleNode ) { this . m_processor = processor ; this . m_sourceNode = sourceNode ; this . m_mode = mode ; this . m_styleNode = styleNode ; } public static String printNode ( Node n ) { String r = n . hashCode ( ) + " " ; if ( n instanceof Element ) { r += "<" + n . getNodeName ( ) ; Node c = n . getFirstChild ( ) ; while ( null != c ) { if ( c instanceof Attr ) { r += printNode ( c ) + " " ; } c = c . getNextSibling ( ) ; } r += ">" ; } else { if ( n instanceof Attr ) { r += n . getNodeName ( ) + "=" + n . getNodeValue ( ) ; } else { r += n . getNodeName ( ) ; } } return r ; } public static String printNodeList ( NodeList l ) { String r = l . hashCode ( ) + "[" ; int len = l . getLength ( ) - 1 ; int i = 0 ; while ( i < len ) { Node n = l . item ( i ) ; if ( null != n ) { r += printNode ( n ) + ", " ; } ++ i ; } if ( i == len ) { Node n = l . item ( len ) ; if ( null != n ) { r += printNode ( n ) ; } } return r + "]" ; } } 	1
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . objects . XNodeSet ; public class FilterExprIterator extends BasicTestIterator { private Expression m_expr ; transient private XNodeSet m_exprObj ; private boolean m_mustHardReset = false ; private boolean m_canDetachNodeset = true ; public FilterExprIterator ( ) { super ( null ) ; } public FilterExprIterator ( Expression expr ) { super ( null ) ; m_expr = expr ; } public void setRoot ( int context , Object environment ) { super . setRoot ( context , environment ) ; m_exprObj = FilterExprIteratorSimple . executeFilterExpr ( context , m_execContext , getPrefixResolver ( ) , getIsTopLevel ( ) , m_stackFrame , m_expr ) ; } protected int getNextNode ( ) { if ( null != m_exprObj ) { m_lastFetched = m_exprObj . nextNode ( ) ; } else m_lastFetched = DTM . NULL ; return m_lastFetched ; } public void detach ( ) { super . detach ( ) ; m_exprObj . detach ( ) ; m_exprObj = null ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; m_expr . fixupVariables ( vars , globalsSize ) ; } public Expression getInnerExpression ( ) { return m_expr ; } public void setInnerExpression ( Expression expr ) { expr . exprSetParent ( this ) ; m_expr = expr ; } public int getAnalysisBits ( ) { if ( null != m_expr && m_expr instanceof PathComponent ) { return ( ( PathComponent ) m_expr ) . getAnalysisBits ( ) ; } return WalkerFactory . BIT_FILTER ; } public boolean isDocOrdered ( ) { return m_exprObj . isDocOrdered ( ) ; } class filterExprOwner implements ExpressionOwner { public Expression getExpression ( ) { return m_expr ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( FilterExprIterator . this ) ; m_expr = exp ; } } public void callPredicateVisitors ( XPathVisitor visitor ) { m_expr . callVisitors ( new filterExprOwner ( ) , visitor ) ; super . callPredicateVisitors ( visitor ) ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; FilterExprIterator fet = ( FilterExprIterator ) expr ; if ( ! m_expr . deepEquals ( fet . m_expr ) ) return false ; return true ; } } 	0
package org . apache . xalan . xsltc . compiler ; import java . text . Collator ; import java . util . ArrayList ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . Method ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ANEWARRAY ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . NOP ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . bcel . generic . TABLESWITCH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . CompareGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSortRecordFactGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSortRecordGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . dom . Axis ; final class Sort extends Instruction implements Closure { private Expression _select ; private AttributeValue _order ; private AttributeValue _caseOrder ; private AttributeValue _dataType ; private String _data = null ; public String _lang ; public String _country ; private String _className = null ; private ArrayList _closureVars = null ; private boolean _needsSortRecordFactory = false ; public boolean inInnerClass ( ) { return ( _className != null ) ; } public Closure getParentClosure ( ) { return null ; } public String getInnerClassName ( ) { return _className ; } public void addVariable ( VariableRefBase variableRef ) { if ( _closureVars == null ) { _closureVars = new ArrayList ( ) ; } if ( ! _closureVars . contains ( variableRef ) ) { _closureVars . add ( variableRef ) ; _needsSortRecordFactory = true ; } } private void setInnerClassName ( String className ) { _className = className ; } public void parseContents ( Parser parser ) { final SyntaxTreeNode parent = getParent ( ) ; if ( ! ( parent instanceof ApplyTemplates ) && ! ( parent instanceof ForEach ) ) { reportError ( this , parser , ErrorMsg . STRAY_SORT_ERR , null ) ; return ; } _select = parser . parseExpression ( this , "select" , "string(.)" ) ; String val = getAttribute ( "order" ) ; if ( val . length ( ) == 0 ) val = "ascending" ; _order = AttributeValue . create ( this , val , parser ) ; val = getAttribute ( "case-order" ) ; if ( val . length ( ) == 0 ) val = "upper-first" ; _caseOrder = AttributeValue . create ( this , val , parser ) ; val = getAttribute ( "data-type" ) ; if ( val . length ( ) == 0 ) { try { final Type type = _select . typeCheck ( parser . getSymbolTable ( ) ) ; if ( type instanceof IntType ) val = "number" ; else val = "text" ; } catch ( TypeCheckError e ) { val = "text" ; } } _dataType = AttributeValue . create ( this , val , parser ) ; if ( ( val = getAttribute ( "lang" ) ) != null ) { try { StringTokenizer st = new StringTokenizer ( val , "-" , false ) ; _lang = st . nextToken ( ) ; _country = st . nextToken ( ) ; } catch ( NoSuchElementException e ) { } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tselect = _select . typeCheck ( stable ) ; if ( ! ( tselect instanceof StringType ) ) { _select = new CastExpr ( _select , Type . String ) ; } _order . typeCheck ( stable ) ; _caseOrder . typeCheck ( stable ) ; _dataType . typeCheck ( stable ) ; return Type . Void ; } public void translateSortType ( ClassGenerator classGen , MethodGenerator methodGen ) { _dataType . translate ( classGen , methodGen ) ; } public void translateSortOrder ( ClassGenerator classGen , MethodGenerator methodGen ) { _order . translate ( classGen , methodGen ) ; } public void translateSelect ( ClassGenerator classGen , MethodGenerator methodGen ) { _select . translate ( classGen , methodGen ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } public static void translateSortIterator ( ClassGenerator classGen , MethodGenerator methodGen , Expression nodeSet , Vector sortObjects ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int init = cpg . addMethodref ( SORT_ITERATOR , "<init>" , "(" + NODE_ITERATOR_SIG + NODE_SORT_FACTORY_SIG + ")V" ) ; il . append ( new NEW ( cpg . addClass ( SORT_ITERATOR ) ) ) ; il . append ( DUP ) ; if ( nodeSet == null ) { final int children = cpg . addInterfaceMethodref ( DOM_INTF , "getAxisIterator" , "(I)" + NODE_ITERATOR_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , Axis . CHILD ) ) ; il . append ( new INVOKEINTERFACE ( children , 2 ) ) ; } else { nodeSet . translate ( classGen , methodGen ) ; } compileSortRecordFactory ( sortObjects , classGen , methodGen ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } public static void compileSortRecordFactory ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen ) { String sortRecordClass = compileSortRecord ( sortObjects , classGen , methodGen ) ; boolean needsSortRecordFactory = false ; final int nsorts = sortObjects . size ( ) ; for ( int i = 0 ; i < nsorts ; i ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( i ) ; needsSortRecordFactory |= sort . _needsSortRecordFactory ; } String sortRecordFactoryClass = NODE_SORT_FACTORY ; if ( needsSortRecordFactory ) { sortRecordFactoryClass = compileSortRecordFactory ( sortObjects , classGen , methodGen , sortRecordClass ) ; } final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( sortRecordFactoryClass ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new PUSH ( cpg , sortRecordClass ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , nsorts ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int level = 0 ; level < nsorts ; level ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , level ) ) ; sort . translateSortOrder ( classGen , methodGen ) ; il . append ( AASTORE ) ; } il . append ( new PUSH ( cpg , nsorts ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int level = 0 ; level < nsorts ; level ++ ) { final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , level ) ) ; sort . translateSortType ( classGen , methodGen ) ; il . append ( AASTORE ) ; } il . append ( new INVOKESPECIAL ( cpg . addMethodref ( sortRecordFactoryClass , "<init>" , "(" + DOM_INTF_SIG + STRING_SIG + TRANSLET_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + ")V" ) ) ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { VariableRefBase varRef = ( VariableRefBase ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; il . append ( DUP ) ; il . append ( var . loadInstruction ( ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( sortRecordFactoryClass , var . getVariable ( ) , var . getType ( ) . toSignature ( ) ) ) ) ; dups . add ( varRef ) ; } } } public static String compileSortRecordFactory ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen , String sortRecordClass ) { final XSLTC xsltc = ( ( Sort ) sortObjects . firstElement ( ) ) . getXSLTC ( ) ; final String className = xsltc . getHelperClassName ( ) ; final NodeSortRecordFactGenerator sortRecordFactory = new NodeSortRecordFactGenerator ( className , NODE_SORT_FACTORY , className + ".java" , ACC_PUBLIC | ACC_SUPER | ACC_FINAL , new String [ ] { } , classGen . getStylesheet ( ) ) ; ConstantPoolGen cpg = sortRecordFactory . getConstantPool ( ) ; final int nsorts = sortObjects . size ( ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final VariableRef varRef = ( VariableRef ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; sortRecordFactory . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getVariable ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; dups . add ( varRef ) ; } } final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 5 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( STRING_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_INTF_SIG ) ; argTypes [ 3 ] = Util . getJCRefType ( "[" + STRING_SIG ) ; argTypes [ 4 ] = Util . getJCRefType ( "[" + STRING_SIG ) ; final String [ ] argNames = new String [ 5 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = "className" ; argNames [ 2 ] = TRANSLET_PNAME ; argNames [ 3 ] = "order" ; argNames [ 4 ] = "type" ; InstructionList il = new InstructionList ( ) ; final MethodGenerator constructor = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "<init>" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ALOAD_1 ) ; il . append ( ALOAD_2 ) ; il . append ( new ALOAD ( 3 ) ) ; il . append ( new ALOAD ( 4 ) ) ; il . append ( new ALOAD ( 5 ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_FACTORY , "<init>" , "(" + DOM_INTF_SIG + STRING_SIG + TRANSLET_INTF_SIG + "[" + STRING_SIG + "[" + STRING_SIG + ")V" ) ) ) ; il . append ( RETURN ) ; il = new InstructionList ( ) ; final MethodGenerator makeNodeSortRecord = new MethodGenerator ( ACC_PUBLIC , Util . getJCRefType ( NODE_SORT_RECORD_SIG ) , new org . apache . bcel . generic . Type [ ] { org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT } , new String [ ] { "node" , "last" } , "makeNodeSortRecord" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( ILOAD_1 ) ; il . append ( ILOAD_2 ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_FACTORY , "makeNodeSortRecord" , "(II)" + NODE_SORT_RECORD_SIG ) ) ) ; il . append ( DUP ) ; il . append ( new CHECKCAST ( cpg . addClass ( sortRecordClass ) ) ) ; final int ndups = dups . size ( ) ; for ( int i = 0 ; i < ndups ; i ++ ) { final VariableRef varRef = ( VariableRef ) dups . get ( i ) ; final VariableBase var = varRef . getVariable ( ) ; final Type varType = var . getType ( ) ; il . append ( DUP ) ; il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( className , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( sortRecordClass , var . getVariable ( ) , varType . toSignature ( ) ) ) ) ; } il . append ( POP ) ; il . append ( ARETURN ) ; constructor . setMaxLocals ( ) ; constructor . setMaxStack ( ) ; sortRecordFactory . addMethod ( constructor . getMethod ( ) ) ; makeNodeSortRecord . setMaxLocals ( ) ; makeNodeSortRecord . setMaxStack ( ) ; sortRecordFactory . addMethod ( makeNodeSortRecord . getMethod ( ) ) ; xsltc . dumpClass ( sortRecordFactory . getJavaClass ( ) ) ; return className ; } private static String compileSortRecord ( Vector sortObjects , ClassGenerator classGen , MethodGenerator methodGen ) { final XSLTC xsltc = ( ( Sort ) sortObjects . firstElement ( ) ) . getXSLTC ( ) ; final String className = xsltc . getHelperClassName ( ) ; final NodeSortRecordGenerator sortRecord = new NodeSortRecordGenerator ( className , NODE_SORT_RECORD , "sort$0.java" , ACC_PUBLIC | ACC_SUPER | ACC_FINAL , new String [ ] { } , classGen . getStylesheet ( ) ) ; final ConstantPoolGen cpg = sortRecord . getConstantPool ( ) ; final int nsorts = sortObjects . size ( ) ; final ArrayList dups = new ArrayList ( ) ; for ( int j = 0 ; j < nsorts ; j ++ ) { final Sort sort = ( Sort ) sortObjects . get ( j ) ; sort . setInnerClassName ( className ) ; final int length = ( sort . _closureVars == null ) ? 0 : sort . _closureVars . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final VariableRef varRef = ( VariableRef ) sort . _closureVars . get ( i ) ; if ( dups . contains ( varRef ) ) continue ; final VariableBase var = varRef . getVariable ( ) ; sortRecord . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( var . getVariable ( ) ) , cpg . addUtf8 ( var . getType ( ) . toSignature ( ) ) , null , cpg . getConstantPool ( ) ) ) ; dups . add ( varRef ) ; } } Method init = compileInit ( sortObjects , sortRecord , cpg , className ) ; Method extract = compileExtract ( sortObjects , sortRecord , cpg , className ) ; sortRecord . addMethod ( init ) ; sortRecord . addMethod ( extract ) ; xsltc . dumpClass ( sortRecord . getJavaClass ( ) ) ; return className ; } private static Method compileInit ( Vector sortObjects , NodeSortRecordGenerator sortRecord , ConstantPoolGen cpg , String className ) { final InstructionList il = new InstructionList ( ) ; final MethodGenerator init = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , null , null , "<init>" , className , il , cpg ) ; il . append ( ALOAD_0 ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( NODE_SORT_RECORD , "<init>" , "()V" ) ) ) ; final int initLocale = cpg . addMethodref ( "java/util/Locale" , "<init>" , "(Ljava/lang/String;" + "Ljava/lang/String;)V" ) ; final int getCollator = cpg . addMethodref ( COLLATOR_CLASS , "getInstance" , "(Ljava/util/Locale;)" + COLLATOR_SIG ) ; final int setStrength = cpg . addMethodref ( COLLATOR_CLASS , "setStrength" , "(I)V" ) ; final int levels = sortObjects . size ( ) ; String language = null ; String country = null ; Sort sort = ( Sort ) sortObjects . elementAt ( 0 ) ; for ( int level = 0 ; level < levels ; level ++ ) { if ( language == null && sort . _lang != null ) { language = sort . _lang ; } if ( country == null && sort . _country != null ) { country = sort . _country ; } } final int collator = cpg . addFieldref ( className , "_collator" , COLLATOR_SIG ) ; final int locale = cpg . addFieldref ( className , "_locale" , LOCALE_SIG ) ; if ( language != null ) { il . append ( new NEW ( cpg . addClass ( "java/util/Locale" ) ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , language ) ) ; il . append ( new PUSH ( cpg , ( country != null ? country : EMPTYSTRING ) ) ) ; il . append ( new INVOKESPECIAL ( initLocale ) ) ; il . append ( ALOAD_0 ) ; il . append ( SWAP ) ; il . append ( new PUTFIELD ( locale ) ) ; il . append ( new INVOKESTATIC ( getCollator ) ) ; il . append ( ALOAD_0 ) ; il . append ( SWAP ) ; il . append ( new PUTFIELD ( collator ) ) ; } il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( collator ) ) ; il . append ( new ICONST ( Collator . TERTIARY ) ) ; il . append ( new INVOKEVIRTUAL ( setStrength ) ) ; il . append ( RETURN ) ; init . stripAttributes ( true ) ; init . setMaxLocals ( ) ; init . setMaxStack ( ) ; return init . getMethod ( ) ; } private static Method compileExtract ( Vector sortObjects , NodeSortRecordGenerator sortRecord , ConstantPoolGen cpg , String className ) { final InstructionList il = new InstructionList ( ) ; final CompareGenerator extractMethod = new CompareGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . STRING , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( DOM_INTF_SIG ) , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT , Util . getJCRefType ( TRANSLET_SIG ) , org . apache . bcel . generic . Type . INT } , new String [ ] { "dom" , "current" , "level" , "translet" , "last" } , "extractValueFromDOM" , className , il , cpg ) ; final int levels = sortObjects . size ( ) ; final int match [ ] = new int [ levels ] ; final InstructionHandle target [ ] = new InstructionHandle [ levels ] ; InstructionHandle tblswitch = null ; if ( levels > 1 ) { il . append ( new ILOAD ( extractMethod . getLocalIndex ( "level" ) ) ) ; tblswitch = il . append ( new NOP ( ) ) ; } for ( int level = 0 ; level < levels ; level ++ ) { match [ level ] = level ; final Sort sort = ( Sort ) sortObjects . elementAt ( level ) ; target [ level ] = il . append ( NOP ) ; sort . translateSelect ( sortRecord , extractMethod ) ; il . append ( ARETURN ) ; } if ( levels > 1 ) { InstructionHandle defaultTarget = il . append ( new PUSH ( cpg , EMPTYSTRING ) ) ; il . insert ( tblswitch , new TABLESWITCH ( match , target , defaultTarget ) ) ; il . append ( ARETURN ) ; } extractMethod . stripAttributes ( true ) ; extractMethod . setMaxLocals ( ) ; extractMethod . setMaxStack ( ) ; extractMethod . removeNOPs ( ) ; return extractMethod . getMethod ( ) ; } } 	1
