package org . apache . velocity . app . event . implement ; import org . apache . oro . text . perl . MalformedPerl5PatternException ; import org . apache . oro . text . perl . Perl5Util ; import org . apache . velocity . app . event . ReferenceInsertionEventHandler ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; import org . apache . velocity . util . StringUtils ; public abstract class EscapeReference implements ReferenceInsertionEventHandler , RuntimeServicesAware { private Perl5Util perl = new Perl5Util ( ) ; private RuntimeServices rs ; private String matchRegExp = null ; protected abstract String escape ( Object text ) ; protected abstract String getMatchAttribute ( ) ; public Object referenceInsert ( String reference , Object value ) { if ( value == null ) { return value ; } if ( matchRegExp == null ) { return escape ( value ) ; } else if ( perl . match ( matchRegExp , reference ) ) { return escape ( value ) ; } else { return value ; } } public void setRuntimeServices ( RuntimeServices rs ) { this . rs = rs ; matchRegExp = StringUtils . nullTrim ( rs . getConfiguration ( ) . getString ( getMatchAttribute ( ) ) ) ; if ( ( matchRegExp != null ) && ( matchRegExp . length ( ) == 0 ) ) { matchRegExp = null ; } if ( matchRegExp != null ) { try { perl . match ( matchRegExp , "" ) ; } catch ( MalformedPerl5PatternException E ) { rs . getLog ( ) . error ( "Invalid regular expression '" + matchRegExp + "'.  No escaping will be performed." , E ) ; matchRegExp = null ; } } } protected RuntimeServices getRuntimeServices ( ) { return rs ; } } 	0
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . parser . node . Node ; public class Macro extends Directive { private static boolean debugMode = false ; public String getName ( ) { return "macro" ; } public int getType ( ) { return BLOCK ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException { return true ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; } public static void processAndRegister ( RuntimeServices rs , Token t , Node node , String sourceTemplate ) throws IOException , ParseException { int numArgs = node . jjtGetNumChildren ( ) ; if ( numArgs < 2 ) { rs . getLog ( ) . error ( "#macro error : Velocimacro must have name as 1st " + "argument to #macro(). #args = " + numArgs ) ; throw new MacroParseException ( "First argument to #macro() must be " + " macro name." , sourceTemplate , t ) ; } int firstType = node . jjtGetChild ( 0 ) . getType ( ) ; if ( firstType != ParserTreeConstants . JJTWORD ) { throw new MacroParseException ( "First argument to #macro() must be a" + " token without surrounding \' or \", which specifies" + " the macro name.  Currently it is a " + ParserTreeConstants . jjtNodeName [ firstType ] , sourceTemplate , t ) ; } String argArray [ ] = getArgArray ( node , rs ) ; rs . addVelocimacro ( argArray [ 0 ] , node . jjtGetChild ( numArgs - 1 ) , argArray , sourceTemplate ) ; } private static String [ ] getArgArray ( Node node , RuntimeServices rsvc ) { int numArgs = node . jjtGetNumChildren ( ) ; numArgs -- ; String argArray [ ] = new String [ numArgs ] ; int i = 0 ; while ( i < numArgs ) { argArray [ i ] = node . jjtGetChild ( i ) . getFirstToken ( ) . image ; if ( i > 0 ) { if ( argArray [ i ] . startsWith ( "$" ) ) { argArray [ i ] = argArray [ i ] . substring ( 1 , argArray [ i ] . length ( ) ) ; } } i ++ ; } if ( debugMode ) { StringBuffer msg = new StringBuffer ( "Macro.getArgArray() : nbrArgs=" ) ; msg . append ( numArgs ) . append ( " : " ) ; macroToString ( msg , argArray ) ; rsvc . getLog ( ) . debug ( msg ) ; } return argArray ; } public static final StringBuffer macroToString ( final StringBuffer buf , final String [ ] argArray ) { StringBuffer ret = ( buf == null ) ? new StringBuffer ( ) : buf ; ret . append ( '#' ) . append ( argArray [ 0 ] ) . append ( "( " ) ; for ( int i = 1 ; i < argArray . length ; i ++ ) { ret . append ( ' ' ) . append ( argArray [ i ] ) ; } ret . append ( " )" ) ; return ret ; } } 	1
package org . apache . velocity . runtime . directive ; public interface DirectiveConstants { public static final int BLOCK = 1 ; public static final int LINE = 2 ; } 	0
package org . apache . velocity . runtime . parser . node ; public interface ParserVisitor { public Object visit ( SimpleNode node , Object data ) ; public Object visit ( ASTprocess node , Object data ) ; public Object visit ( ASTEscapedDirective node , Object data ) ; public Object visit ( ASTEscape node , Object data ) ; public Object visit ( ASTComment node , Object data ) ; public Object visit ( ASTFloatingPointLiteral node , Object data ) ; public Object visit ( ASTIntegerLiteral node , Object data ) ; public Object visit ( ASTStringLiteral node , Object data ) ; public Object visit ( ASTIdentifier node , Object data ) ; public Object visit ( ASTWord node , Object data ) ; public Object visit ( ASTDirective node , Object data ) ; public Object visit ( ASTBlock node , Object data ) ; public Object visit ( ASTMap node , Object data ) ; public Object visit ( ASTObjectArray node , Object data ) ; public Object visit ( ASTIntegerRange node , Object data ) ; public Object visit ( ASTMethod node , Object data ) ; public Object visit ( ASTReference node , Object data ) ; public Object visit ( ASTTrue node , Object data ) ; public Object visit ( ASTFalse node , Object data ) ; public Object visit ( ASTText node , Object data ) ; public Object visit ( ASTIfStatement node , Object data ) ; public Object visit ( ASTElseStatement node , Object data ) ; public Object visit ( ASTElseIfStatement node , Object data ) ; public Object visit ( ASTSetDirective node , Object data ) ; public Object visit ( ASTStop node , Object data ) ; public Object visit ( ASTExpression node , Object data ) ; public Object visit ( ASTAssignment node , Object data ) ; public Object visit ( ASTOrNode node , Object data ) ; public Object visit ( ASTAndNode node , Object data ) ; public Object visit ( ASTEQNode node , Object data ) ; public Object visit ( ASTNENode node , Object data ) ; public Object visit ( ASTLTNode node , Object data ) ; public Object visit ( ASTGTNode node , Object data ) ; public Object visit ( ASTLENode node , Object data ) ; public Object visit ( ASTGENode node , Object data ) ; public Object visit ( ASTAddNode node , Object data ) ; public Object visit ( ASTSubtractNode node , Object data ) ; public Object visit ( ASTMulNode node , Object data ) ; public Object visit ( ASTDivNode node , Object data ) ; public Object visit ( ASTModNode node , Object data ) ; public Object visit ( ASTNotNode node , Object data ) ; } 	1
package org . apache . velocity . app . event ; public interface EventHandlerMethodExecutor { public void execute ( EventHandler handler ) throws Exception ; public boolean isDone ( ) ; public Object getReturnValue ( ) ; } 	0
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . commons . lang . builder . ToStringBuilder ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; public class SimpleNode implements Node { protected RuntimeServices rsvc = null ; protected Log log = null ; protected Node parent ; protected Node [ ] children ; protected int id ; protected Parser parser ; protected int info ; public boolean state ; protected boolean invalid = false ; protected Token first ; protected Token last ; protected String templateName ; public SimpleNode ( int i ) { id = i ; } public SimpleNode ( Parser p , int i ) { this ( i ) ; parser = p ; templateName = parser . currentTemplateName ; } public void jjtOpen ( ) { first = parser . getToken ( 1 ) ; } public void jjtClose ( ) { last = parser . getToken ( 0 ) ; } public void setFirstToken ( Token t ) { this . first = t ; } public Token getFirstToken ( ) { return first ; } public Token getLastToken ( ) { return last ; } public void jjtSetParent ( Node n ) { parent = n ; } public Node jjtGetParent ( ) { return parent ; } public void jjtAddChild ( Node n , int i ) { if ( children == null ) { children = new Node [ i + 1 ] ; } else if ( i >= children . length ) { Node c [ ] = new Node [ i + 1 ] ; System . arraycopy ( children , 0 , c , 0 , children . length ) ; children = c ; } children [ i ] = n ; } public Node jjtGetChild ( int i ) { return children [ i ] ; } public int jjtGetNumChildren ( ) { return ( children == null ) ? 0 : children . length ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object childrenAccept ( ParserVisitor visitor , Object data ) { if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { children [ i ] . jjtAccept ( visitor , data ) ; } } return data ; } public String toString ( String prefix ) { return prefix + toString ( ) ; } public void dump ( String prefix ) { System . out . println ( toString ( prefix ) ) ; if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { SimpleNode n = ( SimpleNode ) children [ i ] ; if ( n != null ) { n . dump ( prefix + " " ) ; } } } } protected String getLocation ( InternalContextAdapter context ) { return Log . formatFileString ( this ) ; } public String literal ( ) { if ( first == last ) { return NodeUtils . tokenLiteral ( first ) ; } Token t = first ; StrBuilder sb = new StrBuilder ( NodeUtils . tokenLiteral ( t ) ) ; while ( t != last ) { t = t . next ; sb . append ( NodeUtils . tokenLiteral ( t ) ) ; } return sb . toString ( ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { rsvc = ( RuntimeServices ) data ; log = rsvc . getLog ( ) ; int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) { jjtGetChild ( i ) . init ( context , data ) ; } return data ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { return false ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return null ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException { int i , k = jjtGetNumChildren ( ) ; for ( i = 0 ; i < k ; i ++ ) jjtGetChild ( i ) . render ( context , writer ) ; return true ; } public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException { return null ; } public int getType ( ) { return id ; } public void setInfo ( int info ) { this . info = info ; } public int getInfo ( ) { return info ; } public void setInvalid ( ) { invalid = true ; } public boolean isInvalid ( ) { return invalid ; } public int getLine ( ) { return first . beginLine ; } public int getColumn ( ) { return first . beginColumn ; } public String toString ( ) { StrBuilder tokens = new StrBuilder ( ) ; for ( Token t = getFirstToken ( ) ; t != null ; ) { tokens . append ( "[" ) . append ( t . image ) . append ( "]" ) ; if ( t . next != null ) { if ( t . equals ( getLastToken ( ) ) ) { break ; } else { tokens . append ( ", " ) ; } } t = t . next ; } return new ToStringBuilder ( this ) . append ( "id" , getType ( ) ) . append ( "info" , getInfo ( ) ) . append ( "invalid" , isInvalid ( ) ) . append ( "children" , jjtGetNumChildren ( ) ) . append ( "tokens" , tokens ) . toString ( ) ; } public String getTemplateName ( ) { return templateName ; } } 	1
package org . apache . velocity . util . introspection ; public interface VelMethod { public Object invoke ( Object o , Object [ ] params ) throws Exception ; public boolean isCacheable ( ) ; public String getMethodName ( ) ; public Class getReturnType ( ) ; } 	0
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import java . lang . reflect . InvocationTargetException ; import org . apache . velocity . app . event . EventHandlerUtil ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . Renderable ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . util . introspection . Info ; import org . apache . velocity . util . introspection . VelPropertySet ; public class ASTReference extends SimpleNode { private static final int NORMAL_REFERENCE = 1 ; private static final int FORMAL_REFERENCE = 2 ; private static final int QUIET_REFERENCE = 3 ; private static final int RUNT = 4 ; private int referenceType ; private String nullString ; private String rootString ; private boolean escaped = false ; private boolean computableReference = true ; private boolean logOnNull = true ; private String escPrefix = "" ; private String morePrefix = "" ; private String identifier = "" ; private String literal = null ; public boolean strictRef = false ; private int numChildren = 0 ; protected Info uberInfo ; public ASTReference ( int id ) { super ( id ) ; } public ASTReference ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { super . init ( context , data ) ; rootString = getRoot ( ) ; numChildren = jjtGetNumChildren ( ) ; if ( numChildren > 0 ) { identifier = jjtGetChild ( numChildren - 1 ) . getFirstToken ( ) . image ; } uberInfo = new Info ( getTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; logOnNull = rsvc . getBoolean ( RuntimeConstants . RUNTIME_LOG_REFERENCE_LOG_INVALID , true ) ; strictRef = rsvc . getBoolean ( RuntimeConstants . RUNTIME_REFERENCES_STRICT , false ) ; if ( strictRef && numChildren == 0 ) { logOnNull = false ; Node node = this . jjtGetParent ( ) ; if ( node instanceof ASTNotNode || node instanceof ASTExpression || node instanceof ASTOrNode || node instanceof ASTAndNode ) { while ( node != null ) { if ( node instanceof ASTIfStatement ) { strictRef = false ; break ; } node = node . jjtGetParent ( ) ; } } } return data ; } public String getRootString ( ) { return rootString ; } public Object execute ( Object o , InternalContextAdapter context ) throws MethodInvocationException { if ( referenceType == RUNT ) return null ; Object result = getVariableValue ( context , rootString ) ; if ( result == null && ! strictRef ) { return EventHandlerUtil . invalidGetMethod ( rsvc , context , "$" + rootString , null , null , uberInfo ) ; } try { Object previousResult = result ; int failedChild = - 1 ; for ( int i = 0 ; i < numChildren ; i ++ ) { if ( strictRef && result == null ) { String name = jjtGetChild ( i ) . getFirstToken ( ) . image ; throw new VelocityException ( "Attempted to access '" + name + "' on a null value at " + Log . formatFileString ( uberInfo . getTemplateName ( ) , + jjtGetChild ( i ) . getLine ( ) , jjtGetChild ( i ) . getColumn ( ) ) ) ; } previousResult = result ; result = jjtGetChild ( i ) . execute ( result , context ) ; if ( result == null && ! strictRef ) { failedChild = i ; break ; } } if ( result == null ) { if ( failedChild == - 1 ) { result = EventHandlerUtil . invalidGetMethod ( rsvc , context , "$" + rootString , previousResult , null , uberInfo ) ; } else { StringBuffer name = new StringBuffer ( "$" ) . append ( rootString ) ; for ( int i = 0 ; i <= failedChild ; i ++ ) { Node node = jjtGetChild ( i ) ; if ( node instanceof ASTMethod ) { name . append ( "." ) . append ( ( ( ASTMethod ) node ) . getMethodName ( ) ) . append ( "()" ) ; } else { name . append ( "." ) . append ( node . getFirstToken ( ) . image ) ; } } if ( jjtGetChild ( failedChild ) instanceof ASTMethod ) { String methodName = ( ( ASTMethod ) jjtGetChild ( failedChild ) ) . getMethodName ( ) ; result = EventHandlerUtil . invalidMethod ( rsvc , context , name . toString ( ) , previousResult , methodName , uberInfo ) ; } else { String property = jjtGetChild ( failedChild ) . getFirstToken ( ) . image ; result = EventHandlerUtil . invalidGetMethod ( rsvc , context , name . toString ( ) , previousResult , property , uberInfo ) ; } } } return result ; } catch ( MethodInvocationException mie ) { log . error ( "Method " + mie . getMethodName ( ) + " threw exception for reference $" + rootString + " in " + Log . formatFileString ( this ) ) ; mie . setReferenceName ( rootString ) ; throw mie ; } } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException { if ( referenceType == RUNT ) { if ( context . getAllowRendering ( ) ) { writer . write ( rootString ) ; } return true ; } Object value = execute ( null , context ) ; String localNullString = null ; if ( escaped ) { localNullString = getNullString ( context ) ; if ( value == null ) { if ( context . getAllowRendering ( ) ) { writer . write ( escPrefix ) ; writer . write ( "\\" ) ; writer . write ( localNullString ) ; } } else { if ( context . getAllowRendering ( ) ) { writer . write ( escPrefix ) ; writer . write ( localNullString ) ; } } return true ; } value = EventHandlerUtil . referenceInsert ( rsvc , context , literal ( ) , value ) ; String toString = null ; if ( value != null ) { if ( value instanceof Renderable && ( ( Renderable ) value ) . render ( context , writer ) ) { return true ; } toString = value . toString ( ) ; } if ( value == null || toString == null ) { if ( context . getAllowRendering ( ) ) { localNullString = getNullString ( context ) ; writer . write ( escPrefix ) ; writer . write ( escPrefix ) ; writer . write ( morePrefix ) ; writer . write ( localNullString ) ; } if ( logOnNull && referenceType != QUIET_REFERENCE && log . isDebugEnabled ( ) ) { log . debug ( "Null reference [template '" + getTemplateName ( ) + "', line " + this . getLine ( ) + ", column " + this . getColumn ( ) + "] : " + this . literal ( ) + " cannot be resolved." ) ; } return true ; } else { if ( context . getAllowRendering ( ) ) { writer . write ( escPrefix ) ; writer . write ( morePrefix ) ; writer . write ( toString ) ; } return true ; } } private String getNullString ( InternalContextAdapter context ) { Object callingArgument = context . get ( ".literal." + nullString ) ; if ( callingArgument != null ) return ( ( Node ) callingArgument ) . literal ( ) ; else return nullString ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object value = execute ( null , context ) ; if ( value == null ) { return false ; } else if ( value instanceof Boolean ) { if ( ( ( Boolean ) value ) . booleanValue ( ) ) return true ; else return false ; } else if ( value . toString ( ) == null ) { return false ; } else return true ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return ( computableReference ? execute ( null , context ) : null ) ; } public boolean setValue ( InternalContextAdapter context , Object value ) throws MethodInvocationException { if ( jjtGetNumChildren ( ) == 0 ) { context . put ( rootString , value ) ; return true ; } Object result = getVariableValue ( context , rootString ) ; if ( result == null ) { String msg = "reference set is not a valid reference at " + Log . formatFileString ( uberInfo ) ; log . error ( msg ) ; return false ; } for ( int i = 0 ; i < numChildren - 1 ; i ++ ) { result = jjtGetChild ( i ) . execute ( result , context ) ; if ( result == null ) { if ( strictRef ) { String name = jjtGetChild ( i + 1 ) . getFirstToken ( ) . image ; throw new MethodInvocationException ( "Attempted to access '" + name + "' on a null value" , null , name , uberInfo . getTemplateName ( ) , jjtGetChild ( i + 1 ) . getLine ( ) , jjtGetChild ( i + 1 ) . getColumn ( ) ) ; } String msg = "reference set is not a valid reference at " + Log . formatFileString ( uberInfo ) ; log . error ( msg ) ; return false ; } } try { VelPropertySet vs = rsvc . getUberspect ( ) . getPropertySet ( result , identifier , value , uberInfo ) ; if ( vs == null ) { if ( strictRef ) { throw new MethodInvocationException ( "Object '" + result . getClass ( ) . getName ( ) + "' does not contain property '" + identifier + "'" , null , identifier , uberInfo . getTemplateName ( ) , uberInfo . getLine ( ) , uberInfo . getColumn ( ) ) ; } else { return false ; } } vs . invoke ( result , value ) ; } catch ( InvocationTargetException ite ) { throw new MethodInvocationException ( "ASTReference : Invocation of method '" + identifier + "' in  " + result . getClass ( ) + " threw exception " + ite . getTargetException ( ) . toString ( ) , ite . getTargetException ( ) , identifier , getTemplateName ( ) , this . getLine ( ) , this . getColumn ( ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "ASTReference setValue() : exception : " + e + " template at " + Log . formatFileString ( uberInfo ) ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } return true ; } private String getRoot ( ) { Token t = getFirstToken ( ) ; int slashbang = t . image . indexOf ( "\\!" ) ; if ( slashbang != - 1 ) { int i = 0 ; int len = t . image . length ( ) ; i = t . image . indexOf ( '$' ) ; if ( i == - 1 ) { log . error ( "ASTReference.getRoot() : internal error : " + "no $ found for slashbang." ) ; computableReference = false ; nullString = t . image ; return nullString ; } while ( i < len && t . image . charAt ( i ) != '\\' ) { i ++ ; } int start = i ; int count = 0 ; while ( i < len && t . image . charAt ( i ++ ) == '\\' ) { count ++ ; } nullString = t . image . substring ( 0 , start ) ; nullString += t . image . substring ( start , start + count - 1 ) ; nullString += t . image . substring ( start + count ) ; computableReference = false ; return nullString ; } escaped = false ; if ( t . image . startsWith ( "\\" ) ) { int i = 0 ; int len = t . image . length ( ) ; while ( i < len && t . image . charAt ( i ) == '\\' ) { i ++ ; } if ( ( i % 2 ) != 0 ) escaped = true ; if ( i > 0 ) escPrefix = t . image . substring ( 0 , i / 2 ) ; t . image = t . image . substring ( i ) ; } int loc1 = t . image . lastIndexOf ( '$' ) ; if ( loc1 > 0 ) { morePrefix = morePrefix + t . image . substring ( 0 , loc1 ) ; t . image = t . image . substring ( loc1 ) ; } nullString = literal ( ) ; if ( t . image . startsWith ( "$!" ) ) { referenceType = QUIET_REFERENCE ; if ( ! escaped ) nullString = "" ; if ( t . image . startsWith ( "$!{" ) ) { return t . next . image ; } else { return t . image . substring ( 2 ) ; } } else if ( t . image . equals ( "${" ) ) { referenceType = FORMAL_REFERENCE ; return t . next . image ; } else if ( t . image . startsWith ( "$" ) ) { referenceType = NORMAL_REFERENCE ; return t . image . substring ( 1 ) ; } else { referenceType = RUNT ; return t . image ; } } public Object getVariableValue ( Context context , String variable ) throws MethodInvocationException { Object obj = null ; try { obj = context . get ( variable ) ; } catch ( RuntimeException e ) { log . error ( "Exception calling reference $" + variable + " at " + Log . formatFileString ( uberInfo ) ) ; throw e ; } if ( strictRef && obj == null ) { if ( ! context . containsKey ( variable ) ) { log . error ( "Variable $" + variable + " has not been set at " + Log . formatFileString ( uberInfo ) ) ; throw new MethodInvocationException ( "Variable $" + variable + " has not been set" , null , identifier , uberInfo . getTemplateName ( ) , uberInfo . getLine ( ) , uberInfo . getColumn ( ) ) ; } } return obj ; } public void setLiteral ( String literal ) { if ( this . literal == null ) this . literal = literal ; } public String literal ( ) { if ( literal != null ) return literal ; return super . literal ( ) ; } } 	1
package org . apache . velocity . runtime . parser . node ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . velocity . runtime . log . Log ; public abstract class SetExecutor { protected Log log = null ; private Method method = null ; public abstract Object execute ( Object o , Object value ) throws IllegalAccessException , InvocationTargetException ; public boolean isAlive ( ) { return ( method != null ) ; } public Method getMethod ( ) { return method ; } protected void setMethod ( final Method method ) { this . method = method ; } } 	0
package org . apache . velocity . runtime . directive ; import org . apache . velocity . exception . ExtendedParseException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . Token ; public class MacroParseException extends ParseException implements ExtendedParseException { private final String templateName ; private static final long serialVersionUID = - 4985224672336070689L ; public MacroParseException ( final String msg , final String templateName , final Token currentToken ) { super ( msg ) ; this . currentToken = currentToken ; this . templateName = templateName ; } public String getTemplateName ( ) { return templateName ; } public int getLineNumber ( ) { if ( ( currentToken != null ) && ( currentToken . next != null ) ) { return currentToken . next . beginLine ; } else { return - 1 ; } } public int getColumnNumber ( ) { if ( ( currentToken != null ) && ( currentToken . next != null ) ) { return currentToken . next . beginColumn ; } else { return - 1 ; } } public String getMessage ( ) { if ( ! specialConstructor ) { StringBuffer sb = new StringBuffer ( super . getMessage ( ) ) ; appendTemplateInfo ( sb ) ; return sb . toString ( ) ; } int maxSize = 0 ; StringBuffer expected = new StringBuffer ( ) ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected . append ( tokenImage [ expectedTokenSequences [ i ] [ j ] ] ) . append ( " " ) ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected . append ( "..." ) ; } expected . append ( eol ) . append ( "    " ) ; } StringBuffer retval = new StringBuffer ( "Encountered \"" ) ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) { retval . append ( " " ) ; } if ( tok . kind == 0 ) { retval . append ( tokenImage [ 0 ] ) ; break ; } retval . append ( add_escapes ( tok . image ) ) ; tok = tok . next ; } retval . append ( "\"" ) ; appendTemplateInfo ( retval ) ; if ( expectedTokenSequences . length == 1 ) { retval . append ( "Was expecting:" ) . append ( eol ) . append ( "    " ) ; } else { retval . append ( "Was expecting one of:" ) . append ( eol ) . append ( "    " ) ; } retval . append ( expected . toString ( ) ) ; return retval . toString ( ) ; } protected void appendTemplateInfo ( final StringBuffer sb ) { sb . append ( Log . formatFileString ( getTemplateName ( ) , getLineNumber ( ) , getColumnNumber ( ) ) ) ; sb . append ( eol ) ; } } 	1
package org . apache . velocity . runtime . resource ; import org . apache . velocity . Template ; public class ResourceFactory { public static Resource getResource ( String resourceName , int resourceType ) { Resource resource = null ; switch ( resourceType ) { case ResourceManager . RESOURCE_TEMPLATE : resource = new Template ( ) ; break ; case ResourceManager . RESOURCE_CONTENT : resource = new ContentResource ( ) ; break ; } return resource ; } } 	0
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; public class NullLogChute implements LogChute { public void init ( RuntimeServices rs ) throws Exception { } public void log ( int level , String message ) { } public void log ( int level , String message , Throwable t ) { } public boolean isLevelEnabled ( int level ) { return false ; } } 	1
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTParameters extends SimpleNode { public ASTParameters ( int id ) { super ( id ) ; } public ASTParameters ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . EvaluateContext ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . util . introspection . Info ; public class Evaluate extends Directive { public String getName ( ) { return "evaluate" ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; int argCount = node . jjtGetNumChildren ( ) ; if ( argCount == 0 ) { throw new TemplateInitException ( "#" + getName ( ) + "() requires exactly one argument" , context . getCurrentTemplateName ( ) , node . getColumn ( ) , node . getLine ( ) ) ; } if ( argCount > 1 ) { throw new TemplateInitException ( "#" + getName ( ) + "() requires exactly one argument" , context . getCurrentTemplateName ( ) , node . jjtGetChild ( 1 ) . getColumn ( ) , node . jjtGetChild ( 1 ) . getLine ( ) ) ; } Node childNode = node . jjtGetChild ( 0 ) ; if ( childNode . getType ( ) != ParserTreeConstants . JJTSTRINGLITERAL && childNode . getType ( ) != ParserTreeConstants . JJTREFERENCE ) { throw new TemplateInitException ( "#" + getName ( ) + "()  argument must be a string literal or reference" , context . getCurrentTemplateName ( ) , childNode . getColumn ( ) , childNode . getLine ( ) ) ; } } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , ResourceNotFoundException , ParseErrorException , MethodInvocationException { Object value = node . jjtGetChild ( 0 ) . value ( context ) ; String sourceText ; if ( value != null ) { sourceText = value . toString ( ) ; } else { sourceText = "" ; } String templateName = context . getCurrentTemplateName ( ) ; SimpleNode nodeTree = null ; try { nodeTree = rsvc . parse ( sourceText , templateName ) ; } catch ( ParseException pex ) { Info info = new Info ( templateName , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( pex . getMessage ( ) , info ) ; } catch ( TemplateInitException pex ) { Info info = new Info ( templateName , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( pex . getMessage ( ) , info ) ; } if ( nodeTree != null ) { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( new EvaluateContext ( context , rsvc ) ) ; ica . pushCurrentTemplateName ( templateName ) ; try { try { nodeTree . init ( ica , rsvc ) ; } catch ( TemplateInitException pex ) { Info info = new Info ( templateName , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( pex . getMessage ( ) , info ) ; } try { nodeTree . render ( ica , writer ) ; } catch ( ParseErrorException pex ) { Info info = new Info ( templateName , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( pex . getMessage ( ) , info ) ; } } finally { ica . popCurrentTemplateName ( ) ; } return true ; } return false ; } } 	1
package org . apache . velocity . convert ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import org . apache . oro . text . perl . Perl5Util ; import org . apache . velocity . util . StringUtils ; import org . apache . tools . ant . DirectoryScanner ; public class WebMacro { protected static final String VM_EXT = ".vm" ; protected static final String WM_EXT = ".wm" ; protected static String [ ] perLineREs = { "#if\\s*[(]\\s*(.*\\S)\\s*[)]\\s*(#begin|{)[ \\t]?" , "#if( $1 )" , "[ \\t]?(#end|})[ \\t]*\n(\\s*)#else\\s*(#begin|{)[ \\t]?(\\w)" , "$2#else#**#$4" , "[ \\t]?(#end|})[ \\t]*\n(\\s*)#else\\s*(#begin|{)[ \\t]?" , "$2#else" , "(#end|})(\\s*#else)\\s*(#begin|{)[ \\t]?" , "$1\n$2" , "#foreach\\s+(\\$\\w+)\\s+in\\s+(\\$[^\\s#]+)\\s*(#begin|{)[ \\t]?" , "#foreach( $1 in $2 )" , "#set\\s+(\\$[^\\s=]+)\\s*=\\s*([\\S \\t]+)" , "#set( $1 = $2 )" , "(##[# \\t\\w]*)\\)" , ")$1" , "#parse\\s+([^\\s#]+)[ \\t]?" , "#parse( $1 )" , "#include\\s+([^\\s#]+)[ \\t]?" , "#include( $1 )" , "\\$\\(([^\\)]+)\\)" , "${$1}" , "\\${([^}\\(]+)\\(([^}]+)}\\)" , "${$1($2)}" , "\\$_" , "$l_" , "\\${(_[^}]+)}" , "${l$1}" , "(#set\\s*\\([^;]+);(\\s*\\))" , "$1$2" , "(^|[^\\\\])\\$(\\w[^=\n;'\"]*);" , "$1${$2}" , "\\.wm" , ".vm" } ; public void convert ( String target ) { File file = new File ( target ) ; if ( ! file . exists ( ) ) { throw new RuntimeException ( "The specified template or directory does not exist" ) ; } if ( file . isDirectory ( ) ) { String basedir = file . getAbsolutePath ( ) ; String newBasedir = basedir + VM_EXT ; DirectoryScanner ds = new DirectoryScanner ( ) ; ds . setBasedir ( basedir ) ; ds . addDefaultExcludes ( ) ; ds . scan ( ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { writeTemplate ( files [ i ] , basedir , newBasedir ) ; } } else { writeTemplate ( file . getAbsolutePath ( ) , "" , "" ) ; } } private boolean writeTemplate ( String file , String basedir , String newBasedir ) { if ( file . indexOf ( WM_EXT ) < 0 ) { return false ; } System . out . println ( "Converting " + file + "..." ) ; String template = file ; String newTemplate = convertName ( file ) ; if ( basedir . length ( ) > 0 ) { String templateDir = newBasedir + extractPath ( file ) ; File outputDirectory = new File ( templateDir ) ; template = basedir + File . separator + file ; if ( ! outputDirectory . exists ( ) ) { outputDirectory . mkdirs ( ) ; } newTemplate = newBasedir + File . separator + convertName ( file ) ; } String convertedTemplate = convertTemplate ( template ) ; FileWriter fw = null ; try { fw = new FileWriter ( newTemplate ) ; fw . write ( convertedTemplate ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( fw != null ) { try { fw . close ( ) ; } catch ( IOException io ) { } } } return true ; } private final String extractPath ( String file ) { int lastSepPos = file . lastIndexOf ( File . separator ) ; return ( lastSepPos == - 1 ? "" : File . separator + file . substring ( 0 , lastSepPos ) ) ; } private String convertName ( String name ) { return ( name . indexOf ( WM_EXT ) < 0 ) ? name : name . substring ( 0 , name . indexOf ( WM_EXT ) ) + VM_EXT ; } private static final void usage ( ) { System . err . println ( "Usage: convert-wm <template.wm | directory>" ) ; } public String convertTemplate ( String template ) { String contents = StringUtils . fileContentsToString ( template ) ; if ( ! contents . endsWith ( "\n" ) ) { contents += "\n" ; } Perl5Util perl = new Perl5Util ( ) ; for ( int i = 0 ; i < perLineREs . length ; i += 2 ) { contents = perl . substitute ( makeSubstRE ( i ) , contents ) ; } if ( perl . match ( "m/javascript/i" , contents ) ) { contents = perl . substitute ( "s/\n}/\n#end/g" , contents ) ; } else { contents = perl . substitute ( "s/(\n\\s*)}/$1#end/g" , contents ) ; contents = perl . substitute ( "s/#end\\s*\n\\s*#else/#else/g" , contents ) ; } return contents ; } private final String makeSubstRE ( int i ) { return ( "s/" + perLineREs [ i ] + '/' + perLineREs [ i + 1 ] + "/g" ) ; } public static void main ( String [ ] args ) { if ( args . length > 0 ) { for ( int x = 0 ; x < args . length ; x ++ ) { WebMacro converter = new WebMacro ( ) ; converter . convert ( args [ x ] ) ; } } else { usage ( ) ; } } } 	0
package org . apache . velocity . runtime ; import java . io . Reader ; import java . util . Properties ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . Template ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . ContentResource ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . util . introspection . Uberspect ; public class RuntimeSingleton implements RuntimeConstants { private static RuntimeInstance ri = new RuntimeInstance ( ) ; public synchronized static void init ( ) throws Exception { ri . init ( ) ; } public static boolean isInitialized ( ) { return ri . isInitialized ( ) ; } public static RuntimeServices getRuntimeServices ( ) { return ri ; } public static void setProperty ( String key , Object value ) { ri . setProperty ( key , value ) ; } public static void setConfiguration ( ExtendedProperties configuration ) { ri . setConfiguration ( configuration ) ; } public static void addProperty ( String key , Object value ) { ri . addProperty ( key , value ) ; } public static void clearProperty ( String key ) { ri . clearProperty ( key ) ; } public static Object getProperty ( String key ) { return ri . getProperty ( key ) ; } public static void init ( Properties p ) throws Exception { ri . init ( p ) ; } public static void init ( String configurationFile ) throws Exception { ri . init ( configurationFile ) ; } public static SimpleNode parse ( Reader reader , String templateName ) throws ParseException { return ri . parse ( reader , templateName ) ; } public static SimpleNode parse ( Reader reader , String templateName , boolean dumpNamespace ) throws ParseException { return ri . parse ( reader , templateName , dumpNamespace ) ; } public static Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name ) ; } public static Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getTemplate ( name , encoding ) ; } public static ContentResource getContent ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getContent ( name ) ; } public static ContentResource getContent ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return ri . getContent ( name , encoding ) ; } public static String getLoaderNameForResource ( String resourceName ) { return ri . getLoaderNameForResource ( resourceName ) ; } public static Log getLog ( ) { return ri . getLog ( ) ; } public static void warn ( Object message ) { getLog ( ) . warn ( message ) ; } public static void info ( Object message ) { getLog ( ) . info ( message ) ; } public static void error ( Object message ) { getLog ( ) . error ( message ) ; } public static void debug ( Object message ) { getLog ( ) . debug ( message ) ; } public static String getString ( String key , String defaultValue ) { return ri . getString ( key , defaultValue ) ; } public static Directive getVelocimacro ( String vmName , String templateName ) { return ri . getVelocimacro ( vmName , templateName ) ; } public static boolean addVelocimacro ( String name , Node macro , String argArray [ ] , String sourceTemplate ) { return ri . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public static boolean addVelocimacro ( String name , String macro , String argArray [ ] , String sourceTemplate ) { return ri . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public static boolean isVelocimacro ( String vmName , String templateName ) { return ri . isVelocimacro ( vmName , templateName ) ; } public static boolean dumpVMNamespace ( String namespace ) { return ri . dumpVMNamespace ( namespace ) ; } public static String getString ( String key ) { return ri . getString ( key ) ; } public static int getInt ( String key ) { return ri . getInt ( key ) ; } public static int getInt ( String key , int defaultValue ) { return ri . getInt ( key , defaultValue ) ; } public static boolean getBoolean ( String key , boolean def ) { return ri . getBoolean ( key , def ) ; } public static ExtendedProperties getConfiguration ( ) { return ri . getConfiguration ( ) ; } public static Introspector getIntrospector ( ) { return ri . getIntrospector ( ) ; } public EventCartridge getEventCartridge ( ) { return ri . getApplicationEventCartridge ( ) ; } public static Object getApplicationAttribute ( Object key ) { return ri . getApplicationAttribute ( key ) ; } public static Uberspect getUberspect ( ) { return ri . getUberspect ( ) ; } public static RuntimeInstance getRuntimeInstance ( ) { return ri ; } } 	1
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTIncludeStatement extends SimpleNode { public ASTIncludeStatement ( int id ) { super ( id ) ; } public ASTIncludeStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTEscape extends SimpleNode { public String val ; private char [ ] ctext ; public ASTEscape ( int id ) { super ( id ) ; } public ASTEscape ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) { ctext = val . toCharArray ( ) ; return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException { if ( context . getAllowRendering ( ) ) { writer . write ( ctext ) ; } return true ; } } 	1
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTAssignment extends SimpleNode { public ASTAssignment ( int id ) { super ( id ) ; } public ASTAssignment ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0
package org . apache . velocity . util . introspection ; import java . util . Iterator ; public interface Uberspect { public void init ( ) throws Exception ; public Iterator getIterator ( Object obj , Info info ) throws Exception ; public VelMethod getMethod ( Object obj , String method , Object [ ] args , Info info ) throws Exception ; public VelPropertyGet getPropertyGet ( Object obj , String identifier , Info info ) throws Exception ; public VelPropertySet getPropertySet ( Object obj , String identifier , Object arg , Info info ) throws Exception ; } 	1
package org . apache . velocity . app . event ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalEventContext ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; public class EventCartridge { private List referenceHandlers = new ArrayList ( ) ; private List nullSetHandlers = new ArrayList ( ) ; private List methodExceptionHandlers = new ArrayList ( ) ; private List includeHandlers = new ArrayList ( ) ; private List invalidReferenceHandlers = new ArrayList ( ) ; Set initializedHandlers = new HashSet ( ) ; public boolean addEventHandler ( EventHandler ev ) { if ( ev == null ) { return false ; } boolean found = false ; if ( ev instanceof ReferenceInsertionEventHandler ) { addReferenceInsertionEventHandler ( ( ReferenceInsertionEventHandler ) ev ) ; found = true ; } if ( ev instanceof NullSetEventHandler ) { addNullSetEventHandler ( ( NullSetEventHandler ) ev ) ; found = true ; } if ( ev instanceof MethodExceptionEventHandler ) { addMethodExceptionHandler ( ( MethodExceptionEventHandler ) ev ) ; found = true ; } if ( ev instanceof IncludeEventHandler ) { addIncludeEventHandler ( ( IncludeEventHandler ) ev ) ; found = true ; } if ( ev instanceof InvalidReferenceEventHandler ) { addInvalidReferenceEventHandler ( ( InvalidReferenceEventHandler ) ev ) ; found = true ; } return found ; } public void addReferenceInsertionEventHandler ( ReferenceInsertionEventHandler ev ) { referenceHandlers . add ( ev ) ; } public void addNullSetEventHandler ( NullSetEventHandler ev ) { nullSetHandlers . add ( ev ) ; } public void addMethodExceptionHandler ( MethodExceptionEventHandler ev ) { methodExceptionHandlers . add ( ev ) ; } public void addIncludeEventHandler ( IncludeEventHandler ev ) { includeHandlers . add ( ev ) ; } public void addInvalidReferenceEventHandler ( InvalidReferenceEventHandler ev ) { invalidReferenceHandlers . add ( ev ) ; } public boolean removeEventHandler ( EventHandler ev ) { if ( ev == null ) { return false ; } boolean found = false ; if ( ev instanceof ReferenceInsertionEventHandler ) return referenceHandlers . remove ( ev ) ; if ( ev instanceof NullSetEventHandler ) return nullSetHandlers . remove ( ev ) ; if ( ev instanceof MethodExceptionEventHandler ) return methodExceptionHandlers . remove ( ev ) ; if ( ev instanceof IncludeEventHandler ) return includeHandlers . remove ( ev ) ; if ( ev instanceof InvalidReferenceEventHandler ) return invalidReferenceHandlers . remove ( ev ) ; return found ; } public Iterator getReferenceInsertionEventHandlers ( ) { return referenceHandlers . size ( ) == 0 ? null : referenceHandlers . iterator ( ) ; } public Iterator getNullSetEventHandlers ( ) { return nullSetHandlers . iterator ( ) ; } public Iterator getMethodExceptionEventHandlers ( ) { return methodExceptionHandlers . iterator ( ) ; } public Iterator getIncludeEventHandlers ( ) { return includeHandlers . iterator ( ) ; } public Iterator getInvalidReferenceEventHandlers ( ) { return invalidReferenceHandlers . iterator ( ) ; } public final boolean attachToContext ( Context context ) { if ( context instanceof InternalEventContext ) { InternalEventContext iec = ( InternalEventContext ) context ; iec . attachEventCartridge ( this ) ; return true ; } else { return false ; } } public void initialize ( RuntimeServices rs ) throws Exception { for ( Iterator i = referenceHandlers . iterator ( ) ; i . hasNext ( ) ; ) { EventHandler eh = ( EventHandler ) i . next ( ) ; if ( ( eh instanceof RuntimeServicesAware ) && ! initializedHandlers . contains ( eh ) ) { ( ( RuntimeServicesAware ) eh ) . setRuntimeServices ( rs ) ; initializedHandlers . add ( eh ) ; } } for ( Iterator i = nullSetHandlers . iterator ( ) ; i . hasNext ( ) ; ) { EventHandler eh = ( EventHandler ) i . next ( ) ; if ( ( eh instanceof RuntimeServicesAware ) && ! initializedHandlers . contains ( eh ) ) { ( ( RuntimeServicesAware ) eh ) . setRuntimeServices ( rs ) ; initializedHandlers . add ( eh ) ; } } for ( Iterator i = methodExceptionHandlers . iterator ( ) ; i . hasNext ( ) ; ) { EventHandler eh = ( EventHandler ) i . next ( ) ; if ( ( eh instanceof RuntimeServicesAware ) && ! initializedHandlers . contains ( eh ) ) { ( ( RuntimeServicesAware ) eh ) . setRuntimeServices ( rs ) ; initializedHandlers . add ( eh ) ; } } for ( Iterator i = includeHandlers . iterator ( ) ; i . hasNext ( ) ; ) { EventHandler eh = ( EventHandler ) i . next ( ) ; if ( ( eh instanceof RuntimeServicesAware ) && ! initializedHandlers . contains ( eh ) ) { ( ( RuntimeServicesAware ) eh ) . setRuntimeServices ( rs ) ; initializedHandlers . add ( eh ) ; } } for ( Iterator i = invalidReferenceHandlers . iterator ( ) ; i . hasNext ( ) ; ) { EventHandler eh = ( EventHandler ) i . next ( ) ; if ( ( eh instanceof RuntimeServicesAware ) && ! initializedHandlers . contains ( eh ) ) { ( ( RuntimeServicesAware ) eh ) . setRuntimeServices ( rs ) ; initializedHandlers . add ( eh ) ; } } } } 	0
package org . apache . velocity . util ; import java . io . InputStream ; public class ClassUtils { private ClassUtils ( ) { } public static Class getClass ( String clazz ) throws ClassNotFoundException { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader != null ) { try { return Class . forName ( clazz , true , loader ) ; } catch ( ClassNotFoundException E ) { } } return Class . forName ( clazz ) ; } public static Object getNewInstance ( String clazz ) throws ClassNotFoundException , IllegalAccessException , InstantiationException { return getClass ( clazz ) . newInstance ( ) ; } public static InputStream getResourceAsStream ( Class claz , String name ) { InputStream result = null ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader == null ) { classLoader = claz . getClassLoader ( ) ; result = classLoader . getResourceAsStream ( name ) ; } else { result = classLoader . getResourceAsStream ( name ) ; if ( result == null ) { classLoader = claz . getClassLoader ( ) ; if ( classLoader != null ) result = classLoader . getResourceAsStream ( name ) ; } } return result ; } } 	1
package org . apache . velocity . app . event . implement ; import java . util . ArrayList ; import java . util . List ; import org . apache . velocity . app . event . InvalidReferenceEventHandler ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; import org . apache . velocity . util . introspection . Info ; public class ReportInvalidReferences implements InvalidReferenceEventHandler , RuntimeServicesAware { public static final String EVENTHANDLER_INVALIDREFERENCE_EXCEPTION = "eventhandler.invalidreference.exception" ; List invalidReferences = new ArrayList ( ) ; private boolean stopOnFirstInvalidReference = false ; public Object invalidGetMethod ( Context context , String reference , Object object , String property , Info info ) { reportInvalidReference ( reference , info ) ; return null ; } public Object invalidMethod ( Context context , String reference , Object object , String method , Info info ) { if ( reference == null ) { reportInvalidReference ( object . getClass ( ) . getName ( ) + "." + method , info ) ; } else { reportInvalidReference ( reference , info ) ; } return null ; } public boolean invalidSetMethod ( Context context , String leftreference , String rightreference , Info info ) { reportInvalidReference ( leftreference , info ) ; return false ; } private void reportInvalidReference ( String reference , Info info ) { InvalidReferenceInfo invalidReferenceInfo = new InvalidReferenceInfo ( reference , info ) ; invalidReferences . add ( invalidReferenceInfo ) ; if ( stopOnFirstInvalidReference ) { throw new ParseErrorException ( "Error in page - invalid reference.  " , info , invalidReferenceInfo . getInvalidReference ( ) ) ; } } public List getInvalidReferences ( ) { return invalidReferences ; } public void setRuntimeServices ( RuntimeServices rs ) { stopOnFirstInvalidReference = rs . getConfiguration ( ) . getBoolean ( EVENTHANDLER_INVALIDREFERENCE_EXCEPTION , false ) ; } } 	0
package org . apache . velocity . runtime ; import java . util . Collections ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . apache . velocity . runtime . directive . VelocimacroProxy ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . util . MapFactory ; public class VelocimacroManager { private static String GLOBAL_NAMESPACE = "" ; private boolean registerFromLib = false ; private final Map namespaceHash = MapFactory . create ( 17 , 0.5f , 20 , false ) ; private final Map globalNamespace ; private final Set libraries = Collections . synchronizedSet ( new HashSet ( ) ) ; private boolean namespacesOn = true ; private boolean inlineLocalMode = false ; private boolean inlineReplacesGlobal = false ; VelocimacroManager ( RuntimeServices rsvc ) { globalNamespace = addNamespace ( GLOBAL_NAMESPACE ) ; } public boolean addVM ( final String vmName , final Node macroBody , final String argArray [ ] , final String namespace , boolean canReplaceGlobalMacro ) { if ( macroBody == null ) { throw new RuntimeException ( "Null AST for " + vmName + " in " + namespace ) ; } MacroEntry me = new MacroEntry ( vmName , macroBody , argArray , namespace ) ; me . setFromLibrary ( registerFromLib ) ; boolean isLib = true ; MacroEntry exist = ( MacroEntry ) globalNamespace . get ( vmName ) ; if ( registerFromLib ) { libraries . add ( namespace ) ; } else { isLib = libraries . contains ( namespace ) ; } if ( ! isLib && usingNamespaces ( namespace ) ) { Map local = getNamespace ( namespace , true ) ; local . put ( vmName , me ) ; return true ; } else { if ( exist != null ) { me . setFromLibrary ( exist . getFromLibrary ( ) ) ; } globalNamespace . put ( vmName , me ) ; return true ; } } public VelocimacroProxy get ( final String vmName , final String namespace ) { return ( get ( vmName , namespace , null ) ) ; } public VelocimacroProxy get ( final String vmName , final String namespace , final String renderingTemplate ) { if ( inlineReplacesGlobal && renderingTemplate != null ) { Map local = getNamespace ( renderingTemplate , false ) ; if ( local != null ) { MacroEntry me = ( MacroEntry ) local . get ( vmName ) ; if ( me != null ) { return me . getProxy ( namespace ) ; } } } if ( usingNamespaces ( namespace ) ) { Map local = getNamespace ( namespace , false ) ; if ( local != null ) { MacroEntry me = ( MacroEntry ) local . get ( vmName ) ; if ( me != null ) { return me . getProxy ( namespace ) ; } } } MacroEntry me = ( MacroEntry ) globalNamespace . get ( vmName ) ; if ( me != null ) { return me . getProxy ( namespace ) ; } return null ; } public boolean dumpNamespace ( final String namespace ) { synchronized ( this ) { if ( usingNamespaces ( namespace ) ) { Map h = ( Map ) namespaceHash . remove ( namespace ) ; if ( h == null ) { return false ; } h . clear ( ) ; return true ; } return false ; } } public void setNamespaceUsage ( final boolean namespaceOn ) { this . namespacesOn = namespaceOn ; } public void setRegisterFromLib ( final boolean registerFromLib ) { this . registerFromLib = registerFromLib ; } public void setTemplateLocalInlineVM ( final boolean inlineLocalMode ) { this . inlineLocalMode = inlineLocalMode ; } private Map getNamespace ( final String namespace , final boolean addIfNew ) { Map h = ( Map ) namespaceHash . get ( namespace ) ; if ( h == null && addIfNew ) { h = addNamespace ( namespace ) ; } return h ; } private Map addNamespace ( final String namespace ) { Map h = MapFactory . create ( 17 , 0.5f , 20 , false ) ; Object oh ; if ( ( oh = namespaceHash . put ( namespace , h ) ) != null ) { namespaceHash . put ( namespace , oh ) ; return null ; } return h ; } private boolean usingNamespaces ( final String namespace ) { if ( ! namespacesOn ) { return false ; } if ( inlineLocalMode ) { return true ; } return false ; } public String getLibraryName ( final String vmName , final String namespace ) { if ( usingNamespaces ( namespace ) ) { Map local = getNamespace ( namespace , false ) ; if ( local != null ) { MacroEntry me = ( MacroEntry ) local . get ( vmName ) ; if ( me != null ) { return null ; } } } MacroEntry me = ( MacroEntry ) globalNamespace . get ( vmName ) ; if ( me != null ) { return me . getSourceTemplate ( ) ; } return null ; } public void setInlineReplacesGlobal ( boolean is ) { inlineReplacesGlobal = is ; } private static class MacroEntry { private final String vmName ; private final String [ ] argArray ; private final String sourceTemplate ; private SimpleNode nodeTree = null ; private boolean fromLibrary = false ; private VelocimacroProxy vp ; private MacroEntry ( final String vmName , final Node macro , final String argArray [ ] , final String sourceTemplate ) { this . vmName = vmName ; this . argArray = argArray ; this . nodeTree = ( SimpleNode ) macro ; this . sourceTemplate = sourceTemplate ; vp = new VelocimacroProxy ( ) ; vp . setName ( this . vmName ) ; vp . setArgArray ( this . argArray ) ; vp . setNodeTree ( this . nodeTree ) ; } public void setFromLibrary ( final boolean fromLibrary ) { this . fromLibrary = fromLibrary ; } public boolean getFromLibrary ( ) { return fromLibrary ; } public SimpleNode getNodeTree ( ) { return nodeTree ; } public String getSourceTemplate ( ) { return sourceTemplate ; } VelocimacroProxy getProxy ( final String namespace ) { return vp ; } } } 	1
package org . apache . velocity . runtime . parser . node ; import java . math . BigDecimal ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTFloatingPointLiteral extends SimpleNode { private Number value = null ; public ASTFloatingPointLiteral ( int id ) { super ( id ) ; } public ASTFloatingPointLiteral ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { super . init ( context , data ) ; String str = getFirstToken ( ) . image ; try { value = new Double ( str ) ; } catch ( NumberFormatException E1 ) { value = new BigDecimal ( str ) ; } return data ; } public Object value ( InternalContextAdapter context ) { return value ; } } 	0
package org . apache . velocity . runtime . directive ; import java . io . Writer ; import java . io . IOException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; public abstract class Directive implements DirectiveConstants , Cloneable { private int line = 0 ; private int column = 0 ; protected RuntimeServices rsvc = null ; public abstract String getName ( ) ; public abstract int getType ( ) ; public void setLocation ( int line , int column ) { this . line = line ; this . column = column ; } public int getLine ( ) { return line ; } public int getColumn ( ) { return column ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { rsvc = rs ; } public abstract boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , ResourceNotFoundException , ParseErrorException , MethodInvocationException ; } 	1
package org . apache . velocity . anakia ; import org . jdom . Element ; import org . jdom . Namespace ; import org . jdom . output . XMLOutputter ; import java . util . List ; public class AnakiaElement extends Element { private static final long serialVersionUID = 8429597252274491314L ; private static final XMLOutputter DEFAULT_OUTPUTTER = new XMLOutputter ( ) ; static { DEFAULT_OUTPUTTER . getFormat ( ) . setLineSeparator ( System . getProperty ( "line.separator" ) ) ; } public AnakiaElement ( String name , Namespace namespace ) { super ( name , namespace ) ; } public AnakiaElement ( String name ) { super ( name ) ; } public AnakiaElement ( String name , String uri ) { super ( name , uri ) ; } public AnakiaElement ( String name , String prefix , String uri ) { super ( name , prefix , uri ) ; } public NodeList selectNodes ( String xpathExpression ) { return new NodeList ( XPathCache . getXPath ( xpathExpression ) . applyTo ( this ) , false ) ; } public String toString ( ) { return DEFAULT_OUTPUTTER . outputString ( this ) ; } public List getContent ( ) { return new NodeList ( super . getContent ( ) , false ) ; } public List getChildren ( ) { return new NodeList ( super . getChildren ( ) , false ) ; } public List getChildren ( String name ) { return new NodeList ( super . getChildren ( name ) ) ; } public List getChildren ( String name , Namespace ns ) { return new NodeList ( super . getChildren ( name , ns ) ) ; } public List getAttributes ( ) { return new NodeList ( super . getAttributes ( ) ) ; } } 	0
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . Node ; public class Literal extends Directive { String literalText ; public String getName ( ) { return "literal" ; } public int getType ( ) { return BLOCK ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; literalText = node . jjtGetChild ( 0 ) . literal ( ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException { writer . write ( literalText ) ; return true ; } } 	1
package org . apache . velocity . app . event . implement ; import java . io . PrintWriter ; import java . io . StringWriter ; import org . apache . velocity . app . event . MethodExceptionEventHandler ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; public class PrintExceptions implements MethodExceptionEventHandler , RuntimeServicesAware { private static String SHOW_MESSAGE = "eventhandler.methodexception.message" ; private static String SHOW_STACK_TRACE = "eventhandler.methodexception.stacktrace" ; private RuntimeServices rs = null ; public Object methodException ( Class claz , String method , Exception e ) throws Exception { boolean showMessage = rs . getBoolean ( SHOW_MESSAGE , false ) ; boolean showStackTrace = rs . getBoolean ( SHOW_STACK_TRACE , false ) ; StringBuffer st ; if ( showMessage && showStackTrace ) { st = new StringBuffer ( 200 ) ; st . append ( e . getClass ( ) . getName ( ) ) . append ( "\n" ) ; st . append ( e . getMessage ( ) ) . append ( "\n" ) ; st . append ( getStackTrace ( e ) ) ; } else if ( showMessage ) { st = new StringBuffer ( 50 ) ; st . append ( e . getClass ( ) . getName ( ) ) . append ( "\n" ) ; st . append ( e . getMessage ( ) ) . append ( "\n" ) ; } else if ( showStackTrace ) { st = new StringBuffer ( 200 ) ; st . append ( e . getClass ( ) . getName ( ) ) . append ( "\n" ) ; st . append ( getStackTrace ( e ) ) ; } else { st = new StringBuffer ( 15 ) ; st . append ( e . getClass ( ) . getName ( ) ) . append ( "\n" ) ; } return st . toString ( ) ; } private static String getStackTrace ( Throwable throwable ) { PrintWriter printWriter = null ; try { StringWriter stackTraceWriter = new StringWriter ( ) ; printWriter = new PrintWriter ( stackTraceWriter ) ; throwable . printStackTrace ( printWriter ) ; printWriter . flush ( ) ; return stackTraceWriter . toString ( ) ; } finally { if ( printWriter != null ) { printWriter . close ( ) ; } } } public void setRuntimeServices ( RuntimeServices rs ) { this . rs = rs ; } } 	0
package org . apache . velocity . runtime . parser . node ; import java . util . Map ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . log . Log ; public class MapSetExecutor extends SetExecutor { private final String property ; public MapSetExecutor ( final Log log , final Class clazz , final String property ) { this . log = log ; this . property = property ; discover ( clazz ) ; } protected void discover ( final Class clazz ) { Class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( interfaces [ i ] . equals ( Map . class ) ) { try { if ( property != null ) { setMethod ( Map . class . getMethod ( "put" , new Class [ ] { Object . class , Object . class } ) ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "Exception while looking for put('" + property + "') method" ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } break ; } } } public Object execute ( final Object o , final Object arg ) { return ( ( Map ) o ) . put ( property , arg ) ; } } 	1
package org . apache . velocity . app . event . implement ; import org . apache . commons . lang . StringEscapeUtils ; public class EscapeXmlReference extends EscapeReference { protected String escape ( Object text ) { return StringEscapeUtils . escapeXml ( text . toString ( ) ) ; } protected String getMatchAttribute ( ) { return "eventhandler.escape.xml.match" ; } } 	0
package org . apache . velocity . runtime . directive ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . Token ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . util . introspection . Info ; import java . io . Writer ; import java . io . IOException ; import java . util . List ; public class RuntimeMacro extends Directive { private String macroName ; private String sourceTemplate ; private String literal = null ; private Node node = null ; protected boolean strictRef = false ; public RuntimeMacro ( String macroName , String sourceTemplate ) { if ( macroName == null || sourceTemplate == null ) { throw new IllegalArgumentException ( "Null arguments" ) ; } this . macroName = macroName ; this . sourceTemplate = sourceTemplate ; } public String getName ( ) { return macroName ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) { super . init ( rs , context , node ) ; rsvc = rs ; this . node = node ; Token t = node . getLastToken ( ) ; if ( t . image . charAt ( 0 ) == ')' ) { strictRef = rsvc . getBoolean ( RuntimeConstants . RUNTIME_REFERENCES_STRICT , false ) ; } } private String getLiteral ( ) { if ( literal == null ) { StrBuilder buffer = new StrBuilder ( ) ; Token t = node . getFirstToken ( ) ; while ( t != null && t != node . getLastToken ( ) ) { buffer . append ( t . image ) ; t = t . next ; } if ( t != null ) { buffer . append ( t . image ) ; } literal = buffer . toString ( ) ; } return literal ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , ResourceNotFoundException , ParseErrorException , MethodInvocationException { VelocimacroProxy vmProxy = null ; String renderingTemplate = context . getCurrentTemplateName ( ) ; Object o = rsvc . getVelocimacro ( macroName , sourceTemplate , renderingTemplate ) ; if ( o != null ) { vmProxy = ( VelocimacroProxy ) o ; } if ( vmProxy == null ) { List macroLibraries = context . getMacroLibraries ( ) ; if ( macroLibraries != null ) { for ( int i = macroLibraries . size ( ) - 1 ; i >= 0 ; i -- ) { o = rsvc . getVelocimacro ( macroName , ( String ) macroLibraries . get ( i ) , renderingTemplate ) ; if ( o != null ) { vmProxy = ( VelocimacroProxy ) o ; break ; } } } } if ( vmProxy != null ) { try { vmProxy . init ( rsvc , context , node ) ; } catch ( TemplateInitException die ) { Info info = new Info ( sourceTemplate , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( die . getMessage ( ) + " at " + Log . formatFileString ( info ) , info ) ; } try { return vmProxy . render ( context , writer , node ) ; } catch ( RuntimeException e ) { rsvc . getLog ( ) . error ( "Exception in macro #" + macroName + " at " + Log . formatFileString ( sourceTemplate , getLine ( ) , getColumn ( ) ) ) ; throw e ; } catch ( IOException e ) { rsvc . getLog ( ) . error ( "Exception in macro #" + macroName + " at " + Log . formatFileString ( sourceTemplate , getLine ( ) , getColumn ( ) ) ) ; throw e ; } } else if ( strictRef ) { Info info = new Info ( sourceTemplate , node . getLine ( ) , node . getColumn ( ) ) ; throw new ParseErrorException ( "Macro '#" + macroName + "' is not defined at " + Log . formatFileString ( info ) , info ) ; } writer . write ( getLiteral ( ) ) ; return true ; } } 	1
package org . apache . velocity . runtime . resource . loader ; import java . io . InputStream ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . ExceptionUtils ; public class ClasspathResourceLoader extends ResourceLoader { public void init ( ExtendedProperties configuration ) { if ( log . isTraceEnabled ( ) ) { log . trace ( "ClasspathResourceLoader : initialization complete." ) ; } } public InputStream getResourceStream ( String name ) throws ResourceNotFoundException { InputStream result = null ; if ( StringUtils . isEmpty ( name ) ) { throw new ResourceNotFoundException ( "No template name provided" ) ; } try { result = ClassUtils . getResourceAsStream ( getClass ( ) , name ) ; } catch ( Exception fnfe ) { throw ( ResourceNotFoundException ) ExceptionUtils . createWithCause ( ResourceNotFoundException . class , "problem with template: " + name , fnfe ) ; } if ( result == null ) { String msg = "ClasspathResourceLoader Error: cannot find resource " + name ; throw new ResourceNotFoundException ( msg ) ; } return result ; } public boolean isSourceModified ( Resource resource ) { return false ; } public long getLastModified ( Resource resource ) { return 0 ; } } 	0
package org . apache . velocity . context ; import java . util . HashMap ; import java . util . Stack ; import java . util . List ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; class InternalContextBase implements InternalHousekeepingContext , InternalEventContext { private static final long serialVersionUID = - 245905472770843470L ; private HashMap introspectionCache = new HashMap ( 33 ) ; private Stack templateNameStack = new Stack ( ) ; private Stack macroNameStack = new Stack ( ) ; private EventCartridge eventCartridge = null ; private Resource currentResource = null ; private boolean allowRendering = true ; private List macroLibraries = null ; public void pushCurrentTemplateName ( String s ) { templateNameStack . push ( s ) ; } public void popCurrentTemplateName ( ) { templateNameStack . pop ( ) ; } public String getCurrentTemplateName ( ) { if ( templateNameStack . empty ( ) ) return "<undef>" ; else return ( String ) templateNameStack . peek ( ) ; } public Object [ ] getTemplateNameStack ( ) { return templateNameStack . toArray ( ) ; } public void pushCurrentMacroName ( String s ) { macroNameStack . push ( s ) ; } public void popCurrentMacroName ( ) { macroNameStack . pop ( ) ; } public String getCurrentMacroName ( ) { if ( macroNameStack . empty ( ) ) { return "<undef>" ; } else { return ( String ) macroNameStack . peek ( ) ; } } public int getCurrentMacroCallDepth ( ) { return macroNameStack . size ( ) ; } public Object [ ] getMacroNameStack ( ) { return macroNameStack . toArray ( ) ; } public IntrospectionCacheData icacheGet ( Object key ) { return ( IntrospectionCacheData ) introspectionCache . get ( key ) ; } public void icachePut ( Object key , IntrospectionCacheData o ) { introspectionCache . put ( key , o ) ; } public void setCurrentResource ( Resource r ) { currentResource = r ; } public Resource getCurrentResource ( ) { return currentResource ; } public boolean getAllowRendering ( ) { return allowRendering ; } public void setAllowRendering ( boolean v ) { allowRendering = v ; } public void setMacroLibraries ( List macroLibraries ) { this . macroLibraries = macroLibraries ; } public List getMacroLibraries ( ) { return macroLibraries ; } public EventCartridge attachEventCartridge ( EventCartridge ec ) { EventCartridge temp = eventCartridge ; eventCartridge = ec ; return temp ; } public EventCartridge getEventCartridge ( ) { return eventCartridge ; } } 	1
package org . apache . velocity . util . introspection ; public interface ChainableUberspector extends Uberspect { public void wrap ( Uberspect inner ) ; } 	0
package org . apache . velocity . runtime . visitor ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . node . ASTAddNode ; import org . apache . velocity . runtime . parser . node . ASTAndNode ; import org . apache . velocity . runtime . parser . node . ASTAssignment ; import org . apache . velocity . runtime . parser . node . ASTBlock ; import org . apache . velocity . runtime . parser . node . ASTComment ; import org . apache . velocity . runtime . parser . node . ASTDirective ; import org . apache . velocity . runtime . parser . node . ASTDivNode ; import org . apache . velocity . runtime . parser . node . ASTEQNode ; import org . apache . velocity . runtime . parser . node . ASTElseIfStatement ; import org . apache . velocity . runtime . parser . node . ASTElseStatement ; import org . apache . velocity . runtime . parser . node . ASTEscape ; import org . apache . velocity . runtime . parser . node . ASTEscapedDirective ; import org . apache . velocity . runtime . parser . node . ASTExpression ; import org . apache . velocity . runtime . parser . node . ASTFalse ; import org . apache . velocity . runtime . parser . node . ASTFloatingPointLiteral ; import org . apache . velocity . runtime . parser . node . ASTGENode ; import org . apache . velocity . runtime . parser . node . ASTGTNode ; import org . apache . velocity . runtime . parser . node . ASTIdentifier ; import org . apache . velocity . runtime . parser . node . ASTIfStatement ; import org . apache . velocity . runtime . parser . node . ASTIntegerLiteral ; import org . apache . velocity . runtime . parser . node . ASTIntegerRange ; import org . apache . velocity . runtime . parser . node . ASTLENode ; import org . apache . velocity . runtime . parser . node . ASTLTNode ; import org . apache . velocity . runtime . parser . node . ASTMap ; import org . apache . velocity . runtime . parser . node . ASTMethod ; import org . apache . velocity . runtime . parser . node . ASTModNode ; import org . apache . velocity . runtime . parser . node . ASTMulNode ; import org . apache . velocity . runtime . parser . node . ASTNENode ; import org . apache . velocity . runtime . parser . node . ASTNotNode ; import org . apache . velocity . runtime . parser . node . ASTObjectArray ; import org . apache . velocity . runtime . parser . node . ASTOrNode ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . node . ASTSetDirective ; import org . apache . velocity . runtime . parser . node . ASTStop ; import org . apache . velocity . runtime . parser . node . ASTStringLiteral ; import org . apache . velocity . runtime . parser . node . ASTSubtractNode ; import org . apache . velocity . runtime . parser . node . ASTText ; import org . apache . velocity . runtime . parser . node . ASTTrue ; import org . apache . velocity . runtime . parser . node . ASTWord ; import org . apache . velocity . runtime . parser . node . ASTprocess ; import org . apache . velocity . runtime . parser . node . ParserVisitor ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public abstract class BaseVisitor implements ParserVisitor { protected InternalContextAdapter context ; protected Writer writer ; public void setWriter ( Writer writer ) { this . writer = writer ; } public void setContext ( InternalContextAdapter context ) { this . context = context ; } public Object visit ( SimpleNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTprocess node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTExpression node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTAssignment node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTOrNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTAndNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTEQNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTNENode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTLTNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTGTNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTLENode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTGENode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTAddNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTSubtractNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTMulNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTDivNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTModNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTNotNode node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTIntegerLiteral node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTFloatingPointLiteral node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTStringLiteral node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTIdentifier node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTMethod node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTReference node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTTrue node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTFalse node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTBlock node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTText node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTIfStatement node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTElseStatement node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTElseIfStatement node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTComment node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTObjectArray node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTWord node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTSetDirective node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTDirective node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTEscapedDirective node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTEscape node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTMap node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTIntegerRange node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } public Object visit ( ASTStop node , Object data ) { data = node . childrenAccept ( this , data ) ; return data ; } } 	1
package org . apache . velocity . app . event . implement ; import org . apache . velocity . util . introspection . Info ; public class InvalidReferenceInfo extends Info { private String invalidReference ; public InvalidReferenceInfo ( String invalidReference , Info info ) { super ( info . getTemplateName ( ) , info . getLine ( ) , info . getColumn ( ) ) ; this . invalidReference = invalidReference ; } public String getInvalidReference ( ) { return invalidReference ; } public String toString ( ) { return getTemplateName ( ) + " [line " + getLine ( ) + ", column " + getColumn ( ) + "]: " + invalidReference ; } } 	0
package org . apache . velocity . runtime . resource . loader ; import java . io . InputStream ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . runtime . resource . ResourceCacheImpl ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; import org . apache . commons . collections . ExtendedProperties ; public abstract class ResourceLoader { protected boolean isCachingOn = false ; protected long modificationCheckInterval = 2 ; protected String className = null ; protected RuntimeServices rsvc = null ; protected Log log = null ; public void commonInit ( RuntimeServices rs , ExtendedProperties configuration ) { this . rsvc = rs ; this . log = rsvc . getLog ( ) ; try { isCachingOn = configuration . getBoolean ( "cache" , false ) ; } catch ( Exception e ) { isCachingOn = false ; String msg = "Exception parsing cache setting: " + configuration . getString ( "cache" ) ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } try { modificationCheckInterval = configuration . getLong ( "modificationCheckInterval" , 0 ) ; } catch ( Exception e ) { modificationCheckInterval = 0 ; String msg = "Exception parsing modificationCheckInterval setting: " + configuration . getString ( "modificationCheckInterval" ) ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } className = ResourceCacheImpl . class . getName ( ) ; try { className = configuration . getString ( "class" , className ) ; } catch ( Exception e ) { String msg = "Exception retrieving resource cache class name" ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } public abstract void init ( ExtendedProperties configuration ) ; public abstract InputStream getResourceStream ( String source ) throws ResourceNotFoundException ; public abstract boolean isSourceModified ( Resource resource ) ; public abstract long getLastModified ( Resource resource ) ; public String getClassName ( ) { return className ; } public void setCachingOn ( boolean value ) { isCachingOn = value ; } public boolean isCachingOn ( ) { return isCachingOn ; } public void setModificationCheckInterval ( long modificationCheckInterval ) { this . modificationCheckInterval = modificationCheckInterval ; } public long getModificationCheckInterval ( ) { return modificationCheckInterval ; } public boolean resourceExists ( final String resourceName ) { InputStream is = null ; try { is = getResourceStream ( resourceName ) ; } catch ( ResourceNotFoundException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Could not load resource '" + resourceName + "' from ResourceLoader " + this . getClass ( ) . getName ( ) + ": " , e ) ; } } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( Exception e ) { if ( log . isErrorEnabled ( ) ) { String msg = "While closing InputStream for resource '" + resourceName + "' from ResourceLoader " + this . getClass ( ) . getName ( ) ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } } return ( is != null ) ; } } 	1
package org . apache . velocity . util ; import org . apache . velocity . context . Context ; public interface ContextAware { public void setContext ( Context context ) ; } 	0
package org . apache . velocity . runtime . log ; import java . io . File ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import org . apache . commons . lang . StringUtils ; import org . apache . log . Hierarchy ; import org . apache . log . LogTarget ; import org . apache . log . Logger ; import org . apache . log . Priority ; import org . apache . log . output . io . FileTarget ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; public class AvalonLogChute implements LogChute { public static final String AVALON_LOGGER = "runtime.log.logsystem.avalon.logger" ; public static final String AVALON_LOGGER_FORMAT = "runtime.log.logsystem.avalon.format" ; public static final String AVALON_LOGGER_LEVEL = "runtime.log.logsystem.avalon.level" ; private Logger logger = null ; private RuntimeServices rsvc = null ; private static final Map logLevels = new HashMap ( ) ; static { logLevels . put ( "trace" , Priority . DEBUG ) ; logLevels . put ( "debug" , Priority . DEBUG ) ; logLevels . put ( "info" , Priority . INFO ) ; logLevels . put ( "warn" , Priority . WARN ) ; logLevels . put ( "error" , Priority . ERROR ) ; } public void init ( RuntimeServices rs ) throws Exception { this . rsvc = rs ; String name = ( String ) rsvc . getProperty ( AVALON_LOGGER ) ; if ( name != null ) { this . logger = Hierarchy . getDefaultHierarchy ( ) . getLoggerFor ( name ) ; } else { logger = Hierarchy . getDefaultHierarchy ( ) . getLoggerFor ( rsvc . toString ( ) ) ; String file = ( String ) rsvc . getProperty ( RuntimeConstants . RUNTIME_LOG ) ; if ( StringUtils . isNotEmpty ( file ) ) { initTarget ( file , rsvc ) ; } } } private void initTarget ( final String file , final RuntimeServices rsvc ) throws Exception { try { String format = null ; Priority level = null ; if ( rsvc != null ) { format = rsvc . getString ( AVALON_LOGGER_FORMAT , "%{time} %{message}\\n%{throwable}" ) ; level = ( Priority ) logLevels . get ( rsvc . getString ( AVALON_LOGGER_LEVEL , "warn" ) ) ; } VelocityFormatter vf = new VelocityFormatter ( format ) ; FileTarget target = new FileTarget ( new File ( file ) , false , vf ) ; logger . setPriority ( level ) ; logger . setLogTargets ( new LogTarget [ ] { target } ) ; log ( DEBUG_ID , "AvalonLogChute initialized using file '" + file + '\'' ) ; } catch ( IOException ioe ) { rsvc . getLog ( ) . error ( "Unable to create log file for AvalonLogChute" , ioe ) ; throw new Exception ( "Error configuring AvalonLogChute : " + ioe ) ; } } public void init ( String file ) throws Exception { logger = Hierarchy . getDefaultHierarchy ( ) . getLoggerFor ( rsvc . toString ( ) ) ; initTarget ( file , null ) ; log ( DEBUG_ID , "You shouldn't be using the init(String file) method!" ) ; } public void log ( int level , String message ) { switch ( level ) { case WARN_ID : logger . warn ( WARN_PREFIX + message ) ; break ; case INFO_ID : logger . info ( INFO_PREFIX + message ) ; break ; case DEBUG_ID : logger . debug ( DEBUG_PREFIX + message ) ; break ; case TRACE_ID : logger . debug ( TRACE_PREFIX + message ) ; break ; case ERROR_ID : logger . error ( ERROR_PREFIX + message ) ; break ; default : logger . info ( message ) ; break ; } } public void log ( int level , String message , Throwable t ) { switch ( level ) { case WARN_ID : logger . warn ( WARN_PREFIX + message , t ) ; break ; case INFO_ID : logger . info ( INFO_PREFIX + message , t ) ; break ; case DEBUG_ID : logger . debug ( DEBUG_PREFIX + message , t ) ; break ; case TRACE_ID : logger . debug ( TRACE_PREFIX + message , t ) ; break ; case ERROR_ID : logger . error ( ERROR_PREFIX + message , t ) ; break ; default : logger . info ( message , t ) ; break ; } } public boolean isLevelEnabled ( int level ) { switch ( level ) { case TRACE_ID : case DEBUG_ID : return logger . isDebugEnabled ( ) ; case INFO_ID : return logger . isInfoEnabled ( ) ; case WARN_ID : return logger . isWarnEnabled ( ) ; case ERROR_ID : return logger . isErrorEnabled ( ) ; default : return true ; } } protected void finalize ( ) throws Throwable { shutdown ( ) ; } public void shutdown ( ) { logger . unsetLogTargets ( ) ; } } 	1
package org . apache . velocity . runtime . log ; public class AvalonLogSystem extends AvalonLogChute implements LogSystem { public void logVelocityMessage ( int level , String message ) { log ( level , message ) ; } } 	0
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . TemplateNumber ; public class ASTGTNode extends SimpleNode { public ASTGTNode ( int id ) { super ( id ) ; } public ASTGTNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '>' operation has null value." + " Operation not possible. " + Log . formatFileString ( this ) ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of '>=' operation is not a Numbere. " + Log . formatFileString ( this ) ) ; return false ; } return MathUtils . compare ( ( Number ) left , ( Number ) right ) == 1 ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1
package org . apache . velocity . exception ; public class MacroOverflowException extends VelocityException { private static final long serialVersionUID = 7305635093478106342L ; public MacroOverflowException ( final String exceptionMessage ) { super ( exceptionMessage ) ; } public MacroOverflowException ( final String exceptionMessage , final Throwable wrapped ) { super ( exceptionMessage , wrapped ) ; } public MacroOverflowException ( final Throwable wrapped ) { super ( wrapped ) ; } } 	0
package org . apache . velocity . runtime . log ; import java . util . Vector ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeServices ; class HoldingLogChute implements LogChute { private Vector pendingMessages = new Vector ( ) ; private volatile boolean transferring = false ; public void init ( RuntimeServices rs ) throws Exception { } public synchronized void log ( int level , String message ) { if ( ! transferring ) { Object [ ] data = new Object [ 2 ] ; data [ 0 ] = new Integer ( level ) ; data [ 1 ] = message ; pendingMessages . addElement ( data ) ; } } public synchronized void log ( int level , String message , Throwable t ) { if ( ! transferring ) { Object [ ] data = new Object [ 3 ] ; data [ 0 ] = new Integer ( level ) ; data [ 1 ] = message ; data [ 2 ] = t ; pendingMessages . addElement ( data ) ; } } public boolean isLevelEnabled ( int level ) { return true ; } public synchronized void transferTo ( LogChute newChute ) { if ( ! transferring && ! pendingMessages . isEmpty ( ) ) { transferring = true ; for ( Iterator i = pendingMessages . iterator ( ) ; i . hasNext ( ) ; ) { Object [ ] data = ( Object [ ] ) i . next ( ) ; int level = ( ( Integer ) data [ 0 ] ) . intValue ( ) ; String message = ( String ) data [ 1 ] ; if ( data . length == 2 ) { newChute . log ( level , message ) ; } else { newChute . log ( level , message , ( Throwable ) data [ 2 ] ) ; } } } } } 	1
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MathException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTModNode extends ASTMathNode { public ASTModNode ( int id ) { super ( id ) ; } public ASTModNode ( Parser p , int id ) { super ( p , id ) ; } public Number perform ( Number left , Number right , InternalContextAdapter context ) { if ( MathUtils . isZero ( right ) ) { String msg = "Right side of modulus operation is zero. Must be non-zero. " + getLocation ( context ) ; if ( strictMode ) { log . error ( msg ) ; throw new MathException ( msg ) ; } else { log . debug ( msg ) ; return null ; } } return MathUtils . modulo ( left , right ) ; } } 	0
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import java . util . Iterator ; import java . util . List ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . context . ChainedInternalContextAdapter ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . ASTReference ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . introspection . Info ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; public class Foreach extends Directive { protected static class NullHolderContext extends ChainedInternalContextAdapter { private String loopVariableKey = "" ; private boolean active = true ; private NullHolderContext ( String key , InternalContextAdapter context ) { super ( context ) ; if ( key != null ) loopVariableKey = key ; } public Object get ( String key ) throws MethodInvocationException { return ( active && loopVariableKey . equals ( key ) ) ? null : super . get ( key ) ; } public Object put ( String key , Object value ) { if ( loopVariableKey . equals ( key ) && ( value == null ) ) { active = true ; } return super . put ( key , value ) ; } public Object localPut ( final String key , final Object value ) { return put ( key , value ) ; } public Object remove ( Object key ) { if ( loopVariableKey . equals ( key ) ) { active = false ; } return super . remove ( key ) ; } } public String getName ( ) { return "foreach" ; } public int getType ( ) { return BLOCK ; } private String counterName ; private String hasNextName ; private int counterInitialValue ; private int maxNbrLoops ; private boolean skipInvalidIterator ; private String elementKey ; protected Info uberInfo ; public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; counterName = rsvc . getString ( RuntimeConstants . COUNTER_NAME ) ; hasNextName = rsvc . getString ( RuntimeConstants . HAS_NEXT_NAME ) ; counterInitialValue = rsvc . getInt ( RuntimeConstants . COUNTER_INITIAL_VALUE ) ; maxNbrLoops = rsvc . getInt ( RuntimeConstants . MAX_NUMBER_LOOPS , Integer . MAX_VALUE ) ; if ( maxNbrLoops < 1 ) { maxNbrLoops = Integer . MAX_VALUE ; } skipInvalidIterator = rsvc . getBoolean ( RuntimeConstants . SKIP_INVALID_ITERATOR , true ) ; SimpleNode sn = ( SimpleNode ) node . jjtGetChild ( 0 ) ; if ( sn instanceof ASTReference ) { elementKey = ( ( ASTReference ) sn ) . getRootString ( ) ; } else { elementKey = sn . getFirstToken ( ) . image . substring ( 1 ) ; } uberInfo = new Info ( context . getCurrentTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; } protected void put ( InternalContextAdapter context , String key , Object value ) { context . put ( key , value ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException , ResourceNotFoundException , ParseErrorException { Object listObject = node . jjtGetChild ( 2 ) . value ( context ) ; if ( listObject == null ) return false ; Iterator i = null ; try { i = rsvc . getUberspect ( ) . getIterator ( listObject , uberInfo ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception ee ) { String msg = "Error getting iterator for #foreach at " + uberInfo ; rsvc . getLog ( ) . error ( msg , ee ) ; throw new VelocityException ( msg , ee ) ; } if ( i == null ) { if ( skipInvalidIterator ) { return false ; } else { Node pnode = node . jjtGetChild ( 2 ) ; String msg = "#foreach parameter " + pnode . literal ( ) + " at " + rsvc . getLog ( ) . formatFileString ( uberInfo . getTemplateName ( ) , pnode . getLine ( ) , pnode . getColumn ( ) ) + " is of type " + listObject . getClass ( ) . getName ( ) + " and is either of wrong type or cannot be iterated." ; rsvc . getLog ( ) . error ( msg ) ; throw new VelocityException ( msg ) ; } } int counter = counterInitialValue ; boolean maxNbrLoopsExceeded = false ; Object o = context . get ( elementKey ) ; Object savedCounter = context . get ( counterName ) ; NullHolderContext nullHolderContext = null ; while ( ! maxNbrLoopsExceeded && i . hasNext ( ) ) { put ( context , counterName , new Integer ( counter ) ) ; put ( context , hasNextName , Boolean . valueOf ( i . hasNext ( ) ) ) ; Object value = i . next ( ) ; put ( context , elementKey , value ) ; try { if ( value == null ) { if ( nullHolderContext == null ) { nullHolderContext = new NullHolderContext ( elementKey , context ) ; } node . jjtGetChild ( 3 ) . render ( nullHolderContext , writer ) ; } else { node . jjtGetChild ( 3 ) . render ( context , writer ) ; } } catch ( Break . BreakException ex ) { break ; } counter ++ ; maxNbrLoopsExceeded = ( counter - counterInitialValue ) >= maxNbrLoops ; } if ( savedCounter != null ) { context . put ( counterName , savedCounter ) ; } else { context . remove ( counterName ) ; } if ( o != null ) { context . put ( elementKey , o ) ; } else { context . remove ( elementKey ) ; } return true ; } } 	1
package org . apache . velocity . texen . util ; import java . io . FileInputStream ; import java . io . InputStream ; import java . util . Properties ; import java . util . StringTokenizer ; import org . apache . velocity . texen . Generator ; public class PropertiesUtil { public Properties load ( final String propertiesFile ) { Properties properties = null ; String templatePath = Generator . getInstance ( ) . getTemplatePath ( ) ; try { if ( templatePath != null ) { properties = loadFromTemplatePath ( propertiesFile ) ; } else { properties = loadFromClassPath ( propertiesFile ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( "Could not load properties: " + e . getMessage ( ) ) ; } return properties ; } protected Properties loadFromTemplatePath ( final String propertiesFile ) throws Exception { Properties properties = new Properties ( ) ; String templatePath = Generator . getInstance ( ) . getTemplatePath ( ) ; StringTokenizer st = new StringTokenizer ( templatePath , "," ) ; while ( st . hasMoreTokens ( ) ) { String templateDir = st . nextToken ( ) ; InputStream stream = null ; try { String fullPath = propertiesFile ; if ( ! fullPath . startsWith ( templateDir ) ) { fullPath = templateDir + "/" + propertiesFile ; } stream = new FileInputStream ( fullPath ) ; properties . load ( stream ) ; break ; } finally { if ( stream != null ) { stream . close ( ) ; } } } return properties ; } protected Properties loadFromClassPath ( final String propertiesName ) throws Exception { Properties properties = new Properties ( ) ; ClassLoader classLoader = this . getClass ( ) . getClassLoader ( ) ; InputStream inputStream = null ; try { String propertiesFile = propertiesName . startsWith ( "$generator" ) ? propertiesName . substring ( "$generator.templatePath/" . length ( ) ) : propertiesName ; inputStream = classLoader . getResourceAsStream ( propertiesFile ) ; properties . load ( inputStream ) ; } finally { if ( inputStream != null ) { inputStream . close ( ) ; } } return properties ; } } 	0
package org . apache . velocity . util . introspection ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; public class MethodMap { private static final int MORE_SPECIFIC = 0 ; private static final int LESS_SPECIFIC = 1 ; private static final int INCOMPARABLE = 2 ; Map methodByNameMap = new HashMap ( ) ; public void add ( Method method ) { String methodName = method . getName ( ) ; List l = get ( methodName ) ; if ( l == null ) { l = new ArrayList ( ) ; methodByNameMap . put ( methodName , l ) ; } l . add ( method ) ; } public List get ( String key ) { return ( List ) methodByNameMap . get ( key ) ; } public Method find ( String methodName , Object [ ] args ) throws AmbiguousException { List methodList = get ( methodName ) ; if ( methodList == null ) { return null ; } int l = args . length ; Class [ ] classes = new Class [ l ] ; for ( int i = 0 ; i < l ; ++ i ) { Object arg = args [ i ] ; classes [ i ] = arg == null ? null : arg . getClass ( ) ; } return getBestMatch ( methodList , classes ) ; } private static Method getBestMatch ( List methods , Class [ ] args ) { List equivalentMatches = null ; Method bestMatch = null ; Class [ ] bestMatchTypes = null ; for ( Iterator i = methods . iterator ( ) ; i . hasNext ( ) ; ) { Method method = ( Method ) i . next ( ) ; if ( isApplicable ( method , args ) ) { if ( bestMatch == null ) { bestMatch = method ; bestMatchTypes = method . getParameterTypes ( ) ; } else { Class [ ] methodTypes = method . getParameterTypes ( ) ; switch ( compare ( methodTypes , bestMatchTypes ) ) { case MORE_SPECIFIC : if ( equivalentMatches == null ) { bestMatch = method ; bestMatchTypes = methodTypes ; } else { int ambiguities = equivalentMatches . size ( ) ; for ( int a = 0 ; a < ambiguities ; a ++ ) { Method other = ( Method ) equivalentMatches . get ( a ) ; switch ( compare ( methodTypes , other . getParameterTypes ( ) ) ) { case MORE_SPECIFIC : bestMatch = method ; bestMatchTypes = methodTypes ; equivalentMatches = null ; ambiguities = 0 ; break ; case INCOMPARABLE : equivalentMatches . add ( method ) ; break ; case LESS_SPECIFIC : break ; } } } break ; case INCOMPARABLE : if ( equivalentMatches == null ) { equivalentMatches = new ArrayList ( bestMatchTypes . length ) ; } equivalentMatches . add ( method ) ; break ; case LESS_SPECIFIC : break ; } } } } if ( equivalentMatches != null ) { throw new AmbiguousException ( ) ; } return bestMatch ; } public static class AmbiguousException extends RuntimeException { private static final long serialVersionUID = - 2314636505414551663L ; } private static int compare ( Class [ ] c1 , Class [ ] c2 ) { boolean c1MoreSpecific = false ; boolean c2MoreSpecific = false ; if ( c1 . length > c2 . length ) { return MORE_SPECIFIC ; } if ( c2 . length > c1 . length ) { return LESS_SPECIFIC ; } for ( int i = 0 ; i < c1 . length ; ++ i ) { if ( c1 [ i ] != c2 [ i ] ) { boolean last = ( i == c1 . length - 1 ) ; c1MoreSpecific = c1MoreSpecific || isStrictConvertible ( c2 [ i ] , c1 [ i ] , last ) ; c2MoreSpecific = c2MoreSpecific || isStrictConvertible ( c1 [ i ] , c2 [ i ] , last ) ; } } if ( c1MoreSpecific ) { if ( c2MoreSpecific ) { boolean last1Array = c1 [ c1 . length - 1 ] . isArray ( ) ; boolean last2Array = c2 [ c2 . length - 1 ] . isArray ( ) ; if ( last1Array && ! last2Array ) { return LESS_SPECIFIC ; } if ( ! last1Array && last2Array ) { return MORE_SPECIFIC ; } return INCOMPARABLE ; } return MORE_SPECIFIC ; } if ( c2MoreSpecific ) { return LESS_SPECIFIC ; } return INCOMPARABLE ; } private static boolean isApplicable ( Method method , Class [ ] classes ) { Class [ ] methodArgs = method . getParameterTypes ( ) ; if ( methodArgs . length > classes . length ) { if ( methodArgs . length == classes . length + 1 && methodArgs [ methodArgs . length - 1 ] . isArray ( ) ) { return true ; } else { return false ; } } else if ( methodArgs . length == classes . length ) { for ( int i = 0 ; i < classes . length ; ++ i ) { if ( ! isConvertible ( methodArgs [ i ] , classes [ i ] , false ) ) { if ( i == classes . length - 1 && methodArgs [ i ] . isArray ( ) ) { return isConvertible ( methodArgs [ i ] , classes [ i ] , true ) ; } return false ; } } } else if ( methodArgs . length > 0 ) { Class lastarg = methodArgs [ methodArgs . length - 1 ] ; if ( ! lastarg . isArray ( ) ) { return false ; } for ( int i = 0 ; i < methodArgs . length - 1 ; ++ i ) { if ( ! isConvertible ( methodArgs [ i ] , classes [ i ] , false ) ) { return false ; } } Class vararg = lastarg . getComponentType ( ) ; for ( int i = methodArgs . length - 1 ; i < classes . length ; ++ i ) { if ( ! isConvertible ( vararg , classes [ i ] , false ) ) { return false ; } } } return true ; } private static boolean isConvertible ( Class formal , Class actual , boolean possibleVarArg ) { return IntrospectionUtils . isMethodInvocationConvertible ( formal , actual , possibleVarArg ) ; } private static boolean isStrictConvertible ( Class formal , Class actual , boolean possibleVarArg ) { return IntrospectionUtils . isStrictMethodInvocationConvertible ( formal , actual , possibleVarArg ) ; } } 	1
package org . apache . velocity . runtime . parser . node ; import java . util . HashMap ; import java . util . Map ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTMap extends SimpleNode { public ASTMap ( int id ) { super ( id ) ; } public ASTMap ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { int size = jjtGetNumChildren ( ) ; Map objectMap = new HashMap ( ) ; for ( int i = 0 ; i < size ; i += 2 ) { SimpleNode keyNode = ( SimpleNode ) jjtGetChild ( i ) ; SimpleNode valueNode = ( SimpleNode ) jjtGetChild ( i + 1 ) ; Object key = ( keyNode == null ? null : keyNode . value ( context ) ) ; Object value = ( valueNode == null ? null : valueNode . value ( context ) ) ; objectMap . put ( key , value ) ; } return objectMap ; } } 	0
package org . apache . velocity . util . introspection ; import java . lang . reflect . Array ; import java . lang . reflect . Method ; import java . util . Collection ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . Map ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . RuntimeLoggerLog ; import org . apache . velocity . runtime . parser . node . AbstractExecutor ; import org . apache . velocity . runtime . parser . node . BooleanPropertyExecutor ; import org . apache . velocity . runtime . parser . node . GetExecutor ; import org . apache . velocity . runtime . parser . node . MapGetExecutor ; import org . apache . velocity . runtime . parser . node . MapSetExecutor ; import org . apache . velocity . runtime . parser . node . PropertyExecutor ; import org . apache . velocity . runtime . parser . node . PutExecutor ; import org . apache . velocity . runtime . parser . node . SetExecutor ; import org . apache . velocity . runtime . parser . node . SetPropertyExecutor ; import org . apache . velocity . util . ArrayIterator ; import org . apache . velocity . util . ArrayListWrapper ; import org . apache . velocity . util . EnumerationIterator ; public class UberspectImpl implements Uberspect , UberspectLoggable { protected Log log ; protected Introspector introspector ; public void init ( ) throws Exception { introspector = new Introspector ( log ) ; } public void setLog ( Log log ) { this . log = log ; } public void setRuntimeLogger ( RuntimeLogger runtimeLogger ) { setLog ( new RuntimeLoggerLog ( runtimeLogger ) ) ; } public Iterator getIterator ( Object obj , Info i ) throws Exception { if ( obj . getClass ( ) . isArray ( ) ) { return new ArrayIterator ( obj ) ; } else if ( obj instanceof Collection ) { return ( ( Collection ) obj ) . iterator ( ) ; } else if ( obj instanceof Map ) { return ( ( Map ) obj ) . values ( ) . iterator ( ) ; } else if ( obj instanceof Iterator ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "The iterative object in the #foreach() loop at " + i + " is of type java.util.Iterator.  Because " + "it is not resettable, if used in more than once it " + "may lead to unexpected results." ) ; } return ( ( Iterator ) obj ) ; } else if ( obj instanceof Enumeration ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "The iterative object in the #foreach() loop at " + i + " is of type java.util.Enumeration.  Because " + "it is not resettable, if used in more than once it " + "may lead to unexpected results." ) ; } return new EnumerationIterator ( ( Enumeration ) obj ) ; } else { Class type = obj . getClass ( ) ; try { Method iter = type . getMethod ( "iterator" , null ) ; Class returns = iter . getReturnType ( ) ; if ( Iterator . class . isAssignableFrom ( returns ) ) { return ( Iterator ) iter . invoke ( obj , null ) ; } else { log . debug ( "iterator() method of reference in #foreach loop at " + i + " does not return a true Iterator." ) ; } } catch ( NoSuchMethodException nsme ) { } } log . debug ( "Could not determine type of iterator in #foreach loop at " + i ) ; return null ; } public VelMethod getMethod ( Object obj , String methodName , Object [ ] args , Info i ) throws Exception { if ( obj == null ) { return null ; } Method m = introspector . getMethod ( obj . getClass ( ) , methodName , args ) ; if ( m != null ) { return new VelMethodImpl ( m ) ; } Class cls = obj . getClass ( ) ; if ( cls . isArray ( ) ) { m = introspector . getMethod ( ArrayListWrapper . class , methodName , args ) ; if ( m != null ) { return new VelMethodImpl ( m , true ) ; } } else if ( cls == Class . class ) { m = introspector . getMethod ( ( Class ) obj , methodName , args ) ; if ( m != null ) { return new VelMethodImpl ( m ) ; } } return null ; } public VelPropertyGet getPropertyGet ( Object obj , String identifier , Info i ) throws Exception { if ( obj == null ) { return null ; } Class claz = obj . getClass ( ) ; AbstractExecutor executor = new PropertyExecutor ( log , introspector , claz , identifier ) ; if ( ! executor . isAlive ( ) ) { executor = new MapGetExecutor ( log , claz , identifier ) ; } if ( ! executor . isAlive ( ) ) { executor = new GetExecutor ( log , introspector , claz , identifier ) ; } if ( ! executor . isAlive ( ) ) { executor = new BooleanPropertyExecutor ( log , introspector , claz , identifier ) ; } return ( executor . isAlive ( ) ) ? new VelGetterImpl ( executor ) : null ; } public VelPropertySet getPropertySet ( Object obj , String identifier , Object arg , Info i ) throws Exception { if ( obj == null ) { return null ; } Class claz = obj . getClass ( ) ; SetExecutor executor = new SetPropertyExecutor ( log , introspector , claz , identifier , arg ) ; if ( ! executor . isAlive ( ) ) { executor = new MapSetExecutor ( log , claz , identifier ) ; } if ( ! executor . isAlive ( ) ) { executor = new PutExecutor ( log , introspector , claz , arg , identifier ) ; } return ( executor . isAlive ( ) ) ? new VelSetterImpl ( executor ) : null ; } public static class VelMethodImpl implements VelMethod { final Method method ; Boolean isVarArg ; boolean wrapArray ; public VelMethodImpl ( Method m ) { this ( m , false ) ; } public VelMethodImpl ( Method method , boolean wrapArray ) { this . method = method ; this . wrapArray = wrapArray ; } private VelMethodImpl ( ) { method = null ; } public Object invoke ( Object o , Object [ ] actual ) throws Exception { if ( wrapArray ) { o = new ArrayListWrapper ( o ) ; } if ( isVarArg ( ) ) { Class [ ] formal = method . getParameterTypes ( ) ; int index = formal . length - 1 ; if ( actual . length >= index ) { Class type = formal [ index ] . getComponentType ( ) ; actual = handleVarArg ( type , index , actual ) ; } } return doInvoke ( o , actual ) ; } protected Object doInvoke ( Object o , Object [ ] actual ) throws Exception { return method . invoke ( o , actual ) ; } public boolean isVarArg ( ) { if ( isVarArg == null ) { Class [ ] formal = method . getParameterTypes ( ) ; if ( formal == null || formal . length == 0 ) { this . isVarArg = Boolean . FALSE ; } else { Class last = formal [ formal . length - 1 ] ; this . isVarArg = Boolean . valueOf ( last . isArray ( ) ) ; } } return isVarArg . booleanValue ( ) ; } private Object [ ] handleVarArg ( final Class type , final int index , Object [ ] actual ) { if ( actual . length == index ) { actual = new Object [ ] { Array . newInstance ( type , 0 ) } ; } else if ( actual . length == index + 1 && actual [ index ] != null ) { Class argClass = actual [ index ] . getClass ( ) ; if ( ! argClass . isArray ( ) && IntrospectionUtils . isMethodInvocationConvertible ( type , argClass , false ) ) { Object lastActual = Array . newInstance ( type , 1 ) ; Array . set ( lastActual , 0 , actual [ index ] ) ; actual [ index ] = lastActual ; } } else if ( actual . length > index + 1 ) { int size = actual . length - index ; Object lastActual = Array . newInstance ( type , size ) ; for ( int i = 0 ; i < size ; i ++ ) { Array . set ( lastActual , i , actual [ index + i ] ) ; } Object [ ] newActual = new Object [ index + 1 ] ; for ( int i = 0 ; i < index ; i ++ ) { newActual [ i ] = actual [ i ] ; } newActual [ index ] = lastActual ; actual = newActual ; } return actual ; } public boolean isCacheable ( ) { return true ; } public String getMethodName ( ) { return method . getName ( ) ; } public Class getReturnType ( ) { return method . getReturnType ( ) ; } } public static class VelGetterImpl implements VelPropertyGet { final AbstractExecutor getExecutor ; public VelGetterImpl ( AbstractExecutor exec ) { getExecutor = exec ; } private VelGetterImpl ( ) { getExecutor = null ; } public Object invoke ( Object o ) throws Exception { return getExecutor . execute ( o ) ; } public boolean isCacheable ( ) { return true ; } public String getMethodName ( ) { return getExecutor . isAlive ( ) ? getExecutor . getMethod ( ) . getName ( ) : null ; } } public static class VelSetterImpl implements VelPropertySet { private final SetExecutor setExecutor ; public VelSetterImpl ( final SetExecutor setExecutor ) { this . setExecutor = setExecutor ; } private VelSetterImpl ( ) { setExecutor = null ; } public Object invoke ( final Object o , final Object value ) throws Exception { return setExecutor . execute ( o , value ) ; } public boolean isCacheable ( ) { return true ; } public String getMethodName ( ) { return setExecutor . isAlive ( ) ? setExecutor . getMethod ( ) . getName ( ) : null ; } } } 	1
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . parser . Parser ; public class ASTNotNode extends SimpleNode { public ASTNotNode ( int id ) { super ( id ) ; } public ASTNotNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { if ( jjtGetChild ( 0 ) . evaluate ( context ) ) return false ; else return true ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { return ( jjtGetChild ( 0 ) . evaluate ( context ) ? Boolean . FALSE : Boolean . TRUE ) ; } } 	0
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . TemplateNumber ; public class ASTLENode extends SimpleNode { public ASTLENode ( int id ) { super ( id ) ; } public ASTLENode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '<=' operation has null value." + " Operation not possible. " + Log . formatFileString ( this ) ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of '>=' operation is not a Number. " + Log . formatFileString ( this ) ) ; return false ; } return MathUtils . compare ( ( Number ) left , ( Number ) right ) <= 0 ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1
package org . apache . velocity . anakia ; import com . werken . xpath . XPath ; import java . util . Map ; import java . util . WeakHashMap ; class XPathCache { private static final Map XPATH_CACHE = new WeakHashMap ( ) ; private XPathCache ( ) { } static XPath getXPath ( String xpathString ) { XPath xpath = null ; synchronized ( XPATH_CACHE ) { xpath = ( XPath ) XPATH_CACHE . get ( xpathString ) ; if ( xpath == null ) { xpath = new XPath ( xpathString ) ; XPATH_CACHE . put ( xpathString , xpath ) ; } } return xpath ; } } 	0
package org . apache . velocity ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . List ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . runtime . resource . ResourceManager ; public class Template extends Resource { private VelocityException errorCondition = null ; public Template ( ) { super ( ) ; setType ( ResourceManager . RESOURCE_TEMPLATE ) ; } public boolean process ( ) throws ResourceNotFoundException , ParseErrorException , IOException { data = null ; InputStream is = null ; errorCondition = null ; try { is = resourceLoader . getResourceStream ( name ) ; } catch ( ResourceNotFoundException rnfe ) { errorCondition = rnfe ; throw rnfe ; } if ( is != null ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( is , encoding ) ) ; data = rsvc . parse ( br , name ) ; initDocument ( ) ; return true ; } catch ( UnsupportedEncodingException uce ) { String msg = "Template.process : Unsupported input encoding : " + encoding + " for template " + name ; errorCondition = new ParseErrorException ( msg ) ; throw errorCondition ; } catch ( ParseException pex ) { errorCondition = new ParseErrorException ( pex ) ; throw errorCondition ; } catch ( TemplateInitException pex ) { errorCondition = new ParseErrorException ( pex ) ; throw errorCondition ; } catch ( RuntimeException e ) { throw new RuntimeException ( "Exception thrown processing Template " + getName ( ) , e ) ; } finally { is . close ( ) ; } } else { errorCondition = new ResourceNotFoundException ( "Unknown resource error for resource " + name ) ; throw errorCondition ; } } public void initDocument ( ) throws TemplateInitException { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( new VelocityContext ( ) ) ; try { ica . pushCurrentTemplateName ( name ) ; ica . setCurrentResource ( this ) ; ( ( SimpleNode ) data ) . init ( ica , rsvc ) ; } finally { ica . popCurrentTemplateName ( ) ; ica . setCurrentResource ( null ) ; } } public void merge ( Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , IOException { merge ( context , writer , null ) ; } public void merge ( Context context , Writer writer , List macroLibraries ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , IOException { if ( errorCondition != null ) { throw errorCondition ; } if ( data != null ) { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( context ) ; ica . setMacroLibraries ( macroLibraries ) ; if ( macroLibraries != null ) { for ( int i = 0 ; i < macroLibraries . size ( ) ; i ++ ) { try { rsvc . getTemplate ( ( String ) macroLibraries . get ( i ) ) ; } catch ( ResourceNotFoundException re ) { rsvc . getLog ( ) . error ( "template.merge(): " + "cannot find template " + ( String ) macroLibraries . get ( i ) ) ; throw re ; } catch ( ParseErrorException pe ) { rsvc . getLog ( ) . error ( "template.merge(): " + "syntax error in template " + ( String ) macroLibraries . get ( i ) + "." ) ; throw pe ; } catch ( Exception e ) { throw new RuntimeException ( "Template.merge(): parse failed in template  " + ( String ) macroLibraries . get ( i ) + "." , e ) ; } } } try { ica . pushCurrentTemplateName ( name ) ; ica . setCurrentResource ( this ) ; ( ( SimpleNode ) data ) . render ( ica , writer ) ; } finally { ica . popCurrentTemplateName ( ) ; ica . setCurrentResource ( null ) ; } } else { String msg = "Template.merge() failure. The document is null, " + "most likely due to parsing error." ; throw new RuntimeException ( msg ) ; } } } 	1
package org . apache . velocity . runtime . parser . node ; import java . lang . reflect . InvocationTargetException ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . RuntimeLoggerLog ; import org . apache . velocity . util . introspection . Introspector ; public class PropertyExecutor extends AbstractExecutor { private final Introspector introspector ; public PropertyExecutor ( final Log log , final Introspector introspector , final Class clazz , final String property ) { this . log = log ; this . introspector = introspector ; if ( StringUtils . isNotEmpty ( property ) ) { discover ( clazz , property ) ; } } public PropertyExecutor ( final RuntimeLogger r , final Introspector introspector , final Class clazz , final String property ) { this ( new RuntimeLoggerLog ( r ) , introspector , clazz , property ) ; } protected Introspector getIntrospector ( ) { return this . introspector ; } protected void discover ( final Class clazz , final String property ) { try { Object [ ] params = { } ; StringBuffer sb = new StringBuffer ( "get" ) ; sb . append ( property ) ; setMethod ( introspector . getMethod ( clazz , sb . toString ( ) , params ) ) ; if ( ! isAlive ( ) ) { char c = sb . charAt ( 3 ) ; if ( Character . isLowerCase ( c ) ) { sb . setCharAt ( 3 , Character . toUpperCase ( c ) ) ; } else { sb . setCharAt ( 3 , Character . toLowerCase ( c ) ) ; } setMethod ( introspector . getMethod ( clazz , sb . toString ( ) , params ) ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "Exception while looking for property getter for '" + property ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } public Object execute ( Object o ) throws IllegalAccessException , InvocationTargetException { return isAlive ( ) ? getMethod ( ) . invoke ( o , ( ( Object [ ] ) null ) ) : null ; } } 	0
package org . apache . velocity . util . introspection ; import java . util . Iterator ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; public class SecureUberspector extends UberspectImpl implements RuntimeServicesAware { RuntimeServices runtimeServices ; public SecureUberspector ( ) { super ( ) ; } public void init ( ) { String [ ] badPackages = runtimeServices . getConfiguration ( ) . getStringArray ( RuntimeConstants . INTROSPECTOR_RESTRICT_PACKAGES ) ; String [ ] badClasses = runtimeServices . getConfiguration ( ) . getStringArray ( RuntimeConstants . INTROSPECTOR_RESTRICT_CLASSES ) ; introspector = new SecureIntrospectorImpl ( badClasses , badPackages , log ) ; } public Iterator getIterator ( Object obj , Info i ) throws Exception { if ( obj != null ) { SecureIntrospectorControl sic = ( SecureIntrospectorControl ) introspector ; if ( sic . checkObjectExecutePermission ( obj . getClass ( ) , null ) ) { return super . getIterator ( obj , i ) ; } else { log . warn ( "Cannot retrieve iterator from " + obj . getClass ( ) + " due to security restrictions." ) ; } } return null ; } public void setRuntimeServices ( RuntimeServices rs ) { this . runtimeServices = rs ; } } 	1
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeLogger ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . RuntimeLoggerLog ; import org . apache . velocity . util . introspection . Introspector ; public class BooleanPropertyExecutor extends PropertyExecutor { public BooleanPropertyExecutor ( final Log log , final Introspector introspector , final Class clazz , final String property ) { super ( log , introspector , clazz , property ) ; } public BooleanPropertyExecutor ( final RuntimeLogger rlog , final Introspector introspector , final Class clazz , final String property ) { super ( new RuntimeLoggerLog ( rlog ) , introspector , clazz , property ) ; } protected void discover ( final Class clazz , final String property ) { try { Object [ ] params = { } ; StringBuffer sb = new StringBuffer ( "is" ) ; sb . append ( property ) ; setMethod ( getIntrospector ( ) . getMethod ( clazz , sb . toString ( ) , params ) ) ; if ( ! isAlive ( ) ) { char c = sb . charAt ( 2 ) ; if ( Character . isLowerCase ( c ) ) { sb . setCharAt ( 2 , Character . toUpperCase ( c ) ) ; } else { sb . setCharAt ( 2 , Character . toLowerCase ( c ) ) ; } setMethod ( getIntrospector ( ) . getMethod ( clazz , sb . toString ( ) , params ) ) ; } if ( isAlive ( ) ) { if ( getMethod ( ) . getReturnType ( ) != Boolean . TYPE && getMethod ( ) . getReturnType ( ) != Boolean . class ) { setMethod ( null ) ; } } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "Exception while looking for boolean property getter for '" + property ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } } 	0
package org . apache . velocity . runtime . resource ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Vector ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . resource . loader . ResourceLoader ; import org . apache . velocity . runtime . resource . loader . ResourceLoaderFactory ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . StringUtils ; public class ResourceManagerImpl implements ResourceManager { public static final int RESOURCE_TEMPLATE = 1 ; public static final int RESOURCE_CONTENT = 2 ; private static final String RESOURCE_LOADER_IDENTIFIER = "_RESOURCE_LOADER_IDENTIFIER_" ; protected ResourceCache globalCache = null ; protected final List resourceLoaders = new ArrayList ( ) ; private final List sourceInitializerList = new ArrayList ( ) ; private boolean isInit = false ; private boolean logWhenFound = true ; protected RuntimeServices rsvc = null ; protected Log log = null ; public synchronized void initialize ( final RuntimeServices rsvc ) throws Exception { if ( isInit ) { log . debug ( "Re-initialization of ResourceLoader attempted and ignored." ) ; return ; } ResourceLoader resourceLoader = null ; this . rsvc = rsvc ; log = rsvc . getLog ( ) ; log . trace ( "Default ResourceManager initializing. (" + this . getClass ( ) + ")" ) ; assembleResourceLoaderInitializers ( ) ; for ( Iterator it = sourceInitializerList . iterator ( ) ; it . hasNext ( ) ; ) { ExtendedProperties configuration = ( ExtendedProperties ) it . next ( ) ; String loaderClass = StringUtils . nullTrim ( configuration . getString ( "class" ) ) ; ResourceLoader loaderInstance = ( ResourceLoader ) configuration . get ( "instance" ) ; if ( loaderInstance != null ) { resourceLoader = loaderInstance ; } else if ( loaderClass != null ) { resourceLoader = ResourceLoaderFactory . getLoader ( rsvc , loaderClass ) ; } else { String msg = "Unable to find '" + configuration . getString ( RESOURCE_LOADER_IDENTIFIER ) + ".resource.loader.class' specification in configuration." + " This is a critical value.  Please adjust configuration." ; log . error ( msg ) ; throw new Exception ( msg ) ; } resourceLoader . commonInit ( rsvc , configuration ) ; resourceLoader . init ( configuration ) ; resourceLoaders . add ( resourceLoader ) ; } logWhenFound = rsvc . getBoolean ( RuntimeConstants . RESOURCE_MANAGER_LOGWHENFOUND , true ) ; String cacheClassName = rsvc . getString ( RuntimeConstants . RESOURCE_MANAGER_CACHE_CLASS ) ; Object cacheObject = null ; if ( org . apache . commons . lang . StringUtils . isNotEmpty ( cacheClassName ) ) { try { cacheObject = ClassUtils . getNewInstance ( cacheClassName ) ; } catch ( ClassNotFoundException cnfe ) { String msg = "The specified class for ResourceCache (" + cacheClassName + ") does not exist or is not accessible to the current classloader." ; log . error ( msg , cnfe ) ; throw cnfe ; } if ( ! ( cacheObject instanceof ResourceCache ) ) { String msg = "The specified resource cache class (" + cacheClassName + ") must implement " + ResourceCache . class . getName ( ) ; log . error ( msg ) ; throw new RuntimeException ( msg ) ; } } if ( cacheObject == null ) { cacheObject = new ResourceCacheImpl ( ) ; } globalCache = ( ResourceCache ) cacheObject ; globalCache . initialize ( rsvc ) ; log . trace ( "Default ResourceManager initialization complete." ) ; } private void assembleResourceLoaderInitializers ( ) { Vector resourceLoaderNames = rsvc . getConfiguration ( ) . getVector ( RuntimeConstants . RESOURCE_LOADER ) ; StringUtils . trimStrings ( resourceLoaderNames ) ; for ( Iterator it = resourceLoaderNames . iterator ( ) ; it . hasNext ( ) ; ) { String loaderName = ( String ) it . next ( ) ; StringBuffer loaderID = new StringBuffer ( loaderName ) ; loaderID . append ( "." ) . append ( RuntimeConstants . RESOURCE_LOADER ) ; ExtendedProperties loaderConfiguration = rsvc . getConfiguration ( ) . subset ( loaderID . toString ( ) ) ; if ( loaderConfiguration == null ) { log . debug ( "ResourceManager : No configuration information found " + "for resource loader named '" + loaderName + "' (id is " + loaderID + "). Skipping it..." ) ; continue ; } loaderConfiguration . setProperty ( RESOURCE_LOADER_IDENTIFIER , loaderName ) ; sourceInitializerList . add ( loaderConfiguration ) ; } } public Resource getResource ( final String resourceName , final int resourceType , final String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { String resourceKey = resourceType + resourceName ; Resource resource = globalCache . get ( resourceKey ) ; if ( resource != null ) { try { if ( resource . requiresChecking ( ) ) { resource = refreshResource ( resource , encoding ) ; } } catch ( ResourceNotFoundException rnfe ) { globalCache . remove ( resourceKey ) ; return getResource ( resourceName , resourceType , encoding ) ; } catch ( ParseErrorException pee ) { log . error ( "ResourceManager.getResource() exception" , pee ) ; throw pee ; } catch ( RuntimeException re ) { log . error ( "ResourceManager.getResource() exception" , re ) ; throw re ; } catch ( Exception e ) { log . error ( "ResourceManager.getResource() exception" , e ) ; throw e ; } } else { try { resource = loadResource ( resourceName , resourceType , encoding ) ; if ( resource . getResourceLoader ( ) . isCachingOn ( ) ) { globalCache . put ( resourceKey , resource ) ; } } catch ( ResourceNotFoundException rnfe ) { log . error ( "ResourceManager : unable to find resource '" + resourceName + "' in any resource loader." ) ; throw rnfe ; } catch ( ParseErrorException pee ) { log . error ( "ResourceManager.getResource() parse exception" , pee ) ; throw pee ; } catch ( RuntimeException re ) { log . error ( "ResourceManager.getResource() load exception" , re ) ; throw re ; } catch ( Exception e ) { log . error ( "ResourceManager.getResource() exception new" , e ) ; throw e ; } } return resource ; } protected Resource createResource ( String resourceName , int resourceType ) { return ResourceFactory . getResource ( resourceName , resourceType ) ; } protected Resource loadResource ( String resourceName , int resourceType , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { Resource resource = createResource ( resourceName , resourceType ) ; resource . setRuntimeServices ( rsvc ) ; resource . setName ( resourceName ) ; resource . setEncoding ( encoding ) ; long howOldItWas = 0 ; for ( Iterator it = resourceLoaders . iterator ( ) ; it . hasNext ( ) ; ) { ResourceLoader resourceLoader = ( ResourceLoader ) it . next ( ) ; resource . setResourceLoader ( resourceLoader ) ; try { if ( resource . process ( ) ) { if ( logWhenFound && log . isDebugEnabled ( ) ) { log . debug ( "ResourceManager : found " + resourceName + " with loader " + resourceLoader . getClassName ( ) ) ; } howOldItWas = resourceLoader . getLastModified ( resource ) ; break ; } } catch ( ResourceNotFoundException rnfe ) { } } if ( resource . getData ( ) == null ) { throw new ResourceNotFoundException ( "Unable to find resource '" + resourceName + "'" ) ; } resource . setLastModified ( howOldItWas ) ; resource . setModificationCheckInterval ( resource . getResourceLoader ( ) . getModificationCheckInterval ( ) ) ; resource . touch ( ) ; return resource ; } protected Resource refreshResource ( Resource resource , final String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { resource . touch ( ) ; if ( resource . isSourceModified ( ) ) { if ( ! org . apache . commons . lang . StringUtils . equals ( resource . getEncoding ( ) , encoding ) ) { log . warn ( "Declared encoding for template '" + resource . getName ( ) + "' is different on reload. Old = '" + resource . getEncoding ( ) + "' New = '" + encoding ) ; resource . setEncoding ( encoding ) ; } long howOldItWas = resource . getResourceLoader ( ) . getLastModified ( resource ) ; String resourceKey = resource . getType ( ) + resource . getName ( ) ; Resource newResource = ResourceFactory . getResource ( resource . getName ( ) , resource . getType ( ) ) ; newResource . setRuntimeServices ( rsvc ) ; newResource . setName ( resource . getName ( ) ) ; newResource . setEncoding ( resource . getEncoding ( ) ) ; newResource . setResourceLoader ( resource . getResourceLoader ( ) ) ; newResource . setModificationCheckInterval ( resource . getResourceLoader ( ) . getModificationCheckInterval ( ) ) ; newResource . process ( ) ; newResource . setLastModified ( howOldItWas ) ; resource = newResource ; globalCache . put ( resourceKey , newResource ) ; } return resource ; } public Resource getResource ( String resourceName , int resourceType ) throws ResourceNotFoundException , ParseErrorException , Exception { return getResource ( resourceName , resourceType , RuntimeConstants . ENCODING_DEFAULT ) ; } public String getLoaderNameForResource ( String resourceName ) { for ( Iterator it = resourceLoaders . iterator ( ) ; it . hasNext ( ) ; ) { ResourceLoader resourceLoader = ( ResourceLoader ) it . next ( ) ; if ( resourceLoader . resourceExists ( resourceName ) ) { return resourceLoader . getClass ( ) . toString ( ) ; } } return null ; } } 	1
package org . apache . velocity . util . introspection ; public interface IntrospectorCache { void clear ( ) ; ClassMap get ( Class c ) ; ClassMap put ( Class c ) ; } 	0
package org . apache . velocity . app ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . Properties ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . Template ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . apache . velocity . runtime . log . Log ; public class Velocity implements RuntimeConstants { public static void init ( ) throws Exception { RuntimeSingleton . init ( ) ; } public static void init ( String propsFilename ) throws Exception { RuntimeSingleton . init ( propsFilename ) ; } public static void init ( Properties p ) throws Exception { RuntimeSingleton . init ( p ) ; } public static void setProperty ( String key , Object value ) { RuntimeSingleton . setProperty ( key , value ) ; } public static void addProperty ( String key , Object value ) { RuntimeSingleton . addProperty ( key , value ) ; } public static void clearProperty ( String key ) { RuntimeSingleton . clearProperty ( key ) ; } public static void setExtendedProperties ( ExtendedProperties configuration ) { RuntimeSingleton . setConfiguration ( configuration ) ; } public static Object getProperty ( String key ) { return RuntimeSingleton . getProperty ( key ) ; } public static boolean evaluate ( Context context , Writer out , String logTag , String instring ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { return RuntimeSingleton . getRuntimeServices ( ) . evaluate ( context , out , logTag , instring ) ; } public static boolean evaluate ( Context context , Writer writer , String logTag , InputStream instream ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { BufferedReader br = null ; String encoding = null ; try { encoding = RuntimeSingleton . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) ; br = new BufferedReader ( new InputStreamReader ( instream , encoding ) ) ; } catch ( UnsupportedEncodingException uce ) { String msg = "Unsupported input encoding : " + encoding + " for template " + logTag ; throw new ParseErrorException ( msg ) ; } return evaluate ( context , writer , logTag , br ) ; } public static boolean evaluate ( Context context , Writer writer , String logTag , Reader reader ) throws ParseErrorException , MethodInvocationException , ResourceNotFoundException , IOException { return RuntimeSingleton . getRuntimeServices ( ) . evaluate ( context , writer , logTag , reader ) ; } public static boolean invokeVelocimacro ( String vmName , String logTag , String params [ ] , Context context , Writer writer ) { try { return RuntimeSingleton . getRuntimeServices ( ) . invokeVelocimacro ( vmName , logTag , params , context , writer ) ; } catch ( IOException ioe ) { String msg = "Velocity.invokeVelocimacro(" + vmName + ") failed" ; getLog ( ) . error ( msg , ioe ) ; throw new VelocityException ( msg , ioe ) ; } } public static boolean mergeTemplate ( String templateName , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { return mergeTemplate ( templateName , RuntimeSingleton . getString ( INPUT_ENCODING , ENCODING_DEFAULT ) , context , writer ) ; } public static boolean mergeTemplate ( String templateName , String encoding , Context context , Writer writer ) throws ResourceNotFoundException , ParseErrorException , MethodInvocationException , Exception { Template template = RuntimeSingleton . getTemplate ( templateName , encoding ) ; if ( template == null ) { String msg = "Velocity.mergeTemplate() was unable to load template '" + templateName + "'" ; getLog ( ) . error ( msg ) ; throw new ResourceNotFoundException ( msg ) ; } else { template . merge ( context , writer ) ; return true ; } } public static Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name ) ; } public static Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { return RuntimeSingleton . getTemplate ( name , encoding ) ; } public static boolean resourceExists ( String resourceName ) { return ( RuntimeSingleton . getLoaderNameForResource ( resourceName ) != null ) ; } public static Log getLog ( ) { return RuntimeSingleton . getLog ( ) ; } public static void warn ( Object message ) { getLog ( ) . warn ( message ) ; } public static void info ( Object message ) { getLog ( ) . info ( message ) ; } public static void error ( Object message ) { getLog ( ) . error ( message ) ; } public static void debug ( Object message ) { getLog ( ) . debug ( message ) ; } public static void setApplicationAttribute ( Object key , Object value ) { RuntimeSingleton . getRuntimeInstance ( ) . setApplicationAttribute ( key , value ) ; } public static boolean templateExists ( String resourceName ) { return resourceExists ( resourceName ) ; } } 	1
package org . apache . velocity . exception ; public class ResourceNotFoundException extends VelocityException { private static final long serialVersionUID = - 4287732191458420347L ; public ResourceNotFoundException ( final String exceptionMessage ) { super ( exceptionMessage ) ; } public ResourceNotFoundException ( final String exceptionMessage , final Throwable t ) { super ( exceptionMessage , t ) ; } public ResourceNotFoundException ( final Throwable t ) { super ( t ) ; } } 	0
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . commons . lang . StringUtils ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . context . ProxyVMContext ; import org . apache . velocity . exception . MacroOverflowException ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . ASTDirective ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public class VelocimacroProxy extends Directive { private String macroName ; private String [ ] argArray = null ; private String [ ] literalArgArray = null ; private SimpleNode nodeTree = null ; private int numMacroArgs = 0 ; private boolean preInit = false ; private boolean strictArguments ; private boolean localContextScope = false ; private int maxCallDepth ; public String getName ( ) { return macroName ; } public int getType ( ) { return LINE ; } public void setName ( String name ) { macroName = name ; } public void setArgArray ( String [ ] arr ) { argArray = arr ; literalArgArray = new String [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { literalArgArray [ i ] = ".literal.$" + argArray [ i ] ; } numMacroArgs = argArray . length - 1 ; } public void setNodeTree ( SimpleNode tree ) { nodeTree = tree ; } public int getNumArgs ( ) { return numMacroArgs ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException , MacroOverflowException { final ProxyVMContext vmc = new ProxyVMContext ( context , rsvc , localContextScope ) ; int callArguments = node . jjtGetNumChildren ( ) ; if ( callArguments > 0 ) { for ( int i = 1 ; i < argArray . length && i <= callArguments ; i ++ ) { Node macroCallArgument = node . jjtGetChild ( i - 1 ) ; vmc . addVMProxyArg ( context , argArray [ i ] , literalArgArray [ i ] , macroCallArgument ) ; } } if ( maxCallDepth > 0 && maxCallDepth == vmc . getCurrentMacroCallDepth ( ) ) { String templateName = vmc . getCurrentTemplateName ( ) ; Object [ ] stack = vmc . getMacroNameStack ( ) ; StringBuffer out = new StringBuffer ( 100 ) . append ( "Max calling depth of " ) . append ( maxCallDepth ) . append ( " was exceeded in Template:" ) . append ( templateName ) . append ( " and Macro:" ) . append ( macroName ) . append ( " with Call Stack:" ) ; for ( int i = 0 ; i < stack . length ; i ++ ) { if ( i != 0 ) { out . append ( "->" ) ; } out . append ( stack [ i ] ) ; } rsvc . getLog ( ) . error ( out . toString ( ) ) ; try { throw new MacroOverflowException ( out . toString ( ) ) ; } finally { while ( vmc . getCurrentMacroCallDepth ( ) > 0 ) { vmc . popCurrentMacroName ( ) ; } } } try { vmc . pushCurrentMacroName ( macroName ) ; nodeTree . render ( vmc , writer ) ; vmc . popCurrentMacroName ( ) ; return true ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "VelocimacroProxy.render() : exception VM = #" + macroName + "()" ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { synchronized ( this ) { if ( ! preInit ) { super . init ( rs , context , node ) ; strictArguments = rs . getConfiguration ( ) . getBoolean ( RuntimeConstants . VM_ARGUMENTS_STRICT , false ) ; localContextScope = rsvc . getBoolean ( RuntimeConstants . VM_CONTEXT_LOCALSCOPE , false ) ; maxCallDepth = rsvc . getInt ( RuntimeConstants . VM_MAX_DEPTH ) ; nodeTree . init ( context , rs ) ; preInit = true ; } } int i = node . jjtGetNumChildren ( ) ; if ( getNumArgs ( ) != i ) { for ( Node parent = node . jjtGetParent ( ) ; parent != null ; ) { if ( ( parent instanceof ASTDirective ) && StringUtils . equals ( ( ( ASTDirective ) parent ) . getDirectiveName ( ) , "macro" ) ) { return ; } parent = parent . jjtGetParent ( ) ; } String msg = "VM #" + macroName + ": too " + ( ( getNumArgs ( ) > i ) ? "few" : "many" ) + " arguments to macro. Wanted " + getNumArgs ( ) + " got " + i ; if ( strictArguments ) { throw new TemplateInitException ( msg , context . getCurrentTemplateName ( ) , 0 , 0 ) ; } else { rsvc . getLog ( ) . debug ( msg ) ; return ; } } for ( int n = 0 ; n < i ; n ++ ) { Node child = node . jjtGetChild ( n ) ; if ( child . getType ( ) == ParserTreeConstants . JJTWORD ) { throw new TemplateInitException ( "Invalid arg #" + n + " in VM #" + macroName , context . getCurrentTemplateName ( ) , 0 , 0 ) ; } } } } 	1
package org . apache . velocity . runtime ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . SimplePool ; import org . apache . velocity . runtime . parser . CharStream ; public class ParserPoolImpl implements ParserPool { SimplePool pool = null ; int max = RuntimeConstants . NUMBER_OF_PARSERS ; public void initialize ( RuntimeServices rsvc ) { max = rsvc . getInt ( RuntimeConstants . PARSER_POOL_SIZE , RuntimeConstants . NUMBER_OF_PARSERS ) ; pool = new SimplePool ( max ) ; for ( int i = 0 ; i < max ; i ++ ) { pool . put ( rsvc . createNewParser ( ) ) ; } if ( rsvc . getLog ( ) . isDebugEnabled ( ) ) { rsvc . getLog ( ) . debug ( "Created '" + max + "' parsers." ) ; } } public Parser get ( ) { return ( Parser ) pool . get ( ) ; } public void put ( Parser parser ) { parser . ReInit ( ( CharStream ) null ) ; pool . put ( parser ) ; } } 	0
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . app . event . EventHandlerUtil ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . ParserTreeConstants ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . resource . Resource ; public class Include extends InputBase { private String outputMsgStart = "" ; private String outputMsgEnd = "" ; public String getName ( ) { return "include" ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; outputMsgStart = rsvc . getString ( RuntimeConstants . ERRORMSG_START ) ; outputMsgStart = outputMsgStart + " " ; outputMsgEnd = rsvc . getString ( RuntimeConstants . ERRORMSG_END ) ; outputMsgEnd = " " + outputMsgEnd ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , MethodInvocationException , ResourceNotFoundException { int argCount = node . jjtGetNumChildren ( ) ; for ( int i = 0 ; i < argCount ; i ++ ) { Node n = node . jjtGetChild ( i ) ; if ( n . getType ( ) == ParserTreeConstants . JJTSTRINGLITERAL || n . getType ( ) == ParserTreeConstants . JJTREFERENCE ) { if ( ! renderOutput ( n , context , writer ) ) outputErrorToStream ( writer , "error with arg " + i + " please see log." ) ; } else { String msg = "invalid #include() argument type [line " + getLine ( ) + ", column " + getColumn ( ) + ", template " + context . getCurrentTemplateName ( ) + "]: " + n . toString ( ) ; rsvc . getLog ( ) . error ( msg ) ; outputErrorToStream ( writer , "error with arg " + i + " please see log." ) ; throw new VelocityException ( msg ) ; } } return true ; } private boolean renderOutput ( Node node , InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException { if ( node == null ) { rsvc . getLog ( ) . error ( "#include() null argument" ) ; return false ; } Object value = node . value ( context ) ; if ( value == null ) { rsvc . getLog ( ) . error ( "#include()  null argument" ) ; return false ; } String sourcearg = value . toString ( ) ; String arg = EventHandlerUtil . includeEvent ( rsvc , context , sourcearg , context . getCurrentTemplateName ( ) , getName ( ) ) ; boolean blockinput = false ; if ( arg == null ) blockinput = true ; Resource resource = null ; try { if ( ! blockinput ) resource = rsvc . getContent ( arg , getInputEncoding ( context ) ) ; } catch ( ResourceNotFoundException rnfe ) { rsvc . getLog ( ) . error ( "#include(): cannot find resource '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ")" ) ; throw rnfe ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "#include(): arg = '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ')' ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } if ( blockinput ) return true ; else if ( resource == null ) return false ; writer . write ( ( String ) resource . getData ( ) ) ; return true ; } private void outputErrorToStream ( Writer writer , String msg ) throws IOException { if ( outputMsgStart != null && outputMsgEnd != null ) { writer . write ( outputMsgStart ) ; writer . write ( msg ) ; writer . write ( outputMsgEnd ) ; } } } 	1
package org . apache . velocity . util . introspection ; public class IntrospectionCacheData { public Object thingy ; public Class contextData ; } 	0
package org . apache . velocity . runtime . resource ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . resource . loader . ResourceLoader ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . ParseErrorException ; public abstract class Resource { protected RuntimeServices rsvc = null ; protected ResourceLoader resourceLoader ; protected static final long MILLIS_PER_SECOND = 1000 ; protected long modificationCheckInterval = 0 ; protected long lastModified = 0 ; protected long nextCheck = 0 ; protected String name ; protected String encoding = RuntimeConstants . ENCODING_DEFAULT ; protected Object data = null ; protected int type ; public Resource ( ) { } public void setRuntimeServices ( RuntimeServices rs ) { rsvc = rs ; } public abstract boolean process ( ) throws ResourceNotFoundException , ParseErrorException , Exception ; public boolean isSourceModified ( ) { return resourceLoader . isSourceModified ( this ) ; } public void setModificationCheckInterval ( long modificationCheckInterval ) { this . modificationCheckInterval = modificationCheckInterval ; } public boolean requiresChecking ( ) { if ( modificationCheckInterval <= 0 ) { return false ; } return ( System . currentTimeMillis ( ) >= nextCheck ) ; } public void touch ( ) { nextCheck = System . currentTimeMillis ( ) + ( MILLIS_PER_SECOND * modificationCheckInterval ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public long getLastModified ( ) { return lastModified ; } public void setLastModified ( long lastModified ) { this . lastModified = lastModified ; } public ResourceLoader getResourceLoader ( ) { return resourceLoader ; } public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; } public void setData ( Object data ) { this . data = data ; } public Object getData ( ) { return data ; } public void setType ( int type ) { this . type = type ; } public int getType ( ) { return type ; } } 	1
package org . apache . velocity . runtime . directive ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . resource . Resource ; public abstract class InputBase extends Directive { protected String getInputEncoding ( InternalContextAdapter context ) { Resource current = context . getCurrentResource ( ) ; if ( current != null ) { return current . getEncoding ( ) ; } else { return ( String ) rsvc . getProperty ( RuntimeConstants . INPUT_ENCODING ) ; } } } 	0
package org . apache . velocity . runtime ; public interface RuntimeConstants { String RUNTIME_LOG = "runtime.log" ; String RUNTIME_LOG_LOGSYSTEM = "runtime.log.logsystem" ; String RUNTIME_LOG_LOGSYSTEM_CLASS = "runtime.log.logsystem.class" ; String RUNTIME_REFERENCES_STRICT = "runtime.references.strict" ; String RUNTIME_LOG_ERROR_STACKTRACE = "runtime.log.error.stacktrace" ; String RUNTIME_LOG_WARN_STACKTRACE = "runtime.log.warn.stacktrace" ; String RUNTIME_LOG_INFO_STACKTRACE = "runtime.log.info.stacktrace" ; String RUNTIME_LOG_REFERENCE_LOG_INVALID = "runtime.log.invalid.references" ; String TRACE_PREFIX = " [trace] " ; String DEBUG_PREFIX = " [debug] " ; String INFO_PREFIX = "  [info] " ; String WARN_PREFIX = "  [warn] " ; String ERROR_PREFIX = " [error] " ; String UNKNOWN_PREFIX = " [unknown] " ; String COUNTER_NAME = "directive.foreach.counter.name" ; String HAS_NEXT_NAME = "directive.foreach.iterator.name" ; String COUNTER_INITIAL_VALUE = "directive.foreach.counter.initial.value" ; String MAX_NUMBER_LOOPS = "directive.foreach.maxloops" ; String SKIP_INVALID_ITERATOR = "directive.foreach.skip.invalid" ; String SET_NULL_ALLOWED = "directive.set.null.allowed" ; String ERRORMSG_START = "directive.include.output.errormsg.start" ; String ERRORMSG_END = "directive.include.output.errormsg.end" ; String PARSE_DIRECTIVE_MAXDEPTH = "directive.parse.max.depth" ; String DEFINE_DIRECTIVE_MAXDEPTH = "directive.define.max.depth" ; String EVALUATE_CONTEXT_CLASS = "directive.evaluate.context.class" ; String RESOURCE_MANAGER_CLASS = "resource.manager.class" ; String RESOURCE_MANAGER_CACHE_CLASS = "resource.manager.cache.class" ; String RESOURCE_MANAGER_DEFAULTCACHE_SIZE = "resource.manager.defaultcache.size" ; String RESOURCE_MANAGER_LOGWHENFOUND = "resource.manager.logwhenfound" ; String RESOURCE_LOADER = "resource.loader" ; String FILE_RESOURCE_LOADER_PATH = "file.resource.loader.path" ; String FILE_RESOURCE_LOADER_CACHE = "file.resource.loader.cache" ; String EVENTHANDLER_REFERENCEINSERTION = "eventhandler.referenceinsertion.class" ; String EVENTHANDLER_NULLSET = "eventhandler.nullset.class" ; String EVENTHANDLER_METHODEXCEPTION = "eventhandler.methodexception.class" ; String EVENTHANDLER_INCLUDE = "eventhandler.include.class" ; String EVENTHANDLER_INVALIDREFERENCES = "eventhandler.invalidreferences.class" ; String VM_LIBRARY = "velocimacro.library" ; String VM_LIBRARY_DEFAULT = "VM_global_library.vm" ; String VM_LIBRARY_AUTORELOAD = "velocimacro.library.autoreload" ; String VM_PERM_ALLOW_INLINE = "velocimacro.permissions.allow.inline" ; String VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL = "velocimacro.permissions.allow.inline.to.replace.global" ; String VM_PERM_INLINE_LOCAL = "velocimacro.permissions.allow.inline.local.scope" ; String VM_MESSAGES_ON = "velocimacro.messages.on" ; String VM_CONTEXT_LOCALSCOPE = "velocimacro.context.localscope" ; String VM_ARGUMENTS_STRICT = "velocimacro.arguments.strict" ; String VM_MAX_DEPTH = "velocimacro.max.depth" ; String INTERPOLATE_STRINGLITERALS = "runtime.interpolate.string.literals" ; String INPUT_ENCODING = "input.encoding" ; String OUTPUT_ENCODING = "output.encoding" ; String ENCODING_DEFAULT = "ISO-8859-1" ; String UBERSPECT_CLASSNAME = "runtime.introspector.uberspect" ; String INTROSPECTOR_RESTRICT_PACKAGES = "introspector.restrict.packages" ; String INTROSPECTOR_RESTRICT_CLASSES = "introspector.restrict.classes" ; String STRICT_MATH = "runtime.strict.math" ; String PARSER_POOL_CLASS = "parser.pool.class" ; String PARSER_POOL_SIZE = "parser.pool.size" ; String DEFAULT_RUNTIME_PROPERTIES = "org/apache/velocity/runtime/defaults/velocity.properties" ; String DEFAULT_RUNTIME_DIRECTIVES = "org/apache/velocity/runtime/defaults/directive.properties" ; int NUMBER_OF_PARSERS = 20 ; } 	1
package org . apache . velocity . io ; import java . io . IOException ; import java . io . InputStream ; import java . io . PushbackInputStream ; import org . apache . velocity . util . ExceptionUtils ; public class UnicodeInputStream extends InputStream { public static final UnicodeBOM UTF8_BOM = new UnicodeBOM ( "UTF-8" , new byte [ ] { ( byte ) 0xef , ( byte ) 0xbb , ( byte ) 0xbf } ) ; public static final UnicodeBOM UTF16LE_BOM = new UnicodeBOM ( "UTF-16LE" , new byte [ ] { ( byte ) 0xff , ( byte ) 0xfe } ) ; public static final UnicodeBOM UTF16BE_BOM = new UnicodeBOM ( "UTF-16BE" , new byte [ ] { ( byte ) 0xfe , ( byte ) 0xff } ) ; public static final UnicodeBOM UTF32LE_BOM = new UnicodeBOM ( "UTF-32LE" , new byte [ ] { ( byte ) 0xff , ( byte ) 0xfe , ( byte ) 0x00 , ( byte ) 0x00 } ) ; public static final UnicodeBOM UTF32BE_BOM = new UnicodeBOM ( "UTF-32BE" , new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0xfe , ( byte ) 0xff } ) ; private static final int MAX_BOM_SIZE = 4 ; private byte [ ] buf = new byte [ MAX_BOM_SIZE ] ; private int pos = 0 ; private final String encoding ; private final boolean skipBOM ; private final PushbackInputStream inputStream ; public UnicodeInputStream ( final InputStream inputStream ) throws IllegalStateException , IOException { this ( inputStream , true ) ; } public UnicodeInputStream ( final InputStream inputStream , boolean skipBOM ) throws IllegalStateException , IOException { super ( ) ; this . skipBOM = skipBOM ; this . inputStream = new PushbackInputStream ( inputStream , MAX_BOM_SIZE ) ; try { this . encoding = readEncoding ( ) ; } catch ( IOException ioe ) { IllegalStateException ex = new IllegalStateException ( "Could not read BOM from Stream" ) ; ExceptionUtils . setCause ( ex , ioe ) ; throw ex ; } } public boolean isSkipBOM ( ) { return skipBOM ; } public String getEncodingFromStream ( ) { return encoding ; } protected String readEncoding ( ) throws IOException { pos = 0 ; UnicodeBOM encoding = null ; if ( readByte ( ) ) { switch ( buf [ 0 ] ) { case ( byte ) 0x00 : encoding = match ( UTF32BE_BOM , null ) ; break ; case ( byte ) 0xef : encoding = match ( UTF8_BOM , null ) ; break ; case ( byte ) 0xfe : encoding = match ( UTF16BE_BOM , null ) ; break ; case ( byte ) 0xff : encoding = match ( UTF16LE_BOM , null ) ; if ( encoding != null ) { encoding = match ( UTF32LE_BOM , encoding ) ; } break ; default : encoding = null ; break ; } } pushback ( encoding ) ; return ( encoding != null ) ? encoding . getEncoding ( ) : null ; } private final UnicodeBOM match ( final UnicodeBOM matchEncoding , final UnicodeBOM noMatchEncoding ) throws IOException { byte [ ] bom = matchEncoding . getBytes ( ) ; for ( int i = 0 ; i < bom . length ; i ++ ) { if ( pos <= i ) { if ( ! readByte ( ) ) { return noMatchEncoding ; } } if ( bom [ i ] != buf [ i ] ) { return noMatchEncoding ; } } return matchEncoding ; } private final boolean readByte ( ) throws IOException { int res = inputStream . read ( ) ; if ( res == - 1 ) { return false ; } if ( pos >= buf . length ) { throw new IOException ( "BOM read error" ) ; } buf [ pos ++ ] = ( byte ) res ; return true ; } private final void pushback ( final UnicodeBOM matchBOM ) throws IOException { int count = pos ; int start = 0 ; if ( matchBOM != null && skipBOM ) { start = matchBOM . getBytes ( ) . length ; count = ( pos - start ) ; if ( count < 0 ) { throw new IllegalStateException ( "Match has more bytes than available!" ) ; } } inputStream . unread ( buf , start , count ) ; } public void close ( ) throws IOException { inputStream . close ( ) ; } public int available ( ) throws IOException { return inputStream . available ( ) ; } public void mark ( final int readlimit ) { inputStream . mark ( readlimit ) ; } public boolean markSupported ( ) { return inputStream . markSupported ( ) ; } public int read ( ) throws IOException { return inputStream . read ( ) ; } public int read ( final byte [ ] b ) throws IOException { return inputStream . read ( b ) ; } public int read ( final byte [ ] b , final int off , final int len ) throws IOException { return inputStream . read ( b , off , len ) ; } public void reset ( ) throws IOException { inputStream . reset ( ) ; } public long skip ( final long n ) throws IOException { return inputStream . skip ( n ) ; } static final class UnicodeBOM { private final String encoding ; private final byte [ ] bytes ; private UnicodeBOM ( final String encoding , final byte [ ] bytes ) { this . encoding = encoding ; this . bytes = bytes ; } String getEncoding ( ) { return encoding ; } byte [ ] getBytes ( ) { return bytes ; } } } 	0
package org . apache . velocity . runtime . directive ; import java . io . IOException ; import java . io . Writer ; import java . util . List ; import java . util . ArrayList ; import org . apache . velocity . Template ; import org . apache . velocity . app . event . EventHandlerUtil ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; public class Parse extends InputBase { private int maxDepth ; public String getName ( ) { return "parse" ; } public int getType ( ) { return LINE ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; this . maxDepth = rsvc . getInt ( RuntimeConstants . PARSE_DIRECTIVE_MAXDEPTH , 10 ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) throws IOException , ResourceNotFoundException , ParseErrorException , MethodInvocationException { if ( ! context . getAllowRendering ( ) ) { return true ; } if ( node . jjtGetChild ( 0 ) == null ) { rsvc . getLog ( ) . error ( "#parse() null argument" ) ; return false ; } Object value = node . jjtGetChild ( 0 ) . value ( context ) ; if ( value == null ) { rsvc . getLog ( ) . error ( "#parse() null argument" ) ; return false ; } String sourcearg = value . toString ( ) ; String arg = EventHandlerUtil . includeEvent ( rsvc , context , sourcearg , context . getCurrentTemplateName ( ) , getName ( ) ) ; boolean blockinput = false ; if ( arg == null ) blockinput = true ; if ( maxDepth > 0 ) { Object [ ] templateStack = context . getTemplateNameStack ( ) ; if ( templateStack . length >= maxDepth ) { StringBuffer path = new StringBuffer ( ) ; for ( int i = 0 ; i < templateStack . length ; ++ i ) { path . append ( " > " + templateStack [ i ] ) ; } rsvc . getLog ( ) . error ( "Max recursion depth reached (" + templateStack . length + ')' + " File stack:" + path ) ; return false ; } } Template t = null ; try { if ( ! blockinput ) t = rsvc . getTemplate ( arg , getInputEncoding ( context ) ) ; } catch ( ResourceNotFoundException rnfe ) { rsvc . getLog ( ) . error ( "#parse(): cannot find template '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ")" ) ; throw rnfe ; } catch ( ParseErrorException pee ) { rsvc . getLog ( ) . error ( "#parse(): syntax error in #parse()-ed template '" + arg + "', called from template " + context . getCurrentTemplateName ( ) + " at (" + getLine ( ) + ", " + getColumn ( ) + ")" ) ; throw pee ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "#parse() : arg = " + arg + '.' ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } List macroLibraries = context . getMacroLibraries ( ) ; if ( macroLibraries == null ) { macroLibraries = new ArrayList ( ) ; } context . setMacroLibraries ( macroLibraries ) ; macroLibraries . add ( arg ) ; try { if ( ! blockinput ) { context . pushCurrentTemplateName ( arg ) ; ( ( SimpleNode ) t . getData ( ) ) . render ( context , writer ) ; } } catch ( MethodInvocationException e ) { throw e ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "Exception rendering #parse(" + arg + ')' ; rsvc . getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } finally { if ( ! blockinput ) context . popCurrentTemplateName ( ) ; } return true ; } } 	1
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTElseStatement extends SimpleNode { public ASTElseStatement ( int id ) { super ( id ) ; } public ASTElseStatement ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) { return true ; } } 	0
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; public interface LogChute { String TRACE_PREFIX = " [trace] " ; String DEBUG_PREFIX = " [debug] " ; String INFO_PREFIX = "  [info] " ; String WARN_PREFIX = "  [warn] " ; String ERROR_PREFIX = " [error] " ; int TRACE_ID = - 1 ; int DEBUG_ID = 0 ; int INFO_ID = 1 ; int WARN_ID = 2 ; int ERROR_ID = 3 ; void init ( RuntimeServices rs ) throws Exception ; void log ( int level , String message ) ; void log ( int level , String message , Throwable t ) ; boolean isLevelEnabled ( int level ) ; } 	1
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . runtime . parser . Parser ; public class ASTTrue extends SimpleNode { private static Boolean value = Boolean . TRUE ; public ASTTrue ( int id ) { super ( id ) ; } public ASTTrue ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) { return true ; } public Object value ( InternalContextAdapter context ) { return value ; } } 	0
package org . apache . velocity . runtime . log ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . util . ClassUtils ; public class LogManager { private static LogChute createLogChute ( RuntimeServices rsvc ) throws Exception { Log log = rsvc . getLog ( ) ; Object o = rsvc . getProperty ( RuntimeConstants . RUNTIME_LOG_LOGSYSTEM ) ; if ( o != null ) { if ( o instanceof LogChute ) { try { ( ( LogChute ) o ) . init ( rsvc ) ; return ( LogChute ) o ; } catch ( Exception e ) { String msg = "Could not init runtime.log.logsystem " + o ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } else if ( o instanceof LogSystem ) { log . debug ( "LogSystem has been deprecated. Please use a LogChute implementation." ) ; try { LogChute chute = new LogChuteSystem ( ( LogSystem ) o ) ; chute . init ( rsvc ) ; return chute ; } catch ( Exception e ) { String msg = "Could not init runtime.log.logsystem " + o ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } else { String msg = o . getClass ( ) . getName ( ) + " object set as runtime.log.logsystem is not a valid log implementation." ; log . error ( msg ) ; throw new VelocityException ( msg ) ; } } List classes = new ArrayList ( ) ; Object obj = rsvc . getProperty ( RuntimeConstants . RUNTIME_LOG_LOGSYSTEM_CLASS ) ; if ( obj instanceof List ) { classes = ( List ) obj ; } else if ( obj instanceof String ) { classes . add ( obj ) ; } for ( Iterator ii = classes . iterator ( ) ; ii . hasNext ( ) ; ) { String claz = ( String ) ii . next ( ) ; if ( claz != null && claz . length ( ) > 0 ) { log . debug ( "Trying to use logger class " + claz ) ; try { o = ClassUtils . getNewInstance ( claz ) ; if ( o instanceof LogChute ) { ( ( LogChute ) o ) . init ( rsvc ) ; log . debug ( "Using logger class " + claz ) ; return ( LogChute ) o ; } else if ( o instanceof LogSystem ) { log . debug ( "LogSystem has been deprecated. Please use a LogChute implementation." ) ; LogChute chute = new LogChuteSystem ( ( LogSystem ) o ) ; chute . init ( rsvc ) ; return chute ; } else { String msg = "The specified logger class " + claz + " does not implement the " + LogChute . class . getName ( ) + " interface." ; log . error ( msg ) ; if ( isProbablyProvidedLogChute ( claz ) ) { log . error ( "This appears to be a ClassLoader issue.  Check for multiple Velocity jars in your classpath." ) ; } throw new VelocityException ( msg ) ; } } catch ( NoClassDefFoundError ncdfe ) { if ( isProbablyProvidedLogChute ( claz ) ) { log . debug ( "Target log system for " + claz + " is not available (" + ncdfe . toString ( ) + ").  Falling back to next log system..." ) ; } else { log . debug ( "Couldn't find class " + claz + " or necessary supporting classes in classpath." , ncdfe ) ; } } catch ( Exception e ) { String msg = "Failed to initialize an instance of " + claz + " with the current runtime configuration." ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } } LogChute slc = new SystemLogChute ( ) ; slc . init ( rsvc ) ; log . debug ( "Using SystemLogChute." ) ; return slc ; } private static boolean isProbablyProvidedLogChute ( String claz ) { if ( claz == null ) { return false ; } else { return ( claz . startsWith ( "org.apache.velocity.runtime.log" ) && claz . endsWith ( "LogChute" ) ) ; } } public static void updateLog ( Log log , RuntimeServices rsvc ) throws Exception { LogChute newLogChute = createLogChute ( rsvc ) ; LogChute oldLogChute = log . getLogChute ( ) ; log . setLogChute ( newLogChute ) ; if ( oldLogChute instanceof HoldingLogChute ) { HoldingLogChute hlc = ( HoldingLogChute ) oldLogChute ; hlc . transferTo ( newLogChute ) ; } } } 	1
package org . apache . velocity . anakia ; import java . io . IOException ; import java . io . StringWriter ; import org . jdom . Element ; import org . jdom . output . XMLOutputter ; import org . jdom . output . Format ; public class OutputWrapper extends XMLOutputter { public OutputWrapper ( ) { } public OutputWrapper ( Format f ) { super ( f ) ; } public String outputString ( Element element , boolean strip ) { StringWriter buff = new StringWriter ( ) ; try { outputElementContent ( element , buff ) ; } catch ( IOException e ) { } return buff . toString ( ) ; } } 	0
package org . apache . velocity . runtime . parser ; public interface ParserConstants { int EOF = 0 ; int LBRACKET = 1 ; int RBRACKET = 2 ; int COMMA = 3 ; int DOUBLEDOT = 4 ; int COLON = 5 ; int LEFT_CURLEY = 6 ; int RIGHT_CURLEY = 7 ; int LPAREN = 8 ; int RPAREN = 9 ; int REFMOD2_RPAREN = 10 ; int ESCAPE_DIRECTIVE = 11 ; int SET_DIRECTIVE = 12 ; int DOLLAR = 13 ; int DOLLARBANG = 14 ; int HASH = 17 ; int SINGLE_LINE_COMMENT_START = 18 ; int DOUBLE_ESCAPE = 19 ; int ESCAPE = 20 ; int TEXT = 21 ; int SINGLE_LINE_COMMENT = 22 ; int FORMAL_COMMENT = 23 ; int MULTI_LINE_COMMENT = 24 ; int WHITESPACE = 26 ; int STRING_LITERAL = 27 ; int TRUE = 28 ; int FALSE = 29 ; int NEWLINE = 30 ; int MINUS = 31 ; int PLUS = 32 ; int MULTIPLY = 33 ; int DIVIDE = 34 ; int MODULUS = 35 ; int LOGICAL_AND = 36 ; int LOGICAL_OR = 37 ; int LOGICAL_LT = 38 ; int LOGICAL_LE = 39 ; int LOGICAL_GT = 40 ; int LOGICAL_GE = 41 ; int LOGICAL_EQUALS = 42 ; int LOGICAL_NOT_EQUALS = 43 ; int LOGICAL_NOT = 44 ; int EQUALS = 45 ; int END = 46 ; int IF_DIRECTIVE = 47 ; int ELSEIF_DIRECTIVE = 48 ; int ELSE_DIRECTIVE = 49 ; int STOP_DIRECTIVE = 50 ; int DIGIT = 51 ; int INTEGER_LITERAL = 52 ; int FLOATING_POINT_LITERAL = 53 ; int EXPONENT = 54 ; int LETTER = 55 ; int DIRECTIVE_CHAR = 56 ; int WORD = 57 ; int BRACKETED_WORD = 58 ; int ALPHA_CHAR = 59 ; int ALPHANUM_CHAR = 60 ; int IDENTIFIER_CHAR = 61 ; int IDENTIFIER = 62 ; int DOT = 63 ; int LCURLY = 64 ; int RCURLY = 65 ; int REFERENCE_TERMINATOR = 66 ; int DIRECTIVE_TERMINATOR = 67 ; int DIRECTIVE = 0 ; int REFMOD2 = 1 ; int REFMODIFIER = 2 ; int DEFAULT = 3 ; int REFERENCE = 4 ; int PRE_DIRECTIVE = 5 ; int IN_MULTI_LINE_COMMENT = 6 ; int IN_FORMAL_COMMENT = 7 ; int IN_SINGLE_LINE_COMMENT = 8 ; String [ ] tokenImage = { "<EOF>" , "\"[\"" , "\"]\"" , "\",\"" , "\"..\"" , "\":\"" , "\"{\"" , "\"}\"" , "\"(\"" , "<RPAREN>" , "\")\"" , "<ESCAPE_DIRECTIVE>" , "<SET_DIRECTIVE>" , "<DOLLAR>" , "<DOLLARBANG>" , "<token of kind 15>" , "\"#*\"" , "\"#\"" , "\"##\"" , "\"\\\\\\\\\"" , "\"\\\\\"" , "<TEXT>" , "<SINGLE_LINE_COMMENT>" , "\"*#\"" , "\"*#\"" , "<token of kind 25>" , "<WHITESPACE>" , "<STRING_LITERAL>" , "\"true\"" , "\"false\"" , "<NEWLINE>" , "\"-\"" , "\"+\"" , "\"*\"" , "\"/\"" , "\"%\"" , "<LOGICAL_AND>" , "<LOGICAL_OR>" , "<LOGICAL_LT>" , "<LOGICAL_LE>" , "<LOGICAL_GT>" , "<LOGICAL_GE>" , "<LOGICAL_EQUALS>" , "<LOGICAL_NOT_EQUALS>" , "<LOGICAL_NOT>" , "\"=\"" , "<END>" , "<IF_DIRECTIVE>" , "<ELSEIF_DIRECTIVE>" , "<ELSE_DIRECTIVE>" , "<STOP_DIRECTIVE>" , "<DIGIT>" , "<INTEGER_LITERAL>" , "<FLOATING_POINT_LITERAL>" , "<EXPONENT>" , "<LETTER>" , "<DIRECTIVE_CHAR>" , "<WORD>" , "<BRACKETED_WORD>" , "<ALPHA_CHAR>" , "<ALPHANUM_CHAR>" , "<IDENTIFIER_CHAR>" , "<IDENTIFIER>" , "<DOT>" , "\"{\"" , "\"}\"" , "<REFERENCE_TERMINATOR>" , "<DIRECTIVE_TERMINATOR>" , } ; } 	1
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . app . event . EventHandlerUtil ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . introspection . Info ; public class ASTSetDirective extends SimpleNode { private String leftReference = "" ; private Node right = null ; private ASTReference left = null ; boolean logOnNull = false ; private boolean allowNull = false ; private boolean isInitialized ; protected Info uberInfo ; protected boolean strictRef = false ; public ASTSetDirective ( int id ) { super ( id ) ; } public ASTSetDirective ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public synchronized Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { if ( ! isInitialized ) { super . init ( context , data ) ; uberInfo = new Info ( getTemplateName ( ) , getLine ( ) , getColumn ( ) ) ; right = getRightHandSide ( ) ; left = getLeftHandSide ( ) ; logOnNull = rsvc . getBoolean ( RuntimeConstants . RUNTIME_LOG_REFERENCE_LOG_INVALID , true ) ; allowNull = rsvc . getBoolean ( RuntimeConstants . SET_NULL_ALLOWED , false ) ; strictRef = rsvc . getBoolean ( RuntimeConstants . RUNTIME_REFERENCES_STRICT , false ) ; if ( strictRef ) allowNull = true ; leftReference = left . getFirstToken ( ) . image . substring ( 1 ) ; isInitialized = true ; } return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException { Object value = right . value ( context ) ; if ( ! allowNull ) { if ( value == null ) { if ( logOnNull ) { boolean doit = EventHandlerUtil . shouldLogOnNullSet ( rsvc , context , left . literal ( ) , right . literal ( ) ) ; if ( doit && rsvc . getLog ( ) . isDebugEnabled ( ) ) { rsvc . getLog ( ) . debug ( "RHS of #set statement is null. Context will not be modified. " + Log . formatFileString ( this ) ) ; } } String rightReference = null ; if ( right instanceof ASTExpression ) { rightReference = ( ( ASTExpression ) right ) . getLastToken ( ) . image ; } EventHandlerUtil . invalidSetMethod ( rsvc , context , leftReference , rightReference , uberInfo ) ; return false ; } } if ( value == null && ! strictRef ) { String rightReference = null ; if ( right instanceof ASTExpression ) { rightReference = ( ( ASTExpression ) right ) . getLastToken ( ) . image ; } EventHandlerUtil . invalidSetMethod ( rsvc , context , leftReference , rightReference , uberInfo ) ; if ( left . jjtGetNumChildren ( ) == 0 ) { context . remove ( leftReference ) ; } else { left . setValue ( context , null ) ; } return false ; } else { if ( left . jjtGetNumChildren ( ) == 0 ) { context . put ( leftReference , value ) ; } else { left . setValue ( context , value ) ; } } return true ; } private ASTReference getLeftHandSide ( ) { return ( ASTReference ) jjtGetChild ( 0 ) ; } private Node getRightHandSide ( ) { return jjtGetChild ( 1 ) ; } } 	0
package org . apache . velocity . runtime . log ; import org . apache . velocity . runtime . RuntimeServices ; public interface LogSystem { public final static boolean DEBUG_ON = true ; public final static int DEBUG_ID = 0 ; public final static int INFO_ID = 1 ; public final static int WARN_ID = 2 ; public final static int ERROR_ID = 3 ; public void init ( RuntimeServices rs ) throws Exception ; public void logVelocityMessage ( int level , String message ) ; } 	1
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MathException ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . TemplateNumber ; public abstract class ASTMathNode extends SimpleNode { protected boolean strictMode = false ; public ASTMathNode ( int id ) { super ( id ) ; } public ASTMathNode ( Parser p , int id ) { super ( p , id ) ; } public Object init ( InternalContextAdapter context , Object data ) throws TemplateInitException { super . init ( context , data ) ; strictMode = rsvc . getBoolean ( RuntimeConstants . STRICT_MATH , false ) ; return data ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; Object special = handleSpecial ( left , right , context ) ; if ( special != null ) { return special ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { boolean wrongright = ( left instanceof Number ) ; boolean wrongtype = wrongright ? right != null : left != null ; String msg = ( wrongright ? "Right" : "Left" ) + " side of math operation (" + jjtGetChild ( wrongright ? 1 : 0 ) . literal ( ) + ") " + ( wrongtype ? "is not a Number. " : "has a null value. " ) + getLocation ( context ) ; if ( strictMode ) { log . error ( msg ) ; throw new MathException ( msg ) ; } else { log . debug ( msg ) ; return null ; } } return perform ( ( Number ) left , ( Number ) right , context ) ; } protected Object handleSpecial ( Object left , Object right , InternalContextAdapter context ) { return null ; } public abstract Number perform ( Number left , Number right , InternalContextAdapter context ) ; } 	0
package org . apache . velocity . runtime ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . io . StringReader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Map ; import java . util . Properties ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . Template ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . app . event . EventHandler ; import org . apache . velocity . app . event . IncludeEventHandler ; import org . apache . velocity . app . event . InvalidReferenceEventHandler ; import org . apache . velocity . app . event . MethodExceptionEventHandler ; import org . apache . velocity . app . event . NullSetEventHandler ; import org . apache . velocity . app . event . ReferenceInsertionEventHandler ; import org . apache . velocity . context . Context ; import org . apache . velocity . context . InternalContextAdapterImpl ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . log . LogManager ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . ContentResource ; import org . apache . velocity . runtime . resource . ResourceManager ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . RuntimeServicesAware ; import org . apache . velocity . util . StringUtils ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . util . introspection . Uberspect ; import org . apache . velocity . util . introspection . UberspectLoggable ; import org . apache . velocity . util . introspection . ChainableUberspector ; import org . apache . velocity . util . introspection . LinkingUberspector ; public class RuntimeInstance implements RuntimeConstants , RuntimeServices { private VelocimacroFactory vmFactory = null ; private Log log = new Log ( ) ; private ParserPool parserPool ; private boolean initializing = false ; private boolean initialized = false ; private ExtendedProperties overridingProperties = null ; private Hashtable runtimeDirectives ; private ExtendedProperties configuration = new ExtendedProperties ( ) ; private ResourceManager resourceManager = null ; private EventCartridge eventCartridge = null ; private Introspector introspector = null ; private Map applicationAttributes = null ; private Uberspect uberSpect ; private String encoding ; public RuntimeInstance ( ) { vmFactory = new VelocimacroFactory ( this ) ; introspector = new Introspector ( getLog ( ) ) ; applicationAttributes = new HashMap ( ) ; } public synchronized void init ( ) throws Exception { if ( ! initialized && ! initializing ) { initializing = true ; log . trace ( "*******************************************************************" ) ; log . debug ( "Starting Apache Velocity v@build.version@ (compiled: @build.time@)" ) ; log . trace ( "RuntimeInstance initializing." ) ; initializeProperties ( ) ; initializeLog ( ) ; initializeResourceManager ( ) ; initializeDirectives ( ) ; initializeEventHandlers ( ) ; initializeParserPool ( ) ; initializeIntrospection ( ) ; vmFactory . initVelocimacro ( ) ; log . trace ( "RuntimeInstance successfully initialized." ) ; initialized = true ; initializing = false ; } } public boolean isInitialized ( ) { return initialized ; } private void requireInitialization ( ) { if ( ! initialized && ! initializing ) { log . debug ( "Velocity was not initialized! Calling init()..." ) ; try { init ( ) ; } catch ( Exception e ) { getLog ( ) . error ( "Could not auto-initialize Velocity" , e ) ; throw new RuntimeException ( "Velocity could not be initialized!" , e ) ; } } } private void initializeIntrospection ( ) throws Exception { String [ ] uberspectors = configuration . getStringArray ( RuntimeConstants . UBERSPECT_CLASSNAME ) ; for ( int i = 0 ; i < uberspectors . length ; i ++ ) { String rm = uberspectors [ i ] ; Object o = null ; try { o = ClassUtils . getNewInstance ( rm ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for Uberspect (" + rm + ") does not exist or is not accessible to the current classloader." ; log . error ( err ) ; throw new Exception ( err ) ; } if ( ! ( o instanceof Uberspect ) ) { String err = "The specified class for Uberspect (" + rm + ") does not implement " + Uberspect . class . getName ( ) + "; Velocity is not initialized correctly." ; log . error ( err ) ; throw new Exception ( err ) ; } Uberspect u = ( Uberspect ) o ; if ( u instanceof UberspectLoggable ) { ( ( UberspectLoggable ) u ) . setLog ( getLog ( ) ) ; } if ( u instanceof RuntimeServicesAware ) { ( ( RuntimeServicesAware ) u ) . setRuntimeServices ( this ) ; } if ( uberSpect == null ) { uberSpect = u ; } else { if ( u instanceof ChainableUberspector ) { ( ( ChainableUberspector ) u ) . wrap ( uberSpect ) ; uberSpect = u ; } else { uberSpect = new LinkingUberspector ( uberSpect , u ) ; } } } if ( uberSpect != null ) { uberSpect . init ( ) ; } else { String err = "It appears that no class was specified as the" + " Uberspect.  Please ensure that all configuration" + " information is correct." ; log . error ( err ) ; throw new Exception ( err ) ; } } private void setDefaultProperties ( ) { InputStream inputStream = null ; try { inputStream = getClass ( ) . getResourceAsStream ( '/' + DEFAULT_RUNTIME_PROPERTIES ) ; configuration . load ( inputStream ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Default Properties File: " + new File ( DEFAULT_RUNTIME_PROPERTIES ) . getPath ( ) ) ; } } catch ( IOException ioe ) { String msg = "Cannot get Velocity Runtime default properties!" ; log . error ( msg , ioe ) ; throw new RuntimeException ( msg , ioe ) ; } finally { try { if ( inputStream != null ) { inputStream . close ( ) ; } } catch ( IOException ioe ) { String msg = "Cannot close Velocity Runtime default properties!" ; log . error ( msg , ioe ) ; throw new RuntimeException ( msg , ioe ) ; } } } public void setProperty ( String key , Object value ) { if ( overridingProperties == null ) { overridingProperties = new ExtendedProperties ( ) ; } overridingProperties . setProperty ( key , value ) ; } public void setConfiguration ( ExtendedProperties configuration ) { if ( overridingProperties == null ) { overridingProperties = configuration ; } else { if ( overridingProperties != configuration ) { overridingProperties . combine ( configuration ) ; } } } public void addProperty ( String key , Object value ) { if ( overridingProperties == null ) { overridingProperties = new ExtendedProperties ( ) ; } overridingProperties . addProperty ( key , value ) ; } public void clearProperty ( String key ) { if ( overridingProperties != null ) { overridingProperties . clearProperty ( key ) ; } } public Object getProperty ( String key ) { Object o = null ; if ( ! initialized && ! initializing && overridingProperties != null ) { o = overridingProperties . get ( key ) ; } if ( o == null ) { o = configuration . getProperty ( key ) ; } if ( o instanceof String ) { return StringUtils . nullTrim ( ( String ) o ) ; } else { return o ; } } private void initializeProperties ( ) { if ( configuration . isInitialized ( ) == false ) { setDefaultProperties ( ) ; } if ( overridingProperties != null ) { configuration . combine ( overridingProperties ) ; } } public void init ( Properties p ) throws Exception { setProperties ( ExtendedProperties . convertProperties ( p ) ) ; init ( ) ; } private void setProperties ( ExtendedProperties p ) { if ( overridingProperties == null ) { overridingProperties = p ; } else { overridingProperties . combine ( p ) ; } } public void init ( String configurationFile ) throws Exception { setProperties ( new ExtendedProperties ( configurationFile ) ) ; init ( ) ; } private void initializeResourceManager ( ) throws Exception { String rm = getString ( RuntimeConstants . RESOURCE_MANAGER_CLASS ) ; if ( rm != null && rm . length ( ) > 0 ) { Object o = null ; try { o = ClassUtils . getNewInstance ( rm ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for ResourceManager (" + rm + ") does not exist or is not accessible to the current classloader." ; log . error ( err ) ; throw new Exception ( err ) ; } if ( ! ( o instanceof ResourceManager ) ) { String err = "The specified class for ResourceManager (" + rm + ") does not implement " + ResourceManager . class . getName ( ) + "; Velocity is not initialized correctly." ; log . error ( err ) ; throw new Exception ( err ) ; } resourceManager = ( ResourceManager ) o ; resourceManager . initialize ( this ) ; } else { String err = "It appears that no class was specified as the" + " ResourceManager.  Please ensure that all configuration" + " information is correct." ; log . error ( err ) ; throw new Exception ( err ) ; } } private void initializeEventHandlers ( ) throws Exception { eventCartridge = new EventCartridge ( ) ; String [ ] referenceinsertion = configuration . getStringArray ( RuntimeConstants . EVENTHANDLER_REFERENCEINSERTION ) ; if ( referenceinsertion != null ) { for ( int i = 0 ; i < referenceinsertion . length ; i ++ ) { EventHandler ev = initializeSpecificEventHandler ( referenceinsertion [ i ] , RuntimeConstants . EVENTHANDLER_REFERENCEINSERTION , ReferenceInsertionEventHandler . class ) ; if ( ev != null ) eventCartridge . addReferenceInsertionEventHandler ( ( ReferenceInsertionEventHandler ) ev ) ; } } String [ ] nullset = configuration . getStringArray ( RuntimeConstants . EVENTHANDLER_NULLSET ) ; if ( nullset != null ) { for ( int i = 0 ; i < nullset . length ; i ++ ) { EventHandler ev = initializeSpecificEventHandler ( nullset [ i ] , RuntimeConstants . EVENTHANDLER_NULLSET , NullSetEventHandler . class ) ; if ( ev != null ) eventCartridge . addNullSetEventHandler ( ( NullSetEventHandler ) ev ) ; } } String [ ] methodexception = configuration . getStringArray ( RuntimeConstants . EVENTHANDLER_METHODEXCEPTION ) ; if ( methodexception != null ) { for ( int i = 0 ; i < methodexception . length ; i ++ ) { EventHandler ev = initializeSpecificEventHandler ( methodexception [ i ] , RuntimeConstants . EVENTHANDLER_METHODEXCEPTION , MethodExceptionEventHandler . class ) ; if ( ev != null ) eventCartridge . addMethodExceptionHandler ( ( MethodExceptionEventHandler ) ev ) ; } } String [ ] includeHandler = configuration . getStringArray ( RuntimeConstants . EVENTHANDLER_INCLUDE ) ; if ( includeHandler != null ) { for ( int i = 0 ; i < includeHandler . length ; i ++ ) { EventHandler ev = initializeSpecificEventHandler ( includeHandler [ i ] , RuntimeConstants . EVENTHANDLER_INCLUDE , IncludeEventHandler . class ) ; if ( ev != null ) eventCartridge . addIncludeEventHandler ( ( IncludeEventHandler ) ev ) ; } } String [ ] invalidReferenceSet = configuration . getStringArray ( RuntimeConstants . EVENTHANDLER_INVALIDREFERENCES ) ; if ( invalidReferenceSet != null ) { for ( int i = 0 ; i < invalidReferenceSet . length ; i ++ ) { EventHandler ev = initializeSpecificEventHandler ( invalidReferenceSet [ i ] , RuntimeConstants . EVENTHANDLER_INVALIDREFERENCES , InvalidReferenceEventHandler . class ) ; if ( ev != null ) { eventCartridge . addInvalidReferenceEventHandler ( ( InvalidReferenceEventHandler ) ev ) ; } } } } private EventHandler initializeSpecificEventHandler ( String classname , String paramName , Class EventHandlerInterface ) throws Exception { if ( classname != null && classname . length ( ) > 0 ) { Object o = null ; try { o = ClassUtils . getNewInstance ( classname ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for " + paramName + " (" + classname + ") does not exist or is not accessible to the current classloader." ; log . error ( err ) ; throw new Exception ( err ) ; } if ( ! EventHandlerInterface . isAssignableFrom ( EventHandlerInterface ) ) { String err = "The specified class for " + paramName + " (" + classname + ") does not implement " + EventHandlerInterface . getName ( ) + "; Velocity is not initialized correctly." ; log . error ( err ) ; throw new Exception ( err ) ; } EventHandler ev = ( EventHandler ) o ; if ( ev instanceof RuntimeServicesAware ) ( ( RuntimeServicesAware ) ev ) . setRuntimeServices ( this ) ; return ev ; } else return null ; } private void initializeLog ( ) throws Exception { LogManager . updateLog ( this . log , this ) ; } private void initializeDirectives ( ) throws Exception { runtimeDirectives = new Hashtable ( ) ; Properties directiveProperties = new Properties ( ) ; InputStream inputStream = null ; try { inputStream = getClass ( ) . getResourceAsStream ( '/' + DEFAULT_RUNTIME_DIRECTIVES ) ; if ( inputStream == null ) { throw new Exception ( "Error loading directive.properties! " + "Something is very wrong if these properties " + "aren't being located. Either your Velocity " + "distribution is incomplete or your Velocity " + "jar file is corrupted!" ) ; } directiveProperties . load ( inputStream ) ; } catch ( IOException ioe ) { String msg = "Error while loading directive properties!" ; log . error ( msg , ioe ) ; throw new RuntimeException ( msg , ioe ) ; } finally { try { if ( inputStream != null ) { inputStream . close ( ) ; } } catch ( IOException ioe ) { String msg = "Cannot close directive properties!" ; log . error ( msg , ioe ) ; throw new RuntimeException ( msg , ioe ) ; } } Enumeration directiveClasses = directiveProperties . elements ( ) ; while ( directiveClasses . hasMoreElements ( ) ) { String directiveClass = ( String ) directiveClasses . nextElement ( ) ; loadDirective ( directiveClass ) ; log . debug ( "Loaded System Directive: " + directiveClass ) ; } String [ ] userdirective = configuration . getStringArray ( "userdirective" ) ; for ( int i = 0 ; i < userdirective . length ; i ++ ) { loadDirective ( userdirective [ i ] ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Loaded User Directive: " + userdirective [ i ] ) ; } } } public void addDirective ( Directive directive ) { runtimeDirectives . put ( directive . getName ( ) , directive ) ; } public Directive getDirective ( String name ) { return ( Directive ) runtimeDirectives . get ( name ) ; } public void removeDirective ( String name ) { runtimeDirectives . remove ( name ) ; } private void loadDirective ( String directiveClass ) { try { Object o = ClassUtils . getNewInstance ( directiveClass ) ; if ( o instanceof Directive ) { Directive directive = ( Directive ) o ; addDirective ( directive ) ; } else { String msg = directiveClass + " does not implement " + Directive . class . getName ( ) + "; it cannot be loaded." ; log . error ( msg ) ; throw new VelocityException ( msg ) ; } } catch ( Exception e ) { String msg = "Failed to load Directive: " + directiveClass ; log . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } } private void initializeParserPool ( ) throws Exception { String pp = getString ( RuntimeConstants . PARSER_POOL_CLASS ) ; if ( pp != null && pp . length ( ) > 0 ) { Object o = null ; try { o = ClassUtils . getNewInstance ( pp ) ; } catch ( ClassNotFoundException cnfe ) { String err = "The specified class for ParserPool (" + pp + ") does not exist (or is not accessible to the current classloader." ; log . error ( err ) ; throw new Exception ( err ) ; } if ( ! ( o instanceof ParserPool ) ) { String err = "The specified class for ParserPool (" + pp + ") does not implement " + ParserPool . class + " Velocity not initialized correctly." ; log . error ( err ) ; throw new Exception ( err ) ; } parserPool = ( ParserPool ) o ; parserPool . initialize ( this ) ; } else { String err = "It appears that no class was specified as the" + " ParserPool.  Please ensure that all configuration" + " information is correct." ; log . error ( err ) ; throw new Exception ( err ) ; } } public Parser createNewParser ( ) { requireInitialization ( ) ; Parser parser = new Parser ( this ) ; parser . setDirectives ( runtimeDirectives ) ; return parser ; } public SimpleNode parse ( String string , String templateName ) throws ParseException { return parse ( new StringReader ( string ) , templateName ) ; } public SimpleNode parse ( Reader reader , String templateName ) throws ParseException { return parse ( reader , templateName , true ) ; } public SimpleNode parse ( Reader reader , String templateName , boolean dumpNamespace ) throws ParseException { requireInitialization ( ) ; Parser parser = ( Parser ) parserPool . get ( ) ; boolean keepParser = true ; if ( parser == null ) { if ( log . isInfoEnabled ( ) ) { log . info ( "Runtime : ran out of parsers. Creating a new one. " + " Please increment the parser.pool.size property." + " The current value is too small." ) ; } parser = createNewParser ( ) ; keepParser = false ; } try { if ( dumpNamespace ) { dumpVMNamespace ( templateName ) ; } return parser . parse ( reader , templateName ) ; } finally { if ( keepParser ) { parserPool . put ( parser ) ; } } } public boolean evaluate ( Context context , Writer out , String logTag , String instring ) throws IOException { return evaluate ( context , out , logTag , new StringReader ( instring ) ) ; } public boolean evaluate ( Context context , Writer writer , String logTag , Reader reader ) throws IOException { if ( logTag == null ) { throw new NullPointerException ( "logTag (i.e. template name) cannot be null, you must provide an identifier for the content being evaluated" ) ; } SimpleNode nodeTree = null ; try { nodeTree = parse ( reader , logTag ) ; } catch ( ParseException pex ) { throw new ParseErrorException ( pex ) ; } catch ( TemplateInitException pex ) { throw new ParseErrorException ( pex ) ; } if ( nodeTree == null ) { return false ; } else { return render ( context , writer , logTag , nodeTree ) ; } } public boolean render ( Context context , Writer writer , String logTag , SimpleNode nodeTree ) throws IOException { InternalContextAdapterImpl ica = new InternalContextAdapterImpl ( context ) ; ica . pushCurrentTemplateName ( logTag ) ; try { try { nodeTree . init ( ica , this ) ; } catch ( TemplateInitException pex ) { throw new ParseErrorException ( pex ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { String msg = "RuntimeInstance.render(): init exception for tag = " + logTag ; getLog ( ) . error ( msg , e ) ; throw new VelocityException ( msg , e ) ; } nodeTree . render ( ica , writer ) ; } finally { ica . popCurrentTemplateName ( ) ; } return true ; } public boolean invokeVelocimacro ( final String vmName , String logTag , String [ ] params , final Context context , final Writer writer ) throws IOException { if ( vmName == null || context == null || writer == null ) { String msg = "RuntimeInstance.invokeVelocimacro() : invalid call : vmName, context, and writer must not be null" ; getLog ( ) . error ( msg ) ; throw new NullPointerException ( msg ) ; } if ( logTag == null ) { logTag = vmName ; } if ( params == null ) { params = new String [ 0 ] ; } if ( ! isVelocimacro ( vmName , logTag ) ) { String msg = "RuntimeInstance.invokeVelocimacro() : VM '" + vmName + "' is not registered." ; getLog ( ) . error ( msg ) ; throw new VelocityException ( msg ) ; } StrBuilder template = new StrBuilder ( "#" ) ; template . append ( vmName ) ; template . append ( "(" ) ; for ( int i = 0 ; i < params . length ; i ++ ) { template . append ( " $" ) ; template . append ( params [ i ] ) ; } template . append ( " )" ) ; return evaluate ( context , writer , logTag , template . toString ( ) ) ; } private String getDefaultEncoding ( ) { if ( encoding == null ) { encoding = getString ( INPUT_ENCODING , ENCODING_DEFAULT ) ; } return encoding ; } public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return getTemplate ( name , getDefaultEncoding ( ) ) ; } public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { requireInitialization ( ) ; return ( Template ) resourceManager . getResource ( name , ResourceManager . RESOURCE_TEMPLATE , encoding ) ; } public ContentResource getContent ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception { return getContent ( name , getDefaultEncoding ( ) ) ; } public ContentResource getContent ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception { requireInitialization ( ) ; return ( ContentResource ) resourceManager . getResource ( name , ResourceManager . RESOURCE_CONTENT , encoding ) ; } public String getLoaderNameForResource ( String resourceName ) { requireInitialization ( ) ; return resourceManager . getLoaderNameForResource ( resourceName ) ; } public Log getLog ( ) { return log ; } public void warn ( Object message ) { getLog ( ) . warn ( message ) ; } public void info ( Object message ) { getLog ( ) . info ( message ) ; } public void error ( Object message ) { getLog ( ) . error ( message ) ; } public void debug ( Object message ) { getLog ( ) . debug ( message ) ; } public String getString ( String key , String defaultValue ) { return configuration . getString ( key , defaultValue ) ; } public Directive getVelocimacro ( String vmName , String templateName ) { return vmFactory . getVelocimacro ( vmName , templateName ) ; } public Directive getVelocimacro ( String vmName , String templateName , String renderingTemplate ) { return vmFactory . getVelocimacro ( vmName , templateName , renderingTemplate ) ; } public boolean addVelocimacro ( String name , String macro , String argArray [ ] , String sourceTemplate ) { return vmFactory . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public boolean addVelocimacro ( String name , Node macro , String argArray [ ] , String sourceTemplate ) { return vmFactory . addVelocimacro ( name , macro , argArray , sourceTemplate ) ; } public boolean isVelocimacro ( String vmName , String templateName ) { return vmFactory . isVelocimacro ( vmName , templateName ) ; } public boolean dumpVMNamespace ( String namespace ) { return vmFactory . dumpVMNamespace ( namespace ) ; } public String getString ( String key ) { return StringUtils . nullTrim ( configuration . getString ( key ) ) ; } public int getInt ( String key ) { return configuration . getInt ( key ) ; } public int getInt ( String key , int defaultValue ) { return configuration . getInt ( key , defaultValue ) ; } public boolean getBoolean ( String key , boolean def ) { return configuration . getBoolean ( key , def ) ; } public ExtendedProperties getConfiguration ( ) { return configuration ; } public Introspector getIntrospector ( ) { return introspector ; } public EventCartridge getApplicationEventCartridge ( ) { return eventCartridge ; } public Object getApplicationAttribute ( Object key ) { return applicationAttributes . get ( key ) ; } public Object setApplicationAttribute ( Object key , Object o ) { return applicationAttributes . put ( key , o ) ; } public Uberspect getUberspect ( ) { return uberSpect ; } } 	1
package org . apache . velocity . app . event ; public interface EventHandler { } 	0
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . util . TemplateNumber ; public class ASTLTNode extends SimpleNode { public ASTLTNode ( int id ) { super ( id ) ; } public ASTLTNode ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public boolean evaluate ( InternalContextAdapter context ) throws MethodInvocationException { Object left = jjtGetChild ( 0 ) . value ( context ) ; Object right = jjtGetChild ( 1 ) . value ( context ) ; if ( left == null || right == null ) { log . error ( ( left == null ? "Left" : "Right" ) + " side (" + jjtGetChild ( ( left == null ? 0 : 1 ) ) . literal ( ) + ") of '<' operation has null value." + " Operation not possible. " + Log . formatFileString ( this ) ) ; return false ; } if ( left instanceof TemplateNumber ) { left = ( ( TemplateNumber ) left ) . getAsNumber ( ) ; } if ( right instanceof TemplateNumber ) { right = ( ( TemplateNumber ) right ) . getAsNumber ( ) ; } if ( ! ( left instanceof Number ) || ! ( right instanceof Number ) ) { log . error ( ( ! ( left instanceof Number ) ? "Left" : "Right" ) + " side of '>=' operation is not a valid Number. " + Log . formatFileString ( this ) ) ; return false ; } return MathUtils . compare ( ( Number ) left , ( Number ) right ) == - 1 ; } public Object value ( InternalContextAdapter context ) throws MethodInvocationException { boolean val = evaluate ( context ) ; return val ? Boolean . TRUE : Boolean . FALSE ; } } 	1
package org . apache . velocity . runtime ; import org . apache . velocity . runtime . parser . Parser ; public interface ParserPool { void initialize ( RuntimeServices svc ) ; Parser get ( ) ; void put ( Parser parser ) ; } 	0
package org . apache . velocity . runtime . parser ; public interface ParserTreeConstants { public int JJTPROCESS = 0 ; public int JJTVOID = 1 ; public int JJTESCAPEDDIRECTIVE = 2 ; public int JJTESCAPE = 3 ; public int JJTCOMMENT = 4 ; public int JJTFLOATINGPOINTLITERAL = 5 ; public int JJTINTEGERLITERAL = 6 ; public int JJTSTRINGLITERAL = 7 ; public int JJTIDENTIFIER = 8 ; public int JJTWORD = 9 ; public int JJTDIRECTIVE = 10 ; public int JJTBLOCK = 11 ; public int JJTMAP = 12 ; public int JJTOBJECTARRAY = 13 ; public int JJTINTEGERRANGE = 14 ; public int JJTMETHOD = 15 ; public int JJTREFERENCE = 16 ; public int JJTTRUE = 17 ; public int JJTFALSE = 18 ; public int JJTTEXT = 19 ; public int JJTIFSTATEMENT = 20 ; public int JJTELSESTATEMENT = 21 ; public int JJTELSEIFSTATEMENT = 22 ; public int JJTSETDIRECTIVE = 23 ; public int JJTSTOP = 24 ; public int JJTEXPRESSION = 25 ; public int JJTASSIGNMENT = 26 ; public int JJTORNODE = 27 ; public int JJTANDNODE = 28 ; public int JJTEQNODE = 29 ; public int JJTNENODE = 30 ; public int JJTLTNODE = 31 ; public int JJTGTNODE = 32 ; public int JJTLENODE = 33 ; public int JJTGENODE = 34 ; public int JJTADDNODE = 35 ; public int JJTSUBTRACTNODE = 36 ; public int JJTMULNODE = 37 ; public int JJTDIVNODE = 38 ; public int JJTMODNODE = 39 ; public int JJTNOTNODE = 40 ; public String [ ] jjtNodeName = { "process" , "void" , "EscapedDirective" , "Escape" , "Comment" , "FloatingPointLiteral" , "IntegerLiteral" , "StringLiteral" , "Identifier" , "Word" , "Directive" , "Block" , "Map" , "ObjectArray" , "IntegerRange" , "Method" , "Reference" , "True" , "False" , "Text" , "IfStatement" , "ElseStatement" , "ElseIfStatement" , "SetDirective" , "Stop" , "Expression" , "Assignment" , "OrNode" , "AndNode" , "EQNode" , "NENode" , "LTNode" , "GTNode" , "LENode" , "GENode" , "AddNode" , "SubtractNode" , "MulNode" , "DivNode" , "ModNode" , "NotNode" , } ; } 	1
package org . apache . velocity . runtime . parser ; public final class VelocityCharStream implements CharStream { public static final boolean staticFlag = false ; int bufsize ; private int nextBufExpand ; int available ; int tokenBegin ; public int bufpos = - 1 ; private int bufline [ ] ; private int bufcolumn [ ] ; private int column = 0 ; private int line = 1 ; private boolean prevCharIsCR = false ; private boolean prevCharIsLF = false ; private java . io . Reader inputStream ; private char [ ] buffer ; private int maxNextCharInd = 0 ; private int inBuf = 0 ; private final void ExpandBuff ( boolean wrapAround ) { char [ ] newbuffer = new char [ bufsize + nextBufExpand ] ; int newbufline [ ] = new int [ bufsize + nextBufExpand ] ; int newbufcolumn [ ] = new int [ bufsize + nextBufExpand ] ; try { if ( wrapAround ) { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; System . arraycopy ( buffer , 0 , newbuffer , bufsize - tokenBegin , bufpos ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufline , 0 , newbufline , bufsize - tokenBegin , bufpos ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; System . arraycopy ( bufcolumn , 0 , newbufcolumn , bufsize - tokenBegin , bufpos ) ; bufcolumn = newbufcolumn ; maxNextCharInd = ( bufpos += ( bufsize - tokenBegin ) ) ; } else { System . arraycopy ( buffer , tokenBegin , newbuffer , 0 , bufsize - tokenBegin ) ; buffer = newbuffer ; System . arraycopy ( bufline , tokenBegin , newbufline , 0 , bufsize - tokenBegin ) ; bufline = newbufline ; System . arraycopy ( bufcolumn , tokenBegin , newbufcolumn , 0 , bufsize - tokenBegin ) ; bufcolumn = newbufcolumn ; maxNextCharInd = ( bufpos -= tokenBegin ) ; } } catch ( Throwable t ) { throw new Error ( t . getMessage ( ) ) ; } bufsize += nextBufExpand ; nextBufExpand = bufsize ; available = bufsize ; tokenBegin = 0 ; } private final void FillBuff ( ) throws java . io . IOException { if ( maxNextCharInd == available ) { if ( available == bufsize ) { if ( tokenBegin > nextBufExpand ) { bufpos = maxNextCharInd = 0 ; available = tokenBegin ; } else if ( tokenBegin < 0 ) { bufpos = maxNextCharInd = 0 ; } else { ExpandBuff ( false ) ; } } else if ( available > tokenBegin ) { available = bufsize ; } else if ( ( tokenBegin - available ) < nextBufExpand ) { ExpandBuff ( true ) ; } else { available = tokenBegin ; } } int i ; try { if ( ( i = inputStream . read ( buffer , maxNextCharInd , available - maxNextCharInd ) ) == - 1 ) { inputStream . close ( ) ; throw new java . io . IOException ( ) ; } else { maxNextCharInd += i ; } return ; } catch ( java . io . IOException e ) { -- bufpos ; backup ( 0 ) ; if ( tokenBegin == - 1 ) { tokenBegin = bufpos ; } throw e ; } } public final char BeginToken ( ) throws java . io . IOException { tokenBegin = - 1 ; char c = readChar ( ) ; tokenBegin = bufpos ; return c ; } private final void UpdateLineColumn ( char c ) { column ++ ; if ( prevCharIsLF ) { prevCharIsLF = false ; line += ( column = 1 ) ; } else if ( prevCharIsCR ) { prevCharIsCR = false ; if ( c == '\n' ) { prevCharIsLF = true ; } else { line += ( column = 1 ) ; } } switch ( c ) { case '\r' : prevCharIsCR = true ; break ; case '\n' : prevCharIsLF = true ; break ; case '\t' : column -- ; column += ( 8 - ( column & 07 ) ) ; break ; default : break ; } bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; } public final char readChar ( ) throws java . io . IOException { if ( inBuf > 0 ) { -- inBuf ; return buffer [ ( bufpos == bufsize - 1 ) ? ( bufpos = 0 ) : ++ bufpos ] ; } if ( ++ bufpos >= maxNextCharInd ) { FillBuff ( ) ; } char c = buffer [ bufpos ] ; UpdateLineColumn ( c ) ; return ( c ) ; } public final int getColumn ( ) { return bufcolumn [ bufpos ] ; } public final int getLine ( ) { return bufline [ bufpos ] ; } public final int getEndColumn ( ) { return bufcolumn [ bufpos ] ; } public final int getEndLine ( ) { return bufline [ bufpos ] ; } public final int getBeginColumn ( ) { return bufcolumn [ tokenBegin ] ; } public final int getBeginLine ( ) { return bufline [ tokenBegin ] ; } public final void backup ( int amount ) { inBuf += amount ; if ( ( bufpos -= amount ) < 0 ) bufpos += bufsize ; } public VelocityCharStream ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; available = bufsize = nextBufExpand = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; } public VelocityCharStream ( java . io . Reader dstream , int startline , int startcolumn ) { this ( dstream , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . Reader dstream , int startline , int startcolumn , int buffersize ) { inputStream = dstream ; line = startline ; column = startcolumn - 1 ; if ( buffer == null || buffersize != buffer . length ) { available = bufsize = nextBufExpand = buffersize ; buffer = new char [ buffersize ] ; bufline = new int [ buffersize ] ; bufcolumn = new int [ buffersize ] ; } prevCharIsLF = prevCharIsCR = false ; tokenBegin = inBuf = maxNextCharInd = 0 ; bufpos = - 1 ; } public void ReInit ( java . io . Reader dstream , int startline , int startcolumn ) { ReInit ( dstream , startline , startcolumn , 4096 ) ; } public VelocityCharStream ( java . io . InputStream dstream , int startline , int startcolumn , int buffersize ) { this ( new java . io . InputStreamReader ( dstream ) , startline , startcolumn , buffersize ) ; } public VelocityCharStream ( java . io . InputStream dstream , int startline , int startcolumn ) { this ( dstream , startline , startcolumn , 4096 ) ; } public void ReInit ( java . io . InputStream dstream , int startline , int startcolumn , int buffersize ) { ReInit ( new java . io . InputStreamReader ( dstream ) , startline , startcolumn , buffersize ) ; } public void ReInit ( java . io . InputStream dstream , int startline , int startcolumn ) { ReInit ( dstream , startline , startcolumn , 4096 ) ; } public final String GetImage ( ) { if ( bufpos >= tokenBegin ) { return new String ( buffer , tokenBegin , bufpos - tokenBegin + 1 ) ; } else { return new String ( buffer , tokenBegin , bufsize - tokenBegin ) + new String ( buffer , 0 , bufpos + 1 ) ; } } public final char [ ] GetSuffix ( int len ) { char [ ] ret = new char [ len ] ; if ( ( bufpos + 1 ) >= len ) { System . arraycopy ( buffer , bufpos - len + 1 , ret , 0 , len ) ; } else { System . arraycopy ( buffer , bufsize - ( len - bufpos - 1 ) , ret , 0 , len - bufpos - 1 ) ; System . arraycopy ( buffer , 0 , ret , len - bufpos - 1 , bufpos + 1 ) ; } return ret ; } public void Done ( ) { buffer = null ; bufline = null ; bufcolumn = null ; } public void adjustBeginLineColumn ( int newLine , int newCol ) { int start = tokenBegin ; int len ; if ( bufpos >= tokenBegin ) { len = bufpos - tokenBegin + inBuf + 1 ; } else { len = bufsize - tokenBegin + bufpos + 1 + inBuf ; } int i = 0 , j = 0 , k = 0 ; int nextColDiff = 0 , columnDiff = 0 ; while ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { bufline [ j ] = newLine ; nextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; bufcolumn [ j ] = newCol + columnDiff ; columnDiff = nextColDiff ; i ++ ; } if ( i < len ) { bufline [ j ] = newLine ++ ; bufcolumn [ j ] = newCol + columnDiff ; while ( i ++ < len ) { if ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; else bufline [ j ] = newLine ; } } line = bufline [ j ] ; column = bufcolumn [ j ] ; } } 	0
package org . apache . velocity . app . event ; import org . apache . velocity . context . Context ; import org . apache . velocity . util . introspection . Info ; public interface InvalidReferenceEventHandler extends EventHandler { public Object invalidGetMethod ( Context context , String reference , Object object , String property , Info info ) ; public boolean invalidSetMethod ( Context context , String leftreference , String rightreference , Info info ) ; public Object invalidMethod ( Context context , String reference , Object object , String method , Info info ) ; static class InvalidGetMethodExecutor implements EventHandlerMethodExecutor { private Context context ; private String reference ; private Object object ; private String property ; private Info info ; private Object result ; InvalidGetMethodExecutor ( Context context , String reference , Object object , String property , Info info ) { this . context = context ; this . reference = reference ; this . object = object ; this . property = property ; this . info = info ; } public void execute ( EventHandler handler ) { result = ( ( InvalidReferenceEventHandler ) handler ) . invalidGetMethod ( context , reference , object , property , info ) ; } public Object getReturnValue ( ) { return result ; } public boolean isDone ( ) { return ( result != null ) ; } } static class InvalidSetMethodExecutor implements EventHandlerMethodExecutor { private Context context ; private String leftreference ; private String rightreference ; private Info info ; private boolean result ; InvalidSetMethodExecutor ( Context context , String leftreference , String rightreference , Info info ) { this . context = context ; this . leftreference = leftreference ; this . rightreference = rightreference ; this . info = info ; } public void execute ( EventHandler handler ) { result = ( ( InvalidReferenceEventHandler ) handler ) . invalidSetMethod ( context , leftreference , rightreference , info ) ; } public Object getReturnValue ( ) { return null ; } public boolean isDone ( ) { return result ; } } static class InvalidMethodExecutor implements EventHandlerMethodExecutor { private Context context ; private String reference ; private Object object ; private String method ; private Info info ; private Object result ; private boolean executed = false ; InvalidMethodExecutor ( Context context , String reference , Object object , String method , Info info ) { this . context = context ; this . reference = reference ; this . object = object ; this . method = method ; this . info = info ; } public void execute ( EventHandler handler ) { executed = true ; result = ( ( InvalidReferenceEventHandler ) handler ) . invalidMethod ( context , reference , object , method , info ) ; } public Object getReturnValue ( ) { return result ; } public boolean isDone ( ) { return executed && ( result != null ) ; } } } 	1
package org . apache . velocity . runtime . parser . node ; import org . apache . velocity . runtime . parser . Parser ; public class ASTVariable extends SimpleNode { public ASTVariable ( int id ) { super ( id ) ; } public ASTVariable ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } } 	0
package org . apache . velocity . util ; import java . lang . reflect . Constructor ; import java . util . Collections ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Map ; public class MapFactory { private static Constructor concurrentHashMapConstructor ; static { try { concurrentHashMapConstructor = Class . forName ( "java.util.concurrent.ConcurrentHashMap" ) . getConstructor ( new Class [ ] { int . class , float . class , int . class } ) ; } catch ( Exception ex ) { } } public static Map create ( int size , float loadFactor , int concurrencyLevel , boolean allowNullKeys ) { Map map = null ; if ( concurrencyLevel <= 1 ) { map = new HashMap ( size , loadFactor ) ; } else { if ( concurrentHashMapConstructor != null ) { try { map = ( Map ) concurrentHashMapConstructor . newInstance ( new Object [ ] { new Integer ( size ) , new Float ( loadFactor ) , new Integer ( concurrencyLevel ) } ) ; } catch ( Exception ex ) { throw new RuntimeException ( "this should not happen" , ex ) ; } } else { if ( allowNullKeys ) { map = Collections . synchronizedMap ( new HashMap ( size , loadFactor ) ) ; } else { map = new Hashtable ( size , loadFactor ) ; } } } return map ; } } 	1
package org . apache . velocity . runtime . resource ; import java . util . Collections ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Map ; import java . util . Iterator ; import org . apache . commons . collections . map . LRUMap ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . MapFactory ; public class ResourceCacheImpl implements ResourceCache { protected Map cache = MapFactory . create ( 512 , 0.5f , 30 , false ) ; protected RuntimeServices rsvc = null ; public void initialize ( RuntimeServices rs ) { rsvc = rs ; int maxSize = rsvc . getInt ( RuntimeConstants . RESOURCE_MANAGER_DEFAULTCACHE_SIZE , 89 ) ; if ( maxSize > 0 ) { Map lruCache = Collections . synchronizedMap ( new LRUMap ( maxSize ) ) ; lruCache . putAll ( cache ) ; cache = lruCache ; } rsvc . getLog ( ) . debug ( "ResourceCache: initialized (" + this . getClass ( ) + ") with " + cache . getClass ( ) + " cache map." ) ; } public Resource get ( Object key ) { return ( Resource ) cache . get ( key ) ; } public Resource put ( Object key , Resource value ) { return ( Resource ) cache . put ( key , value ) ; } public Resource remove ( Object key ) { return ( Resource ) cache . remove ( key ) ; } public Iterator enumerateKeys ( ) { return cache . keySet ( ) . iterator ( ) ; } } 	0
package org . apache . velocity . context ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; import java . util . List ; public final class InternalContextAdapterImpl implements InternalContextAdapter { Context context = null ; InternalHousekeepingContext icb = null ; InternalEventContext iec = null ; public InternalContextAdapterImpl ( Context c ) { context = c ; if ( ! ( c instanceof InternalHousekeepingContext ) ) { icb = new InternalContextBase ( ) ; } else { icb = ( InternalHousekeepingContext ) context ; } if ( c instanceof InternalEventContext ) { iec = ( InternalEventContext ) context ; } } public void pushCurrentTemplateName ( String s ) { icb . pushCurrentTemplateName ( s ) ; } public void popCurrentTemplateName ( ) { icb . popCurrentTemplateName ( ) ; } public String getCurrentTemplateName ( ) { return icb . getCurrentTemplateName ( ) ; } public Object [ ] getTemplateNameStack ( ) { return icb . getTemplateNameStack ( ) ; } public void pushCurrentMacroName ( String s ) { icb . pushCurrentMacroName ( s ) ; } public void popCurrentMacroName ( ) { icb . popCurrentMacroName ( ) ; } public String getCurrentMacroName ( ) { return icb . getCurrentMacroName ( ) ; } public int getCurrentMacroCallDepth ( ) { return icb . getCurrentMacroCallDepth ( ) ; } public Object [ ] getMacroNameStack ( ) { return icb . getMacroNameStack ( ) ; } public IntrospectionCacheData icacheGet ( Object key ) { return icb . icacheGet ( key ) ; } public void icachePut ( Object key , IntrospectionCacheData o ) { icb . icachePut ( key , o ) ; } public void setCurrentResource ( Resource r ) { icb . setCurrentResource ( r ) ; } public Resource getCurrentResource ( ) { return icb . getCurrentResource ( ) ; } public boolean getAllowRendering ( ) { return icb . getAllowRendering ( ) ; } public void setAllowRendering ( boolean v ) { icb . setAllowRendering ( v ) ; } public void setMacroLibraries ( List macroLibraries ) { icb . setMacroLibraries ( macroLibraries ) ; } public List getMacroLibraries ( ) { return icb . getMacroLibraries ( ) ; } public Object put ( String key , Object value ) { return context . put ( key , value ) ; } public Object localPut ( final String key , final Object value ) { return put ( key , value ) ; } public Object get ( String key ) { return context . get ( key ) ; } public boolean containsKey ( Object key ) { return context . containsKey ( key ) ; } public Object [ ] getKeys ( ) { return context . getKeys ( ) ; } public Object remove ( Object key ) { return context . remove ( key ) ; } public Context getInternalUserContext ( ) { return context ; } public InternalContextAdapter getBaseContext ( ) { return this ; } public EventCartridge attachEventCartridge ( EventCartridge ec ) { if ( iec != null ) { return iec . attachEventCartridge ( ec ) ; } return null ; } public EventCartridge getEventCartridge ( ) { if ( iec != null ) { return iec . getEventCartridge ( ) ; } return null ; } } 	1
package org . apache . velocity . util ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . lang . reflect . Array ; public class ArrayIterator implements Iterator { private Object array ; private int pos ; private int size ; public ArrayIterator ( Object array ) { if ( ! array . getClass ( ) . isArray ( ) ) { throw new IllegalArgumentException ( "Programmer error : internal ArrayIterator invoked w/o array" ) ; } this . array = array ; pos = 0 ; size = Array . getLength ( this . array ) ; } public Object next ( ) { if ( pos < size ) return Array . get ( array , pos ++ ) ; throw new NoSuchElementException ( "No more elements: " + pos + " / " + size ) ; } public boolean hasNext ( ) { return ( pos < size ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } 	0
package org . apache . velocity . app . event . implement ; import org . apache . velocity . app . event . IncludeEventHandler ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . util . RuntimeServicesAware ; import org . apache . velocity . util . StringUtils ; public class IncludeNotFound implements IncludeEventHandler , RuntimeServicesAware { private static final String DEFAULT_NOT_FOUND = "notfound.vm" ; private static final String PROPERTY_NOT_FOUND = "eventhandler.include.notfound" ; private RuntimeServices rs = null ; String notfound ; public String includeEvent ( String includeResourcePath , String currentResourcePath , String directiveName ) { boolean exists = ( rs . getLoaderNameForResource ( includeResourcePath ) != null ) ; if ( ! exists ) { if ( rs . getLoaderNameForResource ( notfound ) != null ) { return notfound ; } else { rs . getLog ( ) . error ( "Can't find include not found page: " + notfound ) ; return null ; } } else return includeResourcePath ; } public void setRuntimeServices ( RuntimeServices rs ) { this . rs = rs ; notfound = StringUtils . nullTrim ( rs . getString ( PROPERTY_NOT_FOUND , DEFAULT_NOT_FOUND ) ) ; } } 	1
package org . apache . velocity . anakia ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . StringTokenizer ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . velocity . Template ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . util . StringUtils ; import org . jdom . Document ; import org . jdom . JDOMException ; import org . jdom . input . SAXBuilder ; import org . jdom . output . Format ; import org . xml . sax . SAXParseException ; public class AnakiaTask extends MatchingTask { SAXBuilder builder ; private File destDir = null ; File baseDir = null ; private String style = null ; private long styleSheetLastModified = 0 ; private String projectAttribute = null ; private File projectFile = null ; private long projectFileLastModified = 0 ; private boolean lastModifiedCheck = true ; private String extension = ".html" ; private String templatePath = null ; private File velocityPropertiesFile = null ; private VelocityEngine ve = new VelocityEngine ( ) ; private List contexts = new LinkedList ( ) ; public AnakiaTask ( ) { builder = new SAXBuilder ( ) ; builder . setFactory ( new AnakiaJDOMFactory ( ) ) ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String extension ) { this . extension = extension ; } public void setStyle ( String style ) { this . style = style ; } public void setProjectFile ( String projectAttribute ) { this . projectAttribute = projectAttribute ; } public void setTemplatePath ( File templatePath ) { try { this . templatePath = templatePath . getCanonicalPath ( ) ; } catch ( java . io . IOException ioe ) { throw new BuildException ( ioe ) ; } } public void setVelocityPropertiesFile ( File velocityPropertiesFile ) { this . velocityPropertiesFile = velocityPropertiesFile ; } public void setLastModifiedCheck ( String lastmod ) { if ( lastmod . equalsIgnoreCase ( "false" ) || lastmod . equalsIgnoreCase ( "no" ) || lastmod . equalsIgnoreCase ( "off" ) ) { this . lastModifiedCheck = false ; } } public void execute ( ) throws BuildException { DirectoryScanner scanner ; String [ ] list ; if ( baseDir == null ) { baseDir = project . resolveFile ( "." ) ; } if ( destDir == null ) { String msg = "destdir attribute must be set!" ; throw new BuildException ( msg ) ; } if ( style == null ) { throw new BuildException ( "style attribute must be set!" ) ; } if ( velocityPropertiesFile == null ) { velocityPropertiesFile = new File ( "velocity.properties" ) ; } if ( ! velocityPropertiesFile . exists ( ) && templatePath == null ) { throw new BuildException ( "No template path and could not " + "locate velocity.properties file: " + velocityPropertiesFile . getAbsolutePath ( ) ) ; } log ( "Transforming into: " + destDir . getAbsolutePath ( ) , Project . MSG_INFO ) ; if ( projectAttribute != null && projectAttribute . length ( ) > 0 ) { projectFile = new File ( baseDir , projectAttribute ) ; if ( projectFile . exists ( ) ) { projectFileLastModified = projectFile . lastModified ( ) ; } else { log ( "Project file is defined, but could not be located: " + projectFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; projectFile = null ; } } Document projectDocument = null ; try { if ( velocityPropertiesFile . exists ( ) ) { String file = velocityPropertiesFile . getAbsolutePath ( ) ; ExtendedProperties config = new ExtendedProperties ( file ) ; ve . setExtendedProperties ( config ) ; } if ( templatePath != null && templatePath . length ( ) > 0 ) { ve . setProperty ( RuntimeConstants . FILE_RESOURCE_LOADER_PATH , templatePath ) ; } ve . init ( ) ; styleSheetLastModified = ve . getTemplate ( style ) . getLastModified ( ) ; if ( projectFile != null ) { projectDocument = builder . build ( projectFile ) ; } } catch ( Exception e ) { log ( "Error: " + e . toString ( ) , Project . MSG_INFO ) ; throw new BuildException ( e ) ; } scanner = getDirectoryScanner ( baseDir ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( list [ i ] , projectDocument ) ; } } private void process ( String xmlFile , Document projectDocument ) throws BuildException { File outFile = null ; File inFile = null ; Writer writer = null ; try { inFile = new File ( baseDir , xmlFile ) ; outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + extension ) ; if ( lastModifiedCheck == false || ( inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) || projectFileLastModified > outFile . lastModified ( ) || userContextsModifed ( outFile . lastModified ( ) ) ) ) { ensureDirectoryFor ( outFile ) ; log ( "Input:  " + xmlFile , Project . MSG_INFO ) ; Document root = builder . build ( inFile ) ; VelocityContext context = new VelocityContext ( ) ; String encoding = ( String ) ve . getProperty ( RuntimeConstants . OUTPUT_ENCODING ) ; if ( encoding == null || encoding . length ( ) == 0 || encoding . equals ( "8859-1" ) || encoding . equals ( "8859_1" ) ) { encoding = "ISO-8859-1" ; } Format f = Format . getRawFormat ( ) ; f . setEncoding ( encoding ) ; OutputWrapper ow = new OutputWrapper ( f ) ; context . put ( "root" , root . getRootElement ( ) ) ; context . put ( "xmlout" , ow ) ; context . put ( "relativePath" , getRelativePath ( xmlFile ) ) ; context . put ( "treeWalk" , new TreeWalker ( ) ) ; context . put ( "xpath" , new XPathTool ( ) ) ; context . put ( "escape" , new Escape ( ) ) ; context . put ( "date" , new java . util . Date ( ) ) ; if ( projectDocument != null ) { context . put ( "project" , projectDocument . getRootElement ( ) ) ; } for ( Iterator iter = contexts . iterator ( ) ; iter . hasNext ( ) ; ) { Context subContext = ( Context ) iter . next ( ) ; if ( subContext == null ) { throw new BuildException ( "Found an undefined SubContext!" ) ; } if ( subContext . getContextDocument ( ) == null ) { throw new BuildException ( "Could not build a subContext for " + subContext . getName ( ) ) ; } context . put ( subContext . getName ( ) , subContext . getContextDocument ( ) . getRootElement ( ) ) ; } writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( outFile ) , encoding ) ) ; Template template = ve . getTemplate ( style ) ; template . merge ( context , writer ) ; log ( "Output: " + outFile , Project . MSG_INFO ) ; } } catch ( JDOMException e ) { outFile . delete ( ) ; if ( e . getCause ( ) != null ) { Throwable rootCause = e . getCause ( ) ; if ( rootCause instanceof SAXParseException ) { System . out . println ( "" ) ; System . out . println ( "Error: " + rootCause . getMessage ( ) ) ; System . out . println ( "       Line: " + ( ( SAXParseException ) rootCause ) . getLineNumber ( ) + " Column: " + ( ( SAXParseException ) rootCause ) . getColumnNumber ( ) ) ; System . out . println ( "" ) ; } else { rootCause . printStackTrace ( ) ; } } else { e . printStackTrace ( ) ; } } catch ( Throwable e ) { if ( outFile != null ) { outFile . delete ( ) ; } e . printStackTrace ( ) ; } finally { if ( writer != null ) { try { writer . flush ( ) ; } catch ( IOException e ) { } try { writer . close ( ) ; } catch ( IOException e ) { } } } } private String getRelativePath ( String file ) { if ( file == null || file . length ( ) == 0 ) return "" ; StringTokenizer st = new StringTokenizer ( file , "/\\" ) ; int slashCount = st . countTokens ( ) - 1 ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < slashCount ; i ++ ) { sb . append ( "../" ) ; } if ( sb . toString ( ) . length ( ) > 0 ) { return StringUtils . chop ( sb . toString ( ) , 1 ) ; } return "." ; } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = new File ( targetFile . getParent ( ) ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } private boolean userContextsModifed ( long lastModified ) { for ( Iterator iter = contexts . iterator ( ) ; iter . hasNext ( ) ; ) { AnakiaTask . Context ctx = ( AnakiaTask . Context ) iter . next ( ) ; if ( ctx . getLastModified ( ) > lastModified ) { return true ; } } return false ; } public Context createContext ( ) { Context context = new Context ( ) ; contexts . add ( context ) ; return context ; } public class Context { private String name ; private Document contextDoc = null ; private String file ; public Context ( ) { } public String getName ( ) { return name ; } public void setName ( String name ) { if ( name . equals ( "relativePath" ) || name . equals ( "treeWalk" ) || name . equals ( "xpath" ) || name . equals ( "escape" ) || name . equals ( "date" ) || name . equals ( "project" ) ) { throw new IllegalArgumentException ( "Context name '" + name + "' is reserved by Anakia" ) ; } this . name = name ; } public void setFile ( String file ) { this . file = file ; } public long getLastModified ( ) { return new File ( baseDir , file ) . lastModified ( ) ; } public Document getContextDocument ( ) { if ( contextDoc == null ) { File contextFile = new File ( baseDir , file ) ; try { contextDoc = builder . build ( contextFile ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } return contextDoc ; } } } 	0
package org . apache . velocity . context ; import java . util . HashSet ; import java . util . Set ; import java . util . List ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . util . ClassUtils ; import org . apache . velocity . util . introspection . IntrospectionCacheData ; public abstract class ChainedInternalContextAdapter implements InternalContextAdapter { protected InternalContextAdapter innerContext = null ; public ChainedInternalContextAdapter ( InternalContextAdapter inner ) { innerContext = inner ; } public Context getInternalUserContext ( ) { return innerContext . getInternalUserContext ( ) ; } public InternalContextAdapter getBaseContext ( ) { return innerContext . getBaseContext ( ) ; } public Object get ( String key ) { return innerContext . get ( key ) ; } public Object put ( String key , Object value ) { return innerContext . put ( key , value ) ; } public boolean containsKey ( Object key ) { return innerContext . containsKey ( key ) ; } public Object [ ] getKeys ( ) { return innerContext . getKeys ( ) ; } public Object remove ( Object key ) { return innerContext . remove ( key ) ; } public void pushCurrentTemplateName ( String s ) { innerContext . pushCurrentTemplateName ( s ) ; } public void popCurrentTemplateName ( ) { innerContext . popCurrentTemplateName ( ) ; } public String getCurrentTemplateName ( ) { return innerContext . getCurrentTemplateName ( ) ; } public Object [ ] getTemplateNameStack ( ) { return innerContext . getTemplateNameStack ( ) ; } public void pushCurrentMacroName ( String s ) { innerContext . pushCurrentMacroName ( s ) ; } public void popCurrentMacroName ( ) { innerContext . popCurrentMacroName ( ) ; } public String getCurrentMacroName ( ) { return innerContext . getCurrentMacroName ( ) ; } public int getCurrentMacroCallDepth ( ) { return innerContext . getCurrentMacroCallDepth ( ) ; } public Object [ ] getMacroNameStack ( ) { return innerContext . getMacroNameStack ( ) ; } public IntrospectionCacheData icacheGet ( Object key ) { return innerContext . icacheGet ( key ) ; } public Object localPut ( final String key , final Object value ) { return innerContext . put ( key , value ) ; } public void icachePut ( Object key , IntrospectionCacheData o ) { innerContext . icachePut ( key , o ) ; } public boolean getAllowRendering ( ) { return innerContext . getAllowRendering ( ) ; } public void setAllowRendering ( boolean v ) { innerContext . setAllowRendering ( v ) ; } public void setMacroLibraries ( List macroLibraries ) { innerContext . setMacroLibraries ( macroLibraries ) ; } public List getMacroLibraries ( ) { return innerContext . getMacroLibraries ( ) ; } public EventCartridge attachEventCartridge ( EventCartridge ec ) { return innerContext . attachEventCartridge ( ec ) ; } public EventCartridge getEventCartridge ( ) { return innerContext . getEventCartridge ( ) ; } public void setCurrentResource ( Resource r ) { innerContext . setCurrentResource ( r ) ; } public Resource getCurrentResource ( ) { return innerContext . getCurrentResource ( ) ; } } 	1
package org . apache . velocity . context ; public interface InternalContextAdapter extends InternalHousekeepingContext , Context , InternalWrapperContext , InternalEventContext { } 	0
package org . apache . velocity . runtime . parser . node ; import java . io . IOException ; import java . io . Writer ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . Token ; public class ASTComment extends SimpleNode { private static final char [ ] ZILCH = "" . toCharArray ( ) ; private char [ ] carr ; public ASTComment ( int id ) { super ( id ) ; } public ASTComment ( Parser p , int id ) { super ( p , id ) ; } public Object jjtAccept ( ParserVisitor visitor , Object data ) { return visitor . visit ( this , data ) ; } public Object init ( InternalContextAdapter context , Object data ) { Token t = getFirstToken ( ) ; int loc1 = t . image . indexOf ( "##" ) ; int loc2 = t . image . indexOf ( "#*" ) ; if ( loc1 == - 1 && loc2 == - 1 ) { carr = ZILCH ; } else { carr = t . image . substring ( 0 , ( loc1 == - 1 ) ? loc2 : loc1 ) . toCharArray ( ) ; } return data ; } public boolean render ( InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ParseErrorException , ResourceNotFoundException { if ( context . getAllowRendering ( ) ) { writer . write ( carr ) ; } return true ; } } 	1
package org . apache . velocity . anakia ; import java . util . List ; import org . jdom . Document ; import org . jdom . Element ; public class XPathTool { public XPathTool ( ) { } public NodeList applyTo ( String xpathSpec , Document doc ) { return new NodeList ( XPathCache . getXPath ( xpathSpec ) . applyTo ( doc ) , false ) ; } public NodeList applyTo ( String xpathSpec , Element elem ) { return new NodeList ( XPathCache . getXPath ( xpathSpec ) . applyTo ( elem ) , false ) ; } public NodeList applyTo ( String xpathSpec , List nodeSet ) { return new NodeList ( XPathCache . getXPath ( xpathSpec ) . applyTo ( nodeSet ) , false ) ; } } 	0
package org . apache . velocity . runtime . directive ; import java . io . Writer ; import java . io . IOException ; import java . io . StringWriter ; import org . apache . commons . lang . text . StrBuilder ; import org . apache . velocity . context . InternalContextAdapter ; import org . apache . velocity . exception . TemplateInitException ; import org . apache . velocity . exception . VelocityException ; import org . apache . velocity . runtime . Renderable ; import org . apache . velocity . runtime . RuntimeConstants ; import org . apache . velocity . runtime . RuntimeServices ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . node . Node ; public class Define extends Directive { private String key ; private Node block ; private Log log ; private int maxDepth ; private String definingTemplate ; public String getName ( ) { return "define" ; } public int getType ( ) { return BLOCK ; } public void init ( RuntimeServices rs , InternalContextAdapter context , Node node ) throws TemplateInitException { super . init ( rs , context , node ) ; log = rs . getLog ( ) ; maxDepth = rs . getInt ( RuntimeConstants . DEFINE_DIRECTIVE_MAXDEPTH , 2 ) ; key = node . jjtGetChild ( 0 ) . getFirstToken ( ) . image . substring ( 1 ) ; block = node . jjtGetChild ( 1 ) ; definingTemplate = context . getCurrentTemplateName ( ) ; } public boolean render ( InternalContextAdapter context , Writer writer , Node node ) { context . put ( key , new Block ( context , this ) ) ; return true ; } protected String id ( InternalContextAdapter context ) { StrBuilder str = new StrBuilder ( 100 ) . append ( "block $" ) . append ( key ) . append ( " (defined in " ) . append ( definingTemplate ) . append ( " [line " ) . append ( getLine ( ) ) . append ( ", column " ) . append ( getColumn ( ) ) . append ( "])" ) ; if ( ! context . getCurrentTemplateName ( ) . equals ( definingTemplate ) ) { str . append ( " used in " ) . append ( context . getCurrentTemplateName ( ) ) ; } return str . toString ( ) ; } public static class Block implements Renderable { private InternalContextAdapter context ; private Define parent ; private int depth ; public Block ( InternalContextAdapter context , Define parent ) { this . context = context ; this . parent = parent ; } public boolean render ( InternalContextAdapter context , Writer writer ) { try { depth ++ ; if ( depth > parent . maxDepth ) { parent . log . debug ( "Max recursion depth reached for " + parent . id ( context ) ) ; depth -- ; return false ; } else { parent . block . render ( context , writer ) ; depth -- ; return true ; } } catch ( IOException e ) { String msg = "Failed to render " + parent . id ( context ) + " to writer" ; parent . log . error ( msg , e ) ; throw new RuntimeException ( msg , e ) ; } catch ( VelocityException ve ) { String msg = "Failed to render " + parent . id ( context ) + " due to " + ve ; parent . log . error ( msg , ve ) ; throw ve ; } } public String toString ( ) { Writer stringwriter = new StringWriter ( ) ; if ( render ( context , stringwriter ) ) { return stringwriter . toString ( ) ; } else { return null ; } } } } 	1
package org . apache . velocity . runtime . resource . util ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . apache . velocity . runtime . resource . loader . StringResourceLoader ; public class StringResourceRepositoryImpl implements StringResourceRepository { protected Map resources = Collections . synchronizedMap ( new HashMap ( ) ) ; private String encoding = StringResourceLoader . REPOSITORY_ENCODING_DEFAULT ; public StringResource getStringResource ( final String name ) { return ( StringResource ) resources . get ( name ) ; } public void putStringResource ( final String name , final String body ) { resources . put ( name , new StringResource ( body , getEncoding ( ) ) ) ; } public void putStringResource ( final String name , final String body , final String encoding ) { resources . put ( name , new StringResource ( body , encoding ) ) ; } public void removeStringResource ( final String name ) { resources . remove ( name ) ; } public String getEncoding ( ) { return encoding ; } public void setEncoding ( final String encoding ) { this . encoding = encoding ; } } 	0
package org . apache . velocity . runtime ; import java . io . IOException ; import java . io . Reader ; import java . io . Writer ; import java . util . Properties ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . Template ; import org . apache . velocity . app . event . EventCartridge ; import org . apache . velocity . context . Context ; import org . apache . velocity . exception . MethodInvocationException ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . directive . Directive ; import org . apache . velocity . runtime . log . Log ; import org . apache . velocity . runtime . parser . ParseException ; import org . apache . velocity . runtime . parser . Parser ; import org . apache . velocity . runtime . parser . node . Node ; import org . apache . velocity . runtime . parser . node . SimpleNode ; import org . apache . velocity . runtime . resource . ContentResource ; import org . apache . velocity . util . introspection . Introspector ; import org . apache . velocity . util . introspection . Uberspect ; public interface RuntimeServices extends RuntimeLogger { public void init ( ) throws Exception ; public void setProperty ( String key , Object value ) ; public void setConfiguration ( ExtendedProperties configuration ) ; public void addProperty ( String key , Object value ) ; public void clearProperty ( String key ) ; public Object getProperty ( String key ) ; public void init ( Properties p ) throws Exception ; public void init ( String configurationFile ) throws Exception ; public SimpleNode parse ( String string , String templateName ) throws ParseException ; public SimpleNode parse ( Reader reader , String templateName ) throws ParseException ; public SimpleNode parse ( Reader reader , String templateName , boolean dumpNamespace ) throws ParseException ; public boolean evaluate ( Context context , Writer out , String logTag , String instring ) throws IOException ; public boolean evaluate ( Context context , Writer writer , String logTag , Reader reader ) throws IOException ; public boolean invokeVelocimacro ( final String vmName , String logTag , String [ ] params , final Context context , final Writer writer ) throws IOException ; public Template getTemplate ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception ; public Template getTemplate ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception ; public ContentResource getContent ( String name ) throws ResourceNotFoundException , ParseErrorException , Exception ; public ContentResource getContent ( String name , String encoding ) throws ResourceNotFoundException , ParseErrorException , Exception ; public String getLoaderNameForResource ( String resourceName ) ; public String getString ( String key , String defaultValue ) ; public Directive getVelocimacro ( String vmName , String templateName ) ; public Directive getVelocimacro ( String vmName , String templateName , String renderingTemplate ) ; public boolean addVelocimacro ( String name , String macro , String argArray [ ] , String sourceTemplate ) ; public boolean addVelocimacro ( String name , Node macro , String argArray [ ] , String sourceTemplate ) ; public boolean isVelocimacro ( String vmName , String templateName ) ; public boolean dumpVMNamespace ( String namespace ) ; public String getString ( String key ) ; public int getInt ( String key ) ; public int getInt ( String key , int defaultValue ) ; public boolean getBoolean ( String key , boolean def ) ; public ExtendedProperties getConfiguration ( ) ; public Object getApplicationAttribute ( Object key ) ; public Object setApplicationAttribute ( Object key , Object value ) ; public Uberspect getUberspect ( ) ; public Log getLog ( ) ; public EventCartridge getApplicationEventCartridge ( ) ; public Introspector getIntrospector ( ) ; public boolean isInitialized ( ) ; public Parser createNewParser ( ) ; public Directive getDirective ( String name ) ; } 	1
