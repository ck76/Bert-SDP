package org . apache . camel . component . quartz ; import org . apache . camel . CamelContext ; import org . apache . camel . impl . DefaultExchange ; import org . quartz . JobExecutionContext ; public class QuartzExchange extends DefaultExchange { public QuartzExchange ( CamelContext context , JobExecutionContext jobExecutionContext ) { super ( context ) ; setIn ( new QuartzMessage ( this , jobExecutionContext ) ) ; } @ Override public QuartzMessage getIn ( ) { return ( QuartzMessage ) super . getIn ( ) ; } public JobExecutionContext getJobExecutionContext ( ) { return getIn ( ) . getJobExecutionContext ( ) ; } } 	0
package org . apache . camel ; import java . util . Map ; public interface Message { String getMessageId ( ) ; void setMessageId ( String messageId ) ; Exchange getExchange ( ) ; Object getHeader ( String name ) ; < T > T getHeader ( String name , Class < T > type ) ; void setHeader ( String name , Object value ) ; Map < String , Object > getHeaders ( ) ; void setHeaders ( Map < String , Object > headers ) ; public Object getBody ( ) ; public < T > T getBody ( Class < T > type ) ; public void setBody ( Object body ) ; public < T > void setBody ( Object body , Class < T > type ) ; Message copy ( ) ; } 	1
package org . apache . camel . component . mina ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . mina . common . IoAcceptor ; import org . apache . mina . common . IoConnector ; import org . apache . mina . filter . codec . ProtocolCodecFilter ; import org . apache . mina . filter . codec . serialization . ObjectSerializationCodecFactory ; import org . apache . mina . transport . socket . nio . DatagramAcceptor ; import org . apache . mina . transport . socket . nio . DatagramConnector ; import org . apache . mina . transport . socket . nio . DatagramConnectorConfig ; import org . apache . mina . transport . socket . nio . SocketAcceptor ; import org . apache . mina . transport . socket . nio . SocketConnector ; import org . apache . mina . transport . socket . nio . SocketConnectorConfig ; import org . apache . mina . transport . vmpipe . VmPipeAcceptor ; import org . apache . mina . transport . vmpipe . VmPipeAddress ; import org . apache . mina . transport . vmpipe . VmPipeConnector ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Map ; public class MinaComponent extends DefaultComponent < MinaExchange > { public MinaComponent ( ) { } public MinaComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < MinaExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { URI u = new URI ( remaining ) ; String protocol = u . getScheme ( ) ; if ( protocol . equals ( "tcp" ) ) { return createSocketEndpoint ( uri , u ) ; } else if ( protocol . equals ( "udp" ) || protocol . equals ( "mcast" ) || protocol . equals ( "multicast" ) ) { return createDatagramEndpoint ( uri , u ) ; } else if ( protocol . equals ( "vm" ) ) { return createVmEndpoint ( uri , u ) ; } else { throw new IOException ( "Unrecognised MINA protocol: " + protocol + " for uri: " + uri ) ; } } protected MinaEndpoint createVmEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new VmPipeAcceptor ( ) ; SocketAddress address = new VmPipeAddress ( connectUri . getPort ( ) ) ; IoConnector connector = new VmPipeConnector ( ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , null ) ; } protected MinaEndpoint createSocketEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new SocketAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new SocketConnector ( ) ; SocketConnectorConfig config = new SocketConnectorConfig ( ) ; config . getFilterChain ( ) . addLast ( "codec" , new ProtocolCodecFilter ( new ObjectSerializationCodecFactory ( ) ) ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , config ) ; } protected MinaEndpoint createDatagramEndpoint ( String uri , URI connectUri ) { IoAcceptor acceptor = new DatagramAcceptor ( ) ; SocketAddress address = new InetSocketAddress ( connectUri . getHost ( ) , connectUri . getPort ( ) ) ; IoConnector connector = new DatagramConnector ( ) ; DatagramConnectorConfig config = new DatagramConnectorConfig ( ) ; config . getFilterChain ( ) . addLast ( "codec" , new ProtocolCodecFilter ( new ObjectSerializationCodecFactory ( ) ) ) ; return new MinaEndpoint ( uri , this , address , acceptor , connector , config ) ; } } 	0
package org . apache . camel . component . file ; import org . apache . camel . Exchange ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; public class FileProducer extends DefaultProducer { private static final transient Log log = LogFactory . getLog ( FileProducer . class ) ; private final FileEndpoint endpoint ; public FileProducer ( FileEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) { process ( endpoint . toExchangeType ( exchange ) ) ; } public void process ( FileExchange exchange ) { String fileName = exchange . getIn ( ) . getMessageId ( ) ; ByteBuffer payload = exchange . getIn ( ) . getBody ( ByteBuffer . class ) ; payload . flip ( ) ; File file = null ; if ( endpoint . getFile ( ) != null && endpoint . getFile ( ) . isDirectory ( ) ) { file = new File ( endpoint . getFile ( ) , fileName ) ; } else { file = new File ( fileName ) ; } buildDirectory ( file ) ; try { FileChannel fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . position ( fc . size ( ) ) ; fc . write ( payload ) ; fc . close ( ) ; } catch ( Throwable e ) { log . error ( "Failed to write to File: " + file , e ) ; } } private void buildDirectory ( File file ) { String dirName = file . getAbsolutePath ( ) ; int index = dirName . lastIndexOf ( File . separatorChar ) ; if ( index > 0 ) { dirName = dirName . substring ( 0 , index ) ; File dir = new File ( dirName ) ; dir . mkdirs ( ) ; } } } 	1
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import java . util . List ; public class RandomLoadBalancer extends QueueLoadBalancer { protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { int size = processors . size ( ) ; while ( true ) { int index = ( int ) Math . round ( Math . random ( ) * size ) ; if ( index < size ) { return processors . get ( index ) ; } } } } 	0
package org . apache . camel ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . Callable ; public interface CamelContext extends Service { void addComponent ( String componentName , Component component ) ; Component getComponent ( String componentName ) ; < T extends Component > T getComponent ( String name , Class < T > componentType ) ; Component removeComponent ( String componentName ) ; Component getOrCreateComponent ( String componentName , Callable < Component > factory ) ; Endpoint getEndpoint ( String uri ) ; < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) ; Collection < Endpoint > getSingletonEndpoints ( ) ; Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception ; Endpoint removeSingletonEndpoint ( String uri ) throws Exception ; List < Route > getRoutes ( ) ; void setRoutes ( List < Route > routes ) ; void addRoutes ( Collection < Route > routes ) throws Exception ; void addRoutes ( RouteBuilder builder ) throws Exception ; ExchangeConverter getExchangeConverter ( ) ; TypeConverter getTypeConverter ( ) ; Injector getInjector ( ) ; } 	1
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; public class ValueBuilder < E extends Exchange > implements Expression < E > { private Expression < E > expression ; public ValueBuilder ( Expression < E > expression ) { this . expression = expression ; } public Object evaluate ( E exchange ) { return expression . evaluate ( exchange ) ; } public Expression < E > getExpression ( ) { return expression ; } @ Override public String toString ( ) { return expression . toString ( ) ; } @ Fluent public Predicate < E > isNotEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isNotEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isLessThan ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThan ( expression , right ) ) ; } @ Fluent public Predicate < E > isLessThanOrEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isLessThanOrEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isGreaterThan ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThan ( expression , right ) ) ; } @ Fluent public Predicate < E > isGreaterThanOrEqualTo ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . isGreaterThanOrEqualTo ( expression , right ) ) ; } @ Fluent public Predicate < E > isInstanceOf ( @ FluentArg ( "class" ) Class type ) { return onNewPredicate ( PredicateBuilder . isInstanceOf ( expression , type ) ) ; } @ Fluent public Predicate < E > matchesRegex ( @ FluentArg ( "regex" ) String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } @ Fluent public Predicate < E > isNull ( ) { return onNewPredicate ( PredicateBuilder . isNull ( expression ) ) ; } @ Fluent public Predicate < E > isNotNull ( ) { return onNewPredicate ( PredicateBuilder . isNotNull ( expression ) ) ; } @ Fluent public Predicate < E > contains ( @ FluentArg ( "value" ) Object value ) { Expression < E > right = asExpression ( value ) ; return onNewPredicate ( PredicateBuilder . contains ( expression , right ) ) ; } @ Fluent public Predicate < E > regex ( String regex ) { return onNewPredicate ( PredicateBuilder . regex ( expression , regex ) ) ; } @ Fluent public ValueBuilder < E > tokenize ( ) { return tokenize ( "\n" ) ; } @ Fluent public ValueBuilder < E > tokenize ( @ FluentArg ( "token" ) String token ) { Expression < E > newExp = ExpressionBuilder . tokenizeExpression ( expression , token ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > regexTokenize ( @ FluentArg ( "regex" ) String regex ) { Expression < E > newExp = ExpressionBuilder . regexTokenize ( expression , regex ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > regexReplaceAll ( @ FluentArg ( "regex" ) String regex , @ FluentArg ( "replacement" ) String replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > regexReplaceAll ( @ FluentArg ( "regex" ) String regex , @ FluentArg ( "replacement" ) Expression < E > replacement ) { Expression < E > newExp = ExpressionBuilder . regexReplaceAll ( expression , regex , replacement ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > convertTo ( @ FluentArg ( "type" ) Class type ) { Expression < E > newExp = ExpressionBuilder . convertTo ( expression , type ) ; return new ValueBuilder < E > ( newExp ) ; } @ Fluent public ValueBuilder < E > convertToString ( ) { return convertTo ( String . class ) ; } @ Fluent public ValueBuilder < E > append ( @ FluentArg ( "value" ) Object value ) { return new ValueBuilder < E > ( ExpressionBuilder . append ( expression , asExpression ( value ) ) ) ; } protected Predicate < E > onNewPredicate ( Predicate < E > predicate ) { return predicate ; } protected Expression < E > asExpression ( Object value ) { if ( value instanceof Expression ) { return ( Expression < E > ) value ; } else { return ExpressionBuilder . constantExpression ( value ) ; } } } 	0
package org . apache . camel . component . file ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ScheduledPollEndpoint ; import java . io . File ; public class FileEndpoint extends ScheduledPollEndpoint < FileExchange > { private File file ; private boolean autoCreate = true ; protected FileEndpoint ( File file , String endpointUri , FileComponent component ) { super ( endpointUri , component ) ; this . file = file ; } public Producer < FileExchange > createProducer ( ) throws Exception { Producer < FileExchange > result = new FileProducer ( this ) ; return result ; } public Consumer < FileExchange > createConsumer ( Processor file ) throws Exception { Consumer < FileExchange > result = new FileConsumer ( this , file ) ; configureConsumer ( result ) ; return result ; } public FileExchange createExchange ( File file ) { return new FileExchange ( getContext ( ) , file ) ; } public FileExchange createExchange ( ) { return createExchange ( getFile ( ) ) ; } public File getFile ( ) { if ( autoCreate && ! file . exists ( ) ) { file . mkdirs ( ) ; } return file ; } public boolean isSingleton ( ) { return true ; } public boolean isAutoCreate ( ) { return this . autoCreate ; } public void setAutoCreate ( boolean autoCreate ) { this . autoCreate = autoCreate ; } } 	1
package org . apache . camel . component . xmpp ; import com . sun . jndi . toolkit . url . Uri ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . URISupport ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Map ; public class XmppComponent extends DefaultComponent < XmppExchange > { public static XmppComponent xmppComponent ( ) { return new XmppComponent ( ) ; } public XmppComponent ( ) { } public XmppComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < XmppExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { XmppEndpoint endpoint = new XmppEndpoint ( uri , this ) ; URI u = new URI ( uri ) ; endpoint . setHost ( u . getHost ( ) ) ; endpoint . setPort ( u . getPort ( ) ) ; if ( u . getUserInfo ( ) != null ) { endpoint . setUser ( u . getUserInfo ( ) ) ; } String remainingPath = u . getPath ( ) ; if ( remainingPath != null ) { if ( remainingPath . startsWith ( "/" ) ) { remainingPath = remainingPath . substring ( 1 ) ; } if ( remainingPath . length ( ) > 0 ) { endpoint . setParticipant ( remainingPath ) ; } } return endpoint ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; public abstract class MessageSupport implements Message { private static final UuidGenerator defaultIdGenerator = new UuidGenerator ( ) ; private Exchange exchange ; private Object body ; private String messageId = defaultIdGenerator . generateId ( ) ; public Object getBody ( ) { if ( body == null ) { body = createBody ( ) ; } return body ; } @ SuppressWarnings ( { "unchecked" } ) public < T > T getBody ( Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { return e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , getBody ( ) ) ; } return ( T ) getBody ( ) ; } public void setBody ( Object body ) { this . body = body ; } public < T > void setBody ( Object body , Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { T value = e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , body ) ; if ( value != null ) { body = value ; } } setBody ( body ) ; } public Message copy ( ) { Message answer = newInstance ( ) ; answer . setMessageId ( getMessageId ( ) ) ; answer . setBody ( getBody ( ) ) ; answer . getHeaders ( ) . putAll ( getHeaders ( ) ) ; return answer ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public abstract Message newInstance ( ) ; protected Object createBody ( ) { return null ; } public String getMessageId ( ) { return this . messageId ; } public void setMessageId ( String messageId ) { this . messageId = messageId ; } } 	1
package org . apache . camel . builder ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . Exchange ; import org . apache . camel . Service ; import org . apache . camel . processor . Resequencer ; import java . util . List ; public class ResequencerBuilder extends FromBuilder { private final List < Expression < Exchange > > expressions ; private long batchTimeout = 1000L ; private int batchSize = 100 ; public ResequencerBuilder ( FromBuilder builder , List < Expression < Exchange > > expressions ) { super ( builder ) ; this . expressions = expressions ; } @ Override public Route createRoute ( ) throws Exception { final Processor processor = super . createProcessor ( ) ; final Resequencer resequencer = new Resequencer ( getFrom ( ) , processor , expressions ) ; return new Route < Exchange > ( getFrom ( ) ) { protected void addServices ( List < Service > list ) throws Exception { list . add ( resequencer ) ; } @ Override public String toString ( ) { return "ResequencerRoute[" + getEndpoint ( ) + " -> " + processor + "]" ; } } ; } public ResequencerBuilder batchSize ( int batchSize ) { setBatchSize ( batchSize ) ; return this ; } public ResequencerBuilder batchTimeout ( int batchTimeout ) { setBatchTimeout ( batchTimeout ) ; return this ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; import java . util . HashMap ; import java . util . Map ; public class DefaultExchange implements Exchange { private static final UuidGenerator defaultIdGenerator = new UuidGenerator ( ) ; protected final CamelContext context ; private Map < String , Object > headers ; private Message in ; private Message out ; private Message fault ; private Throwable exception ; private String exchangeId = DefaultExchange . defaultIdGenerator . generateId ( ) ; public DefaultExchange ( CamelContext context ) { this . context = context ; } @ Override public String toString ( ) { return "Exchange[" + in + "]" ; } public Exchange copy ( ) { Exchange exchange = newInstance ( ) ; exchange . copyFrom ( this ) ; return exchange ; } public void copyFrom ( Exchange exchange ) { if ( exchange == this ) { return ; } setHeaders ( safeCopy ( exchange . getProperties ( ) ) ) ; setIn ( safeCopy ( exchange . getIn ( ) ) ) ; setOut ( safeCopy ( exchange . getOut ( ) ) ) ; setFault ( safeCopy ( exchange . getFault ( ) ) ) ; setException ( exchange . getException ( ) ) ; } static private Map < String , Object > safeCopy ( Map < String , Object > properties ) { if ( properties == null ) return null ; return new HashMap < String , Object > ( properties ) ; } static private Message safeCopy ( Message message ) { if ( message == null ) return null ; return message . copy ( ) ; } public Exchange newInstance ( ) { return new DefaultExchange ( context ) ; } public CamelContext getContext ( ) { return context ; } public Object getProperty ( String name ) { if ( headers != null ) { return headers . get ( name ) ; } return null ; } public < T > T getProperty ( String name , Class < T > type ) { Object value = getProperty ( name ) ; return getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setProperty ( String name , Object value ) { getProperties ( ) . put ( name , value ) ; } public Map < String , Object > getProperties ( ) { if ( headers == null ) { headers = new HashMap < String , Object > ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public Message getIn ( ) { if ( in == null ) { in = createInMessage ( ) ; configureMessage ( in ) ; } return in ; } public void setIn ( Message in ) { this . in = in ; configureMessage ( in ) ; } public Message getOut ( ) { return getOut ( true ) ; } public Message getOut ( boolean lazyCreate ) { if ( out == null && lazyCreate ) { out = createOutMessage ( ) ; configureMessage ( out ) ; } return out ; } public void setOut ( Message out ) { this . out = out ; configureMessage ( out ) ; } public Throwable getException ( ) { return exception ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Message getFault ( ) { return fault ; } public void setFault ( Message fault ) { this . fault = fault ; configureMessage ( fault ) ; } public String getExchangeId ( ) { return exchangeId ; } public void setExchangeId ( String id ) { this . exchangeId = id ; } protected Message createInMessage ( ) { return new DefaultMessage ( ) ; } protected Message createOutMessage ( ) { return new DefaultMessage ( ) ; } protected void configureMessage ( Message message ) { if ( message instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) message ; messageSupport . setExchange ( this ) ; } } } 	1
package org . apache . camel . spring . xml ; import java . lang . annotation . Annotation ; import java . lang . reflect . Array ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Set ; import java . util . Map ; import org . apache . camel . Expression ; import org . apache . camel . builder . Fluent ; import org . apache . camel . builder . FluentArg ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . builder . ValueBuilder ; import org . springframework . beans . SimpleTypeConverter ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . ChildBeanDefinition ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . StringUtils ; import org . springframework . util . xml . DomUtils ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class CamelBeanDefinitionParser extends AbstractBeanDefinitionParser { private final CamelNamespaceHandler namespaceHandler ; private int counter ; public CamelBeanDefinitionParser ( CamelNamespaceHandler namespaceHandler ) { this . namespaceHandler = namespaceHandler ; } protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) { BeanDefinitionBuilder factory = BeanDefinitionBuilder . rootBeanDefinition ( RouteBuilderFactoryBean . class ) ; List childElements = DomUtils . getChildElementsByTagName ( element , "route" ) ; ArrayList < BuilderStatement > routes = new ArrayList < BuilderStatement > ( childElements . size ( ) ) ; if ( childElements != null && childElements . size ( ) > 0 ) { for ( int i = 0 ; i < childElements . size ( ) ; ++ i ) { Element routeElement = ( Element ) childElements . get ( i ) ; ArrayList < BuilderAction > actions = new ArrayList < BuilderAction > ( ) ; Class type = parseBuilderElement ( parserContext , routeElement , RouteBuilder . class , actions ) ; BuilderStatement statement = new BuilderStatement ( ) ; statement . setReturnType ( type ) ; statement . setActions ( actions ) ; routes . add ( statement ) ; } } factory . addPropertyValue ( "routes" , routes ) ; return factory . getBeanDefinition ( ) ; } private Class parseBuilderElement ( ParserContext parserContext , Element element , Class < RouteBuilder > builder , ArrayList < BuilderAction > actions ) { Class currentBuilder = builder ; NodeList childElements = element . getChildNodes ( ) ; Element previousElement = null ; for ( int i = 0 ; i < childElements . getLength ( ) ; ++ i ) { Node node = childElements . item ( i ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { currentBuilder = parseAction ( parserContext , currentBuilder , actions , ( Element ) node , previousElement ) ; previousElement = ( Element ) node ; BuilderAction action = actions . get ( actions . size ( ) - 1 ) ; if ( action . getMethodInfo ( ) . methodAnnotation . nestedActions ( ) ) { currentBuilder = parseBuilderElement ( parserContext , ( Element ) node , currentBuilder , actions ) ; } else { if ( hasChildElements ( node ) ) { throw new IllegalArgumentException ( "The element " + node . getLocalName ( ) + " should not have any child elements." ) ; } } } } if ( currentBuilder != null ) { Method [ ] methods = currentBuilder . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; Fluent annotation = method . getAnnotation ( Fluent . class ) ; if ( annotation != null && annotation . callOnElementEnd ( ) ) { if ( method . getParameterTypes ( ) . length > 0 ) { throw new RuntimeException ( "Only methods with no parameters can annotated with @Fluent(callOnElementEnd=true): " + method ) ; } MethodInfo methodInfo = new MethodInfo ( method , annotation , new LinkedHashMap < String , Class > ( ) , new LinkedHashMap < String , FluentArg > ( ) ) ; actions . add ( new BuilderAction ( methodInfo , new HashMap < String , Object > ( ) ) ) ; currentBuilder = method . getReturnType ( ) ; } } } return currentBuilder ; } private boolean hasChildElements ( Node node ) { NodeList nl = node . getChildNodes ( ) ; for ( int j = 0 ; j < nl . getLength ( ) ; ++ j ) { if ( nl . item ( j ) . getNodeType ( ) == Node . ELEMENT_NODE ) { return true ; } } return false ; } private Class parseAction ( ParserContext parserContext , Class currentBuilder , ArrayList < BuilderAction > actions , Element element , Element previousElement ) { String actionName = element . getLocalName ( ) ; ArrayList < MethodInfo > methods = findFluentMethodsWithName ( currentBuilder , element . getLocalName ( ) ) ; if ( methods . isEmpty ( ) ) { throw new IllegalActionException ( actionName , previousElement == null ? null : previousElement . getLocalName ( ) ) ; } Collections . sort ( methods , new Comparator < MethodInfo > ( ) { public int compare ( MethodInfo m1 , MethodInfo m2 ) { return m1 . method . getParameterTypes ( ) . length - m2 . method . getParameterTypes ( ) . length ; } } ) ; HashMap < String , Object > attributeArguments = getArugmentsFromAttributes ( element ) ; HashMap < String , ArrayList < Element > > elementArguments = getArgumentsFromElements ( element ) ; MethodInfo match = null ; match = findMethodMatch ( methods , attributeArguments . keySet ( ) , elementArguments . keySet ( ) ) ; if ( match == null ) throw new IllegalActionException ( actionName , previousElement == null ? null : previousElement . getLocalName ( ) ) ; Set < Map . Entry < String , Object > > attributeEntries = attributeArguments . entrySet ( ) ; for ( Map . Entry < String , Object > entry : attributeEntries ) { String name = entry . getKey ( ) ; FluentArg arg = match . parameterAnnotations . get ( name ) ; if ( arg != null && ( arg . reference ( ) || name . equals ( "ref" ) ) ) { Object value = entry . getValue ( ) ; if ( value instanceof String ) { entry . setValue ( new RuntimeBeanReference ( value . toString ( ) ) ) ; } } } Set < String > parameterNames = new HashSet < String > ( match . parameters . keySet ( ) ) ; parameterNames . removeAll ( attributeArguments . keySet ( ) ) ; for ( String key : parameterNames ) { ArrayList < Element > elements = elementArguments . get ( key ) ; if ( elements == null ) { elements = getFirstChildElements ( element ) ; } Class clazz = match . parameters . get ( key ) ; Object value = convertTo ( parserContext , elements , clazz ) ; attributeArguments . put ( key , value ) ; for ( Element el : elements ) { el . getParentNode ( ) . removeChild ( el ) ; } } actions . add ( new BuilderAction ( match , attributeArguments ) ) ; return match . method . getReturnType ( ) ; } private ArrayList < Element > getFirstChildElements ( Element element ) { ArrayList < Element > answer = new ArrayList < Element > ( ) ; NodeList list = element . getChildNodes ( ) ; for ( int i = 0 , size = list . getLength ( ) ; i < size ; i ++ ) { Node node = list . item ( i ) ; if ( node instanceof Element ) { answer . add ( ( Element ) node ) ; break ; } } return answer ; } private Object convertTo ( ParserContext parserContext , ArrayList < Element > elements , Class clazz ) { if ( clazz . isArray ( ) || elements . size ( ) > 1 ) { List list = new ArrayList ( ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { ArrayList < Element > e = new ArrayList < Element > ( 1 ) ; e . add ( elements . get ( i ) ) ; Object value = convertTo ( parserContext , e , clazz . getComponentType ( ) ) ; list . add ( value ) ; } return list ; } else { Element element = elements . get ( 0 ) ; String ref = element . getAttribute ( "ref" ) ; if ( StringUtils . hasText ( ref ) ) { return new RuntimeBeanReference ( ref ) ; } if ( hasChildElements ( element ) ) { ArrayList < BuilderAction > actions = new ArrayList < BuilderAction > ( ) ; Class type = parseBuilderElement ( parserContext , element , RouteBuilder . class , actions ) ; if ( type == ValueBuilder . class && clazz == Expression . class ) { Method method ; try { method = ValueBuilder . class . getMethod ( "getExpression" , new Class [ ] { } ) ; } catch ( Throwable e ) { throw new RuntimeException ( ValueBuilder . class . getName ( ) + " does not have the getExpression() method." ) ; } MethodInfo methodInfo = new MethodInfo ( method , null , new LinkedHashMap < String , Class > ( ) , new LinkedHashMap < String , FluentArg > ( ) ) ; actions . add ( new BuilderAction ( methodInfo , new HashMap < String , Object > ( ) ) ) ; type = Expression . class ; } BuilderStatement statement = new BuilderStatement ( ) ; statement . setReturnType ( type ) ; statement . setActions ( actions ) ; if ( ! clazz . isAssignableFrom ( statement . getReturnType ( ) ) ) { throw new IllegalStateException ( "Builder does not produce object of expected type: " + clazz . getName ( ) + ", it produced: " + statement . getReturnType ( ) ) ; } return statement ; } else { String name = element . getLocalName ( ) ; if ( namespaceHandler . getParserElementNames ( ) . contains ( name ) ) { String id = createBeanId ( name ) ; element . setAttribute ( "id" , id ) ; namespaceHandler . parse ( element , parserContext ) ; return new RuntimeBeanReference ( id ) ; } SimpleTypeConverter converter = new SimpleTypeConverter ( ) ; return converter . convertIfNecessary ( element . getTextContent ( ) , clazz ) ; } } } protected synchronized String createBeanId ( String name ) { return "_internal:camel:bean:" + name + ( ++ counter ) ; } private MethodInfo findMethodMatch ( ArrayList < MethodInfo > methods , Set < String > attributeNames , Set < String > elementNames ) { for ( MethodInfo method : methods ) { boolean miss = false ; for ( String key : attributeNames ) { FluentArg arg = method . parameterAnnotations . get ( key ) ; if ( arg == null || ! arg . attribute ( ) ) { miss = true ; break ; } } if ( miss ) continue ; Set < String > parameterNames = new HashSet < String > ( method . parameters . keySet ( ) ) ; parameterNames . removeAll ( attributeNames ) ; if ( parameterNames . isEmpty ( ) ) { return method ; } return method ; } return null ; } private LinkedHashMap < String , ArrayList < Element > > getArgumentsFromElements ( Element element ) { LinkedHashMap < String , ArrayList < Element > > elements = new LinkedHashMap < String , ArrayList < Element > > ( ) ; NodeList childNodes = element . getChildNodes ( ) ; String lastTag = null ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node node = childNodes . item ( i ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { Element el = ( Element ) node ; String tag = el . getLocalName ( ) ; ArrayList < Element > els = elements . get ( tag ) ; if ( els == null ) { els = new ArrayList < Element > ( ) ; elements . put ( el . getLocalName ( ) , els ) ; els . add ( el ) ; lastTag = tag ; } else { if ( tag . equals ( lastTag ) ) { els . add ( el ) ; lastTag = tag ; } } } } return elements ; } private HashMap < String , Object > getArugmentsFromAttributes ( Element element ) { HashMap < String , Object > attributes = new HashMap < String , Object > ( ) ; NamedNodeMap childNodes = element . getAttributes ( ) ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node node = childNodes . item ( i ) ; if ( node . getNodeType ( ) == Node . ATTRIBUTE_NODE ) { Attr attr = ( Attr ) node ; String str = attr . getValue ( ) ; Object value = str ; if ( str . startsWith ( "#" ) ) { str = str . substring ( 1 ) ; if ( ! str . startsWith ( "#" ) ) { value = new RuntimeBeanReference ( str ) ; } } attributes . put ( attr . getName ( ) , value ) ; } } return attributes ; } private ArrayList < MethodInfo > findFluentMethodsWithName ( Class clazz , String name ) { ArrayList < MethodInfo > rc = new ArrayList < MethodInfo > ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; if ( ! method . isAnnotationPresent ( Fluent . class ) ) { continue ; } Fluent fluentAnnotation = method . getAnnotation ( Fluent . class ) ; if ( StringUtils . hasText ( fluentAnnotation . value ( ) ) ? name . equals ( fluentAnnotation . value ( ) ) : name . equals ( method . getName ( ) ) ) { LinkedHashMap < String , Class > map = new LinkedHashMap < String , Class > ( ) ; LinkedHashMap < String , FluentArg > amap = new LinkedHashMap < String , FluentArg > ( ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( int j = 0 ; j < parameters . length ; j ++ ) { Class < ? > parameter = parameters [ j ] ; FluentArg annotation = getParameterAnnotation ( FluentArg . class , method , j ) ; if ( annotation != null ) { map . put ( annotation . value ( ) , parameter ) ; amap . put ( annotation . value ( ) , annotation ) ; } else { break ; } } if ( parameters . length == map . size ( ) ) { rc . add ( new MethodInfo ( method , fluentAnnotation , map , amap ) ) ; } } } return rc ; } private < T > T getParameterAnnotation ( Class < T > annotationClass , Method method , int index ) { Annotation [ ] annotations = method . getParameterAnnotations ( ) [ index ] ; for ( int i = 0 ; i < annotations . length ; i ++ ) { if ( annotationClass . isAssignableFrom ( annotations [ i ] . getClass ( ) ) ) { return ( T ) annotations [ i ] ; } } return null ; } } 	0
package org . apache . camel . builder . xml ; import org . apache . camel . Exchange ; import org . apache . camel . ExpectedBodyTypeException ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeTransformException ; import org . apache . camel . converter . jaxp . XmlConverter ; import static org . apache . camel . util . ObjectHelper . notNull ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . stream . StreamSource ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class XsltBuilder implements Processor { private Map < String , Object > parameters = new HashMap < String , Object > ( ) ; private XmlConverter converter = new XmlConverter ( ) ; private Transformer transformer ; private ResultHandler resultHandler = new StringResultHandler ( ) ; private boolean failOnNullBody = true ; public XsltBuilder ( ) { } public XsltBuilder ( Transformer transformer ) { this . transformer = transformer ; } @ Override public String toString ( ) { return "XSLT[" + transformer + "]" ; } public synchronized void process ( Exchange exchange ) throws Exception { Transformer transformer = getTransformer ( ) ; if ( transformer == null ) { throw new IllegalArgumentException ( "No transformer configured!" ) ; } configureTransformer ( transformer , exchange ) ; Source source = getSource ( exchange ) ; Result result = resultHandler . getResult ( ) ; transformer . transform ( source , result ) ; resultHandler . setBody ( exchange . getIn ( ) ) ; } public static XsltBuilder xslt ( Transformer transformer ) { return new XsltBuilder ( transformer ) ; } public static XsltBuilder xslt ( Source xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; XsltBuilder answer = new XsltBuilder ( ) ; answer . setTransformerSource ( xslt ) ; return answer ; } public static XsltBuilder xslt ( File xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public static XsltBuilder xslt ( URL xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( xslt . openStream ( ) ) ; } public static XsltBuilder xslt ( InputStream xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public XsltBuilder outputBytes ( ) { setResultHandler ( new StreamResultHandler ( ) ) ; return this ; } public XsltBuilder outputString ( ) { setResultHandler ( new StringResultHandler ( ) ) ; return this ; } public XsltBuilder outputDOM ( ) { setResultHandler ( new DomResultHandler ( ) ) ; return this ; } public XsltBuilder parameter ( String name , Object value ) { parameters . put ( name , value ) ; return this ; } public Map < String , Object > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , Object > parameters ) { this . parameters = parameters ; } public Transformer getTransformer ( ) { return transformer ; } public void setTransformer ( Transformer transformer ) { this . transformer = transformer ; } public boolean isFailOnNullBody ( ) { return failOnNullBody ; } public void setFailOnNullBody ( boolean failOnNullBody ) { this . failOnNullBody = failOnNullBody ; } public ResultHandler getResultHandler ( ) { return resultHandler ; } public void setResultHandler ( ResultHandler resultHandler ) { this . resultHandler = resultHandler ; } public void setTransformerSource ( Source source ) throws TransformerConfigurationException { setTransformer ( converter . getTransformerFactory ( ) . newTransformer ( source ) ) ; } protected Source getSource ( Exchange exchange ) { Message in = exchange . getIn ( ) ; Source source = in . getBody ( Source . class ) ; if ( source == null ) { if ( isFailOnNullBody ( ) ) { throw new ExpectedBodyTypeException ( exchange , Source . class ) ; } else { try { source = converter . toSource ( converter . createDocument ( ) ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeTransformException ( e ) ; } } } return source ; } protected void configureTransformer ( Transformer transformer , Exchange exchange ) { transformer . clearParameters ( ) ; addParameters ( transformer , exchange . getProperties ( ) ) ; addParameters ( transformer , exchange . getIn ( ) . getHeaders ( ) ) ; addParameters ( transformer , getParameters ( ) ) ; transformer . setParameter ( "exchange" , exchange ) ; transformer . setParameter ( "in" , exchange . getIn ( ) ) ; transformer . setParameter ( "out" , exchange . getOut ( ) ) ; } protected void addParameters ( Transformer transformer , Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { transformer . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	1
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class ConstantProcessorBuilder implements ProcessorFactory { private Processor processor ; public ConstantProcessorBuilder ( Processor processor ) { this . processor = processor ; } public Processor createProcessor ( ) { return processor ; } } 	0
package org . apache . camel ; public interface Processor { void process ( Exchange exchange ) throws Exception ; } 	1
package org . apache . camel . component . cxf ; import java . net . URI ; import java . util . Map ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . cxf . Bus ; import org . apache . cxf . BusException ; import org . apache . cxf . bus . CXFBusFactory ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . DestinationFactoryManager ; import org . apache . cxf . transport . local . LocalTransportFactory ; import org . xmlsoap . schemas . wsdl . http . AddressType ; public class CxfComponent extends DefaultComponent < CxfExchange > { private LocalTransportFactory localTransportFactory ; public CxfComponent ( ) { } public CxfComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < CxfExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { URI u = new URI ( remaining ) ; EndpointInfo endpointInfo = new EndpointInfo ( null , "http://schemas.xmlsoap.org/soap/http" ) ; AddressType a = new AddressType ( ) ; a . setLocation ( remaining ) ; endpointInfo . addExtensor ( a ) ; return new CxfEndpoint ( uri , this , endpointInfo ) ; } public LocalTransportFactory getLocalTransportFactory ( ) throws BusException { if ( localTransportFactory == null ) { localTransportFactory = findLocalTransportFactory ( ) ; if ( localTransportFactory == null ) { localTransportFactory = new LocalTransportFactory ( ) ; } } return localTransportFactory ; } public void setLocalTransportFactory ( LocalTransportFactory localTransportFactory ) { this . localTransportFactory = localTransportFactory ; } protected LocalTransportFactory findLocalTransportFactory ( ) throws BusException { Bus bus = CXFBusFactory . getDefaultBus ( ) ; DestinationFactoryManager dfm = bus . getExtension ( DestinationFactoryManager . class ) ; return ( LocalTransportFactory ) dfm . getDestinationFactory ( LocalTransportFactory . TRANSPORT_ID ) ; } } 	0
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . io . * ; import java . nio . ByteBuffer ; @ Converter public class NIOConverter { @ Converter public static byte [ ] toByteArray ( ByteBuffer buffer ) { return buffer . array ( ) ; } @ Converter public static ByteBuffer toByteBuffer ( byte [ ] data ) { return ByteBuffer . wrap ( data ) ; } @ Converter public static ByteBuffer toByteBuffer ( String value ) { ByteBuffer buf = ByteBuffer . allocate ( value . length ( ) ) ; byte [ ] bytes = value . getBytes ( ) ; buf . put ( bytes ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Short value ) { ByteBuffer buf = ByteBuffer . allocate ( 2 ) ; buf . putShort ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Integer value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Long value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putLong ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Float value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putFloat ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Double value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putDouble ( value ) ; return buf ; } } 	1
package org . apache . camel ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ProducerCache ; import java . util . HashMap ; import java . util . Map ; public class CamelTemplate < E extends Exchange > extends ServiceSupport { private CamelContext context ; private ProducerCache < E > producerCache = new ProducerCache < E > ( ) ; private boolean useEndpointCache = true ; private Map < String , Endpoint < E > > endpointCache = new HashMap < String , Endpoint < E > > ( ) ; private Endpoint < E > defaultEndpoint ; public CamelTemplate ( CamelContext context ) { this . context = context ; } public CamelTemplate ( CamelContext context , Endpoint defaultEndpoint ) { this ( context ) ; this . defaultEndpoint = defaultEndpoint ; } public E send ( String endpointUri , E exchange ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; send ( endpoint , exchange ) ; return exchange ; } public E send ( String endpointUri , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor ) ; } public E send ( Endpoint < E > endpoint , E exchange ) { E convertedExchange = endpoint . toExchangeType ( exchange ) ; producerCache . send ( endpoint , convertedExchange ) ; return exchange ; } public E send ( Endpoint < E > endpoint , Processor processor ) { return producerCache . send ( endpoint , processor ) ; } public Object sendBody ( Endpoint < E > endpoint , final Object body ) { E result = send ( endpoint , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , final Object body ) { E result = send ( endpointUri , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , final Object body , final String header , final Object headerValue ) { E result = send ( endpointUri , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setHeader ( header , headerValue ) ; in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , final Object body , final Map < String , Object > headers ) { E result = send ( endpointUri , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; for ( Map . Entry < String , Object > header : headers . entrySet ( ) ) { in . setHeader ( header . getKey ( ) , header . getValue ( ) ) ; } in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public Object sendBody ( Object body ) { return sendBody ( getMandatoryDefaultEndpoint ( ) , body ) ; } public E send ( E exchange ) { return send ( getMandatoryDefaultEndpoint ( ) , exchange ) ; } public E send ( Processor processor ) { return send ( getMandatoryDefaultEndpoint ( ) , processor ) ; } public Producer < E > getProducer ( Endpoint < E > endpoint ) { return producerCache . getProducer ( endpoint ) ; } public CamelContext getContext ( ) { return context ; } public Endpoint < E > getDefaultEndpoint ( ) { return defaultEndpoint ; } public void setDefaultEndpoint ( Endpoint < E > defaultEndpoint ) { this . defaultEndpoint = defaultEndpoint ; } public void setDefaultEndpointUri ( String endpointUri ) { setDefaultEndpoint ( getContext ( ) . getEndpoint ( endpointUri ) ) ; } public boolean isUseEndpointCache ( ) { return useEndpointCache ; } public void setUseEndpointCache ( boolean useEndpointCache ) { this . useEndpointCache = useEndpointCache ; } protected Endpoint resolveMandatoryEndpoint ( String endpointUri ) { Endpoint endpoint = null ; if ( isUseEndpointCache ( ) ) { synchronized ( endpointCache ) { endpoint = endpointCache . get ( endpointUri ) ; if ( endpoint == null ) { endpoint = context . getEndpoint ( endpointUri ) ; if ( endpoint != null ) { endpointCache . put ( endpointUri , endpoint ) ; } } } } else { endpoint = context . getEndpoint ( endpointUri ) ; } if ( endpoint == null ) { throw new NoSuchEndpointException ( endpointUri ) ; } return endpoint ; } protected Endpoint < E > getMandatoryDefaultEndpoint ( ) { Endpoint < E > answer = getDefaultEndpoint ( ) ; ObjectHelper . notNull ( answer , "defaultEndpoint" ) ; return answer ; } protected void doStart ( ) throws Exception { producerCache . start ( ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected Object extractResultBody ( E result ) { return result != null ? result . getOut ( ) . getBody ( ) : null ; } } 	0
package org . apache . camel . component . file ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . channels . FileChannel ; public class FileConsumer extends ScheduledPollConsumer < FileExchange > { private static final transient Log log = LogFactory . getLog ( FileConsumer . class ) ; private final FileEndpoint endpoint ; private boolean recursive = true ; private boolean attemptFileLock = false ; private String regexPattern = "" ; private long lastPollTime = 0l ; public FileConsumer ( final FileEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } protected void poll ( ) throws Exception { pollFileOrDirectory ( endpoint . getFile ( ) , isRecursive ( ) ) ; lastPollTime = System . currentTimeMillis ( ) ; } protected void pollFileOrDirectory ( File fileOrDirectory , boolean processDir ) { if ( ! fileOrDirectory . isDirectory ( ) ) { pollFile ( fileOrDirectory ) ; } else if ( processDir ) { log . debug ( "Polling directory " + fileOrDirectory ) ; File [ ] files = fileOrDirectory . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { pollFileOrDirectory ( files [ i ] , isRecursive ( ) ) ; } } else { log . debug ( "Skipping directory " + fileOrDirectory ) ; } } protected void pollFile ( final File file ) { if ( file . exists ( ) && file . lastModified ( ) > lastPollTime ) { if ( isValidFile ( file ) ) { processFile ( file ) ; } } } protected void processFile ( File file ) { try { getProcessor ( ) . process ( endpoint . createExchange ( file ) ) ; } catch ( Throwable e ) { handleException ( e ) ; } } protected boolean isValidFile ( File file ) { boolean result = false ; if ( file != null && file . exists ( ) ) { if ( isMatched ( file ) ) { if ( isAttemptFileLock ( ) ) { FileChannel fc = null ; try { fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . lock ( ) ; result = true ; } catch ( Throwable e ) { log . debug ( "Failed to get the lock on file: " + file , e ) ; } finally { if ( fc != null ) { try { fc . close ( ) ; } catch ( IOException e ) { } } } } else { result = true ; } } } return result ; } protected boolean isMatched ( File file ) { boolean result = true ; if ( regexPattern != null && regexPattern . length ( ) > 0 ) { result = file . getName ( ) . matches ( getRegexPattern ( ) ) ; } return result ; } public boolean isRecursive ( ) { return this . recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public boolean isAttemptFileLock ( ) { return this . attemptFileLock ; } public void setAttemptFileLock ( boolean attemptFileLock ) { this . attemptFileLock = attemptFileLock ; } public String getRegexPattern ( ) { return this . regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } } 	1
package org . apache . camel . component . mail ; import javax . mail . MessagingException ; public class MessageHeaderAccessException extends RuntimeMailException { private static final long serialVersionUID = - 3996286386119163309L ; private String propertyName ; public MessageHeaderAccessException ( String propertyName , MessagingException e ) { super ( "Error accessing header: " + propertyName , e ) ; this . propertyName = propertyName ; } public String getPropertyName ( ) { return propertyName ; } } 	0
package org . apache . camel . impl ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . Service ; public abstract class ServiceSupport implements Service { private AtomicBoolean started = new AtomicBoolean ( false ) ; private AtomicBoolean stopping = new AtomicBoolean ( false ) ; private AtomicBoolean stopped = new AtomicBoolean ( false ) ; public void start ( ) throws Exception { if ( started . compareAndSet ( false , true ) ) { doStart ( ) ; } } public void stop ( ) throws Exception { if ( stopped . compareAndSet ( false , true ) ) { stopping . set ( true ) ; try { doStop ( ) ; } finally { stopped . set ( true ) ; started . set ( false ) ; stopping . set ( false ) ; } } } public boolean isStarted ( ) { return started . get ( ) ; } public boolean isStopping ( ) { return stopping . get ( ) ; } public boolean isStopped ( ) { return stopped . get ( ) ; } protected abstract void doStart ( ) throws Exception ; protected abstract void doStop ( ) throws Exception ; } 	1
package org . apache . camel . processor ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . util . ServiceHelper ; import org . apache . camel . impl . ServiceSupport ; import java . util . ArrayList ; import java . util . List ; public class ChoiceProcessor extends ServiceSupport implements Processor { private List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; private Processor otherwise ; public ChoiceProcessor ( List < FilterProcessor > filters , Processor otherwise ) { this . filters = filters ; this . otherwise = otherwise ; } public void process ( Exchange exchange ) throws Exception { for ( FilterProcessor filterProcessor : filters ) { Predicate < Exchange > predicate = filterProcessor . getPredicate ( ) ; if ( predicate != null && predicate . matches ( exchange ) ) { filterProcessor . getProcessor ( ) . process ( exchange ) ; return ; } } if ( otherwise != null ) { otherwise . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "choice{" ) ; boolean first = true ; for ( FilterProcessor processor : filters ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( "when " ) ; builder . append ( processor . getPredicate ( ) . toString ( ) ) ; builder . append ( ": " ) ; builder . append ( processor . getProcessor ( ) ) ; } if ( otherwise != null ) { builder . append ( ", otherwise: " ) ; builder . append ( otherwise ) ; } builder . append ( "}" ) ; return builder . toString ( ) ; } public List < FilterProcessor > getFilters ( ) { return filters ; } public Processor getOtherwise ( ) { return otherwise ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( filters ) ; ServiceHelper . startServices ( otherwise ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( otherwise ) ; ServiceHelper . stopServices ( filters ) ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; public class DefaultCamelContext extends ServiceSupport implements CamelContext , Service { private Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; private Map < String , Component > components = new HashMap < String , Component > ( ) ; private List < Route > routes ; private List < Service > servicesToClose = new ArrayList < Service > ( ) ; private TypeConverter typeConverter ; private ExchangeConverter exchangeConverter ; private Injector injector ; private ComponentResolver componentResolver ; private boolean autoCreateComponents = true ; public void addComponent ( String componentName , final Component component ) { if ( component == null ) { throw new IllegalArgumentException ( "Component cannot be null" ) ; } synchronized ( components ) { if ( components . containsKey ( componentName ) ) { throw new IllegalArgumentException ( "Component previously added: " + componentName ) ; } component . setCamelContext ( this ) ; components . put ( componentName , component ) ; } } public Component getComponent ( String name ) { synchronized ( components ) { Component component = components . get ( name ) ; if ( component == null && autoCreateComponents ) { try { component = getComponentResolver ( ) . resolveComponent ( name , this ) ; if ( component != null ) { addComponent ( name , component ) ; if ( isStarted ( ) ) { startServices ( component ) ; } } } catch ( Exception e ) { throw new RuntimeCamelException ( "Could not auto create component: " + name , e ) ; } } return component ; } } public < T extends Component > T getComponent ( String name , Class < T > componentType ) { Component component = getComponent ( name ) ; if ( componentType . isInstance ( component ) ) { return componentType . cast ( component ) ; } else { throw new IllegalArgumentException ( "The component is not of type: " + componentType + " but is: " + component ) ; } } public Component removeComponent ( String componentName ) { synchronized ( components ) { return components . remove ( componentName ) ; } } public Component getOrCreateComponent ( String componentName , Callable < Component > factory ) { synchronized ( components ) { Component component = components . get ( componentName ) ; if ( component == null ) { try { component = factory . call ( ) ; if ( component == null ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component, it returned null." ) ; } components . put ( componentName , component ) ; component . setCamelContext ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component" , e ) ; } } return component ; } } public Collection < Endpoint > getSingletonEndpoints ( ) { synchronized ( endpoints ) { return new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } } public Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { startServices ( endpoint ) ; oldEndpoint = endpoints . remove ( uri ) ; endpoints . put ( uri , endpoint ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint removeSingletonEndpoint ( String uri ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { oldEndpoint = endpoints . remove ( uri ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint getEndpoint ( String uri ) { Endpoint answer ; synchronized ( endpoints ) { answer = endpoints . get ( uri ) ; if ( answer == null ) { try { String splitURI [ ] = ObjectHelper . splitOnCharacter ( uri , ":" , 2 ) ; if ( splitURI [ 1 ] == null ) { throw new IllegalArgumentException ( "Invalid URI, it did not contain a scheme: " + uri ) ; } String scheme = splitURI [ 0 ] ; Component component = getComponent ( scheme ) ; if ( component != null ) { answer = component . createEndpoint ( uri ) ; if ( answer != null && answer . isSingleton ( ) ) { if ( answer != null ) { startServices ( answer ) ; endpoints . put ( uri , answer ) ; } } } } catch ( Exception e ) { throw new ResolveEndpointFailedException ( uri , e ) ; } } } return answer ; } public < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) { Endpoint endpoint = getEndpoint ( name ) ; if ( endpointType . isInstance ( endpoint ) ) { return endpointType . cast ( endpoint ) ; } else { throw new IllegalArgumentException ( "The endpoint is not of type: " + endpointType + " but is: " + endpoint ) ; } } public List < Route > getRoutes ( ) { return routes ; } public void setRoutes ( List < Route > routes ) { this . routes = routes ; } public void addRoutes ( Collection < Route > routes ) throws Exception { if ( this . routes == null ) { this . routes = new ArrayList < Route > ( routes ) ; } else { this . routes . addAll ( routes ) ; } if ( isStarted ( ) ) { startRoutes ( routes ) ; } } public void addRoutes ( RouteBuilder builder ) throws Exception { builder . setContext ( this ) ; addRoutes ( builder . getRouteList ( ) ) ; } public ExchangeConverter getExchangeConverter ( ) { if ( exchangeConverter == null ) { exchangeConverter = createExchangeConverter ( ) ; } return exchangeConverter ; } public void setExchangeConverter ( ExchangeConverter exchangeConverter ) { this . exchangeConverter = exchangeConverter ; } public TypeConverter getTypeConverter ( ) { if ( typeConverter == null ) { typeConverter = createTypeConverter ( ) ; } return typeConverter ; } public void setTypeConverter ( TypeConverter typeConverter ) { this . typeConverter = typeConverter ; } public Injector getInjector ( ) { if ( injector == null ) { injector = createInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } public ComponentResolver getComponentResolver ( ) { if ( componentResolver == null ) { componentResolver = createComponentResolver ( ) ; } return componentResolver ; } public void setComponentResolver ( ComponentResolver componentResolver ) { this . componentResolver = componentResolver ; } protected void doStart ( ) throws Exception { if ( components != null ) { for ( Component component : components . values ( ) ) { startServices ( component ) ; } } startRoutes ( routes ) ; } protected void doStop ( ) throws Exception { stopServices ( servicesToClose ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { stopServices ( component ) ; } } } protected void startRoutes ( Collection < Route > routeList ) throws Exception { if ( routeList != null ) { for ( Route < Exchange > route : routeList ) { List < Service > services = route . getServicesForRoute ( ) ; servicesToClose . addAll ( services ) ; startServices ( services ) ; } } } protected ExchangeConverter createExchangeConverter ( ) { return new DefaultExchangeConverter ( ) ; } protected TypeConverter createTypeConverter ( ) { return new DefaultTypeConverter ( ) ; } protected Injector createInjector ( ) { FactoryFinder finder = new FactoryFinder ( ) ; try { return ( Injector ) finder . newInstance ( "Injector" ) ; } catch ( NoFactoryAvailableException e ) { return new ReflectionInjector ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } protected ComponentResolver createComponentResolver ( ) { return new DefaultComponentResolver ( ) ; } public boolean isAutoCreateComponents ( ) { return autoCreateComponents ; } public void setAutoCreateComponents ( boolean autoCreateComponents ) { this . autoCreateComponents = autoCreateComponents ; } } 	1
package org . apache . camel . component . jbi ; import org . apache . camel . RuntimeCamelException ; public class JbiException extends RuntimeCamelException { public JbiException ( Throwable cause ) { super ( cause ) ; } public JbiException ( String message ) { super ( message ) ; } public JbiException ( String message , Throwable cause ) { super ( message , cause ) ; } } 	0
package org . apache . camel . builder ; import static org . apache . camel . util . ObjectHelper . compare ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . impl . PredicateSupport ; import org . apache . camel . impl . BinaryPredicateSupport ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class PredicateBuilder { public static < E extends Exchange > Predicate < E > and ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) && right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") and (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > or ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) || right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") or (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > isEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isNotEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ! ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return "<" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) <= 0 ; } protected String getOperationText ( ) { return "<=" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) > 0 ; } protected String getOperationText ( ) { return ">" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return ">=" ; } } ; } public static < E extends Exchange > Predicate < E > contains ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . contains ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "contains" ; } } ; } public static < E extends Exchange > Predicate < E > isNull ( final Expression < E > expression ) { return isEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isNotNull ( final Expression < E > expression ) { return isNotEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isInstanceOf ( final Expression < E > expression , final Class type ) { notNull ( expression , "expression" ) ; notNull ( type , "type" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return type . isInstance ( value ) ; } @ Override public String toString ( ) { return expression + " instanceof " + type . getName ( ) ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final String regex ) { return regex ( expression , Pattern . compile ( regex ) ) ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final Pattern pattern ) { notNull ( expression , "expression" ) ; notNull ( pattern , "pattern" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; if ( value != null ) { Matcher matcher = pattern . matcher ( value . toString ( ) ) ; return matcher . matches ( ) ; } return false ; } @ Override public String toString ( ) { return expression + ".matches(" + pattern + ")" ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } } 	1
package org . apache . camel . util ; import java . net . InetAddress ; import java . net . ServerSocket ; import java . util . logging . Level ; import java . util . logging . Logger ; public class UuidGenerator { private static final Logger log = Logger . getLogger ( UuidGenerator . class . getName ( ) ) ; private static final String UNIQUE_STUB ; private static int instanceCount ; private static String hostName ; private String seed ; private long sequence ; static { String stub = "" ; boolean canAccessSystemProps = true ; try { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPropertiesAccess ( ) ; } } catch ( SecurityException se ) { canAccessSystemProps = false ; } if ( canAccessSystemProps ) { try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; ServerSocket ss = new ServerSocket ( 0 ) ; stub = "/" + ss . getLocalPort ( ) + "-" + System . currentTimeMillis ( ) + "/" ; Thread . sleep ( 100 ) ; ss . close ( ) ; } catch ( Exception ioe ) { log . log ( Level . WARNING , "could not generate unique stub" , ioe ) ; } } else { hostName = "localhost" ; stub = "-1-" + System . currentTimeMillis ( ) + "-" ; } UNIQUE_STUB = stub ; } public static String getHostName ( ) { return hostName ; } public UuidGenerator ( String prefix ) { synchronized ( UNIQUE_STUB ) { this . seed = prefix + UNIQUE_STUB + ( instanceCount ++ ) + "-" ; } } public UuidGenerator ( ) { this ( "ID-" + hostName ) ; } public synchronized String generateId ( ) { return this . seed + ( this . sequence ++ ) ; } public String generateSanitizedId ( ) { String result = generateId ( ) ; result = result . replace ( ':' , '-' ) ; result = result . replace ( '_' , '-' ) ; result = result . replace ( '.' , '-' ) ; return result ; } } 	0
package org . apache . camel ; import java . util . Map ; public interface ProducerTemplate < E extends Exchange > extends Service { E send ( E exchange ) ; E send ( Processor processor ) ; Object sendBody ( Object body ) ; Object sendBodyAndHeader ( Object body , String header , Object headerValue ) ; Object sendBodyAndHeaders ( Object body , Map < String , Object > headers ) ; E send ( String endpointUri , E exchange ) ; E send ( String endpointUri , Processor processor ) ; E send ( String endpointUri , ExchangePattern pattern , Processor processor ) ; E send ( Endpoint < E > endpoint , E exchange ) ; E send ( Endpoint < E > endpoint , Processor processor ) ; E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) ; Object sendBody ( Endpoint < E > endpoint , Object body ) ; Object sendBody ( String endpointUri , Object body ) ; Object sendBody ( Endpoint < E > endpoint , ExchangePattern pattern , Object body ) ; Object sendBody ( String endpointUri , ExchangePattern pattern , Object body ) ; Object sendBodyAndHeader ( String endpointUri , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( Endpoint endpoint , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( Endpoint endpoint , ExchangePattern pattern , Object body , String header , Object headerValue ) ; Object sendBodyAndHeader ( String endpoint , ExchangePattern pattern , Object body , String header , Object headerValue ) ; Object sendBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers ) ; Object sendBodyAndHeaders ( Endpoint endpoint , Object body , Map < String , Object > headers ) ; E request ( Endpoint < E > endpoint , Processor processor ) ; Object requestBody ( Endpoint < E > endpoint , Object body ) ; Object requestBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) ; E request ( String endpoint , Processor processor ) ; Object requestBody ( String endpoint , Object body ) ; Object requestBodyAndHeader ( String endpoint , Object body , String header , Object headerValue ) ; } 	1
package org . apache . camel . component . jms ; import javax . jms . Message ; import org . apache . camel . Processor ; import org . apache . camel . PollingConsumer ; import org . apache . camel . impl . DefaultEndpoint ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; public class JmsEndpoint extends DefaultEndpoint < JmsExchange > { private JmsBinding binding ; private String destination ; private final boolean pubSubDomain ; private String selector ; private JmsConfiguration configuration ; public JmsEndpoint ( String uri , JmsComponent component , String destination , boolean pubSubDomain , JmsConfiguration configuration ) { super ( uri , component ) ; this . configuration = configuration ; this . destination = destination ; this . pubSubDomain = pubSubDomain ; } public JmsProducer createProducer ( ) throws Exception { JmsOperations template = createJmsOperations ( ) ; return createProducer ( template ) ; } public JmsProducer createProducer ( JmsOperations template ) throws Exception { if ( template instanceof JmsTemplate ) { JmsTemplate jmsTemplate = ( JmsTemplate ) template ; jmsTemplate . setPubSubDomain ( pubSubDomain ) ; jmsTemplate . setDefaultDestinationName ( destination ) ; } return new JmsProducer ( this , template ) ; } public JmsConsumer createConsumer ( Processor processor ) throws Exception { AbstractMessageListenerContainer listenerContainer = configuration . createMessageListenerContainer ( ) ; return createConsumer ( processor , listenerContainer ) ; } public JmsConsumer createConsumer ( Processor processor , AbstractMessageListenerContainer listenerContainer ) throws Exception { listenerContainer . setDestinationName ( destination ) ; listenerContainer . setPubSubDomain ( pubSubDomain ) ; if ( selector != null ) { listenerContainer . setMessageSelector ( selector ) ; } return new JmsConsumer ( this , processor , listenerContainer ) ; } @ Override public PollingConsumer < JmsExchange > createPollingConsumer ( ) throws Exception { JmsOperations template = createJmsOperations ( ) ; return new JmsPollingConsumer ( this , template ) ; } public JmsExchange createExchange ( ) { return new JmsExchange ( getContext ( ) , getBinding ( ) ) ; } public JmsExchange createExchange ( Message message ) { return new JmsExchange ( getContext ( ) , getBinding ( ) , message ) ; } public JmsBinding getBinding ( ) { if ( binding == null ) { binding = new JmsBinding ( ) ; } return binding ; } public void setBinding ( JmsBinding binding ) { this . binding = binding ; } public String getDestination ( ) { return destination ; } public JmsConfiguration getConfiguration ( ) { return configuration ; } public String getSelector ( ) { return selector ; } public void setSelector ( String selector ) { this . selector = selector ; } public boolean isSingleton ( ) { return false ; } protected JmsOperations createJmsOperations ( ) { return configuration . createJmsOperations ( pubSubDomain , destination ) ; } } 	0
package org . apache . camel . processor ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class TryProcessor extends ServiceSupport implements Processor { private static final Log LOG = LogFactory . getLog ( TryProcessor . class ) ; private final Processor tryProcessor ; private final List < CatchProcessor > catchClauses ; private final Processor finallyProcessor ; public TryProcessor ( Processor tryProcessor , List < CatchProcessor > catchClauses , Processor finallyProcessor ) { this . tryProcessor = tryProcessor ; this . catchClauses = catchClauses ; this . finallyProcessor = finallyProcessor ; } public String toString ( ) { String finallyText = ( finallyProcessor == null ) ? "" : " Finally {" + finallyProcessor + "}" ; return "Try {" + tryProcessor + "} " + catchClauses + finallyText ; } public void process ( Exchange exchange ) throws Exception { Throwable e = null ; try { tryProcessor . process ( exchange ) ; e = exchange . getException ( ) ; if ( e != null && DeadLetterChannel . isFailureHandled ( exchange ) ) { e = null ; } } catch ( Exception ex ) { e = ex ; exchange . setException ( e ) ; } if ( e != null ) { try { DeadLetterChannel . setFailureHandled ( exchange , true ) ; handleException ( exchange , e ) ; } catch ( Exception ex ) { throw ex ; } catch ( Throwable ex ) { throw new RuntimeCamelException ( ex ) ; } finally { handleAll ( exchange ) ; } } else { handleAll ( exchange ) ; } } private void handleAll ( Exchange exchange ) { if ( finallyProcessor != null ) { DeadLetterChannel . setFailureHandled ( exchange , true ) ; try { finallyProcessor . process ( exchange ) ; } catch ( Exception e2 ) { LOG . warn ( "Caught exception in finally block while handling other exception: " + e2 , e2 ) ; } } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( tryProcessor , catchClauses , finallyProcessor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( tryProcessor , catchClauses , finallyProcessor ) ; } protected void handleException ( Exchange exchange , Throwable e ) throws Throwable { for ( CatchProcessor catchClause : catchClauses ) { if ( catchClause . catches ( e ) ) { exchange . setException ( e ) ; try { catchClause . process ( exchange ) ; } catch ( Exception e1 ) { LOG . warn ( "Caught exception inside catch clause: " + e1 , e1 ) ; throw e1 ; } return ; } } if ( finallyProcessor == null ) { throw e ; } } } 	1
package org . apache . camel . bam . model ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaTemplate ; import javax . persistence . Entity ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import java . util . List ; @ Entity public class ProcessDefinition extends EntitySupport { private static final transient Log log = LogFactory . getLog ( ProcessDefinition . class ) ; private String name ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public static ProcessDefinition getRefreshedProcessDefinition ( JpaTemplate template , ProcessDefinition definition ) { ObjectHelper . notNull ( definition , "definition" ) ; Long id = definition . getId ( ) ; if ( id == null ) { log . warn ( "No primary key is available!" ) ; return findOrCreateProcessDefinition ( template , definition . getName ( ) ) ; } definition = template . find ( ProcessDefinition . class , id ) ; return definition ; } public static ProcessDefinition findOrCreateProcessDefinition ( JpaTemplate template , String processName ) { List < ProcessDefinition > list = template . find ( "select x from " + ProcessDefinition . class . getName ( ) + " x where x.name = ?1" , processName ) ; if ( ! list . isEmpty ( ) ) { return list . get ( 0 ) ; } else { ProcessDefinition answer = new ProcessDefinition ( ) ; answer . setName ( processName ) ; template . persist ( answer ) ; return answer ; } } } 	0
package org . apache . camel . builder . xml ; import org . apache . camel . util . ObjectHelper ; public class Namespaces { public static final String DEFAULT_NAMESPACE = "http://activemq.apache.org/camel/schema/spring" ; public static final String IN_NAMESPACE = "http://camel.apache.org/xml/in/" ; public static final String OUT_NAMESPACE = "http://camel.apache.org/xml/out/" ; public static final String SYSTEM_PROPERTIES_NAMESPACE = "http://camel.apache.org/xml/variables/system-properties" ; public static final String ENVIRONMENT_VARIABLES = "http://camel.apache.org/xml/variables/environment-variables" ; public static final String EXCHANGE_PROPERTY = "http://camel.apache.org/xml/variables/exchange-property" ; private Namespaces ( ) { } public static boolean isMatchingNamespaceOrEmptyNamespace ( String namespaceURI , String expectedNamespace ) { return ObjectHelper . isNullOrBlank ( namespaceURI ) || namespaceURI . equals ( expectedNamespace ) ; } } 	1
package org . apache . camel . impl ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingExceptionHandler implements ExceptionHandler { private final Logger logger ; public LoggingExceptionHandler ( Class ownerType ) { this ( new Logger ( LogFactory . getLog ( ownerType ) , LoggingLevel . ERROR ) ) ; } public LoggingExceptionHandler ( Logger logger ) { this . logger = logger ; } public void handleException ( Throwable exception ) { logger . log ( exception . getMessage ( ) , exception ) ; } } 	0
package org . apache . camel . component . seda ; import java . util . concurrent . BlockingQueue ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; public class SedaEndpoint extends DefaultEndpoint < Exchange > { private final class SedaProducer extends DefaultProducer implements AsyncProcessor { private SedaProducer ( Endpoint endpoint ) { super ( endpoint ) ; } public void process ( Exchange exchange ) { queue . add ( exchange . copy ( ) ) ; } public boolean process ( Exchange exchange , AsyncCallback callback ) { queue . add ( exchange . copy ( ) ) ; callback . done ( true ) ; return true ; } } private BlockingQueue < Exchange > queue ; public SedaEndpoint ( String endpointUri , Component component , BlockingQueue < Exchange > queue ) { super ( endpointUri , component ) ; this . queue = queue ; } public SedaEndpoint ( String uri , SedaComponent component ) { this ( uri , component , component . createQueue ( ) ) ; } public Producer createProducer ( ) throws Exception { return new SedaProducer ( this ) ; } public Consumer createConsumer ( Processor processor ) throws Exception { return new SedaConsumer ( this , processor ) ; } public BlockingQueue < Exchange > getQueue ( ) { return queue ; } public boolean isSingleton ( ) { return true ; } } 	1
package org . apache . camel ; public interface Consumer < E extends Exchange > extends Service { } 	0
package org . apache . camel . model ; import org . apache . camel . Endpoint ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . ChoiceProcessor ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . FilterProcessor ; import org . apache . camel . util . CollectionStringBuffer ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; @ XmlRootElement ( name = "choice" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ChoiceType extends ProcessorType < ChoiceType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < WhenType > whenClauses = new ArrayList < WhenType > ( ) ; @ XmlElement ( required = false ) private OtherwiseType otherwise ; @ Override public String toString ( ) { return "Choice[ " + getWhenClauses ( ) + " " + getOtherwise ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; for ( WhenType whenClaus : whenClauses ) { filters . add ( whenClaus . createProcessor ( routeContext ) ) ; } Processor otherwiseProcessor = null ; if ( otherwise != null ) { otherwiseProcessor = otherwise . createProcessor ( routeContext ) ; } return new ChoiceProcessor ( filters , otherwiseProcessor ) ; } public ChoiceType when ( Predicate predicate ) { getWhenClauses ( ) . add ( new WhenType ( predicate ) ) ; return this ; } public OtherwiseType otherwise ( ) { OtherwiseType answer = new OtherwiseType ( ) ; setOtherwise ( answer ) ; return answer ; } @ Override public String getLabel ( ) { CollectionStringBuffer buffer = new CollectionStringBuffer ( ) ; List < WhenType > list = getWhenClauses ( ) ; for ( WhenType whenType : list ) { buffer . append ( whenType . getLabel ( ) ) ; } return buffer . toString ( ) ; } public List < WhenType > getWhenClauses ( ) { return whenClauses ; } public void setWhenClauses ( List < WhenType > whenClauses ) { this . whenClauses = whenClauses ; } public List < ProcessorType < ? > > getOutputs ( ) { if ( otherwise != null ) { return otherwise . getOutputs ( ) ; } else if ( whenClauses . isEmpty ( ) ) { return Collections . EMPTY_LIST ; } else { WhenType when = whenClauses . get ( whenClauses . size ( ) - 1 ) ; return when . getOutputs ( ) ; } } public OtherwiseType getOtherwise ( ) { return otherwise ; } public void setOtherwise ( OtherwiseType otherwise ) { this . otherwise = otherwise ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } } 	1
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . RecipientList ; public class RecipientListBuilder < E extends Exchange > extends BuilderSupport implements ProcessorFactory { private final Expression expression ; public RecipientListBuilder ( FromBuilder parent , Expression expression ) { super ( parent ) ; this . expression = expression ; } public Processor createProcessor ( ) { return new RecipientList ( expression ) ; } } 	0
package org . apache . camel . management ; import java . io . IOException ; import java . lang . management . ManagementFactory ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . rmi . RemoteException ; import java . rmi . registry . LocateRegistry ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import javax . management . InstanceAlreadyExistsException ; import javax . management . JMException ; import javax . management . MBeanServer ; import javax . management . MBeanServerFactory ; import javax . management . NotCompliantMBeanException ; import javax . management . ObjectInstance ; import javax . management . ObjectName ; import javax . management . modelmbean . InvalidTargetObjectTypeException ; import javax . management . modelmbean . ModelMBeanInfo ; import javax . management . modelmbean . RequiredModelMBean ; import javax . management . remote . JMXConnectorServer ; import javax . management . remote . JMXConnectorServerFactory ; import javax . management . remote . JMXServiceURL ; import org . apache . camel . CamelContext ; import org . apache . camel . CamelContextAware ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . InstrumentationAgent ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . jmx . export . annotation . AnnotationJmxAttributeSource ; import org . springframework . jmx . export . assembler . MetadataMBeanInfoAssembler ; public class InstrumentationAgentImpl extends ServiceSupport implements InstrumentationAgent , CamelContextAware { private static final transient Log LOG = LogFactory . getLog ( InstrumentationAgentImpl . class ) ; public static final String SYSTEM_PROPERTY_JMX = "org.apache.camel.jmx" ; public static final String DEFAULT_DOMAIN = "org.apache.camel" ; public static final String DEFAULT_HOST = "localhost" ; public static final int DEFAULT_PORT = 1099 ; private MBeanServer server ; private CamelContext context ; private Set < ObjectName > mbeans = new HashSet < ObjectName > ( ) ; private MetadataMBeanInfoAssembler assembler ; private JMXConnectorServer cs ; private boolean jmxEnabled = false ; private String jmxDomainName = null ; private int jmxConnectorPort = 0 ; private CamelNamingStrategy namingStrategy ; public InstrumentationAgentImpl ( ) { assembler = new MetadataMBeanInfoAssembler ( ) ; assembler . setAttributeSource ( new AnnotationJmxAttributeSource ( ) ) ; namingStrategy = new CamelNamingStrategy ( ) ; } public CamelContext getCamelContext ( ) { return context ; } public void setCamelContext ( CamelContext camelContext ) { context = camelContext ; } public void setMBeanServer ( MBeanServer server ) { this . server = server ; jmxEnabled = true ; } public MBeanServer getMBeanServer ( ) { if ( server == null ) { server = ManagementFactory . getPlatformMBeanServer ( ) ; } return server ; } public void register ( Object obj , ObjectName name ) throws JMException { register ( obj , name , false ) ; } public void register ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException { try { registerMBeanWithServer ( obj , name , forceRegistration ) ; } catch ( NotCompliantMBeanException e ) { ModelMBeanInfo mbi = null ; mbi = assembler . getMBeanInfo ( obj , name . toString ( ) ) ; RequiredModelMBean mbean = ( RequiredModelMBean ) server . instantiate ( RequiredModelMBean . class . getName ( ) ) ; mbean . setModelMBeanInfo ( mbi ) ; try { mbean . setManagedResource ( obj , "ObjectReference" ) ; } catch ( InvalidTargetObjectTypeException itotex ) { throw new JMException ( itotex . getMessage ( ) ) ; } registerMBeanWithServer ( mbean , name , forceRegistration ) ; } } public void unregister ( ObjectName name ) throws JMException { server . unregisterMBean ( name ) ; } public CamelNamingStrategy getNamingStrategy ( ) { return namingStrategy ; } public void setNamingStrategy ( CamelNamingStrategy namingStrategy ) { this . namingStrategy = namingStrategy ; } protected void doStart ( ) throws Exception { ObjectHelper . notNull ( context , "camelContext" ) ; if ( getMBeanServer ( ) == null ) { createMBeanServer ( ) ; } if ( jmxDomainName == null ) { jmxDomainName = System . getProperty ( SYSTEM_PROPERTY_JMX + ".domain" ) ; if ( jmxDomainName == null || jmxDomainName . length ( ) == 0 ) { jmxDomainName = DEFAULT_DOMAIN ; } } configureDomainName ( ) ; LOG . debug ( "Starting JMX agent on server: " + getMBeanServer ( ) ) ; if ( context instanceof DefaultCamelContext ) { DefaultCamelContext dc = ( DefaultCamelContext ) context ; InstrumentationLifecycleStrategy ls = new InstrumentationLifecycleStrategy ( this ) ; dc . setLifecycleStrategy ( ls ) ; ls . onContextCreate ( context ) ; } } protected void doStop ( ) throws Exception { Object [ ] mBeans = mbeans . toArray ( ) ; int caught = 0 ; for ( Object name : mBeans ) { mbeans . remove ( ( ObjectName ) name ) ; try { unregister ( ( ObjectName ) name ) ; } catch ( JMException jmex ) { LOG . info ( "Exception unregistering MBean" , jmex ) ; caught ++ ; } } if ( caught > 0 ) { LOG . warn ( "A number of " + caught + " exceptions caught while unregistering MBeans during stop operation.  " + "See INFO log for details." ) ; } } private void registerMBeanWithServer ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException { ObjectInstance instance = null ; try { instance = server . registerMBean ( obj , name ) ; } catch ( InstanceAlreadyExistsException e ) { if ( forceRegistration ) { server . unregisterMBean ( name ) ; instance = server . registerMBean ( obj , name ) ; } else { throw e ; } } if ( instance != null ) { mbeans . add ( name ) ; } } public void enableJmx ( String domainName , int port ) { jmxEnabled = true ; jmxDomainName = domainName ; configureDomainName ( ) ; jmxConnectorPort = port ; } protected void configureDomainName ( ) { if ( jmxDomainName != null ) { namingStrategy . setDomainName ( jmxDomainName ) ; } } protected void createMBeanServer ( ) { String hostName = DEFAULT_HOST ; boolean canAccessSystemProps = true ; try { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPropertiesAccess ( ) ; } } catch ( SecurityException se ) { canAccessSystemProps = false ; } if ( canAccessSystemProps ) { if ( ! jmxEnabled ) { jmxEnabled = null != System . getProperty ( SYSTEM_PROPERTY_JMX ) ; if ( ! jmxEnabled ) { return ; } } if ( jmxConnectorPort <= 0 ) { String portKey = SYSTEM_PROPERTY_JMX + ".port" ; String portValue = System . getProperty ( portKey ) ; if ( portValue != null && portValue . length ( ) > 0 ) { try { jmxConnectorPort = Integer . parseInt ( portValue ) ; } catch ( NumberFormatException nfe ) { LOG . info ( "Invalid port number specified via System property [" + portKey + "=" + portValue + "].  Using default: " + DEFAULT_PORT ) ; jmxConnectorPort = DEFAULT_PORT ; } } } try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException uhe ) { LOG . info ( "Cannot determine host name.  Using default: " + DEFAULT_PORT , uhe ) ; hostName = DEFAULT_HOST ; } } else { jmxDomainName = jmxDomainName != null ? jmxDomainName : DEFAULT_DOMAIN ; jmxConnectorPort = jmxConnectorPort > 0 ? jmxConnectorPort : DEFAULT_PORT ; hostName = DEFAULT_HOST ; } if ( ! jmxEnabled ) { return ; } List servers = MBeanServerFactory . findMBeanServer ( jmxDomainName ) ; if ( servers . size ( ) == 0 ) { server = MBeanServerFactory . createMBeanServer ( jmxDomainName ) ; } else { server = ( MBeanServer ) servers . get ( 0 ) ; } try { createJmxConnector ( hostName ) ; } catch ( IOException ioe ) { LOG . warn ( "Could not create and start jmx connector." , ioe ) ; } } protected void createJmxConnector ( String host ) throws IOException { if ( jmxConnectorPort > 0 ) { try { LocateRegistry . createRegistry ( jmxConnectorPort ) ; } catch ( RemoteException ex ) { LocateRegistry . getRegistry ( jmxConnectorPort ) ; } JMXServiceURL url = new JMXServiceURL ( "service:jmx:rmi:///jndi/rmi://" + host + ":" + jmxConnectorPort + "/jmxrmi" ) ; cs = JMXConnectorServerFactory . newJMXConnectorServer ( url , null , server ) ; Thread connectorThread = new Thread ( ) { public void run ( ) { try { cs . start ( ) ; } catch ( IOException ioe ) { LOG . warn ( "Could not start jmx connector thread." , ioe ) ; } } } ; connectorThread . setName ( "JMX Connector Thread [" + url + "]" ) ; connectorThread . start ( ) ; LOG . info ( "Jmx connector thread started on " + url ) ; } } } 	1
package org . apache . camel . component . jms ; import org . apache . camel . impl . PollingConsumerSupport ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . core . JmsTemplate102 ; import javax . jms . Message ; public class JmsPollingConsumer extends PollingConsumerSupport < JmsExchange > { private JmsOperations template ; public JmsPollingConsumer ( JmsEndpoint endpoint , JmsOperations template ) { super ( endpoint ) ; this . template = template ; } @ Override public JmsEndpoint getEndpoint ( ) { return ( JmsEndpoint ) super . getEndpoint ( ) ; } public JmsExchange receiveNoWait ( ) { return receive ( 0 ) ; } public JmsExchange receive ( ) { return receive ( - 1 ) ; } public JmsExchange receive ( long timeout ) { setReceiveTimeout ( timeout ) ; Message message = template . receive ( ) ; if ( message != null ) { return getEndpoint ( ) . createExchange ( message ) ; } return null ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { } protected void setReceiveTimeout ( long timeout ) { if ( template instanceof JmsTemplate ) { JmsTemplate jmsTemplate = ( JmsTemplate ) template ; jmsTemplate . setReceiveTimeout ( timeout ) ; } else if ( template instanceof JmsTemplate102 ) { JmsTemplate102 jmsTemplate102 = ( JmsTemplate102 ) template ; jmsTemplate102 . setReceiveTimeout ( timeout ) ; } else { throw new IllegalArgumentException ( "Cannot set the receiveTimeout property on unknown JmsOperations type: " + template ) ; } } } 	0
package org . apache . camel ; public class CamelExchangeException extends CamelException { private static final long serialVersionUID = - 8721487431101572630L ; private final Exchange exchange ; public CamelExchangeException ( String message , Exchange exchange ) { super ( message + " on the exchange: " + exchange ) ; this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } } 	1
package org . apache . camel . builder . xml ; import org . apache . camel . RuntimeExpressionException ; import javax . xml . xpath . XPathException ; public class InvalidXPathExpression extends RuntimeExpressionException { private final String xpath ; public InvalidXPathExpression ( String xpath , XPathException e ) { super ( "Invalid xpath: " + xpath + ". Reason: " + e , e ) ; this . xpath = xpath ; } public String getXpath ( ) { return xpath ; } } 	0
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; @ XmlRootElement ( name = "when" ) public class WhenType < Type extends ProcessorType > extends ExpressionNode { public WhenType ( ) { } public WhenType ( Predicate predicate ) { super ( predicate ) ; } public WhenType ( ExpressionType expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "When[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public FilterProcessor createProcessor ( RouteContext routeContext ) throws Exception { return createFilterProcessor ( routeContext ) ; } } 	1
package org . apache . camel . component . xmpp ; import org . apache . camel . impl . DefaultMessage ; import org . jivesoftware . smack . packet . Message ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class XmppMessage extends DefaultMessage { private Message xmppMessage ; public XmppMessage ( ) { this ( new Message ( ) ) ; } public XmppMessage ( Message jmsMessage ) { this . xmppMessage = jmsMessage ; } @ Override public String toString ( ) { if ( xmppMessage != null ) { return "XmppMessage: " + xmppMessage ; } else { return "XmppMessage: " + getBody ( ) ; } } @ Override public XmppExchange getExchange ( ) { return ( XmppExchange ) super . getExchange ( ) ; } public Message getXmppMessage ( ) { return xmppMessage ; } public void setXmppMessage ( Message xmppMessage ) { this . xmppMessage = xmppMessage ; } public Object getHeader ( String name ) { return xmppMessage . getProperty ( name ) ; } @ Override public void setHeader ( String name , Object value ) { if ( value == null ) { xmppMessage . deleteProperty ( name ) ; } else { xmppMessage . setProperty ( name , value ) ; } } @ Override public Map < String , Object > getHeaders ( ) { Map < String , Object > answer = new HashMap < String , Object > ( ) ; Iterator iter = xmppMessage . getPropertyNames ( ) ; while ( iter . hasNext ( ) ) { String name = ( String ) iter . next ( ) ; answer . put ( name , xmppMessage . getProperty ( name ) ) ; } return answer ; } @ Override public XmppMessage newInstance ( ) { return new XmppMessage ( ) ; } @ Override protected Object createBody ( ) { if ( xmppMessage != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromXmpp ( getExchange ( ) , xmppMessage ) ; } return null ; } } 	0
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . Throttler ; @ XmlRootElement ( name = "throttler" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ThrottlerType extends ProcessorType { @ XmlAttribute private Long maximumRequestsPerPeriod ; @ XmlAttribute private long timePeriodMillis = 1000 ; @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < ProcessorType > outputs = new ArrayList < ProcessorType > ( ) ; public ThrottlerType ( ) { } public ThrottlerType ( long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } @ Override public String toString ( ) { return "Throttler[" + getMaximumRequestsPerPeriod ( ) + " request per " + getTimePeriodMillis ( ) + " millis -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return "" + getMaximumRequestsPerPeriod ( ) + " per " + getTimePeriodMillis ( ) + " (ms)" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new Throttler ( childProcessor , maximumRequestsPerPeriod , timePeriodMillis ) ; } public ThrottlerType timePeriodMillis ( long timePeriodMillis ) { this . timePeriodMillis = timePeriodMillis ; return this ; } public Long getMaximumRequestsPerPeriod ( ) { return maximumRequestsPerPeriod ; } public void setMaximumRequestsPerPeriod ( Long maximumRequestsPerPeriod ) { this . maximumRequestsPerPeriod = maximumRequestsPerPeriod ; } public long getTimePeriodMillis ( ) { return timePeriodMillis ; } public void setTimePeriodMillis ( long timePeriodMillis ) { this . timePeriodMillis = timePeriodMillis ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType > outputs ) { this . outputs = outputs ; } } 	1
package org . apache . camel ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE , ElementType . METHOD } ) public @ interface Converter { } 	0
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class ChoiceProcessor extends ServiceSupport implements Processor { private List < FilterProcessor > filters = new ArrayList < FilterProcessor > ( ) ; private Processor otherwise ; public ChoiceProcessor ( List < FilterProcessor > filters , Processor otherwise ) { this . filters = filters ; this . otherwise = otherwise ; } public void process ( Exchange exchange ) throws Exception { for ( FilterProcessor filterProcessor : filters ) { Predicate < Exchange > predicate = filterProcessor . getPredicate ( ) ; if ( predicate != null && predicate . matches ( exchange ) ) { filterProcessor . getProcessor ( ) . process ( exchange ) ; return ; } } if ( otherwise != null ) { otherwise . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "choice{" ) ; boolean first = true ; for ( FilterProcessor processor : filters ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( "when " ) ; builder . append ( processor . getPredicate ( ) . toString ( ) ) ; builder . append ( ": " ) ; builder . append ( processor . getProcessor ( ) ) ; } if ( otherwise != null ) { builder . append ( ", otherwise: " ) ; builder . append ( otherwise ) ; } builder . append ( "}" ) ; return builder . toString ( ) ; } public List < FilterProcessor > getFilters ( ) { return filters ; } public Processor getOtherwise ( ) { return otherwise ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( filters ) ; ServiceHelper . startServices ( otherwise ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( otherwise ) ; ServiceHelper . stopServices ( filters ) ; } } 	1
package org . apache . camel . impl ; import org . apache . camel . Message ; import java . util . HashMap ; import java . util . Map ; public class DefaultMessage extends MessageSupport { private Map < String , Object > headers ; @ Override public String toString ( ) { return "Message: " + getBody ( ) ; } public Object getHeader ( String name ) { return getHeaders ( ) . get ( name ) ; } public < T > T getHeader ( String name , Class < T > type ) { Object value = getHeader ( name ) ; return getExchange ( ) . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setHeader ( String name , Object value ) { if ( headers == null ) { headers = createHeaders ( ) ; } headers . put ( name , value ) ; } public Map < String , Object > getHeaders ( ) { if ( headers == null ) { headers = createHeaders ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public DefaultMessage newInstance ( ) { return new DefaultMessage ( ) ; } protected Map < String , Object > createHeaders ( ) { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; populateInitialHeaders ( map ) ; return map ; } protected void populateInitialHeaders ( Map < String , Object > map ) { } } 	0
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class TopicLoadBalancer extends LoadBalancerSupport { public void process ( Exchange exchange ) throws Exception { List < Processor > list = getProcessors ( ) ; for ( Processor processor : list ) { Exchange copy = copyExchangeStrategy ( processor , exchange ) ; processor . process ( copy ) ; } } protected Exchange copyExchangeStrategy ( Processor processor , Exchange exchange ) { return exchange . copy ( ) ; } } 	1
package org . apache . camel . bam . model ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; import javax . persistence . OneToMany ; import java . util . Collection ; import java . util . Date ; import java . util . HashSet ; @ Entity public class ProcessInstance extends TemporalEntity { private static final transient Log log = LogFactory . getLog ( ProcessInstance . class ) ; private ProcessDefinition processDefinition ; private Collection < ActivityState > activityStates = new HashSet < ActivityState > ( ) ; private String correlationKey ; public ProcessInstance ( ) { setTimeStarted ( new Date ( ) ) ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[id: " + getId ( ) + ", key: " + getCorrelationKey ( ) + "]" ; } @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST } ) public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } @ OneToMany ( mappedBy = "processInstance" , fetch = FetchType . LAZY , cascade = { CascadeType . ALL } ) public Collection < ActivityState > getActivityStates ( ) { return activityStates ; } public void setActivityStates ( Collection < ActivityState > activityStates ) { this . activityStates = activityStates ; } public String getCorrelationKey ( ) { return correlationKey ; } public void setCorrelationKey ( String correlationKey ) { this . correlationKey = correlationKey ; } public ActivityState getActivityState ( ActivityRules activityRules ) { for ( ActivityState activityState : getActivityStates ( ) ) { if ( activityState . isActivity ( activityRules ) ) { return activityState ; } } return null ; } public ActivityState getOrCreateActivityState ( ActivityRules activityRules ) { ActivityState state = getActivityState ( activityRules ) ; if ( state == null ) { state = createActivityState ( ) ; state . setProcessInstance ( this ) ; state . setActivityDefinition ( activityRules . getActivityDefinition ( ) ) ; } return state ; } protected ActivityState createActivityState ( ) { return new ActivityState ( ) ; } } 	0
package org . apache . camel . language . simple ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . language . IllegalSyntaxException ; import org . apache . camel . spi . Language ; import org . apache . camel . util . ObjectHelper ; public class SimpleLanguage implements Language { public static Expression simple ( String expression ) { SimpleLanguage language = new SimpleLanguage ( ) ; return language . createExpression ( expression ) ; } public Predicate < Exchange > createPredicate ( String expression ) { return PredicateBuilder . toPredicate ( createExpression ( expression ) ) ; } public Expression < Exchange > createExpression ( String expression ) { if ( expression . indexOf ( "${" ) >= 0 ) { return createComplexExpression ( expression ) ; } return createSimpleExpression ( expression ) ; } protected Expression < Exchange > createComplexExpression ( String expression ) { List < Expression > results = new ArrayList < Expression > ( ) ; int pivot = 0 ; int size = expression . length ( ) ; while ( pivot < size ) { int idx = expression . indexOf ( "${" , pivot ) ; if ( idx < 0 ) { results . add ( createConstantExpression ( expression , pivot , size ) ) ; break ; } else { if ( pivot < idx ) { results . add ( createConstantExpression ( expression , pivot , idx ) ) ; } pivot = idx + 2 ; int endIdx = expression . indexOf ( "}" , pivot ) ; if ( endIdx < 0 ) { throw new IllegalArgumentException ( "Expecting } but found end of string for simple expression: " + expression ) ; } String simpleText = expression . substring ( pivot , endIdx ) ; Expression simpleExpression = createSimpleExpression ( simpleText ) ; results . add ( simpleExpression ) ; pivot = endIdx + 1 ; } } return ExpressionBuilder . concatExpression ( results , expression ) ; } protected Expression createConstantExpression ( String expression , int start , int end ) { return ExpressionBuilder . constantExpression ( expression . substring ( start , end ) ) ; } protected Expression < Exchange > createSimpleExpression ( String expression ) { if ( ObjectHelper . isEqualToAny ( expression , "body" , "in.body" ) ) { return ExpressionBuilder . bodyExpression ( ) ; } else if ( ObjectHelper . equals ( expression , "out.body" ) ) { return ExpressionBuilder . outBodyExpression ( ) ; } String remainder = ifStartsWithReturnRemainder ( "in.header." , expression ) ; if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "header." , expression ) ; } if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "headers." , expression ) ; } if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "in.headers." , expression ) ; } if ( remainder != null ) { return ExpressionBuilder . headerExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "out.header." , expression ) ; if ( remainder == null ) { remainder = ifStartsWithReturnRemainder ( "out.headers." , expression ) ; } if ( remainder != null ) { return ExpressionBuilder . outHeaderExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "property." , expression ) ; if ( remainder != null ) { return ExpressionBuilder . propertyExpression ( remainder ) ; } remainder = ifStartsWithReturnRemainder ( "sys." , expression ) ; if ( remainder != null ) { return ExpressionBuilder . propertyExpression ( remainder ) ; } throw new IllegalSyntaxException ( this , expression ) ; } protected String ifStartsWithReturnRemainder ( String prefix , String text ) { if ( text . startsWith ( prefix ) ) { String remainder = text . substring ( prefix . length ( ) ) ; if ( remainder . length ( ) > 0 ) { return remainder ; } } return null ; } } 	1
package org . apache . camel . component . file ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import java . io . File ; import java . util . Map ; public class FileComponent extends DefaultComponent < FileExchange > { public FileComponent ( ) { } public FileComponent ( CamelContext context ) { super ( context ) ; } protected Endpoint < FileExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { File file = new File ( remaining ) ; FileEndpoint result = new FileEndpoint ( file , remaining , this ) ; IntrospectionSupport . setProperties ( result , parameters ) ; return result ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . PollingConsumer ; import org . apache . camel . util . ObjectHelper ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; public abstract class DefaultEndpoint < E extends Exchange > implements Endpoint < E > { private String endpointUri ; private CamelContext context ; private Component component ; private ScheduledExecutorService executorService ; private ExchangePattern exchangePattern = ExchangePattern . InOnly ; protected DefaultEndpoint ( String endpointUri , Component component ) { this ( endpointUri , component . getCamelContext ( ) ) ; this . component = component ; } protected DefaultEndpoint ( String endpointUri , CamelContext context ) { this . endpointUri = endpointUri ; this . context = context ; } public int hashCode ( ) { return endpointUri . hashCode ( ) * 37 + 1 ; } @ Override public boolean equals ( Object object ) { if ( object instanceof DefaultEndpoint ) { DefaultEndpoint that = ( DefaultEndpoint ) object ; return ObjectHelper . equals ( this . endpointUri , that . endpointUri ) ; } return false ; } @ Override public String toString ( ) { return "Endpoint[" + endpointUri + "]" ; } public String getEndpointUri ( ) { return endpointUri ; } public CamelContext getContext ( ) { return context ; } public Component getComponent ( ) { return component ; } public synchronized ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { Component c = getComponent ( ) ; if ( c != null && c instanceof DefaultComponent ) { DefaultComponent dc = ( DefaultComponent ) c ; executorService = dc . getExecutorService ( ) ; } if ( executorService == null ) { executorService = createExecutorService ( ) ; } } return executorService ; } public synchronized void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } public PollingConsumer < E > createPollingConsumer ( ) throws Exception { return new EventDrivenPollingConsumer < E > ( this ) ; } public E convertTo ( Class < E > type , Exchange exchange ) { if ( type . isInstance ( exchange ) ) { return type . cast ( exchange ) ; } return getContext ( ) . getExchangeConverter ( ) . convertTo ( type , exchange ) ; } public E createExchange ( Exchange exchange ) { Class < E > exchangeType = getExchangeType ( ) ; if ( exchangeType != null ) { if ( exchangeType . isInstance ( exchange ) ) { return exchangeType . cast ( exchange ) ; } } E answer = createExchange ( ) ; answer . copyFrom ( exchange ) ; return answer ; } public Class < E > getExchangeType ( ) { Type type = getClass ( ) . getGenericSuperclass ( ) ; if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type [ ] arguments = parameterizedType . getActualTypeArguments ( ) ; if ( arguments . length > 0 ) { Type argumentType = arguments [ 0 ] ; if ( argumentType instanceof Class ) { return ( Class < E > ) argumentType ; } } } return null ; } public E createExchange ( ) { return createExchange ( getExchangePattern ( ) ) ; } public E createExchange ( ExchangePattern pattern ) { return ( E ) new DefaultExchange ( getContext ( ) , pattern ) ; } public ExchangePattern getExchangePattern ( ) { return exchangePattern ; } public void setExchangePattern ( ExchangePattern exchangePattern ) { this . exchangePattern = exchangePattern ; } protected ScheduledThreadPoolExecutor createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( 10 ) ; } } 	1
package org . apache . camel . component . mail ; import org . apache . camel . impl . DefaultMessage ; import org . apache . camel . util . CollectionHelper ; import javax . mail . Header ; import javax . mail . Message ; import javax . mail . MessagingException ; import java . util . Enumeration ; import java . util . Map ; public class MailMessage extends DefaultMessage { private Message mailMessage ; public MailMessage ( ) { } public MailMessage ( Message message ) { this . mailMessage = message ; } @ Override public String toString ( ) { if ( mailMessage != null ) { return "MailMessage: " + mailMessage ; } else { return "MailMessage: " + getBody ( ) ; } } @ Override public MailExchange getExchange ( ) { return ( MailExchange ) super . getExchange ( ) ; } public Message getMessage ( ) { return mailMessage ; } public void setMessage ( Message mailMessage ) { this . mailMessage = mailMessage ; } public Object getHeader ( String name ) { String [ ] answer = null ; if ( mailMessage != null ) { try { answer = mailMessage . getHeader ( name ) ; } catch ( MessagingException e ) { throw new MessageHeaderAccessException ( name , e ) ; } } if ( answer == null ) { return super . getHeader ( name ) ; } if ( answer . length == 1 ) { return answer [ 0 ] ; } return answer ; } @ Override public MailMessage newInstance ( ) { return new MailMessage ( ) ; } @ Override protected Object createBody ( ) { if ( mailMessage != null ) { return getExchange ( ) . getBinding ( ) . extractBodyFromMail ( getExchange ( ) , mailMessage ) ; } return null ; } @ Override protected void populateInitialHeaders ( Map < String , Object > map ) { if ( mailMessage != null ) { Enumeration names ; try { names = mailMessage . getAllHeaders ( ) ; } catch ( MessagingException e ) { throw new MessageHeaderNamesAccessException ( e ) ; } try { while ( names . hasMoreElements ( ) ) { Header header = ( Header ) names . nextElement ( ) ; String value = header . getValue ( ) ; String name = header . getName ( ) ; CollectionHelper . appendValue ( map , name , value ) ; } } catch ( Throwable e ) { throw new MessageHeaderNamesAccessException ( e ) ; } } } } 	0
package org . apache . camel . impl ; import java . util . Collection ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . model . RouteType ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . Route ; import org . apache . camel . Service ; public class DefaultLifecycleStrategy implements LifecycleStrategy { public void onContextCreate ( CamelContext context ) { } public void onEndpointAdd ( Endpoint endpoint ) { } public void onServiceAdd ( CamelContext context , Service service ) { } public void onRoutesAdd ( Collection < Route > routes ) { } public void beforeStartRouteType ( CamelContext context , RouteType routeType ) { } } 	1
package org . apache . camel . component . pojo ; import java . lang . reflect . Method ; public class PojoInvocation { private final Object proxy ; private final Method method ; private final Object [ ] args ; public PojoInvocation ( Object proxy , Method method , Object [ ] args ) { this . proxy = proxy ; this . method = method ; this . args = args ; } public Object [ ] getArgs ( ) { return args ; } public Method getMethod ( ) { return method ; } public Object getProxy ( ) { return proxy ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . impl . converter . TypeConverterRegistry ; public class CachingInjector < T > { private final TypeConverterRegistry repository ; private final Class < T > type ; private T instance ; public CachingInjector ( TypeConverterRegistry repository , Class < T > type ) { this . repository = repository ; this . type = type ; } public synchronized T newInstance ( ) { if ( instance == null ) { instance = createInstance ( type ) ; } return instance ; } protected T createInstance ( Class < T > t ) { return ( T ) repository . getInjector ( ) . newInstance ( t ) ; } } 	1
package org . apache . camel . impl ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . PollingConsumer ; import org . apache . camel . processor . Logger ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . TimeUnit ; public class DefaultPollingConsumer < E extends Exchange > extends PollingConsumerSupport < E > implements Processor { private static final transient Log log = LogFactory . getLog ( DefaultPollingConsumer . class ) ; private BlockingQueue < E > queue ; private ExceptionHandler interuptedExceptionHandler = new LoggingExceptionHandler ( new Logger ( log ) ) ; private Consumer < E > consumer ; public DefaultPollingConsumer ( Endpoint < E > endpoint ) { this ( endpoint , new ArrayBlockingQueue < E > ( 1000 ) ) ; } public DefaultPollingConsumer ( Endpoint < E > endpoint , BlockingQueue < E > queue ) { super ( endpoint ) ; this . queue = queue ; } public E receiveNoWait ( ) { return receive ( 0 ) ; } public E receive ( ) { while ( ! isStopping ( ) && ! isStopped ( ) ) { try { return queue . take ( ) ; } catch ( InterruptedException e ) { handleInteruptedException ( e ) ; } } return null ; } public E receive ( long timeout ) { try { return queue . poll ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { handleInteruptedException ( e ) ; return null ; } } public void process ( Exchange exchange ) throws Exception { queue . offer ( ( E ) exchange ) ; } public ExceptionHandler getInteruptedExceptionHandler ( ) { return interuptedExceptionHandler ; } public void setInteruptedExceptionHandler ( ExceptionHandler interuptedExceptionHandler ) { this . interuptedExceptionHandler = interuptedExceptionHandler ; } protected void handleInteruptedException ( InterruptedException e ) { getInteruptedExceptionHandler ( ) . handleException ( e ) ; } protected void doStart ( ) throws Exception { consumer = getEndpoint ( ) . createConsumer ( this ) ; consumer . start ( ) ; } protected void doStop ( ) throws Exception { if ( consumer != null ) { try { consumer . stop ( ) ; } finally { consumer = null ; } } } } 	0
package org . apache . camel . processor . resequencer ; import java . util . Queue ; import java . util . Timer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class ResequencerEngine < E > implements TimeoutHandler { private static final Log LOG = LogFactory . getLog ( ResequencerEngine . class ) ; private long timeout ; private int capacity ; private Queue < E > outQueue ; private Element < E > lastDelivered ; private Sequence < Element < E > > sequence ; private Timer timer ; public ResequencerEngine ( SequenceElementComparator < E > comparator ) { this ( comparator , Integer . MAX_VALUE ) ; } public ResequencerEngine ( SequenceElementComparator < E > comparator , int capacity ) { this . timer = new Timer ( "Resequencer Timer" ) ; this . sequence = createSequence ( comparator ) ; this . capacity = capacity ; this . timeout = 2000L ; this . lastDelivered = null ; } public void stop ( ) { this . timer . cancel ( ) ; } public Queue < E > getOutQueue ( ) { return outQueue ; } public void setOutQueue ( Queue < E > outQueue ) { this . outQueue = outQueue ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public synchronized void timeout ( Timeout timout ) { try { while ( deliver ( ) ) { } } catch ( RuntimeException e ) { LOG . error ( "error during delivery" , e ) ; } } public synchronized void add ( E o ) { if ( sequence . size ( ) >= capacity ) { throw new IllegalStateException ( "maximum capacity is reached" ) ; } insert ( o ) ; } public synchronized void put ( E o ) throws InterruptedException { if ( sequence . size ( ) >= capacity ) { wait ( ) ; } insert ( o ) ; } E getLastDelivered ( ) { if ( lastDelivered == null ) { return null ; } return lastDelivered . getObject ( ) ; } void setLastDelivered ( E o ) { lastDelivered = new Element < E > ( o ) ; } private void insert ( E o ) { Element < E > element = new Element < E > ( o ) ; sequence . add ( element ) ; Element < E > successor = sequence . successor ( element ) ; if ( successor != null ) { successor . cancel ( ) ; } if ( successorOfLastDelivered ( element ) ) { } else if ( sequence . predecessor ( element ) != null ) { } else { Timeout t = defineTimeout ( ) ; element . schedule ( t ) ; } while ( deliver ( ) ) { } } private boolean deliver ( ) { if ( sequence . size ( ) == 0 ) { return false ; } Element < E > element = sequence . first ( ) ; if ( element . scheduled ( ) ) { return false ; } sequence . remove ( element ) ; lastDelivered = element ; notify ( ) ; outQueue . add ( element . getObject ( ) ) ; return true ; } private boolean successorOfLastDelivered ( Element < E > element ) { if ( lastDelivered == null ) { return false ; } if ( sequence . comparator ( ) . successor ( element , lastDelivered ) ) { return true ; } return false ; } private Timeout defineTimeout ( ) { Timeout result = new Timeout ( timer , timeout ) ; result . addTimeoutHandler ( this ) ; return result ; } private static < E > Sequence < Element < E > > createSequence ( SequenceElementComparator < E > comparator ) { return new Sequence < Element < E > > ( new ElementComparator < E > ( comparator ) ) ; } } 	1
package org . apache . camel . impl ; import org . apache . camel . impl . converter . TypeConverterRegistry ; public class CachingInjector < T > { private final TypeConverterRegistry repository ; private final Class < T > type ; private T instance ; public CachingInjector ( TypeConverterRegistry repository , Class < T > type ) { this . repository = repository ; this . type = type ; } public synchronized T newInstance ( ) { if ( instance == null ) { instance = createInstance ( type ) ; } return instance ; } protected T createInstance ( Class < T > type ) { return ( T ) repository . getInjector ( ) . newInstance ( type ) ; } } 	0
package org . apache . camel ; public class RuntimeCamelException extends RuntimeException { private static final long serialVersionUID = 8046489554418284257L ; public RuntimeCamelException ( ) { } public RuntimeCamelException ( String message ) { super ( message ) ; } public RuntimeCamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeCamelException ( Throwable cause ) { super ( cause ) ; } } 	1
package org . apache . camel . component . mail ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; import javax . mail . Message ; public class MailExchange extends DefaultExchange { private MailBinding binding ; public MailExchange ( CamelContext context , MailBinding binding ) { super ( context ) ; this . binding = binding ; } public MailExchange ( CamelContext context , MailBinding binding , Message message ) { this ( context , binding ) ; setIn ( new MailMessage ( message ) ) ; } @ Override public MailMessage getIn ( ) { return ( MailMessage ) super . getIn ( ) ; } @ Override public MailMessage getOut ( ) { return ( MailMessage ) super . getOut ( ) ; } @ Override public MailMessage getOut ( boolean lazyCreate ) { return ( MailMessage ) super . getOut ( lazyCreate ) ; } @ Override public MailMessage getFault ( ) { return ( MailMessage ) super . getFault ( ) ; } public MailBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new MailExchange ( getContext ( ) , binding ) ; } @ Override protected MailMessage createInMessage ( ) { return new MailMessage ( ) ; } @ Override protected MailMessage createOutMessage ( ) { return new MailMessage ( ) ; } } 	0
package org . apache . camel . impl . converter ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import org . apache . camel . TypeConverter ; public class ArrayTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > type , Object value ) { if ( type . isArray ( ) ) { if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; Object array = Array . newInstance ( type . getComponentType ( ) , collection . size ( ) ) ; if ( array instanceof Object [ ] ) { collection . toArray ( ( Object [ ] ) array ) ; } else { int index = 0 ; for ( Object element : collection ) { Array . set ( array , index ++ , element ) ; } } return ( T ) array ; } else if ( value != null && value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; Object answer = Array . newInstance ( type . getComponentType ( ) , size ) ; for ( int i = 0 ; i < size ; i ++ ) { Array . set ( answer , i , Array . get ( value , i ) ) ; } return ( T ) answer ; } } else if ( Collection . class . isAssignableFrom ( type ) ) { if ( value != null ) { if ( value instanceof Object [ ] ) { return ( T ) Arrays . asList ( ( Object [ ] ) value ) ; } else if ( value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; List answer = new ArrayList ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { answer . add ( Array . get ( value , i ) ) ; } return ( T ) answer ; } } } return null ; } } 	1
package org . apache . camel . bam . model ; import javax . persistence . Transient ; import java . util . Date ; public abstract class TemporalEntity extends EntitySupport { private Date timeStarted ; private Date timeCompleted ; @ Transient public boolean isStarted ( ) { return timeStarted != null ; } @ Transient public boolean isCompleted ( ) { return timeCompleted != null ; } public Date getTimeStarted ( ) { return timeStarted ; } public void setTimeStarted ( Date timeStarted ) { this . timeStarted = timeStarted ; } public Date getTimeCompleted ( ) { return timeCompleted ; } public void setTimeCompleted ( Date timeCompleted ) { this . timeCompleted = timeCompleted ; } } 	0
package org . apache . camel . component . direct ; import java . util . ArrayList ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DirectEndpoint < E extends Exchange > extends DefaultEndpoint < E > { private final class DirectProducer extends DefaultProducer implements AsyncProcessor { private DirectProducer ( Endpoint endpoint ) { super ( endpoint ) ; } public void process ( Exchange exchange ) throws Exception { if ( consumers . isEmpty ( ) ) { LOG . warn ( "No consumers available on " + this + " for " + exchange ) ; } else { for ( DefaultConsumer < E > consumer : consumers ) { consumer . getProcessor ( ) . process ( exchange ) ; } } } public boolean process ( Exchange exchange , AsyncCallback callback ) { int size = consumers . size ( ) ; if ( size == 0 ) { LOG . warn ( "No consumers available on " + this + " for " + exchange ) ; } else { if ( size > 1 ) { try { for ( DefaultConsumer < E > consumer : consumers ) { consumer . getProcessor ( ) . process ( exchange ) ; } } catch ( Throwable error ) { exchange . setException ( error ) ; } } else { for ( DefaultConsumer < E > consumer : consumers ) { AsyncProcessor processor = AsyncProcessorTypeConverter . convert ( consumer . getProcessor ( ) ) ; return processor . process ( exchange , callback ) ; } } } callback . done ( true ) ; return true ; } } private static final Log LOG = LogFactory . getLog ( DirectEndpoint . class ) ; boolean allowMultipleConsumers = true ; private final CopyOnWriteArrayList < DefaultConsumer < E > > consumers = new CopyOnWriteArrayList < DefaultConsumer < E > > ( ) ; public DirectEndpoint ( String uri , DirectComponent < E > component ) { super ( uri , component ) ; } public Producer createProducer ( ) throws Exception { return new DirectProducer ( this ) ; } public Consumer < E > createConsumer ( Processor processor ) throws Exception { return new DefaultConsumer < E > ( this , processor ) { @ Override public void start ( ) throws Exception { if ( ! allowMultipleConsumers && ! consumers . isEmpty ( ) ) { throw new IllegalStateException ( "Endpoint " + getEndpointUri ( ) + " only allows 1 active consumer but you attempted to start a 2nd consumer." ) ; } consumers . add ( this ) ; super . start ( ) ; } @ Override public void stop ( ) throws Exception { super . stop ( ) ; consumers . remove ( this ) ; } } ; } public boolean isAllowMultipleConsumers ( ) { return allowMultipleConsumers ; } public void setAllowMultipleConsumers ( boolean allowMutlipleConsumers ) { this . allowMultipleConsumers = allowMutlipleConsumers ; } public boolean isSingleton ( ) { return true ; } } 	1
package org . apache . camel ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public abstract class Route < E extends Exchange > { private final Map < String , Object > properties = new HashMap < String , Object > ( 16 ) ; private Endpoint < E > endpoint ; private List < Service > services = new ArrayList < Service > ( ) ; public Route ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Map < String , Object > getProperties ( ) { return properties ; } public List < Service > getServicesForRoute ( ) throws Exception { List < Service > servicesForRoute = new ArrayList < Service > ( getServices ( ) ) ; addServices ( servicesForRoute ) ; return servicesForRoute ; } public List < Service > getServices ( ) throws Exception { return services ; } public void setServices ( List < Service > services ) { this . services = services ; } protected abstract void addServices ( List < Service > services ) throws Exception ; } 	0
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public class NoErrorHandlerBuilder extends ErrorHandlerBuilderSupport { public ErrorHandlerBuilder copy ( ) { return this ; } public Processor createErrorHandler ( Processor processor ) { return processor ; } } 	1
package org . apache . camel . spi ; import org . apache . camel . Processor ; public interface Policy < E > { Processor wrap ( Processor processor ) ; } 	0
package org . apache . camel ; import java . util . HashMap ; import java . util . Map ; public enum ExchangePattern { InOnly , RobustInOnly , InOut , InOptionalOut , OutOnly , RobustOutOnly , OutIn , OutOptionalIn ; protected static final Map < String , ExchangePattern > map = new HashMap < String , ExchangePattern > ( ) ; public String getWsdlUri ( ) { switch ( this ) { case InOnly : return "http://www.w3.org/ns/wsdl/in-only" ; case InOptionalOut : return "http://www.w3.org/ns/wsdl/in-optional-out" ; case InOut : return "http://www.w3.org/ns/wsdl/in-out" ; case OutIn : return "http://www.w3.org/ns/wsdl/out-in" ; case OutOnly : return "http://www.w3.org/ns/wsdl/out-only" ; case OutOptionalIn : return "http://www.w3.org/ns/wsdl/out-optional_in" ; case RobustInOnly : return "http://www.w3.org/ns/wsdl/robust-in-only" ; case RobustOutOnly : return "http://www.w3.org/ns/wsdl/robust-out-only" ; default : throw new IllegalArgumentException ( "Unknown message exchange pattern: " + this ) ; } } public boolean isInCapable ( ) { switch ( this ) { case OutOnly : case RobustOutOnly : return true ; default : return false ; } } public boolean isOutCapable ( ) { switch ( this ) { case InOnly : case RobustInOnly : return false ; default : return true ; } } public boolean isFaultCapable ( ) { switch ( this ) { case InOnly : case OutOnly : return false ; default : return true ; } } public static ExchangePattern fromWsdlUri ( String wsdlUri ) { return map . get ( wsdlUri ) ; } static { for ( ExchangePattern mep : values ( ) ) { String uri = mep . getWsdlUri ( ) ; map . put ( uri , mep ) ; String name = uri . substring ( uri . lastIndexOf ( '/' ) ) ; map . put ( "http://www.w3.org/2004/08/wsdl/" + name , mep ) ; map . put ( "http://www.w3.org/2006/01/wsdl/" + name , mep ) ; } } } 	1
package org . apache . camel . util ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class ExpressionHelper { public static < E extends Exchange > String evaluateAsString ( Expression < E > expression , E exchange ) { return evaluateAsType ( expression , exchange , String . class ) ; } public static < T , E extends Exchange > T evaluateAsType ( Expression < E > expression , E exchange , Class < T > resultType ) { Object value = expression . evaluate ( exchange ) ; return exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( resultType , value ) ; } } 	0
package org . apache . camel . model ; import org . apache . camel . processor . RedeliveryPolicy ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "redeliveryPolicy" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RedeliveryPolicyType { private Integer maximumRedeliveries ; private Long initialRedeliveryDelay ; private Double backOffMultiplier ; private Boolean useExponentialBackOff ; private Double collisionAvoidanceFactor ; private Boolean useCollisionAvoidance ; public RedeliveryPolicy createRedeliveryPolicy ( RedeliveryPolicy parentPolicy ) { RedeliveryPolicy answer = parentPolicy . copy ( ) ; if ( maximumRedeliveries != null ) { answer . setMaximumRedeliveries ( maximumRedeliveries ) ; } if ( initialRedeliveryDelay != null ) { answer . setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; } if ( backOffMultiplier != null ) { answer . setBackOffMultiplier ( backOffMultiplier ) ; } if ( useExponentialBackOff != null ) { answer . setUseExponentialBackOff ( useExponentialBackOff ) ; } if ( collisionAvoidanceFactor != null ) { answer . setCollisionAvoidanceFactor ( collisionAvoidanceFactor ) ; } if ( useCollisionAvoidance != null ) { answer . setUseCollisionAvoidance ( useCollisionAvoidance ) ; } return answer ; } public String toString ( ) { return "RedeliveryPolicy[maxRedeliveries: " + maximumRedeliveries + "]" ; } public RedeliveryPolicyType backOffMultiplier ( double backOffMultiplier ) { setBackOffMultiplier ( backOffMultiplier ) ; return this ; } public RedeliveryPolicyType collisionAvoidancePercent ( double collisionAvoidancePercent ) { setCollisionAvoidanceFactor ( collisionAvoidancePercent * 0.01d ) ; return this ; } public RedeliveryPolicyType collisionAvoidanceFactor ( double collisionAvoidanceFactor ) { setCollisionAvoidanceFactor ( collisionAvoidanceFactor ) ; return this ; } public RedeliveryPolicyType initialRedeliveryDelay ( long initialRedeliveryDelay ) { setInitialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public RedeliveryPolicyType maximumRedeliveries ( int maximumRedeliveries ) { setMaximumRedeliveries ( maximumRedeliveries ) ; return this ; } public RedeliveryPolicyType useCollisionAvoidance ( ) { setUseCollisionAvoidance ( true ) ; return this ; } public RedeliveryPolicyType useExponentialBackOff ( ) { setUseExponentialBackOff ( true ) ; return this ; } public Double getBackOffMultiplier ( ) { return backOffMultiplier ; } public void setBackOffMultiplier ( Double backOffMultiplier ) { this . backOffMultiplier = backOffMultiplier ; } public Double getCollisionAvoidanceFactor ( ) { return collisionAvoidanceFactor ; } public void setCollisionAvoidanceFactor ( Double collisionAvoidanceFactor ) { this . collisionAvoidanceFactor = collisionAvoidanceFactor ; } public Long getInitialRedeliveryDelay ( ) { return initialRedeliveryDelay ; } public void setInitialRedeliveryDelay ( Long initialRedeliveryDelay ) { this . initialRedeliveryDelay = initialRedeliveryDelay ; } public Integer getMaximumRedeliveries ( ) { return maximumRedeliveries ; } public void setMaximumRedeliveries ( Integer maximumRedeliveries ) { this . maximumRedeliveries = maximumRedeliveries ; } public Boolean getUseCollisionAvoidance ( ) { return useCollisionAvoidance ; } public void setUseCollisionAvoidance ( Boolean useCollisionAvoidance ) { this . useCollisionAvoidance = useCollisionAvoidance ; } public Boolean getUseExponentialBackOff ( ) { return useExponentialBackOff ; } public void setUseExponentialBackOff ( Boolean useExponentialBackOff ) { this . useExponentialBackOff = useExponentialBackOff ; } } 	1
package org . apache . camel ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface MessageDriven { String uri ( ) default "" ; String name ( ) default "" ; } 	0
package org . apache . camel . processor . loadbalancer ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . Processor ; public abstract class LoadBalancerSupport implements LoadBalancer { private List < Processor > processors = new CopyOnWriteArrayList < Processor > ( ) ; public void addProcessor ( Processor processor ) { processors . add ( processor ) ; } public void removeProcessor ( Processor processor ) { processors . remove ( processor ) ; } public List < Processor > getProcessors ( ) { return processors ; } } 	1
package org . apache . camel . bam . processor ; import org . apache . camel . CamelException ; import org . apache . camel . Exchange ; public class NoCorrelationKeyException extends CamelException { private BamProcessorSupport processor ; private Exchange exchange ; public NoCorrelationKeyException ( BamProcessorSupport processor , Exchange exchange ) { super ( "No correlation key could be found for " + processor . getCorrelationKeyExpression ( ) + " on " + exchange ) ; this . processor = processor ; this . exchange = exchange ; } public Exchange getExchange ( ) { return exchange ; } public BamProcessorSupport getProcessor ( ) { return processor ; } } 	0
package org . apache . camel . processor ; import java . util . concurrent . RejectedExecutionException ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . util . AsyncProcessorHelper ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannel extends ErrorHandlerSupport implements AsyncProcessor { public static final String REDELIVERY_COUNTER = "org.apache.camel.RedeliveryCounter" ; public static final String REDELIVERED = "org.apache.camel.Redelivered" ; private class RedeliveryData { int redeliveryCounter ; long redeliveryDelay ; boolean sync = true ; RedeliveryPolicy currentRedeliveryPolicy = redeliveryPolicy ; Processor failureProcessor = deadLetter ; } private static final transient Log LOG = LogFactory . getLog ( DeadLetterChannel . class ) ; private static final String FAILURE_HANDLED_PROPERTY = DeadLetterChannel . class . getName ( ) + ".FAILURE_HANDLED" ; private Processor output ; private Processor deadLetter ; private AsyncProcessor outputAsync ; private RedeliveryPolicy redeliveryPolicy ; private Logger logger ; public DeadLetterChannel ( Processor output , Processor deadLetter ) { this ( output , deadLetter , new RedeliveryPolicy ( ) , DeadLetterChannel . createDefaultLogger ( ) ) ; } public DeadLetterChannel ( Processor output , Processor deadLetter , RedeliveryPolicy redeliveryPolicy , Logger logger ) { this . deadLetter = deadLetter ; this . output = output ; this . outputAsync = AsyncProcessorTypeConverter . convert ( output ) ; this . redeliveryPolicy = redeliveryPolicy ; this . logger = logger ; } public static < E extends Exchange > Logger createDefaultLogger ( ) { return new Logger ( LOG , LoggingLevel . ERROR ) ; } @ Override public String toString ( ) { return "DeadLetterChannel[" + output + ", " + deadLetter + ", " + redeliveryPolicy + "]" ; } public boolean process ( Exchange exchange , final AsyncCallback callback ) { return process ( exchange , callback , new RedeliveryData ( ) ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback , final RedeliveryData data ) { while ( true ) { if ( ! isRunAllowed ( ) ) { if ( exchange . getException ( ) == null ) { exchange . setException ( new RejectedExecutionException ( ) ) ; } callback . done ( data . sync ) ; return data . sync ; } if ( exchange . getException ( ) != null ) { Throwable e = exchange . getException ( ) ; exchange . setException ( null ) ; logger . log ( "On delivery attempt: " + data . redeliveryCounter + " caught: " + e , e ) ; data . redeliveryCounter = incrementRedeliveryCounter ( exchange , e ) ; ExceptionType exceptionPolicy = getExceptionPolicy ( exchange , e ) ; if ( exceptionPolicy != null ) { data . currentRedeliveryPolicy = exceptionPolicy . createRedeliveryPolicy ( data . currentRedeliveryPolicy ) ; Processor processor = exceptionPolicy . getErrorHandler ( ) ; if ( processor != null ) { data . failureProcessor = processor ; } } } if ( ! data . currentRedeliveryPolicy . shouldRedeliver ( data . redeliveryCounter ) ) { setFailureHandled ( exchange , true ) ; AsyncProcessor afp = AsyncProcessorTypeConverter . convert ( data . failureProcessor ) ; return afp . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { callback . done ( data . sync ) ; } } ) ; } if ( data . redeliveryCounter > 0 ) { data . redeliveryDelay = data . currentRedeliveryPolicy . getRedeliveryDelay ( data . redeliveryDelay ) ; sleep ( data . redeliveryDelay ) ; } exchange . setException ( null ) ; boolean sync = outputAsync . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { if ( sync ) { return ; } data . sync = false ; if ( exchange . getException ( ) != null ) { process ( exchange , callback , data ) ; } else { callback . done ( sync ) ; } } } ) ; if ( ! sync ) { return false ; } if ( exchange . getException ( ) == null || isFailureHandled ( exchange ) ) { callback . done ( true ) ; return true ; } } } public static boolean isFailureHandled ( Exchange exchange ) { Boolean rc = exchange . getProperty ( FAILURE_HANDLED_PROPERTY , Boolean . class ) ; return rc == null ? false : rc ; } public static void setFailureHandled ( Exchange exchange , boolean b ) { exchange . setProperty ( FAILURE_HANDLED_PROPERTY , b ? Boolean . TRUE : Boolean . FALSE ) ; } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public Processor getOutput ( ) { return output ; } public Processor getDeadLetter ( ) { return deadLetter ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } protected int incrementRedeliveryCounter ( Exchange exchange , Throwable e ) { Message in = exchange . getIn ( ) ; Integer counter = in . getHeader ( REDELIVERY_COUNTER , Integer . class ) ; int next = 1 ; if ( counter != null ) { next = counter + 1 ; } in . setHeader ( REDELIVERY_COUNTER , next ) ; in . setHeader ( REDELIVERED , true ) ; exchange . setException ( e ) ; return next ; } protected void sleep ( long redeliveryDelay ) { if ( redeliveryDelay > 0 ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Sleeping for: " + redeliveryDelay + " until attempting redelivery" ) ; } try { Thread . sleep ( redeliveryDelay ) ; } catch ( InterruptedException e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Thread interupted: " + e , e ) ; } } } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( output , deadLetter ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( deadLetter , output ) ; } } 	1
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . Splitter ; public class SplitterBuilder extends FromBuilder { private final Expression expression ; public SplitterBuilder ( FromBuilder parent , Expression expression ) { super ( parent ) ; this . expression = expression ; } public Processor createProcessor ( ) throws Exception { Processor destination = super . createProcessor ( ) ; return new Splitter ( destination , expression ) ; } } 	0
package org . apache . camel . processor . resequencer ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . concurrent . BlockingQueue ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class SequenceSender extends Thread { private static final Log LOG = LogFactory . getLog ( SequenceSender . class ) ; private static final Exchange STOP = createStopSignal ( ) ; private BlockingQueue < Exchange > queue ; private Processor processor ; public SequenceSender ( Processor processor ) { this . processor = processor ; } public void setQueue ( BlockingQueue < Exchange > queue ) { this . queue = queue ; } public void run ( ) { while ( true ) { try { Exchange exchange = queue . take ( ) ; if ( exchange == STOP ) { LOG . info ( "exit processing loop after cancellation" ) ; return ; } processor . process ( exchange ) ; } catch ( InterruptedException e ) { LOG . info ( "exit processing loop after interrupt" ) ; return ; } catch ( Exception e ) { LOG . warn ( "exception during exchange processing" ) ; } } } public void cancel ( ) throws InterruptedException { queue . put ( STOP ) ; } private static Exchange createStopSignal ( ) { return ( Exchange ) Proxy . newProxyInstance ( SequenceSender . class . getClassLoader ( ) , new Class [ ] { Exchange . class } , createStopHandler ( ) ) ; } private static InvocationHandler createStopHandler ( ) { return new InvocationHandler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { throw new RuntimeException ( "illegal method invocation on stop signal" ) ; } } ; } } 	1
package org . apache . camel . spring . xml ; import org . apache . camel . builder . RouteBuilder ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . BeanFactory ; import java . util . ArrayList ; public class StatementRouteBuilder extends RouteBuilder { private ArrayList < BuilderStatement > routes ; private BeanFactory beanFactory ; @ Override public void configure ( ) { for ( BuilderStatement routeFactory : routes ) { routeFactory . create ( beanFactory , this ) ; } } public ArrayList < BuilderStatement > getRoutes ( ) { return routes ; } public void setRoutes ( ArrayList < BuilderStatement > routes ) { this . routes = routes ; } public void setBeanFactory ( BeanFactory beanFactory ) { this . beanFactory = beanFactory ; } } 	0
package org . apache . camel . spi ; import javax . management . JMException ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import org . apache . camel . Service ; import org . apache . camel . management . CamelNamingStrategy ; public interface InstrumentationAgent extends Service { void register ( Object obj , ObjectName name ) throws JMException ; void register ( Object obj , ObjectName name , boolean forceRegistration ) throws JMException ; void unregister ( ObjectName name ) throws JMException ; MBeanServer getMBeanServer ( ) ; CamelNamingStrategy getNamingStrategy ( ) ; } 	1
package org . apache . camel . component . cxf ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . cxf . endpoint . ServerImpl ; import org . apache . cxf . frontend . ServerFactoryBean ; import org . apache . cxf . message . Message ; public class CxfInvokeConsumer extends DefaultConsumer < CxfExchange > { protected CxfInvokeEndpoint cxfEndpoint ; private ServerImpl server ; public CxfInvokeConsumer ( CxfInvokeEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . cxfEndpoint = endpoint ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( server != null ) { ServerFactoryBean svrBean = new ServerFactoryBean ( ) ; svrBean . setAddress ( getEndpoint ( ) . getEndpointUri ( ) ) ; svrBean . setServiceClass ( Class . forName ( cxfEndpoint . getProperty ( CxfConstants . IMPL ) ) ) ; svrBean . setBus ( cxfEndpoint . getBus ( ) ) ; server = ( ServerImpl ) svrBean . create ( ) ; server . start ( ) ; } } @ Override protected void doStop ( ) throws Exception { if ( server != null ) { server . stop ( ) ; server = null ; } super . doStop ( ) ; } protected void incomingCxfMessage ( Message message ) { try { CxfExchange exchange = cxfEndpoint . createExchange ( message ) ; getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } 	0
package org . apache . camel . component . file ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . component . file . strategy . DefaultFileRenamer ; import org . apache . camel . component . file . strategy . DeleteFileProcessStrategy ; import org . apache . camel . component . file . strategy . FileProcessStrategy ; import org . apache . camel . component . file . strategy . FileProcessStrategySupport ; import org . apache . camel . component . file . strategy . NoOpFileProcessStrategy ; import org . apache . camel . component . file . strategy . RenameFileProcessStrategy ; import org . apache . camel . impl . ScheduledPollEndpoint ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; public class FileEndpoint extends ScheduledPollEndpoint < FileExchange > { private static final transient Log LOG = LogFactory . getLog ( FileEndpoint . class ) ; private File file ; private FileProcessStrategy fileProcessStrategy ; private boolean autoCreate = true ; private boolean lock = true ; private boolean delete ; private boolean noop ; private boolean append = true ; private String moveNamePrefix ; private String moveNamePostfix ; private String [ ] excludedNamePrefixes = { "." } ; private String [ ] excludedNamePostfixes = { FileProcessStrategySupport . DEFAULT_LOCK_FILE_POSTFIX } ; private int bufferSize = 128 * 1024 ; private boolean ignoreFileNameHeader ; protected FileEndpoint ( File file , String endpointUri , FileComponent component ) { super ( endpointUri , component ) ; this . file = file ; } public Producer < FileExchange > createProducer ( ) throws Exception { Producer < FileExchange > result = new FileProducer ( this ) ; return result ; } public Consumer < FileExchange > createConsumer ( Processor file ) throws Exception { Consumer < FileExchange > result = new FileConsumer ( this , file ) ; configureConsumer ( result ) ; return result ; } public FileExchange createExchange ( File file ) { return new FileExchange ( getContext ( ) , getExchangePattern ( ) , file ) ; } public FileExchange createExchange ( ) { return createExchange ( getFile ( ) ) ; } public FileExchange createExchange ( ExchangePattern pattern ) { return new FileExchange ( getContext ( ) , pattern , file ) ; } public void configureMessage ( File file , Message message ) { message . setBody ( file ) ; String path = file . getPath ( ) ; String relativePath = path . substring ( path . length ( ) ) ; if ( relativePath . startsWith ( File . separator ) || relativePath . startsWith ( "/" ) ) { relativePath = relativePath . substring ( 1 ) ; } message . setHeader ( FileComponent . HEADER_FILE_NAME , relativePath ) ; } public File getFile ( ) { if ( autoCreate && ! file . exists ( ) ) { file . mkdirs ( ) ; } return file ; } public boolean isSingleton ( ) { return true ; } public boolean isAutoCreate ( ) { return this . autoCreate ; } public void setAutoCreate ( boolean autoCreate ) { this . autoCreate = autoCreate ; } public FileProcessStrategy getFileStrategy ( ) { if ( fileProcessStrategy == null ) { fileProcessStrategy = createFileStrategy ( ) ; LOG . debug ( "" + this + " using strategy: " + fileProcessStrategy ) ; } return fileProcessStrategy ; } public void setFileStrategy ( FileProcessStrategy fileProcessStrategy ) { this . fileProcessStrategy = fileProcessStrategy ; } public boolean isDelete ( ) { return delete ; } public void setDelete ( boolean delete ) { this . delete = delete ; } public boolean isLock ( ) { return lock ; } public void setLock ( boolean lock ) { this . lock = lock ; } public String getMoveNamePostfix ( ) { return moveNamePostfix ; } public void setMoveNamePostfix ( String moveNamePostfix ) { this . moveNamePostfix = moveNamePostfix ; } public String getMoveNamePrefix ( ) { return moveNamePrefix ; } public void setMoveNamePrefix ( String moveNamePrefix ) { this . moveNamePrefix = moveNamePrefix ; } public String [ ] getExcludedNamePrefixes ( ) { return excludedNamePrefixes ; } public void setExcludedNamePrefixes ( String [ ] excludedNamePrefixes ) { this . excludedNamePrefixes = excludedNamePrefixes ; } public String [ ] getExcludedNamePostfixes ( ) { return excludedNamePostfixes ; } public void setExcludedNamePostfixes ( String [ ] excludedNamePostfixes ) { this . excludedNamePostfixes = excludedNamePostfixes ; } public boolean isNoop ( ) { return noop ; } public void setNoop ( boolean noop ) { this . noop = noop ; } public boolean isAppend ( ) { return append ; } public void setAppend ( boolean append ) { this . append = append ; } public int getBufferSize ( ) { return bufferSize ; } public void setBufferSize ( int bufferSize ) { this . bufferSize = bufferSize ; } public boolean isIgnoreFileNameHeader ( ) { return ignoreFileNameHeader ; } public void setIgnoreFileNameHeader ( boolean ignoreFileNameHeader ) { this . ignoreFileNameHeader = ignoreFileNameHeader ; } protected FileProcessStrategy createFileStrategy ( ) { if ( isNoop ( ) ) { return new NoOpFileProcessStrategy ( ) ; } else if ( moveNamePostfix != null || moveNamePrefix != null ) { if ( isDelete ( ) ) { throw new IllegalArgumentException ( "You cannot set the deleteFiles property and a moveFilenamePostfix or moveFilenamePrefix" ) ; } return new RenameFileProcessStrategy ( isLock ( ) , moveNamePrefix , moveNamePostfix ) ; } else if ( isDelete ( ) ) { return new DeleteFileProcessStrategy ( isLock ( ) ) ; } else { return new RenameFileProcessStrategy ( isLock ( ) ) ; } } } 	1
package org . apache . camel . spring . util ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . Expression ; import org . apache . camel . Exchange ; import org . apache . camel . Endpoint ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Message ; import org . apache . camel . builder . ExpressionBuilder ; public class DefaultMethodInvocationStrategy implements MethodInvocationStrategy { private Map < Class , Expression > parameterTypeToExpressionMap = new ConcurrentHashMap < Class , Expression > ( ) ; public DefaultMethodInvocationStrategy ( ) { } public synchronized Expression getDefaultParameterTypeExpression ( Class parameterType ) { return parameterTypeToExpressionMap . get ( parameterType ) ; } public synchronized void addParameterMapping ( Class parameterType , Expression expression ) { parameterTypeToExpressionMap . put ( parameterType , expression ) ; } public void loadDefaultRegistry ( ) { addParameterMapping ( Exchange . class , ExpressionBuilder . exchangeExpression ( ) ) ; addParameterMapping ( Message . class , ExpressionBuilder . inMessageExpression ( ) ) ; } } 	0
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import java . util . Collection ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . builder . ErrorHandlerBuilder ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "onException" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ExceptionType extends ProcessorType < ProcessorType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElement ( name = "redeliveryPolicy" , required = false ) private RedeliveryPolicyType redeliveryPolicy ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; @ XmlTransient private Processor errorHandler ; public ExceptionType ( ) { } public ExceptionType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public ExceptionType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Exception[ " + getExceptionClasses ( ) + " -> " + getOutputs ( ) + "]" ; } public RedeliveryPolicy createRedeliveryPolicy ( RedeliveryPolicy parentPolicy ) { if ( redeliveryPolicy != null ) { return redeliveryPolicy . createRedeliveryPolicy ( parentPolicy ) ; } else if ( errorHandler != null ) { RedeliveryPolicy answer = parentPolicy . copy ( ) ; answer . setMaximumRedeliveries ( 0 ) ; return answer ; } return parentPolicy ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { errorHandler = routeContext . createProcessor ( this ) ; ErrorHandlerBuilder builder = routeContext . getRoute ( ) . getErrorHandlerBuilder ( ) ; builder . addErrorHandlers ( this ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public ExceptionType backOffMultiplier ( double backOffMultiplier ) { getOrCreateRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public ExceptionType collisionAvoidanceFactor ( double collisionAvoidanceFactor ) { getOrCreateRedeliveryPolicy ( ) . collisionAvoidanceFactor ( collisionAvoidanceFactor ) ; return this ; } public ExceptionType collisionAvoidancePercent ( short collisionAvoidancePercent ) { getOrCreateRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public ExceptionType initialRedeliveryDelay ( long initialRedeliveryDelay ) { getOrCreateRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public ExceptionType maximumRedeliveries ( int maximumRedeliveries ) { getOrCreateRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public ExceptionType useCollisionAvoidance ( ) { getOrCreateRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public ExceptionType useExponentialBackOff ( ) { getOrCreateRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } public Processor getErrorHandler ( ) { return errorHandler ; } public RedeliveryPolicyType getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicyType redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } protected RedeliveryPolicyType getOrCreateRedeliveryPolicy ( ) { if ( redeliveryPolicy == null ) { redeliveryPolicy = new RedeliveryPolicyType ( ) ; } return redeliveryPolicy ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	1
package org . apache . camel . component . cxf ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . cxf . BusException ; import org . apache . cxf . message . Message ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . local . LocalTransportFactory ; public class CxfEndpoint extends DefaultEndpoint < CxfExchange > { private CxfBinding binding ; private final CxfComponent component ; private final EndpointInfo endpointInfo ; private boolean inOut = true ; public CxfEndpoint ( String uri , CxfComponent component , EndpointInfo endpointInfo ) { super ( uri , component ) ; this . component = component ; this . endpointInfo = endpointInfo ; } public Producer < CxfExchange > createProducer ( ) throws Exception { return new CxfProducer ( this , getLocalTransportFactory ( ) ) ; } public Consumer < CxfExchange > createConsumer ( Processor processor ) throws Exception { return new CxfConsumer ( this , processor , getLocalTransportFactory ( ) ) ; } public CxfExchange createExchange ( ) { return new CxfExchange ( getContext ( ) , getBinding ( ) ) ; } public CxfExchange createExchange ( Message inMessage ) { return new CxfExchange ( getContext ( ) , getBinding ( ) , inMessage ) ; } public CxfBinding getBinding ( ) { if ( binding == null ) { binding = new CxfBinding ( ) ; } return binding ; } public void setBinding ( CxfBinding binding ) { this . binding = binding ; } public boolean isInOut ( ) { return inOut ; } public void setInOut ( boolean inOut ) { this . inOut = inOut ; } public LocalTransportFactory getLocalTransportFactory ( ) throws BusException { return component . getLocalTransportFactory ( ) ; } public EndpointInfo getEndpointInfo ( ) { return endpointInfo ; } public CxfComponent getComponent ( ) { return component ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; public abstract class MessageSupport implements Message { private static final UuidGenerator DEFALT_ID_GENERATOR = new UuidGenerator ( ) ; private Exchange exchange ; private Object body ; private String messageId = DEFALT_ID_GENERATOR . generateId ( ) ; public Object getBody ( ) { if ( body == null ) { body = createBody ( ) ; } return body ; } @ SuppressWarnings ( { "unchecked" } ) public < T > T getBody ( Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { return e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , getBody ( ) ) ; } return ( T ) getBody ( ) ; } public void setBody ( Object body ) { this . body = body ; } public < T > void setBody ( Object value , Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { T v = e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; if ( v != null ) { value = v ; } } setBody ( value ) ; } public Message copy ( ) { Message answer = newInstance ( ) ; answer . copyFrom ( this ) ; return answer ; } public void copyFrom ( Message that ) { setMessageId ( that . getMessageId ( ) ) ; setBody ( that . getBody ( ) ) ; getHeaders ( ) . putAll ( that . getHeaders ( ) ) ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public abstract Message newInstance ( ) ; protected Object createBody ( ) { return null ; } public String getMessageId ( ) { return this . messageId ; } public void setMessageId ( String messageId ) { this . messageId = messageId ; } } 	1
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . Iterator ; public class StickyLoadBalancer extends QueueLoadBalancer { private Expression < Exchange > correlationExpression ; private QueueLoadBalancer loadBalancer ; private int numberOfHashGroups = 64 * 1024 ; private Map < Object , Processor > stickyMap = new HashMap < Object , Processor > ( ) ; public StickyLoadBalancer ( Expression < Exchange > correlationExpression ) { this ( correlationExpression , new RoundRobinLoadBalancer ( ) ) ; } public StickyLoadBalancer ( Expression < Exchange > correlationExpression , QueueLoadBalancer loadBalancer ) { this . correlationExpression = correlationExpression ; this . loadBalancer = loadBalancer ; } protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { Object value = correlationExpression . evaluate ( exchange ) ; Object key = getStickyKey ( value ) ; Processor processor ; synchronized ( stickyMap ) { processor = stickyMap . get ( key ) ; if ( processor == null ) { processor = loadBalancer . chooseProcessor ( processors , exchange ) ; stickyMap . put ( key , processor ) ; } } return processor ; } @ Override public void removeProcessor ( Processor processor ) { synchronized ( stickyMap ) { Iterator < Map . Entry < Object , Processor > > iter = stickyMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < Object , Processor > entry = iter . next ( ) ; if ( processor . equals ( entry . getValue ( ) ) ) { iter . remove ( ) ; } } } super . removeProcessor ( processor ) ; } public int getNumberOfHashGroups ( ) { return numberOfHashGroups ; } public void setNumberOfHashGroups ( int numberOfHashGroups ) { this . numberOfHashGroups = numberOfHashGroups ; } protected Object getStickyKey ( Object value ) { int hashCode = 37 ; if ( value != null ) { hashCode = value . hashCode ( ) ; } if ( numberOfHashGroups > 0 ) { hashCode = hashCode % numberOfHashGroups ; } return hashCode ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . CamelContext ; import org . apache . camel . Expression ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . spi . Language ; public class ExpressionClause < T extends ProcessorType > { private T result ; private CamelContext camelContext ; public T el ( String text ) { return language ( "el" , text ) ; } public T groovy ( String text ) { return language ( "groovy" , text ) ; } public T javaScript ( String text ) { return language ( "js" , text ) ; } public T ognl ( String text ) { return language ( "ognl" , text ) ; } public T php ( String text ) { return language ( "php" , text ) ; } public T python ( String text ) { return language ( "python" , text ) ; } public T ruby ( String text ) { return language ( "ruby" , text ) ; } public T sql ( String text ) { return language ( "sql" , text ) ; } public T simple ( String text ) { return language ( "simple" , text ) ; } public T xpath ( String text ) { return language ( "xpath" , text ) ; } public T xqery ( String text ) { return language ( "xqery" , text ) ; } public T language ( String languageName , String text ) { Expression expression = createExpression ( "el" , text ) ; return result ; } protected Expression createExpression ( String languageName , String text ) { Language language = camelContext . resolveLanguage ( languageName ) ; if ( language == null ) { throw new IllegalArgumentException ( "Could not resolve language: " + languageName ) ; } return language . createExpression ( text ) ; } } 	1
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Expression ; import org . apache . camel . processor . idempotent . IdempotentConsumer ; import org . apache . camel . processor . idempotent . MessageIdRepository ; public class IdempotentConsumerBuilder extends FromBuilder implements ProcessorFactory { private final Expression messageIdExpression ; private final MessageIdRepository messageIdRegistry ; public IdempotentConsumerBuilder ( FromBuilder fromBuilder , Expression messageIdExpression , MessageIdRepository messageIdRegistry ) { super ( fromBuilder ) ; this . messageIdRegistry = messageIdRegistry ; this . messageIdExpression = messageIdExpression ; } public MessageIdRepository getMessageIdRegistry ( ) { return messageIdRegistry ; } @ Override protected Processor wrapInErrorHandler ( Processor processor ) throws Exception { return processor ; } @ Override protected Processor wrapProcessor ( Processor processor ) { return new IdempotentConsumer ( messageIdExpression , messageIdRegistry , processor ) ; } } 	0
package org . apache . camel . component . file . strategy ; import java . io . File ; import java . io . IOException ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class RenameFileProcessStrategy extends FileProcessStrategySupport { private static final transient Log LOG = LogFactory . getLog ( RenameFileProcessStrategy . class ) ; private FileRenamer renamer ; public RenameFileProcessStrategy ( ) { this ( true ) ; } public RenameFileProcessStrategy ( boolean lock ) { this ( lock , ".camel/" , "" ) ; } public RenameFileProcessStrategy ( boolean lock , String namePrefix , String namePostfix ) { this ( lock , new DefaultFileRenamer ( namePrefix , namePostfix ) ) ; } public RenameFileProcessStrategy ( boolean lock , FileRenamer renamer ) { super ( lock ) ; this . renamer = renamer ; } public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { File newName = renamer . renameFile ( file ) ; newName . getParentFile ( ) . mkdirs ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Renaming file: " + file + " to: " + newName ) ; } boolean renamed = file . renameTo ( newName ) ; if ( ! renamed ) { throw new IOException ( "Could not rename file from: " + file + " to " + newName ) ; } super . commit ( endpoint , exchange , file ) ; } public FileRenamer getRenamer ( ) { return renamer ; } public void setRenamer ( FileRenamer renamer ) { this . renamer = renamer ; } } 	1
package org . apache . camel . component . quartz ; import org . apache . camel . CamelContext ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . quartz . JobDetail ; import org . quartz . Scheduler ; import org . quartz . SchedulerException ; import org . quartz . SchedulerFactory ; import org . quartz . Trigger ; import org . quartz . CronTrigger ; import org . quartz . impl . StdSchedulerFactory ; import java . util . Map ; import java . net . URI ; import com . sun . jndi . toolkit . url . Uri ; public class QuartzComponent extends DefaultComponent < QuartzExchange > { private static final transient Log log = LogFactory . getLog ( QuartzComponent . class ) ; private SchedulerFactory factory ; private Scheduler scheduler ; private Map < Trigger , JobDetail > triggers ; public QuartzComponent ( ) { } public QuartzComponent ( CamelContext context ) { super ( context ) ; } @ Override protected QuartzEndpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { QuartzEndpoint answer = new QuartzEndpoint ( uri , this , getScheduler ( ) ) ; URI u = new URI ( uri ) ; String name ; String group = "Camel" ; String path = u . getPath ( ) ; CronTrigger cronTrigger = null ; if ( path != null && path . length ( ) > 1 ) { if ( path . startsWith ( "/" ) ) { path = path . substring ( 1 ) ; } int idx = path . indexOf ( '/' ) ; if ( idx > 0 ) { cronTrigger = new CronTrigger ( ) ; name = path . substring ( 0 , idx ) ; String cronExpression = path . substring ( idx + 1 ) ; cronExpression = cronExpression . replace ( '/' , ' ' ) ; cronExpression = cronExpression . replace ( '$' , '?' ) ; log . debug ( "Creating cron trigger: " + cronExpression ) ; cronTrigger . setCronExpression ( cronExpression ) ; answer . setTrigger ( cronTrigger ) ; } else { name = path ; } group = u . getHost ( ) ; } else { name = u . getHost ( ) ; } Trigger trigger = cronTrigger ; if ( trigger == null ) { trigger = answer . getTrigger ( ) ; } trigger . setName ( name ) ; trigger . setGroup ( group ) ; Map triggerParameters = IntrospectionSupport . extractProperties ( parameters , "trigger." ) ; Map jobParameters = IntrospectionSupport . extractProperties ( parameters , "job." ) ; IntrospectionSupport . setProperties ( trigger , triggerParameters ) ; IntrospectionSupport . setProperties ( answer . getJobDetail ( ) , jobParameters ) ; return answer ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; getScheduler ( ) . start ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( scheduler != null ) { scheduler . shutdown ( ) ; } super . doStop ( ) ; } public SchedulerFactory getFactory ( ) { if ( factory == null ) { factory = createSchedulerFactory ( ) ; } return factory ; } public void setFactory ( SchedulerFactory factory ) { this . factory = factory ; } public Scheduler getScheduler ( ) throws SchedulerException { if ( scheduler == null ) { scheduler = createScheduler ( ) ; } return scheduler ; } public void setScheduler ( Scheduler scheduler ) { this . scheduler = scheduler ; } public Map getTriggers ( ) { return triggers ; } public void setTriggers ( Map triggers ) { this . triggers = triggers ; } protected SchedulerFactory createSchedulerFactory ( ) { return new StdSchedulerFactory ( ) ; } protected Scheduler createScheduler ( ) throws SchedulerException { return getFactory ( ) . getScheduler ( ) ; } } 	0
package org . apache . camel ; public class NoTypeConversionAvailableException extends RuntimeCamelException { private final Object value ; private final Class type ; public NoTypeConversionAvailableException ( Object value , Class type ) { super ( "No converter available to convert value: " + value + " to the required type: " + type . getName ( ) ) ; this . value = value ; this . type = type ; } public Object getValue ( ) { return value ; } public Class getType ( ) { return type ; } } 	1
package org . apache . camel . impl . converter ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; import org . apache . camel . TypeConverter ; public class PropertyEditorTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value == null ) return null ; if ( value . getClass ( ) == String . class ) { if ( toType == String . class ) { return toType . cast ( value ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( toType ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return toType . cast ( editor . getValue ( ) ) ; } } else if ( toType == String . class ) { PropertyEditor editor = PropertyEditorManager . findEditor ( value . getClass ( ) ) ; if ( editor != null ) { editor . setValue ( value ) ; return toType . cast ( editor . getAsText ( ) ) ; } } return null ; } } 	0
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . processor . TryProcessor ; @ XmlRootElement ( name = "try" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TryType extends OutputType < TryType > { @ XmlTransient private List < CatchType > catchClauses ; @ XmlTransient private FinallyType finallyClause ; @ XmlTransient private boolean initialized ; @ XmlTransient private List < ProcessorType < ? > > outputsWithoutCatches ; @ Override public String toString ( ) { return "Try[ " + getOutputs ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { Processor tryProcessor = createOutputsProcessor ( routeContext , getOutputsWithoutCatches ( ) ) ; Processor finallyProcessor = null ; if ( finallyClause != null ) { finallyProcessor = finallyClause . createProcessor ( routeContext ) ; } List < CatchProcessor > catchProcessors = new ArrayList < CatchProcessor > ( ) ; if ( catchClauses != null ) { for ( CatchType catchClause : catchClauses ) { catchProcessors . add ( catchClause . createProcessor ( routeContext ) ) ; } } return new TryProcessor ( tryProcessor , catchProcessors , finallyProcessor ) ; } public CatchType handle ( Class < ? > exceptionType ) { CatchType answer = new CatchType ( exceptionType ) ; addOutput ( answer ) ; return answer ; } public FinallyType handleAll ( ) { FinallyType answer = new FinallyType ( ) ; addOutput ( answer ) ; return answer ; } public List < CatchType > getCatchClauses ( ) { if ( catchClauses == null ) { checkInitialized ( ) ; } return catchClauses ; } public FinallyType getFinallyClause ( ) { if ( finallyClause == null ) { checkInitialized ( ) ; } return finallyClause ; } public List < ProcessorType < ? > > getOutputsWithoutCatches ( ) { if ( outputsWithoutCatches == null ) { checkInitialized ( ) ; } return outputsWithoutCatches ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { initialized = false ; super . setOutputs ( outputs ) ; } public void addOutput ( ProcessorType output ) { initialized = false ; getOutputs ( ) . add ( output ) ; } protected void checkInitialized ( ) { if ( ! initialized ) { initialized = true ; outputsWithoutCatches = new ArrayList < ProcessorType < ? > > ( ) ; catchClauses = new ArrayList < CatchType > ( ) ; finallyClause = null ; for ( ProcessorType output : outputs ) { if ( output instanceof CatchType ) { catchClauses . add ( ( CatchType ) output ) ; } else if ( output instanceof FinallyType ) { if ( finallyClause != null ) { throw new IllegalArgumentException ( "Multiple finally clauses added: " + finallyClause + " and " + output ) ; } else { finallyClause = ( FinallyType ) output ; } } else { outputsWithoutCatches . add ( output ) ; } } } } } 	1
package org . apache . camel . spi ; import java . io . IOException ; import java . io . OutputStream ; public interface Marshaller { void marshal ( Object graph , OutputStream stream ) throws IOException ; } 	0
package org . apache . camel . impl . converter ; public interface TypeConverterLoader { void load ( TypeConverterRegistry registry ) throws Exception ; } 	1
package org . apache . camel . component . jms ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . util . IntrospectionSupport ; import static org . apache . camel . util . ObjectHelper . removeStartingCharacters ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . listener . serversession . ServerSessionFactory ; import org . springframework . jms . support . converter . MessageConverter ; import org . springframework . transaction . PlatformTransactionManager ; import javax . jms . ConnectionFactory ; import javax . jms . ExceptionListener ; import javax . jms . Session ; import java . util . Map ; public class JmsComponent extends DefaultComponent < JmsExchange > { public static final String QUEUE_PREFIX = "queue:" ; public static final String TOPIC_PREFIX = "topic:" ; private JmsConfiguration configuration ; public static JmsComponent jmsComponent ( ) { return new JmsComponent ( ) ; } public static JmsComponent jmsComponent ( JmsConfiguration configuration ) { return new JmsComponent ( configuration ) ; } public static JmsComponent jmsComponent ( ConnectionFactory connectionFactory ) { return jmsComponent ( new JmsConfiguration ( connectionFactory ) ) ; } public static JmsComponent jmsComponentClientAcknowledge ( ConnectionFactory connectionFactory ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setAcknowledgementMode ( Session . CLIENT_ACKNOWLEDGE ) ; return jmsComponent ( template ) ; } public static JmsComponent jmsComponentAutoAcknowledge ( ConnectionFactory connectionFactory ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setAcknowledgementMode ( Session . AUTO_ACKNOWLEDGE ) ; return jmsComponent ( template ) ; } public static JmsComponent jmsComponentTransacted ( ConnectionFactory connectionFactory ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setTransacted ( true ) ; return jmsComponent ( template ) ; } public static JmsComponent jmsComponentTransacted ( ConnectionFactory connectionFactory , PlatformTransactionManager transactionManager ) { JmsConfiguration template = new JmsConfiguration ( connectionFactory ) ; template . setTransactionManager ( transactionManager ) ; template . setTransacted ( true ) ; return jmsComponent ( template ) ; } public JmsComponent ( ) { } public JmsComponent ( JmsConfiguration configuration ) { this . configuration = configuration ; } public JmsComponent ( CamelContext context ) { super ( context ) ; } @ Override protected Endpoint < JmsExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { boolean pubSubDomain = false ; if ( remaining . startsWith ( QUEUE_PREFIX ) ) { pubSubDomain = false ; remaining = removeStartingCharacters ( remaining . substring ( QUEUE_PREFIX . length ( ) ) , '/' ) ; } else if ( remaining . startsWith ( TOPIC_PREFIX ) ) { pubSubDomain = true ; remaining = removeStartingCharacters ( remaining . substring ( TOPIC_PREFIX . length ( ) ) , '/' ) ; } final String subject = convertPathToActualDestination ( remaining ) ; JmsEndpoint endpoint = new JmsEndpoint ( uri , this , subject , pubSubDomain , getConfiguration ( ) . copy ( ) ) ; String selector = ( String ) parameters . remove ( "selector" ) ; if ( selector != null ) { endpoint . setSelector ( selector ) ; } IntrospectionSupport . setProperties ( endpoint . getConfiguration ( ) , parameters ) ; return endpoint ; } public JmsConfiguration getConfiguration ( ) { if ( configuration == null ) { configuration = createConfiguration ( ) ; } return configuration ; } public void setConfiguration ( JmsConfiguration configuration ) { this . configuration = configuration ; } public void setAcceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping ) { getConfiguration ( ) . setAcceptMessagesWhileStopping ( acceptMessagesWhileStopping ) ; } public void setAcknowledgementMode ( int consumerAcknowledgementMode ) { getConfiguration ( ) . setAcknowledgementMode ( consumerAcknowledgementMode ) ; } public void setAcknowledgementModeName ( String consumerAcknowledgementMode ) { getConfiguration ( ) . setAcknowledgementModeName ( consumerAcknowledgementMode ) ; } public void setAutoStartup ( boolean autoStartup ) { getConfiguration ( ) . setAutoStartup ( autoStartup ) ; } public void setCacheLevel ( int cacheLevel ) { getConfiguration ( ) . setCacheLevel ( cacheLevel ) ; } public void setCacheLevelName ( String cacheName ) { getConfiguration ( ) . setCacheLevelName ( cacheName ) ; } public void setClientId ( String consumerClientId ) { getConfiguration ( ) . setClientId ( consumerClientId ) ; } public void setConcurrentConsumers ( int concurrentConsumers ) { getConfiguration ( ) . setConcurrentConsumers ( concurrentConsumers ) ; } public void setConnectionFactory ( ConnectionFactory connectionFactory ) { getConfiguration ( ) . setConnectionFactory ( connectionFactory ) ; } public void setConsumerType ( ConsumerType consumerType ) { getConfiguration ( ) . setConsumerType ( consumerType ) ; } public void setDeliveryPersistent ( boolean deliveryPersistent ) { getConfiguration ( ) . setDeliveryPersistent ( deliveryPersistent ) ; } public void setDurableSubscriptionName ( String durableSubscriptionName ) { getConfiguration ( ) . setDurableSubscriptionName ( durableSubscriptionName ) ; } public void setExceptionListener ( ExceptionListener exceptionListener ) { getConfiguration ( ) . setExceptionListener ( exceptionListener ) ; } public void setExplicitQosEnabled ( boolean explicitQosEnabled ) { getConfiguration ( ) . setExplicitQosEnabled ( explicitQosEnabled ) ; } public void setExposeListenerSession ( boolean exposeListenerSession ) { getConfiguration ( ) . setExposeListenerSession ( exposeListenerSession ) ; } public void setIdleTaskExecutionLimit ( int idleTaskExecutionLimit ) { getConfiguration ( ) . setIdleTaskExecutionLimit ( idleTaskExecutionLimit ) ; } public void setMaxConcurrentConsumers ( int maxConcurrentConsumers ) { getConfiguration ( ) . setMaxConcurrentConsumers ( maxConcurrentConsumers ) ; } public void setMaxMessagesPerTask ( int maxMessagesPerTask ) { getConfiguration ( ) . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } public void setMessageConverter ( MessageConverter messageConverter ) { getConfiguration ( ) . setMessageConverter ( messageConverter ) ; } public void setMessageIdEnabled ( boolean messageIdEnabled ) { getConfiguration ( ) . setMessageIdEnabled ( messageIdEnabled ) ; } public void setMessageTimestampEnabled ( boolean messageTimestampEnabled ) { getConfiguration ( ) . setMessageTimestampEnabled ( messageTimestampEnabled ) ; } public void setPriority ( int priority ) { getConfiguration ( ) . setPriority ( priority ) ; } public void setPubSubNoLocal ( boolean pubSubNoLocal ) { getConfiguration ( ) . setPubSubNoLocal ( pubSubNoLocal ) ; } public void setReceiveTimeout ( long receiveTimeout ) { getConfiguration ( ) . setReceiveTimeout ( receiveTimeout ) ; } public void setRecoveryInterval ( long recoveryInterval ) { getConfiguration ( ) . setRecoveryInterval ( recoveryInterval ) ; } public void setServerSessionFactory ( ServerSessionFactory serverSessionFactory ) { getConfiguration ( ) . setServerSessionFactory ( serverSessionFactory ) ; } public void setSubscriptionDurable ( boolean subscriptionDurable ) { getConfiguration ( ) . setSubscriptionDurable ( subscriptionDurable ) ; } public void setTaskExecutor ( TaskExecutor taskExecutor ) { getConfiguration ( ) . setTaskExecutor ( taskExecutor ) ; } public void setTimeToLive ( long timeToLive ) { getConfiguration ( ) . setTimeToLive ( timeToLive ) ; } public void setTransacted ( boolean consumerTransacted ) { getConfiguration ( ) . setTransacted ( consumerTransacted ) ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { getConfiguration ( ) . setTransactionManager ( transactionManager ) ; } public void setTransactionName ( String transactionName ) { getConfiguration ( ) . setTransactionName ( transactionName ) ; } public void setTransactionTimeout ( int transactionTimeout ) { getConfiguration ( ) . setTransactionTimeout ( transactionTimeout ) ; } public void setUseVersion102 ( boolean useVersion102 ) { getConfiguration ( ) . setUseVersion102 ( useVersion102 ) ; } protected String convertPathToActualDestination ( String path ) { return path ; } protected JmsConfiguration createConfiguration ( ) { return new JmsConfiguration ( ) ; } } 	0
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; public interface FileProcessStrategy { boolean begin ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception ; } 	1
package org . apache . camel . spring . remoting ; import org . apache . camel . CamelContext ; import org . apache . camel . component . pojo . PojoComponent ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . remoting . support . RemoteExporter ; public class CamelServiceExporter extends RemoteExporter implements InitializingBean , DisposableBean { CamelContext camelContext ; PojoComponent pojoComponent ; String serviceName ; public void afterPropertiesSet ( ) throws Exception { if ( serviceName == null ) { throw new IllegalArgumentException ( "The serviceName must be configured." ) ; } if ( pojoComponent == null ) { if ( camelContext == null ) { throw new IllegalArgumentException ( "A pojoComponent or camelContext must be configured." ) ; } pojoComponent = ( PojoComponent ) camelContext . getComponent ( "pojo" ) ; if ( pojoComponent == null ) { throw new IllegalArgumentException ( "The pojoComponent could not be found." ) ; } } pojoComponent . addService ( serviceName , getProxyForService ( ) ) ; } public void destroy ( ) throws Exception { if ( serviceName != null ) { pojoComponent . removeService ( serviceName ) ; } } public PojoComponent getPojoComponent ( ) { return pojoComponent ; } public void setPojoComponent ( PojoComponent pojoComponent ) { this . pojoComponent = pojoComponent ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public String getServiceName ( ) { return serviceName ; } public void setServiceName ( String serviceName ) { this . serviceName = serviceName ; } } 	0
package org . apache . camel . component . bean ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . List ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ExchangeHelper ; public class MethodInfo { private Class type ; private Method method ; private final List < ParameterInfo > parameters ; private final List < ParameterInfo > bodyParameters ; private final boolean hasCustomAnnotation ; private Expression parametersExpression ; public MethodInfo ( Class type , Method method , List < ParameterInfo > parameters , List < ParameterInfo > bodyParameters , boolean hasCustomAnnotation ) { this . type = type ; this . method = method ; this . parameters = parameters ; this . bodyParameters = bodyParameters ; this . hasCustomAnnotation = hasCustomAnnotation ; this . parametersExpression = createParametersExpression ( ) ; } public String toString ( ) { return method . toString ( ) ; } public MethodInvocation createMethodInvocation ( final Object pojo , final Exchange messageExchange ) { final Object [ ] arguments = ( Object [ ] ) parametersExpression . evaluate ( messageExchange ) ; return new MethodInvocation ( ) { public Method getMethod ( ) { return method ; } public Object [ ] getArguments ( ) { return arguments ; } public Object proceed ( ) throws Throwable { return invoke ( method , pojo , arguments , messageExchange ) ; } public Object getThis ( ) { return pojo ; } public AccessibleObject getStaticPart ( ) { return method ; } } ; } public Class getType ( ) { return type ; } public Method getMethod ( ) { return method ; } public Expression getParametersExpression ( ) { return parametersExpression ; } public List < ParameterInfo > getBodyParameters ( ) { return bodyParameters ; } public Class getBodyParameterType ( ) { ParameterInfo parameterInfo = bodyParameters . get ( 0 ) ; return parameterInfo . getType ( ) ; } public boolean bodyParameterMatches ( Class bodyType ) { Class actualType = getBodyParameterType ( ) ; return actualType != null && ObjectHelper . isAssignableFrom ( bodyType , actualType ) ; } public List < ParameterInfo > getParameters ( ) { return parameters ; } public boolean hasBodyParameter ( ) { return ! bodyParameters . isEmpty ( ) ; } public boolean isHasCustomAnnotation ( ) { return hasCustomAnnotation ; } protected Object invoke ( Method mth , Object pojo , Object [ ] arguments , Exchange exchange ) throws IllegalAccessException , InvocationTargetException { return mth . invoke ( pojo , arguments ) ; } protected Expression createParametersExpression ( ) { final int size = parameters . size ( ) ; final Expression [ ] expressions = new Expression [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { Expression parameterExpression = parameters . get ( i ) . getExpression ( ) ; expressions [ i ] = parameterExpression ; } return new Expression < Exchange > ( ) { public Object evaluate ( Exchange exchange ) { Object [ ] answer = new Object [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { Object value = expressions [ i ] . evaluate ( exchange ) ; value = ExchangeHelper . convertToType ( exchange , parameters . get ( i ) . getType ( ) , value ) ; answer [ i ] = value ; } return answer ; } @ Override public String toString ( ) { return "ParametersExpression: " + Arrays . asList ( expressions ) ; } } ; } } 	1
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; public class DefaultConsumer < E extends Exchange > extends ServiceSupport implements Consumer < E > { private Endpoint < E > endpoint ; private Processor processor ; private ExceptionHandler exceptionHandler ; public DefaultConsumer ( Endpoint < E > endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } @ Override public String toString ( ) { return "Consumer on " + endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void handleException ( Throwable t ) { getExceptionHandler ( ) . handleException ( t ) ; } } 	0
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; @ XmlRootElement ( name = "otherwise" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class OtherwiseType extends OutputType { @ Override public String toString ( ) { return "Otherwise[" + getOutputs ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return routeContext . createProcessor ( this ) ; } @ Override public String getLabel ( ) { return "otherwise" ; } } 	1
package org . apache . camel ; public class FailedToCreateProducerException extends RuntimeCamelException { private final Endpoint endpoint ; public FailedToCreateProducerException ( Endpoint endpoint , Throwable cause ) { super ( "Failed to create Producer for endpoint: " + endpoint + ". Reason: " + cause , cause ) ; this . endpoint = endpoint ; } public Endpoint getEndpoint ( ) { return endpoint ; } } 	0
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . component . bean . BeanProcessor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . util . CamelContextHelper ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "bean" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class BeanRef extends OutputType { @ XmlAttribute ( required = true ) private String ref ; @ XmlAttribute ( required = false ) private String method ; @ XmlAttribute ( required = false ) private Class beanType ; @ XmlTransient private Object bean ; public BeanRef ( ) { } public BeanRef ( String ref ) { this . ref = ref ; } public BeanRef ( String ref , String method ) { this . ref = ref ; this . method = method ; } @ Override public String toString ( ) { return "Bean[" + getLabel ( ) + "]" ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public String getMethod ( ) { return method ; } public void setMethod ( String method ) { this . method = method ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class getBeanType ( ) { return beanType ; } public void setBeanType ( Class beanType ) { this . beanType = beanType ; } @ Override public Processor createProcessor ( RouteContext routeContext ) { if ( bean == null ) { String reference = getRef ( ) ; if ( reference != null ) { bean = routeContext . lookup ( reference , Object . class ) ; } else { ObjectHelper . notNull ( beanType , "bean, ref or beanType" ) ; bean = CamelContextHelper . newInstance ( routeContext . getCamelContext ( ) , beanType ) ; } } BeanProcessor answer = new BeanProcessor ( bean , routeContext . getCamelContext ( ) ) ; if ( method != null ) { answer . setMethodName ( method ) ; } return answer ; } @ Override public String getLabel ( ) { if ( ref != null ) { String methodText = "" ; if ( method != null ) { methodText = " method: " + method ; } return "ref: " + ref + methodText ; } else if ( bean != null ) { return bean . toString ( ) ; } else if ( beanType != null ) { return beanType . getName ( ) ; } else { return "" ; } } } 	1
package org . apache . camel . processor . idempotent ; import org . apache . camel . Expression ; import org . apache . camel . Exchange ; import org . apache . camel . RuntimeCamelException ; public class NoMessageIdException extends RuntimeCamelException { private final Exchange exchange ; private final Expression expression ; public NoMessageIdException ( Exchange exchange , Expression expression ) { super ( "No message ID could be found using expression: " + expression + " on message exchange: " + exchange ) ; this . exchange = exchange ; this . expression = expression ; } public Exchange getExchange ( ) { return exchange ; } public Expression getExpression ( ) { return expression ; } } 	0
package org . apache . camel . converter ; import org . apache . camel . Converter ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; @ Converter public class ObjectConverter { private ObjectConverter ( ) { } public static boolean isCollection ( Object value ) { return value instanceof Collection || ( value != null && value . getClass ( ) . isArray ( ) ) ; } @ Converter public static Iterator iterator ( Object value ) { if ( value == null ) { return Collections . EMPTY_LIST . iterator ( ) ; } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; return collection . iterator ( ) ; } else if ( value . getClass ( ) . isArray ( ) ) { List < Object > list = Arrays . asList ( ( Object [ ] ) value ) ; return list . iterator ( ) ; } else if ( value instanceof NodeList ) { final NodeList nodeList = ( NodeList ) value ; return new Iterator < Node > ( ) { int idx = - 1 ; public boolean hasNext ( ) { return ++ idx < nodeList . getLength ( ) ; } public Node next ( ) { return nodeList . item ( idx ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } else { return Collections . singletonList ( value ) . iterator ( ) ; } } @ Converter public static boolean toBool ( Object value ) { Boolean answer = toBoolean ( value ) ; if ( answer != null ) { return answer . booleanValue ( ) ; } return false ; } @ Converter public static Boolean toBoolean ( Object value ) { if ( value instanceof Boolean ) { return ( Boolean ) value ; } if ( value instanceof String ) { return "true" . equalsIgnoreCase ( value . toString ( ) ) ? Boolean . TRUE : Boolean . FALSE ; } return null ; } @ Converter public static Boolean toBoolean ( Boolean value ) { if ( value != null ) { return value . booleanValue ( ) ; } return false ; } } 	1
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; public class ArrayTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > type , Object value ) { if ( type . isArray ( ) ) { if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; Object array = Array . newInstance ( type . getComponentType ( ) , collection . size ( ) ) ; if ( array instanceof Object [ ] ) { collection . toArray ( ( Object [ ] ) array ) ; } else { int index = 0 ; for ( Object element : collection ) { Array . set ( array , index ++ , element ) ; } } return ( T ) array ; } else if ( value != null && value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; Object answer = Array . newInstance ( type . getComponentType ( ) , size ) ; for ( int i = 0 ; i < size ; i ++ ) { Array . set ( answer , i , Array . get ( value , i ) ) ; } return ( T ) answer ; } } else if ( Collection . class . isAssignableFrom ( type ) ) { if ( value != null ) { if ( value instanceof Object [ ] ) { return ( T ) Arrays . asList ( ( Object [ ] ) value ) ; } else if ( value . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( value ) ; List answer = new ArrayList ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { answer . add ( Array . get ( value , i ) ) ; } return ( T ) answer ; } } } return null ; } } 	0
package org . apache . camel . util ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . camel . spi . Injector ; public class FactoryFinder { private final String path ; private final ConcurrentHashMap classMap = new ConcurrentHashMap ( ) ; public FactoryFinder ( ) { this ( "META-INF/services/org/apache/camel/" ) ; } public FactoryFinder ( String path ) { this . path = path ; } public Object newInstance ( String key ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { return newInstance ( key , ( String ) null ) ; } public Object newInstance ( String key , String propertyPrefix ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { Class clazz = findClass ( key , propertyPrefix ) ; return clazz . newInstance ( ) ; } public Object newInstance ( String key , Injector injector ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , ( String ) null ) ; } public Object newInstance ( String key , Injector injector , String propertyPrefix ) throws IOException , ClassNotFoundException { Class type = findClass ( key , propertyPrefix ) ; return injector . newInstance ( type ) ; } public < T > T newInstance ( String key , Injector injector , Class < T > expectedType ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , null , expectedType ) ; } public < T > T newInstance ( String key , Injector injector , String propertyPrefix , Class < T > expectedType ) throws IOException , ClassNotFoundException { Class type = findClass ( key , propertyPrefix ) ; Object value = injector . newInstance ( type ) ; if ( expectedType . isInstance ( value ) ) { return expectedType . cast ( value ) ; } else { throw new ClassCastException ( "Not instanceof " + expectedType . getName ( ) + " value: " + value ) ; } } public < T > List < T > newInstances ( String key , Injector injector , Class < T > type ) throws IOException , ClassNotFoundException { List < Class > list = findClasses ( key ) ; List < T > answer = new ArrayList < T > ( list . size ( ) ) ; answer . add ( newInstance ( key , injector , type ) ) ; return answer ; } public Class findClass ( String key ) throws ClassNotFoundException , IOException { return findClass ( key , null ) ; } public Class findClass ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { if ( propertyPrefix == null ) { propertyPrefix = "" ; } Class clazz = ( Class ) classMap . get ( propertyPrefix + key ) ; if ( clazz == null ) { clazz = newInstance ( doFindFactoryProperies ( key ) , propertyPrefix ) ; classMap . put ( propertyPrefix + key , clazz ) ; } return clazz ; } public List < Class > findClasses ( String key ) throws ClassNotFoundException , IOException { return findClasses ( key , null ) ; } public List < Class > findClasses ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { Class type = findClass ( key , propertyPrefix ) ; return Collections . singletonList ( type ) ; } public String getPath ( ) { return path ; } private Class newInstance ( Properties properties , String propertyPrefix ) throws ClassNotFoundException , IOException { String className = properties . getProperty ( propertyPrefix + "class" ) ; if ( className == null ) { throw new IOException ( "Expected property is missing: " + propertyPrefix + "class" ) ; } Class clazz = null ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader != null ) { try { clazz = loader . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { } } if ( clazz == null ) { clazz = FactoryFinder . class . getClassLoader ( ) . loadClass ( className ) ; } return clazz ; } private Properties doFindFactoryProperies ( String key ) throws IOException { String uri = path + key ; ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader == null ) { classLoader = getClass ( ) . getClassLoader ( ) ; } InputStream in = classLoader . getResourceAsStream ( uri ) ; if ( in == null ) { in = FactoryFinder . class . getClassLoader ( ) . getResourceAsStream ( uri ) ; if ( in == null ) { throw new NoFactoryAvailableException ( uri ) ; } } BufferedInputStream reader = null ; try { reader = new BufferedInputStream ( in ) ; Properties properties = new Properties ( ) ; properties . load ( reader ) ; return properties ; } finally { try { reader . close ( ) ; } catch ( Exception ignore ) { } } } } 	1
package org . apache . camel . component . direct ; import java . util . concurrent . CopyOnWriteArrayList ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ProducerCache ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DirectEndpoint < E extends Exchange > extends DefaultEndpoint < E > { private static final Log log = LogFactory . getLog ( DirectEndpoint . class ) ; private final CopyOnWriteArrayList < DefaultConsumer < E > > consumers = new CopyOnWriteArrayList < DefaultConsumer < E > > ( ) ; boolean allowMultipleConsumers = true ; public DirectEndpoint ( String uri , DirectComponent < E > component ) { super ( uri , component ) ; } public Producer createProducer ( ) throws Exception { return new DefaultProducer ( this ) { public void process ( Exchange exchange ) throws Exception { DirectEndpoint . this . process ( exchange ) ; } } ; } protected void process ( Exchange exchange ) throws Exception { if ( consumers . isEmpty ( ) ) { log . warn ( "No consumers available on " + this + " for " + exchange ) ; } else { for ( DefaultConsumer < E > consumer : consumers ) { consumer . getProcessor ( ) . process ( exchange ) ; } } } public Consumer < E > createConsumer ( Processor processor ) throws Exception { return new DefaultConsumer < E > ( this , processor ) { @ Override public void start ( ) throws Exception { if ( ! allowMultipleConsumers && ! consumers . isEmpty ( ) ) throw new IllegalStateException ( "Endpoint " + getEndpointUri ( ) + " only allows 1 active consumer but you attempted to start a 2nd consumer." ) ; consumers . add ( this ) ; super . start ( ) ; } @ Override public void stop ( ) throws Exception { super . stop ( ) ; consumers . remove ( this ) ; } } ; } public E createExchange ( ) { return ( E ) new DefaultExchange ( getContext ( ) ) ; } public boolean isAllowMultipleConsumers ( ) { return allowMultipleConsumers ; } public void setAllowMultipleConsumers ( boolean allowMutlipleConsumers ) { this . allowMultipleConsumers = allowMutlipleConsumers ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . spi ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; public interface ComponentResolver < E extends Exchange > { Component < E > resolveComponent ( String name , CamelContext context ) throws Exception ; } 	1
package org . apache . camel . processor ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class FilterProcessor extends ServiceSupport implements Processor { private Predicate < Exchange > predicate ; private Processor processor ; public FilterProcessor ( Predicate < Exchange > predicate , Processor processor ) { this . predicate = predicate ; this . processor = processor ; } public void process ( Exchange exchange ) throws Exception { if ( predicate . matches ( exchange ) ) { processor . process ( exchange ) ; } } @ Override public String toString ( ) { return "filter (" + predicate + ") " + processor ; } public Predicate < Exchange > getPredicate ( ) { return predicate ; } public Processor getProcessor ( ) { return processor ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } } 	0
package org . apache . camel ; public class InvalidPayloadException extends CamelExchangeException { private final Class < ? > type ; public InvalidPayloadException ( Exchange exchange , Class < ? > type ) { super ( "No in body available of type: " + type . getName ( ) + NoSuchPropertyException . valueDescription ( exchange . getIn ( ) . getBody ( ) ) , exchange ) ; this . type = type ; } public Class < ? > getType ( ) { return type ; } } 	1
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . bam . model . ProcessDefinition ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . util . IntrospectionSupport ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . support . TransactionTemplate ; import java . util . List ; public class JpaBamProcessorSupport < T > extends BamProcessorSupport < T > { private ActivityRules activityRules ; private JpaTemplate template ; private String findByKeyQuery ; private String keyPropertyName = "correlationKey" ; public JpaBamProcessorSupport ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules , Class < T > entitytype ) { super ( transactionTemplate , correlationKeyExpression , entitytype ) ; this . activityRules = activityRules ; this . template = template ; } public JpaBamProcessorSupport ( TransactionTemplate transactionTemplate , JpaTemplate template , Expression < Exchange > correlationKeyExpression , ActivityRules activityRules ) { super ( transactionTemplate , correlationKeyExpression ) ; this . activityRules = activityRules ; this . template = template ; } public String getFindByKeyQuery ( ) { if ( findByKeyQuery == null ) { findByKeyQuery = createFindByKeyQuery ( ) ; } return findByKeyQuery ; } public void setFindByKeyQuery ( String findByKeyQuery ) { this . findByKeyQuery = findByKeyQuery ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public void setActivityRules ( ActivityRules activityRules ) { this . activityRules = activityRules ; } public String getKeyPropertyName ( ) { return keyPropertyName ; } public void setKeyPropertyName ( String keyPropertyName ) { this . keyPropertyName = keyPropertyName ; } public JpaTemplate getTemplate ( ) { return template ; } public void setTemplate ( JpaTemplate template ) { this . template = template ; } protected T loadEntity ( Exchange exchange , Object key ) { List < T > list = template . find ( getFindByKeyQuery ( ) , key ) ; T entity = null ; if ( ! list . isEmpty ( ) ) { entity = list . get ( 0 ) ; } if ( entity == null ) { entity = createEntity ( exchange , key ) ; setKeyProperty ( entity , key ) ; ProcessDefinition definition = ProcessDefinition . getRefreshedProcessDefinition ( template , getActivityRules ( ) . getProcessRules ( ) . getProcessDefinition ( ) ) ; setProcessDefinitionProperty ( entity , definition ) ; template . persist ( entity ) ; } return entity ; } protected void setKeyProperty ( T entity , Object key ) { IntrospectionSupport . setProperty ( entity , getKeyPropertyName ( ) , key ) ; } protected void setProcessDefinitionProperty ( T entity , ProcessDefinition processDefinition ) { IntrospectionSupport . setProperty ( entity , "processDefinition" , processDefinition ) ; } protected T createEntity ( Exchange exchange , Object key ) { return ( T ) exchange . getContext ( ) . getInjector ( ) . newInstance ( getEntityType ( ) ) ; } protected void processEntity ( Exchange exchange , T entity ) throws Exception { if ( entity instanceof Processor ) { Processor processor = ( Processor ) entity ; processor . process ( exchange ) ; } else { throw new IllegalArgumentException ( "No processor defined for this route" ) ; } } protected String createFindByKeyQuery ( ) { return "select x from " + getEntityType ( ) . getName ( ) + " x where x." + getKeyPropertyName ( ) + " = ?1" ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultUnitOfWork ; import org . apache . camel . spi . UnitOfWork ; public final class UnitOfWorkProcessor extends DelegateAsyncProcessor { public UnitOfWorkProcessor ( AsyncProcessor processor ) { super ( processor ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( exchange . getUnitOfWork ( ) == null ) { exchange . setUnitOfWork ( new DefaultUnitOfWork ( ) ) ; return processor . process ( exchange , new AsyncCallback ( ) { public void done ( boolean sync ) { callback . done ( sync ) ; exchange . getUnitOfWork ( ) . done ( exchange ) ; exchange . setUnitOfWork ( null ) ; } } ) ; } else { return processor . process ( exchange , callback ) ; } } } 	1
package org . apache . camel . component . cxf . transport ; import org . apache . camel . CamelContext ; import org . apache . cxf . Bus ; import org . apache . cxf . configuration . Configurer ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractTransportFactory ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . ConduitInitiator ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . DestinationFactory ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; import javax . annotation . Resource ; import java . io . IOException ; import java . util . HashSet ; import java . util . Set ; public class CamelTransportFactory extends AbstractTransportFactory implements ConduitInitiator , DestinationFactory { private static final Set < String > URI_PREFIXES = new HashSet < String > ( ) ; static { URI_PREFIXES . add ( "camel://" ) ; } private Bus bus ; private CamelContext camelContext ; @ Resource public void setBus ( Bus b ) { bus = b ; } public Bus getBus ( ) { return bus ; } public CamelContext getCamelContext ( ) { return camelContext ; } @ Resource public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public Conduit getConduit ( EndpointInfo targetInfo ) throws IOException { return getConduit ( targetInfo , null ) ; } public Conduit getConduit ( EndpointInfo endpointInfo , EndpointReferenceType target ) throws IOException { return new CamelConduit ( camelContext , bus , endpointInfo , target ) ; } public Destination getDestination ( EndpointInfo endpointInfo ) throws IOException { CamelDestination destination = new CamelDestination ( camelContext , bus , this , endpointInfo ) ; Configurer configurer = bus . getExtension ( Configurer . class ) ; if ( null != configurer ) { configurer . configureBean ( destination ) ; } return destination ; } public Set < String > getUriPrefixes ( ) { return URI_PREFIXES ; } } 	0
package org . apache . camel . impl ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import java . io . OutputStream ; import org . apache . camel . Exchange ; import org . apache . camel . converter . IOConverter ; import org . apache . camel . spi . DataFormat ; public class SerializationDataFormat implements DataFormat { public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws IOException { ObjectOutput out = IOConverter . toObjectOutput ( stream ) ; out . writeObject ( graph ) ; out . flush ( ) ; } public Object unmarshal ( Exchange exchange , InputStream stream ) throws IOException , ClassNotFoundException { ObjectInput in = IOConverter . toObjectInput ( stream ) ; return in . readObject ( ) ; } } 	1
package org . apache . camel . spring ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . CamelContext ; import org . apache . camel . spring . spi . SpringComponentResolver ; import org . apache . camel . spring . spi . SpringInjector ; import org . apache . camel . spring . component . BeanComponent ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationContext ; import org . springframework . context . support . ClassPathXmlApplicationContext ; import org . springframework . context . support . AbstractRefreshableApplicationContext ; public class SpringCamelContext extends DefaultCamelContext implements InitializingBean , DisposableBean , ApplicationContextAware { private ApplicationContext applicationContext ; public SpringCamelContext ( ) { } public SpringCamelContext ( ApplicationContext applicationContext ) { setApplicationContext ( applicationContext ) ; } public static SpringCamelContext springCamelContext ( ApplicationContext applicationContext ) throws Exception { String [ ] names = applicationContext . getBeanNamesForType ( SpringCamelContext . class ) ; if ( names . length == 1 ) { return ( SpringCamelContext ) applicationContext . getBean ( names [ 0 ] , SpringCamelContext . class ) ; } SpringCamelContext answer = new SpringCamelContext ( ) ; answer . setApplicationContext ( applicationContext ) ; answer . afterPropertiesSet ( ) ; return answer ; } public static SpringCamelContext springCamelContext ( String configLocations ) throws Exception { return springCamelContext ( new ClassPathXmlApplicationContext ( configLocations ) ) ; } public void afterPropertiesSet ( ) throws Exception { getInjector ( ) ; start ( ) ; } public void destroy ( ) throws Exception { stop ( ) ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; addComponent ( "bean" , new BeanComponent ( applicationContext ) ) ; } @ Override protected Injector createInjector ( ) { return new SpringInjector ( ( AbstractRefreshableApplicationContext ) getApplicationContext ( ) ) ; } @ Override protected ComponentResolver createComponentResolver ( ) { ComponentResolver defaultResolver = super . createComponentResolver ( ) ; return new SpringComponentResolver ( getApplicationContext ( ) , defaultResolver ) ; } } 	0
package org . apache . camel . processor ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; public class MulticastProcessor extends ServiceSupport implements Processor { private Collection < Processor > processors ; public MulticastProcessor ( Collection < Processor > processors ) { this . processors = processors ; } public static < E extends Exchange > Collection < Processor > toProducers ( Collection < Endpoint > endpoints ) throws Exception { Collection < Processor > answer = new ArrayList < Processor > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint . createProducer ( ) ) ; } return answer ; } @ Override public String toString ( ) { return "Multicast" + getProcessors ( ) ; } public void process ( Exchange exchange ) throws Exception { for ( Processor producer : processors ) { Exchange copy = copyExchangeStrategy ( producer , exchange ) ; producer . process ( copy ) ; } } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processors ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processors ) ; } public Collection < Processor > getProcessors ( ) { return processors ; } protected Exchange copyExchangeStrategy ( Processor processor , Exchange exchange ) { return exchange . copy ( ) ; } } 	1
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import java . util . List ; public interface LoadBalancer extends Processor { void addProcessor ( Processor processor ) ; void removeProcessor ( Processor processor ) ; List < Processor > getProcessors ( ) ; } 	0
package org . apache . camel . impl ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import javax . naming . Context ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . spi . LifecycleStrategy ; import org . apache . camel . Processor ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . model . RouteType ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DefaultCamelContext extends ServiceSupport implements CamelContext , Service { private static final transient Log LOG = LogFactory . getLog ( DefaultCamelContext . class ) ; private static final String NAME_PREFIX = "camel-" ; private static int NAME_SUFFIX = 0 ; private String name ; private Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; private Map < String , Component > components = new HashMap < String , Component > ( ) ; private List < Route > routes ; private List < Service > servicesToClose = new ArrayList < Service > ( ) ; private TypeConverter typeConverter ; private ExchangeConverter exchangeConverter ; private Injector injector ; private ComponentResolver componentResolver ; private boolean autoCreateComponents = true ; private LanguageResolver languageResolver = new DefaultLanguageResolver ( ) ; private Registry registry ; private LifecycleStrategy lifecycleStrategy = new DefaultLifecycleStrategy ( ) ; private List < RouteType > routeDefinitions = new ArrayList < RouteType > ( ) ; public DefaultCamelContext ( ) { name = NAME_PREFIX + ++ NAME_SUFFIX ; } public DefaultCamelContext ( Context jndiContext ) { this ( new JndiRegistry ( jndiContext ) ) ; } public DefaultCamelContext ( Registry registry ) { this ( ) ; this . registry = registry ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addComponent ( String componentName , final Component component ) { if ( component == null ) { throw new IllegalArgumentException ( "Component cannot be null" ) ; } synchronized ( components ) { if ( components . containsKey ( componentName ) ) { throw new IllegalArgumentException ( "Component previously added: " + componentName ) ; } component . setCamelContext ( this ) ; components . put ( componentName , component ) ; } } public Component getComponent ( String name ) { synchronized ( components ) { Component component = components . get ( name ) ; if ( component == null && autoCreateComponents ) { try { component = getComponentResolver ( ) . resolveComponent ( name , this ) ; if ( component != null ) { addComponent ( name , component ) ; if ( isStarted ( ) ) { startServices ( component ) ; } } } catch ( Exception e ) { throw new RuntimeCamelException ( "Could not auto create component: " + name , e ) ; } } return component ; } } public < T extends Component > T getComponent ( String name , Class < T > componentType ) { Component component = getComponent ( name ) ; if ( componentType . isInstance ( component ) ) { return componentType . cast ( component ) ; } else { throw new IllegalArgumentException ( "The component is not of type: " + componentType + " but is: " + component ) ; } } public Component removeComponent ( String componentName ) { synchronized ( components ) { return components . remove ( componentName ) ; } } public Component getOrCreateComponent ( String componentName , Callable < Component > factory ) { synchronized ( components ) { Component component = components . get ( componentName ) ; if ( component == null ) { try { component = factory . call ( ) ; if ( component == null ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component, it returned null." ) ; } components . put ( componentName , component ) ; component . setCamelContext ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component" , e ) ; } } return component ; } } public Collection < Endpoint > getSingletonEndpoints ( ) { synchronized ( endpoints ) { return new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } } public Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { startServices ( endpoint ) ; oldEndpoint = endpoints . remove ( uri ) ; endpoints . put ( uri , endpoint ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint removeSingletonEndpoint ( String uri ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { oldEndpoint = endpoints . remove ( uri ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint getEndpoint ( String uri ) { Endpoint answer ; synchronized ( endpoints ) { answer = endpoints . get ( uri ) ; if ( answer == null ) { try { String splitURI [ ] = ObjectHelper . splitOnCharacter ( uri , ":" , 2 ) ; if ( splitURI [ 1 ] != null ) { String scheme = splitURI [ 0 ] ; Component component = getComponent ( scheme ) ; if ( component != null ) { answer = component . createEndpoint ( uri ) ; if ( answer != null && LOG . isDebugEnabled ( ) ) { LOG . debug ( uri + " converted to endpoint: " + answer + " by component: " + component ) ; } } } if ( answer == null ) { answer = createEndpoint ( uri ) ; } if ( answer != null && answer . isSingleton ( ) ) { startServices ( answer ) ; endpoints . put ( uri , answer ) ; lifecycleStrategy . onEndpointAdd ( answer ) ; } } catch ( Exception e ) { throw new ResolveEndpointFailedException ( uri , e ) ; } } } return answer ; } public < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) { Endpoint endpoint = getEndpoint ( name ) ; if ( endpointType . isInstance ( endpoint ) ) { return endpointType . cast ( endpoint ) ; } else { throw new IllegalArgumentException ( "The endpoint is not of type: " + endpointType + " but is: " + endpoint ) ; } } public List < Route > getRoutes ( ) { return routes ; } public void setRoutes ( List < Route > routes ) { this . routes = routes ; } public void addRoutes ( Collection < Route > routes ) throws Exception { if ( this . routes == null ) { this . routes = new ArrayList < Route > ( routes ) ; } else { this . routes . addAll ( routes ) ; } lifecycleStrategy . onRoutesAdd ( routes ) ; if ( shouldStartRoutes ( ) ) { startRoutes ( routes ) ; } } public void addRoutes ( RouteBuilder builder ) throws Exception { builder . setContext ( this ) ; List < Route > routeList = builder . getRouteList ( ) ; LOG . debug ( "Adding routes from: " + builder + " routes: " + routeList ) ; addRoutes ( routeList ) ; } public void addRouteDefinitions ( Collection < RouteType > routeDefinitions ) throws Exception { this . routeDefinitions . addAll ( routeDefinitions ) ; if ( shouldStartRoutes ( ) ) { startRouteDefinitions ( routeDefinitions ) ; } } public Language resolveLanguage ( String language ) { return getLanguageResolver ( ) . resolveLanguage ( language , this ) ; } public ExchangeConverter getExchangeConverter ( ) { if ( exchangeConverter == null ) { exchangeConverter = createExchangeConverter ( ) ; } return exchangeConverter ; } public void setExchangeConverter ( ExchangeConverter exchangeConverter ) { this . exchangeConverter = exchangeConverter ; } public TypeConverter getTypeConverter ( ) { if ( typeConverter == null ) { typeConverter = createTypeConverter ( ) ; } return typeConverter ; } public void setTypeConverter ( TypeConverter typeConverter ) { this . typeConverter = typeConverter ; } public Injector getInjector ( ) { if ( injector == null ) { injector = createInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } public ComponentResolver getComponentResolver ( ) { if ( componentResolver == null ) { componentResolver = createComponentResolver ( ) ; } return componentResolver ; } public void setComponentResolver ( ComponentResolver componentResolver ) { this . componentResolver = componentResolver ; } public LanguageResolver getLanguageResolver ( ) { return languageResolver ; } public void setLanguageResolver ( LanguageResolver languageResolver ) { this . languageResolver = languageResolver ; } public boolean isAutoCreateComponents ( ) { return autoCreateComponents ; } public void setAutoCreateComponents ( boolean autoCreateComponents ) { this . autoCreateComponents = autoCreateComponents ; } public Registry getRegistry ( ) { if ( registry == null ) { registry = createRegistry ( ) ; } return registry ; } public void setRegistry ( Registry registry ) { this . registry = registry ; } public LifecycleStrategy getLifecycleStrategy ( ) { return lifecycleStrategy ; } public void setLifecycleStrategy ( LifecycleStrategy lifecycleStrategy ) { this . lifecycleStrategy = lifecycleStrategy ; } public List < RouteType > getRouteDefinitions ( ) { return routeDefinitions ; } protected void doStart ( ) throws Exception { forceLazyInitialization ( ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { startServices ( component ) ; } } startRouteDefinitions ( routeDefinitions ) ; startRoutes ( routes ) ; } protected void startRouteDefinitions ( Collection < RouteType > list ) throws Exception { if ( list != null ) { for ( RouteType route : list ) { lifecycleStrategy . beforeStartRouteType ( this , route ) ; route . addRoutes ( this ) ; } } } protected void doStop ( ) throws Exception { stopServices ( servicesToClose ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { stopServices ( component ) ; } } } protected void startRoutes ( Collection < Route > routeList ) throws Exception { if ( routeList != null ) { for ( Route < Exchange > route : routeList ) { List < Service > services = route . getServicesForRoute ( ) ; servicesToClose . addAll ( services ) ; startServices ( services ) ; } } } protected void forceLazyInitialization ( ) { getExchangeConverter ( ) ; getInjector ( ) ; getLanguageResolver ( ) ; getTypeConverter ( ) ; } protected ExchangeConverter createExchangeConverter ( ) { return new DefaultExchangeConverter ( ) ; } protected TypeConverter createTypeConverter ( ) { return new DefaultTypeConverter ( getInjector ( ) ) ; } protected Injector createInjector ( ) { FactoryFinder finder = new FactoryFinder ( ) ; try { return ( Injector ) finder . newInstance ( "Injector" ) ; } catch ( NoFactoryAvailableException e ) { return new ReflectionInjector ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } protected ComponentResolver createComponentResolver ( ) { return new DefaultComponentResolver ( ) ; } protected Registry createRegistry ( ) { return new JndiRegistry ( ) ; } protected Endpoint createEndpoint ( String uri ) { Object value = getRegistry ( ) . lookup ( uri ) ; if ( value instanceof Endpoint ) { return ( Endpoint ) value ; } else if ( value instanceof Processor ) { return new ProcessorEndpoint ( uri , this , ( Processor ) value ) ; } else if ( value != null ) { return convertBeanToEndpoint ( uri , value ) ; } return null ; } protected Endpoint convertBeanToEndpoint ( String uri , Object bean ) { throw new IllegalArgumentException ( "uri: " + uri + " bean: " + bean + " could not be converted to an Endpoint" ) ; } protected boolean shouldStartRoutes ( ) { return isStarted ( ) && ! isStarting ( ) ; } } 	1
package org . apache . camel . impl ; import org . apache . camel . Predicate ; import org . apache . camel . Exchange ; public abstract class PredicateSupport < E extends Exchange > implements Predicate < E > { public void assertMatches ( String text , E exchange ) { if ( ! matches ( exchange ) ) { throw new AssertionError ( assertionFailureMessage ( exchange ) ) ; } } protected String assertionFailureMessage ( E exchange ) { return this + " failed on " + exchange ; } } 	0
package org . apache . camel . processor ; import java . util . Iterator ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . converter . ObjectConverter ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; public class Splitter extends ServiceSupport implements Processor { private final Processor processor ; private final Expression expression ; public Splitter ( Expression expression , Processor destination ) { this . processor = destination ; this . expression = expression ; notNull ( destination , "destination" ) ; notNull ( expression , "expression" ) ; } @ Override public String toString ( ) { return "Splitter[on: " + expression + " to: " + processor + "]" ; } public void process ( Exchange exchange ) throws Exception { Object value = expression . evaluate ( exchange ) ; Iterator iter = ObjectConverter . iterator ( value ) ; while ( iter . hasNext ( ) ) { Object part = iter . next ( ) ; Exchange newExchange = exchange . copy ( ) ; newExchange . getIn ( ) . setBody ( part ) ; processor . process ( newExchange ) ; } } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } } 	1
package org . apache . camel . spring . spi ; import org . springframework . context . ApplicationContext ; import org . springframework . beans . factory . wiring . BeanConfigurerSupport ; public class BeanInjector extends BeanConfigurerSupport { public BeanInjector ( ApplicationContext applicationContext ) throws Exception { setBeanFactory ( applicationContext ) ; afterPropertiesSet ( ) ; } public void inject ( Object bean ) { configureBean ( bean ) ; } } 	0
package org . apache . camel . model ; import org . apache . camel . model . language . ExpressionType ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import java . util . ArrayList ; import java . util . List ; @ XmlRootElement ( name = "serviceActivation" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ServiceActivationType { @ XmlAttribute private String group = "default" ; @ XmlElementRef private List < ExpressionType > uris = new ArrayList < ExpressionType > ( ) ; public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public List < ExpressionType > getUris ( ) { return uris ; } public void setUris ( List < ExpressionType > uris ) { this . uris = uris ; } } 	1
package org . apache . camel . component . file ; import java . io . File ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultMessage ; public class FileMessage extends DefaultMessage { private File file ; public FileMessage ( ) { this ( new File ( "." ) ) ; } public FileMessage ( File file ) { this . file = file ; } @ Override public String toString ( ) { return "FileMessage: " + file ; } @ Override public FileExchange getExchange ( ) { return ( FileExchange ) super . getExchange ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } @ Override public FileMessage newInstance ( ) { return new FileMessage ( ) ; } } 	0
package org . apache . camel . builder . xml ; public class StreamResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new StreamResultHandler ( ) ; } } 	1
package org . apache . camel . component . mail ; public class MessageHeaderNamesAccessException extends RuntimeMailException { private static final long serialVersionUID = - 6744171518099741324L ; public MessageHeaderNamesAccessException ( Throwable e ) { super ( "Failed to acess the Mail message property names" , e ) ; } } 	0
package org . apache . camel . model ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . util . ObjectHelper ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; @ XmlRootElement ( name = "from" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FromType { @ XmlAttribute private String uri ; @ XmlAttribute private String ref ; @ XmlTransient private Endpoint endpoint ; public FromType ( ) { } public FromType ( String uri ) { setUri ( uri ) ; } public FromType ( Endpoint endpoint ) { this . endpoint = endpoint ; } @ Override public String toString ( ) { return "From[" + getLabel ( ) + "]" ; } public String getLabel ( ) { return description ( getUri ( ) , getRef ( ) , getEndpoint ( ) ) ; } public Endpoint resolveEndpoint ( RouteContext context ) { if ( endpoint == null ) { endpoint = context . resolveEndpoint ( getUri ( ) , getRef ( ) ) ; } return endpoint ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } public String getRef ( ) { return ref ; } public void setRef ( String ref ) { this . ref = ref ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public Object getUriOrRef ( ) { if ( ObjectHelper . isNullOrBlank ( uri ) ) { return uri ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } return ref ; } protected static String description ( String uri , String ref , Endpoint endpoint ) { if ( ref != null ) { return "ref:" + ref ; } else if ( endpoint != null ) { return endpoint . getEndpointUri ( ) ; } else if ( uri != null ) { return uri ; } else { return "no uri or ref supplied!" ; } } } 	1
package org . apache . camel . component . jbi ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . FailedToCreateProducerException ; import org . apache . servicemix . common . DefaultComponent ; import org . apache . servicemix . jbi . util . IntrospectionSupport ; import org . apache . servicemix . jbi . util . URISupport ; import org . apache . servicemix . jbi . resolver . URIResolver ; import javax . jbi . servicedesc . ServiceEndpoint ; import javax . xml . namespace . QName ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; public class CamelJbiComponent extends DefaultComponent implements Component < Exchange > { private JbiBinding binding ; private CamelContext camelContext ; private ScheduledExecutorService executorService ; @ Override protected List < CamelJbiEndpoint > getConfiguredEndpoints ( ) { List < CamelJbiEndpoint > answer = new ArrayList < CamelJbiEndpoint > ( ) ; return answer ; } @ Override protected Class [ ] getEndpointClasses ( ) { return new Class [ ] { CamelJbiEndpoint . class } ; } public JbiBinding getBinding ( ) { if ( binding == null ) { binding = new JbiBinding ( ) ; } return binding ; } public void setBinding ( JbiBinding binding ) { this . binding = binding ; } @ Override protected String [ ] getEPRProtocols ( ) { return new String [ ] { "camel" } ; } protected org . apache . servicemix . common . Endpoint getResolvedEPR ( ServiceEndpoint ep ) throws Exception { CamelJbiEndpoint endpoint = createEndpoint ( ep ) ; endpoint . activate ( ) ; return endpoint ; } public CamelJbiEndpoint createEndpoint ( ServiceEndpoint ep ) throws URISyntaxException { URI uri = new URI ( ep . getEndpointName ( ) ) ; Map map = URISupport . parseQuery ( uri . getQuery ( ) ) ; String camelUri = uri . getSchemeSpecificPart ( ) ; Endpoint camelEndpoint = getCamelContext ( ) . getEndpoint ( camelUri ) ; Processor processor = null ; try { processor = camelEndpoint . createProducer ( ) ; } catch ( Exception e ) { throw new FailedToCreateProducerException ( camelEndpoint , e ) ; } CamelJbiEndpoint endpoint = new CamelJbiEndpoint ( getServiceUnit ( ) , camelEndpoint , getBinding ( ) , processor ) ; IntrospectionSupport . setProperties ( endpoint , map ) ; return endpoint ; } public Endpoint < Exchange > createEndpoint ( String uri ) { if ( uri . startsWith ( "jbi:" ) ) { uri = uri . substring ( "jbi:" . length ( ) ) ; return new JbiEndpoint ( this , uri ) ; } return null ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext camelContext ) { this . camelContext = camelContext ; } public ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { executorService = new ScheduledThreadPoolExecutor ( 5 ) ; } return executorService ; } public CamelJbiEndpoint activateJbiEndpoint ( JbiEndpoint camelEndpoint , Processor processor ) throws Exception { CamelJbiEndpoint jbiEndpoint ; String endpointUri = camelEndpoint . getEndpointUri ( ) ; if ( endpointUri . startsWith ( "endpoint:" ) ) { String uri = endpointUri . substring ( "endpoint:" . length ( ) ) ; String [ ] parts = new String [ 0 ] ; try { parts = URIResolver . split3 ( uri ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( "Expected syntax endpoint:[serviceNamespace]:[serviceName]:[endpointName] but was given: " + endpointUri + ". Cause: " + e , e ) ; } QName service = new QName ( parts [ 0 ] , parts [ 1 ] ) ; String endpoint = parts [ 2 ] ; jbiEndpoint = new CamelJbiEndpoint ( getServiceUnit ( ) , service , endpoint , camelEndpoint , getBinding ( ) , processor ) ; } else { jbiEndpoint = new CamelJbiEndpoint ( getServiceUnit ( ) , camelEndpoint , getBinding ( ) , processor ) ; } addEndpoint ( jbiEndpoint ) ; return jbiEndpoint ; } } 	0
package org . apache . camel . builder . xml ; import java . io . StringReader ; import java . util . List ; import javax . xml . namespace . QName ; import javax . xml . xpath . XPath ; import javax . xml . xpath . XPathConstants ; import javax . xml . xpath . XPathExpression ; import javax . xml . xpath . XPathExpressionException ; import javax . xml . xpath . XPathFactory ; import javax . xml . xpath . XPathFactoryConfigurationException ; import javax . xml . xpath . XPathFunction ; import javax . xml . xpath . XPathFunctionException ; import javax . xml . xpath . XPathFunctionResolver ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . InputSource ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Message ; import org . apache . camel . Predicate ; import org . apache . camel . RuntimeExpressionException ; import static org . apache . camel . builder . xml . Namespaces . DEFAULT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . IN_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . OUT_NAMESPACE ; import static org . apache . camel . builder . xml . Namespaces . isMatchingNamespaceOrEmptyNamespace ; import static org . apache . camel . converter . ObjectConverter . toBoolean ; public class XPathBuilder < E extends Exchange > implements Expression < E > , Predicate < E > { private final String text ; private XPathFactory xpathFactory ; private Class documentType = Document . class ; private QName resultType = XPathConstants . NODESET ; private String objectModelUri ; private DefaultNamespaceContext namespaceContext ; private XPathFunctionResolver functionResolver ; private XPathExpression expression ; private MessageVariableResolver variableResolver = new MessageVariableResolver ( ) ; private E exchange ; private XPathFunction bodyFunction ; private XPathFunction headerFunction ; private XPathFunction outBodyFunction ; private XPathFunction outHeaderFunction ; public XPathBuilder ( String text ) { this . text = text ; } public static XPathBuilder xpath ( String text ) { return new XPathBuilder ( text ) ; } @ Override public String toString ( ) { return "XPath: " + text ; } public boolean matches ( E exchange ) { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; return toBoolean ( booleanResult ) ; } public void assertMatches ( String text , E exchange ) throws AssertionError { Object booleanResult = evaluateAs ( exchange , XPathConstants . BOOLEAN ) ; if ( ! toBoolean ( booleanResult ) ) { throw new AssertionError ( this + " failed on " + exchange + " as returned <" + booleanResult + ">" ) ; } } public Object evaluate ( E exchange ) { return evaluateAs ( exchange , resultType ) ; } public XPathBuilder < E > booleanResult ( ) { resultType = XPathConstants . BOOLEAN ; return this ; } public XPathBuilder < E > nodeResult ( ) { resultType = XPathConstants . NODE ; return this ; } public XPathBuilder < E > nodeSetResult ( ) { resultType = XPathConstants . NODESET ; return this ; } public XPathBuilder < E > numberResult ( ) { resultType = XPathConstants . NUMBER ; return this ; } public XPathBuilder < E > stringResult ( ) { resultType = XPathConstants . STRING ; return this ; } public XPathBuilder < E > objectModel ( String uri ) { this . objectModelUri = uri ; return this ; } public XPathBuilder < E > functionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; return this ; } public XPathBuilder < E > namespace ( String prefix , String uri ) { getNamespaceContext ( ) . add ( prefix , uri ) ; return this ; } public XPathBuilder < E > variable ( String name , Object value ) { variableResolver . addVariable ( name , value ) ; return this ; } public XPathFactory getXPathFactory ( ) throws XPathFactoryConfigurationException { if ( xpathFactory == null ) { if ( objectModelUri != null ) { xpathFactory = XPathFactory . newInstance ( objectModelUri ) ; } xpathFactory = XPathFactory . newInstance ( ) ; } return xpathFactory ; } public void setXPathFactory ( XPathFactory xpathFactory ) { this . xpathFactory = xpathFactory ; } public Class getDocumentType ( ) { return documentType ; } public void setDocumentType ( Class documentType ) { this . documentType = documentType ; } public String getText ( ) { return text ; } public QName getResultType ( ) { return resultType ; } public void setResultType ( QName resultType ) { this . resultType = resultType ; } public DefaultNamespaceContext getNamespaceContext ( ) { if ( namespaceContext == null ) { try { DefaultNamespaceContext defaultNamespaceContext = new DefaultNamespaceContext ( getXPathFactory ( ) ) ; populateDefaultNamespaces ( defaultNamespaceContext ) ; namespaceContext = defaultNamespaceContext ; } catch ( XPathFactoryConfigurationException e ) { throw new RuntimeExpressionException ( e ) ; } } return namespaceContext ; } public void setNamespaceContext ( DefaultNamespaceContext namespaceContext ) { this . namespaceContext = namespaceContext ; } public XPathFunctionResolver getFunctionResolver ( ) { return functionResolver ; } public void setFunctionResolver ( XPathFunctionResolver functionResolver ) { this . functionResolver = functionResolver ; } public XPathExpression getExpression ( ) throws XPathFactoryConfigurationException , XPathExpressionException { if ( expression == null ) { expression = createXPathExpression ( ) ; } return expression ; } public void setNamespacesFromDom ( Element node ) { getNamespaceContext ( ) . setNamespacesFromDom ( node ) ; } public XPathFunction getBodyFunction ( ) { if ( bodyFunction == null ) { bodyFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange == null ) { return null ; } return exchange . getIn ( ) . getBody ( ) ; } } ; } return bodyFunction ; } public void setBodyFunction ( XPathFunction bodyFunction ) { this . bodyFunction = bodyFunction ; } public XPathFunction getHeaderFunction ( ) { if ( headerFunction == null ) { headerFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null && ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value != null ) { return exchange . getIn ( ) . getHeader ( value . toString ( ) ) ; } } return null ; } } ; } return headerFunction ; } public void setHeaderFunction ( XPathFunction headerFunction ) { this . headerFunction = headerFunction ; } public XPathFunction getOutBodyFunction ( ) { if ( outBodyFunction == null ) { outBodyFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange == null ) { return null ; } return exchange . getOut ( ) . getBody ( ) ; } } ; } return outBodyFunction ; } public void setOutBodyFunction ( XPathFunction outBodyFunction ) { this . outBodyFunction = outBodyFunction ; } public XPathFunction getOutHeaderFunction ( ) { if ( outHeaderFunction == null ) { outHeaderFunction = new XPathFunction ( ) { public Object evaluate ( List list ) throws XPathFunctionException { if ( exchange != null && ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value != null ) { return exchange . getOut ( ) . getHeader ( value . toString ( ) ) ; } } return null ; } } ; } return outHeaderFunction ; } public void setOutHeaderFunction ( XPathFunction outHeaderFunction ) { this . outHeaderFunction = outHeaderFunction ; } protected synchronized Object evaluateAs ( E exchange , QName resultType ) { this . exchange = exchange ; variableResolver . setExchange ( exchange ) ; try { Object document = getDocument ( exchange ) ; if ( resultType != null ) { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource , resultType ) ; } else { return getExpression ( ) . evaluate ( document , resultType ) ; } } else { if ( document instanceof InputSource ) { InputSource inputSource = ( InputSource ) document ; return getExpression ( ) . evaluate ( inputSource ) ; } else { return getExpression ( ) . evaluate ( document ) ; } } } catch ( XPathExpressionException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } catch ( XPathFactoryConfigurationException e ) { throw new InvalidXPathExpression ( getText ( ) , e ) ; } } protected XPathExpression createXPathExpression ( ) throws XPathExpressionException , XPathFactoryConfigurationException { XPath xPath = getXPathFactory ( ) . newXPath ( ) ; xpathFactory = null ; xPath . setNamespaceContext ( getNamespaceContext ( ) ) ; xPath . setXPathVariableResolver ( variableResolver ) ; XPathFunctionResolver parentResolver = getFunctionResolver ( ) ; if ( parentResolver == null ) { parentResolver = xPath . getXPathFunctionResolver ( ) ; } xPath . setXPathFunctionResolver ( createDefaultFunctionResolver ( parentResolver ) ) ; return xPath . compile ( text ) ; } protected void populateDefaultNamespaces ( DefaultNamespaceContext context ) { setNamespaceIfNotPresent ( context , "in" , IN_NAMESPACE ) ; setNamespaceIfNotPresent ( context , "out" , OUT_NAMESPACE ) ; setNamespaceIfNotPresent ( context , "env" , Namespaces . ENVIRONMENT_VARIABLES ) ; setNamespaceIfNotPresent ( context , "system" , Namespaces . SYSTEM_PROPERTIES_NAMESPACE ) ; } protected void setNamespaceIfNotPresent ( DefaultNamespaceContext context , String prefix , String uri ) { if ( context != null ) { String current = context . getNamespaceURI ( prefix ) ; if ( current == null ) { context . add ( prefix , uri ) ; } } } protected XPathFunctionResolver createDefaultFunctionResolver ( final XPathFunctionResolver parent ) { return new XPathFunctionResolver ( ) { public XPathFunction resolveFunction ( QName qName , int argumentCount ) { XPathFunction answer = null ; if ( parent != null ) { answer = parent . resolveFunction ( qName , argumentCount ) ; } if ( answer == null ) { if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , IN_NAMESPACE ) || isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , DEFAULT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "body" ) && argumentCount == 0 ) { return getBodyFunction ( ) ; } if ( localPart . equals ( "header" ) && argumentCount == 1 ) { return getHeaderFunction ( ) ; } } if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , OUT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "body" ) && argumentCount == 0 ) { return getOutBodyFunction ( ) ; } if ( localPart . equals ( "header" ) && argumentCount == 1 ) { return getOutHeaderFunction ( ) ; } } if ( isMatchingNamespaceOrEmptyNamespace ( qName . getNamespaceURI ( ) , DEFAULT_NAMESPACE ) ) { String localPart = qName . getLocalPart ( ) ; if ( localPart . equals ( "out-body" ) && argumentCount == 0 ) { return getOutBodyFunction ( ) ; } if ( localPart . equals ( "out-header" ) && argumentCount == 1 ) { return getOutHeaderFunction ( ) ; } } } return answer ; } } ; } protected Object getDocument ( E exchange ) { Message in = exchange . getIn ( ) ; Class type = getDocumentType ( ) ; Object answer = null ; if ( type != null ) { answer = in . getBody ( type ) ; } if ( answer == null ) { answer = in . getBody ( ) ; } if ( answer instanceof String ) { answer = new InputSource ( new StringReader ( answer . toString ( ) ) ) ; } return answer ; } } 	1
package org . apache . camel . spring ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . springframework . beans . factory . FactoryBean ; public class EndpointFactoryBean implements FactoryBean { private CamelContext context ; private String uri ; private Endpoint endpoint ; private boolean singleton ; public Object getObject ( ) throws Exception { if ( endpoint == null ) { endpoint = createEndpoint ( ) ; } return endpoint ; } public Class getObjectType ( ) { return Endpoint . class ; } public boolean isSingleton ( ) { return singleton ; } public CamelContext getContext ( ) { return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } public void setSingleton ( boolean singleton ) { this . singleton = singleton ; } public String getUri ( ) { return uri ; } public void setUri ( String uri ) { this . uri = uri ; } protected Endpoint createEndpoint ( ) { notNull ( context , "context" ) ; notNull ( uri , "uri" ) ; return context . getEndpoint ( uri ) ; } } 	0
package org . apache . camel . builder . xml ; public interface ResultHandlerFactory { ResultHandler createResult ( ) ; } 	1
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; public class Builder { public static < E extends Exchange > ValueBuilder < E > constant ( Object value ) { Expression < E > expression = ExpressionBuilder . constantExpression ( value ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > header ( @ FluentArg ( "name" ) String name ) { Expression < E > expression = ExpressionBuilder . headerExpression ( name ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > body ( ) { Expression < E > expression = ExpressionBuilder . bodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > bodyAs ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . < E , T > bodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > outBody ( ) { Expression < E > expression = ExpressionBuilder . bodyExpression ( ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange , T > ValueBuilder < E > outBody ( Class < T > type ) { Expression < E > expression = ExpressionBuilder . < E , T > bodyExpression ( type ) ; return new ValueBuilder < E > ( expression ) ; } public static < E extends Exchange > ValueBuilder < E > systemProperty ( final String name ) { return systemProperty ( name , null ) ; } public static < E extends Exchange > ValueBuilder < E > systemProperty ( final String name , final String defaultValue ) { return new ValueBuilder < E > ( ExpressionBuilder . < E > systemProperty ( name , defaultValue ) ) ; } } 	0
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "sql" ) public class SqlExpression extends ExpressionType { public SqlExpression ( ) { } public SqlExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "sql" ; } } 	1
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class LoadBalancerSupport implements LoadBalancer { private List < Processor > processors = new CopyOnWriteArrayList < Processor > ( ) ; public void addProcessor ( Processor processor ) { processors . add ( processor ) ; } public void removeProcessor ( Processor processor ) { processors . remove ( processor ) ; } public List < Processor > getProcessors ( ) { return processors ; } } 	0
package org . apache . camel . management ; import org . apache . camel . Exchange ; import org . apache . camel . processor . DelegateProcessor ; public class InstrumentationProcessor extends DelegateProcessor { private PerformanceCounter counter ; InstrumentationProcessor ( PerformanceCounter counter ) { this . counter = counter ; } public void process ( Exchange exchange ) throws Exception { long startTime = System . nanoTime ( ) ; super . process ( exchange ) ; if ( counter != null ) { if ( exchange . getException ( ) == null ) { counter . completedExchange ( ( System . nanoTime ( ) - startTime ) / 1000 ) ; } else { counter . completedExchange ( ) ; } } } } 	1
package org . apache . camel . component . cxf . transport ; public class CamelConstants { public static final String TEXT_MESSAGE_TYPE = "text" ; public static final String BINARY_MESSAGE_TYPE = "binary" ; public static final String CAMEL_SERVER_REQUEST_HEADERS = "org.apache.cxf.camel.server.request.headers" ; public static final String CAMEL_SERVER_RESPONSE_HEADERS = "org.apache.cxf.camel.server.response.headers" ; public static final String CAMEL_REQUEST_MESSAGE = "org.apache.cxf.camel.request.message" ; public static final String CAMEL_RESPONSE_MESSAGE = "org.apache.cxf.camel.reponse.message" ; public static final String CAMEL_CLIENT_REQUEST_HEADERS = "org.apache.cxf.camel.template.request.headers" ; public static final String CAMEL_CLIENT_RESPONSE_HEADERS = "org.apache.cxf.camel.template.response.headers" ; public static final String CAMEL_CLIENT_RECEIVE_TIMEOUT = "org.apache.cxf.camel.template.timeout" ; public static final String CAMEL_SERVER_CONFIGURATION_URI = "http://cxf.apache.org/configuration/transport/camel-server" ; public static final String CAMEL_CLIENT_CONFIGURATION_URI = "http://cxf.apache.org/configuration/transport/camel-template" ; public static final String ENDPOINT_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/endpoint-config" ; public static final String SERVICE_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/service-config" ; public static final String PORT_CONFIGURATION_URI = "http://cxf.apache.org/jaxws/port-config" ; public static final String CAMEL_CLIENT_CONFIG_ID = "camel-template" ; public static final String CAMEL_SERVER_CONFIG_ID = "camel-server" ; public static final String CAMEL_REBASED_REPLY_TO = "org.apache.cxf.camel.server.replyto" ; public static final String CAMEL_CORRELATION_ID = "org.apache.cxf.camel.correlationId" ; } 	0
package org . apache . camel . impl . converter ; import org . apache . camel . Converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . CachingInjector ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ResolverUtil ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . lang . reflect . Method ; import static java . lang . reflect . Modifier . * ; import java . net . URL ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . StringTokenizer ; public class AnnotationTypeConverterLoader implements TypeConverterLoader { public static final String META_INF_SERVICES = "META-INF/services/org/apache/camel/TypeConverter" ; private static final transient Log LOG = LogFactory . getLog ( AnnotationTypeConverterLoader . class ) ; private ResolverUtil resolver = new ResolverUtil ( ) ; private Set < Class > visitedClasses = new HashSet < Class > ( ) ; public void load ( TypeConverterRegistry registry ) throws Exception { String [ ] packageNames = findPackageNames ( ) ; resolver . findAnnotated ( Converter . class , packageNames ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class type : classes ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Loading converter class: " + ObjectHelper . name ( type ) ) ; } loadConverterMethods ( registry , type ) ; } } protected String [ ] findPackageNames ( ) throws IOException { Set < String > packages = new HashSet < String > ( ) ; findPackages ( packages , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; findPackages ( packages , getClass ( ) . getClassLoader ( ) ) ; return packages . toArray ( new String [ packages . size ( ) ] ) ; } protected void findPackages ( Set < String > packages , ClassLoader classLoader ) throws IOException { Enumeration < URL > resources = classLoader . getResources ( META_INF_SERVICES ) ; while ( resources . hasMoreElements ( ) ) { URL url = resources . nextElement ( ) ; if ( url != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; try { while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . startsWith ( "#" ) || line . length ( ) == 0 ) { continue ; } tokenize ( packages , line ) ; } } finally { try { reader . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Caught exception closing stream: " + e , e ) ; } } } } } protected void tokenize ( Set < String > packages , String line ) { StringTokenizer iter = new StringTokenizer ( line , "," ) ; while ( iter . hasMoreTokens ( ) ) { String name = iter . nextToken ( ) . trim ( ) ; if ( name . length ( ) > 0 ) { packages . add ( name ) ; } } } protected void loadConverterMethods ( TypeConverterRegistry registry , Class type ) { if ( visitedClasses . contains ( type ) ) { return ; } visitedClasses . add ( type ) ; try { Method [ ] methods = type . getDeclaredMethods ( ) ; CachingInjector injector = null ; for ( Method method : methods ) { Converter annotation = method . getAnnotation ( Converter . class ) ; if ( annotation != null ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes == null || parameterTypes . length != 1 ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method should have one parameter" ) ; } else { int modifiers = method . getModifiers ( ) ; if ( isAbstract ( modifiers ) || ! isPublic ( modifiers ) ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method is not a public and concrete method" ) ; } else { Class toType = method . getReturnType ( ) ; if ( toType . equals ( Void . class ) ) { LOG . warn ( "Ignoring bad converter on type: " + type . getName ( ) + " method: " + method + " as a converter method returns a void method" ) ; } else { Class fromType = parameterTypes [ 0 ] ; if ( isStatic ( modifiers ) ) { registerTypeConverter ( registry , method , toType , fromType , new StaticMethodTypeConverter ( method ) ) ; } else { if ( injector == null ) { injector = new CachingInjector ( registry , type ) ; } registerTypeConverter ( registry , method , toType , fromType , new InstanceMethodTypeConverter ( injector , method ) ) ; } } } } } } Class superclass = type . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { loadConverterMethods ( registry , superclass ) ; } } catch ( NoClassDefFoundError e ) { LOG . debug ( "Ignoring converter type: " + type . getName ( ) + " as a dependent class could not be found: " + e , e ) ; } } protected void registerTypeConverter ( TypeConverterRegistry registry , Method method , Class toType , Class fromType , TypeConverter typeConverter ) { registry . addTypeConverter ( toType , fromType , typeConverter ) ; } } 	1
package org . apache . camel . component . file ; import java . io . File ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; public class FileExchange extends DefaultExchange { private File file ; public FileExchange ( CamelContext camelContext , File file ) { super ( camelContext ) ; setIn ( new FileMessage ( file ) ) ; this . file = file ; } public File getFile ( ) { return this . file ; } public void setFile ( File file ) { this . file = file ; } } 	0
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; import java . beans . PropertyEditor ; import java . beans . PropertyEditorManager ; public class PropertyEditorTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value == null ) { return null ; } if ( value . getClass ( ) == String . class ) { if ( toType == String . class ) { return ObjectHelper . cast ( toType , value ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( toType ) ; if ( editor != null ) { editor . setAsText ( value . toString ( ) ) ; return ObjectHelper . cast ( toType , editor . getValue ( ) ) ; } } else if ( toType == String . class ) { PropertyEditor editor = PropertyEditorManager . findEditor ( value . getClass ( ) ) ; if ( editor != null ) { editor . setValue ( value ) ; return ObjectHelper . cast ( toType , editor . getAsText ( ) ) ; } } return null ; } } 	1
package org . apache . camel . spring . util ; import org . aopalliance . intercept . MethodInvocation ; import org . apache . camel . Body ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Header ; import org . apache . camel . Property ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . Collection ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; public class BeanInfo { private static final transient Log log = LogFactory . getLog ( BeanInfo . class ) ; private Class type ; private MethodInvocationStrategy strategy ; private Map < String , MethodInfo > operations = new ConcurrentHashMap < String , MethodInfo > ( ) ; private MethodInfo defaultExpression ; public BeanInfo ( Class type , MethodInvocationStrategy strategy ) { this . type = type ; this . strategy = strategy ; } public Class getType ( ) { return type ; } public void introspect ( ) { introspect ( getType ( ) ) ; if ( operations . size ( ) == 1 ) { Collection < MethodInfo > methodInfos = operations . values ( ) ; for ( MethodInfo methodInfo : methodInfos ) { defaultExpression = methodInfo ; } } } public MethodInvocation createInvocation ( Method method , Object pojo , Exchange messageExchange ) throws RuntimeCamelException { MethodInfo methodInfo = introspect ( type , method ) ; return methodInfo . createMethodInvocation ( pojo , messageExchange ) ; } public MethodInvocation createInvocation ( Object pojo , Exchange messageExchange ) throws RuntimeCamelException { MethodInfo methodInfo = null ; String name = messageExchange . getIn ( ) . getHeader ( "org.apache.camel.MethodName" , String . class ) ; if ( name != null ) { methodInfo = operations . get ( name ) ; } if ( methodInfo == null ) { methodInfo = defaultExpression ; } if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , messageExchange ) ; } return null ; } protected void introspect ( Class clazz ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( Method method : methods ) { introspect ( clazz , method ) ; } Class superclass = clazz . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { introspect ( superclass ) ; } } protected MethodInfo introspect ( Class clazz , Method method ) { Class [ ] parameterTypes = method . getParameterTypes ( ) ; Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; final Expression [ ] parameterExpressions = new Expression [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { Class parameterType = parameterTypes [ i ] ; Expression expression = createParameterUnmarshalExpression ( clazz , method , parameterType , parameterAnnotations [ i ] ) ; if ( expression == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "No expression available for method: " + method . toString ( ) + " parameter: " + i + " so ignoring method" ) ; } if ( parameterTypes . length == 1 ) { expression = ExpressionBuilder . bodyExpression ( parameterType ) ; } else { return null ; } } parameterExpressions [ i ] = expression ; } String opName = method . getName ( ) ; Expression parametersExpression = createMethodParametersExpression ( parameterExpressions ) ; MethodInfo methodInfo = new MethodInfo ( clazz , method , parametersExpression ) ; operations . put ( opName , methodInfo ) ; return methodInfo ; } protected Expression createMethodParametersExpression ( final Expression [ ] parameterExpressions ) { return new Expression < Exchange > ( ) { public Object evaluate ( Exchange exchange ) { Object [ ] answer = new Object [ parameterExpressions . length ] ; for ( int i = 0 ; i < parameterExpressions . length ; i ++ ) { Expression parameterExpression = parameterExpressions [ i ] ; answer [ i ] = parameterExpression . evaluate ( exchange ) ; } return answer ; } @ Override public String toString ( ) { return "parametersExpression" + Arrays . asList ( parameterExpressions ) ; } } ; } protected Expression createParameterUnmarshalExpression ( Class clazz , Method method , Class parameterType , Annotation [ ] parameterAnnotation ) { for ( Annotation annotation : parameterAnnotation ) { Expression answer = createParameterUnmarshalExpressionForAnnotation ( clazz , method , parameterType , annotation ) ; if ( answer != null ) { return answer ; } } return strategy . getDefaultParameterTypeExpression ( parameterType ) ; } protected Expression createParameterUnmarshalExpressionForAnnotation ( Class clazz , Method method , Class parameterType , Annotation annotation ) { if ( annotation instanceof Property ) { Property propertyAnnotation = ( Property ) annotation ; return ExpressionBuilder . propertyExpression ( propertyAnnotation . name ( ) ) ; } else if ( annotation instanceof Header ) { Header headerAnnotation = ( Header ) annotation ; return ExpressionBuilder . headerExpression ( headerAnnotation . name ( ) ) ; } else if ( annotation instanceof Body ) { Body content = ( Body ) annotation ; return ExpressionBuilder . bodyExpression ( parameterType ) ; } return null ; } } 	0
package org . apache . camel . impl ; import java . util . concurrent . Future ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Consumer ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . converter . AsyncProcessorTypeConverter ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; public class DefaultConsumer < E extends Exchange > extends ServiceSupport implements Consumer < E > { private Endpoint < E > endpoint ; private Processor processor ; private AsyncProcessor asyncProcessor ; private ExceptionHandler exceptionHandler ; public DefaultConsumer ( Endpoint < E > endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } @ Override public String toString ( ) { return "Consumer on " + endpoint ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } public AsyncProcessor getAsyncProcessor ( ) { if ( asyncProcessor == null ) { asyncProcessor = AsyncProcessorTypeConverter . convert ( processor ) ; } return asyncProcessor ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processor ) ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processor ) ; } protected void handleException ( Throwable t ) { getExceptionHandler ( ) . handleException ( t ) ; } } 	1
package org . apache . camel . component . http ; import java . io . IOException ; import java . util . concurrent . ConcurrentHashMap ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class CamelServlet extends HttpServlet { private ConcurrentHashMap < String , HttpConsumer > consumers = new ConcurrentHashMap < String , HttpConsumer > ( ) ; public CamelServlet ( ) { } @ Override protected void service ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { try { HttpConsumer consumer = resolve ( request ) ; if ( consumer == null ) { response . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; return ; } HttpExchange exchange = new HttpExchange ( consumer . getEndpoint ( ) , request , response ) ; consumer . getProcessor ( ) . process ( exchange ) ; consumer . getBinding ( ) . writeResponse ( exchange ) ; } catch ( Exception e ) { throw new ServletException ( e ) ; } } protected HttpConsumer resolve ( HttpServletRequest request ) { String path = request . getPathInfo ( ) ; return consumers . get ( path ) ; } public void connect ( HttpConsumer consumer ) { consumers . put ( consumer . getPath ( ) , consumer ) ; } public void disconnect ( HttpConsumer consumer ) { consumers . remove ( consumer . getPath ( ) ) ; } } 	0
package org . apache . camel . component . bean ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultComponent ; import org . apache . camel . impl . ProcessorEndpoint ; import org . apache . camel . spi . Registry ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BeanComponent extends DefaultComponent { private static final Log LOG = LogFactory . getLog ( BeanComponent . class ) ; private ParameterMappingStrategy parameterMappingStrategy ; public BeanComponent ( ) { } public ProcessorEndpoint createEndpoint ( Object bean ) { String uri = "bean:generated:" + bean ; return createEndpoint ( bean , uri ) ; } public ProcessorEndpoint createEndpoint ( Object bean , String uri ) { BeanProcessor processor = new BeanProcessor ( bean , getCamelContext ( ) , getParameterMappingStrategy ( ) ) ; return createEndpoint ( uri , processor ) ; } public ParameterMappingStrategy getParameterMappingStrategy ( ) { if ( parameterMappingStrategy == null ) { parameterMappingStrategy = createParameterMappingStrategy ( ) ; } return parameterMappingStrategy ; } public void setParameterMappingStrategy ( ParameterMappingStrategy parameterMappingStrategy ) { this . parameterMappingStrategy = parameterMappingStrategy ; } protected Endpoint createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { Object bean = getBean ( remaining ) ; BeanProcessor processor = new BeanProcessor ( bean , getCamelContext ( ) , getParameterMappingStrategy ( ) ) ; setProperties ( processor , parameters ) ; return createEndpoint ( uri , processor ) ; } public Object getBean ( String remaining ) throws NoBeanAvailableException { Registry registry = getCamelContext ( ) . getRegistry ( ) ; Object bean = registry . lookup ( remaining ) ; if ( bean == null ) { throw new NoBeanAvailableException ( remaining ) ; } return bean ; } protected ProcessorEndpoint createEndpoint ( String uri , BeanProcessor processor ) { ProcessorEndpoint answer = new ProcessorEndpoint ( uri , this , processor ) ; answer . setExchangePattern ( ExchangePattern . InOut ) ; return answer ; } protected ParameterMappingStrategy createParameterMappingStrategy ( ) { return BeanProcessor . createParameterMappingStrategy ( getCamelContext ( ) ) ; } } 	1
package org . apache . camel . builder . xml ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import javax . xml . namespace . QName ; import javax . xml . xpath . XPathVariableResolver ; import java . util . HashMap ; import java . util . Map ; public class MessageVariableResolver implements XPathVariableResolver { public static final String SYSTEM_PROPERTIES_NAMESPACE = "http://camel.apache.org/xml/variables/system-properties" ; public static final String ENVIRONMENT_VARIABLES = "http://camel.apache.org/xml/variables/environment-variables" ; public static final String EXCHANGE_PROPERTY = "http://camel.apache.org/xml/variables/exchange-property" ; public static final String IN_HEADER = "http://camel.apache.org/xml/variables/in-header" ; public static final String OUT_HEADER = "http://camel.apache.org/xml/variables/out-header" ; private static final transient Log log = LogFactory . getLog ( MessageVariableResolver . class ) ; private Exchange exchange ; private Map < String , Object > variables = new HashMap < String , Object > ( ) ; public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public Object resolveVariable ( QName name ) { String uri = name . getNamespaceURI ( ) ; String localPart = name . getLocalPart ( ) ; Object answer = null ; if ( uri == null || uri . length ( ) == 0 ) { answer = variables . get ( localPart ) ; if ( answer == null ) { Message message = exchange . getIn ( ) ; if ( message != null ) { answer = message . getHeader ( localPart ) ; } if ( answer == null ) { answer = exchange . getProperty ( localPart ) ; } } } else if ( uri . equals ( SYSTEM_PROPERTIES_NAMESPACE ) ) { try { answer = System . getProperty ( localPart ) ; } catch ( Exception e ) { log . debug ( "Security exception evaluating system property: " + localPart + ". Reason: " + e , e ) ; } } else if ( uri . equals ( ENVIRONMENT_VARIABLES ) ) { answer = System . getenv ( ) . get ( localPart ) ; } else if ( uri . equals ( EXCHANGE_PROPERTY ) ) { answer = exchange . getProperty ( localPart ) ; } else if ( uri . equals ( IN_HEADER ) ) { answer = exchange . getIn ( ) . getHeader ( localPart ) ; } else if ( uri . equals ( OUT_HEADER ) ) { answer = exchange . getOut ( ) . getHeader ( localPart ) ; } return answer ; } public void addVariable ( String localPart , Object value ) { variables . put ( localPart , value ) ; } } 	0
package org . apache . camel . component . bean ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Method ; public interface MethodInvocation { Method getMethod ( ) ; Object [ ] getArguments ( ) ; Object proceed ( ) throws Throwable ; Object getThis ( ) ; AccessibleObject getStaticPart ( ) ; } 	1
package org . apache . camel . spring ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . util . ResolverUtil ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import java . lang . reflect . Constructor ; import java . lang . reflect . Modifier ; import java . util . List ; import java . util . Map ; import java . util . Set ; public class RouteBuilderFinder implements ApplicationContextAware { private String [ ] packages = { } ; private ApplicationContext applicationContext ; private ResolverUtil resolver = new ResolverUtil ( ) ; public RouteBuilderFinder ( ApplicationContext applicationContext , String [ ] packages ) { this . applicationContext = applicationContext ; this . packages = packages ; } public RouteBuilderFinder ( CamelContextFactoryBean factoryBean ) { this . applicationContext = factoryBean . getApplicationContext ( ) ; this . packages = factoryBean . getPackages ( ) ; } public String [ ] getPackages ( ) { return packages ; } public void setPackages ( String [ ] packages ) { this . packages = packages ; } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; } public void appendBuilders ( List < RouteBuilder > list ) throws IllegalAccessException , InstantiationException { resolver . findImplementations ( RouteBuilder . class , packages ) ; Set < Class > classes = resolver . getClasses ( ) ; for ( Class aClass : classes ) { if ( shouldIgnoreBean ( aClass ) ) { continue ; } if ( isValidClass ( aClass ) ) { list . add ( instantiateBuilder ( aClass ) ) ; } } } public void destroy ( ) throws Exception { } protected boolean shouldIgnoreBean ( Class type ) { Map beans = applicationContext . getBeansOfType ( type , true , true ) ; if ( beans == null || beans . isEmpty ( ) ) { return false ; } return true ; } protected boolean isValidClass ( Class type ) { if ( ! Modifier . isAbstract ( type . getModifiers ( ) ) && ! type . isInterface ( ) ) { Constructor [ ] constructors = type . getDeclaredConstructors ( ) ; for ( Constructor constructor : constructors ) { Class [ ] classes = constructor . getParameterTypes ( ) ; if ( classes . length == 0 ) { return true ; } } } return false ; } protected RouteBuilder instantiateBuilder ( Class type ) throws IllegalAccessException , InstantiationException { return ( RouteBuilder ) type . newInstance ( ) ; } } 	0
package org . apache . camel . model . config ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Exchange ; import org . apache . camel . processor . StreamResequencer ; import org . apache . camel . processor . resequencer . DefaultExchangeComparator ; import org . apache . camel . processor . resequencer . ExpressionResultComparator ; @ XmlRootElement @ XmlAccessorType ( XmlAccessType . FIELD ) public class StreamResequencerConfig { @ XmlAttribute private Integer capacity ; @ XmlAttribute private Long timeout ; @ XmlTransient private ExpressionResultComparator < Exchange > comparator ; public StreamResequencerConfig ( ) { this ( 100 , 1000L ) ; } public StreamResequencerConfig ( int capacity , long timeout ) { this ( capacity , timeout , new DefaultExchangeComparator ( ) ) ; } public StreamResequencerConfig ( int capacity , long timeout , ExpressionResultComparator < Exchange > comparator ) { this . capacity = capacity ; this . timeout = timeout ; this . comparator = comparator ; } public static StreamResequencerConfig getDefault ( ) { return new StreamResequencerConfig ( ) ; } public int getCapacity ( ) { return capacity ; } public void setCapacity ( int capacity ) { this . capacity = capacity ; } public long getTimeout ( ) { return timeout ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public ExpressionResultComparator < Exchange > getComparator ( ) { return comparator ; } public void setComparator ( ExpressionResultComparator < Exchange > comparator ) { this . comparator = comparator ; } } 	1
package org . apache . camel . util ; import java . util . concurrent . TimeUnit ; import java . util . Date ; public class Time { private long number ; private TimeUnit timeUnit = TimeUnit . MILLISECONDS ; public static Time millis ( long value ) { return new Time ( value , TimeUnit . MILLISECONDS ) ; } public static Time micros ( long value ) { return new Time ( value , TimeUnit . MICROSECONDS ) ; } public static Time nanos ( long value ) { return new Time ( value , TimeUnit . NANOSECONDS ) ; } public static Time seconds ( long value ) { return new Time ( value , TimeUnit . SECONDS ) ; } public static Time minutes ( long value ) { return new Time ( minutesAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public static Time hours ( long value ) { return new Time ( hoursAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public static Time days ( long value ) { return new Time ( daysAsSeconds ( value ) , TimeUnit . MILLISECONDS ) ; } public Time ( long number , TimeUnit timeUnit ) { this . number = number ; this . timeUnit = timeUnit ; } public long toMillis ( ) { return timeUnit . toMillis ( number ) ; } public Date toDate ( ) { return new Date ( toMillis ( ) ) ; } public long getNumber ( ) { return number ; } public TimeUnit getTimeUnit ( ) { return timeUnit ; } protected static long minutesAsSeconds ( long value ) { return value * 60 ; } protected static long hoursAsSeconds ( long value ) { return minutesAsSeconds ( value ) * 60 ; } protected static long daysAsSeconds ( long value ) { return hoursAsSeconds ( value ) * 24 ; } } 	0
package org . apache . camel ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . ProducerCache ; public class CamelTemplate < E extends Exchange > extends ServiceSupport implements ProducerTemplate < E > { private CamelContext context ; private ProducerCache < E > producerCache = new ProducerCache < E > ( ) ; private boolean useEndpointCache = true ; private Map < String , Endpoint < E > > endpointCache = new HashMap < String , Endpoint < E > > ( ) ; private Endpoint < E > defaultEndpoint ; public CamelTemplate ( CamelContext context ) { this . context = context ; } public CamelTemplate ( CamelContext context , Endpoint defaultEndpoint ) { this ( context ) ; this . defaultEndpoint = defaultEndpoint ; } public E send ( String endpointUri , E exchange ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , exchange ) ; } public E send ( String endpointUri , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor ) ; } public E send ( String endpointUri , Processor processor , AsyncCallback callback ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , processor , callback ) ; } public E send ( String endpointUri , ExchangePattern pattern , Processor processor ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return send ( endpoint , pattern , processor ) ; } public E send ( Endpoint < E > endpoint , E exchange ) { E convertedExchange = endpoint . createExchange ( exchange ) ; producerCache . send ( endpoint , convertedExchange ) ; return convertedExchange ; } public E send ( Endpoint < E > endpoint , Processor processor ) { return producerCache . send ( endpoint , processor ) ; } public E send ( Endpoint < E > endpoint , Processor processor , AsyncCallback callback ) { return producerCache . send ( endpoint , processor , callback ) ; } public E send ( Endpoint < E > endpoint , ExchangePattern pattern , Processor processor ) { return producerCache . send ( endpoint , pattern , processor ) ; } public Object sendBody ( Endpoint < E > endpoint , ExchangePattern pattern , Object body ) { E result = send ( endpoint , pattern , createSetBodyProcessor ( body ) ) ; return extractResultBody ( result ) ; } public Object sendBody ( Endpoint < E > endpoint , Object body ) { E result = send ( endpoint , createSetBodyProcessor ( body ) ) ; return extractResultBody ( result ) ; } public Object sendBody ( String endpointUri , Object body ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return sendBody ( endpoint , body ) ; } public Object sendBody ( String endpointUri , ExchangePattern pattern , Object body ) { Endpoint endpoint = resolveMandatoryEndpoint ( endpointUri ) ; return sendBody ( endpoint , pattern , body ) ; } public Object sendBodyAndHeader ( String endpointUri , final Object body , final String header , final Object headerValue ) { return sendBodyAndHeader ( resolveMandatoryEndpoint ( endpointUri ) , body , header , headerValue ) ; } public Object sendBodyAndHeader ( Endpoint endpoint , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeader ( Endpoint endpoint , ExchangePattern pattern , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , pattern , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeader ( String endpoint , ExchangePattern pattern , final Object body , final String header , final Object headerValue ) { E result = send ( endpoint , pattern , createBodyAndHeaderProcessor ( body , header , headerValue ) ) ; return extractResultBody ( result ) ; } public Object sendBodyAndHeaders ( String endpointUri , final Object body , final Map < String , Object > headers ) { return sendBodyAndHeaders ( resolveMandatoryEndpoint ( endpointUri ) , body , headers ) ; } public Object sendBodyAndHeaders ( Endpoint endpoint , final Object body , final Map < String , Object > headers ) { E result = send ( endpoint , new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; for ( Map . Entry < String , Object > header : headers . entrySet ( ) ) { in . setHeader ( header . getKey ( ) , header . getValue ( ) ) ; } in . setBody ( body ) ; } } ) ; return extractResultBody ( result ) ; } public E request ( Endpoint < E > endpoint , Processor processor ) { return send ( endpoint , ExchangePattern . InOut , processor ) ; } public Object requestBody ( Endpoint < E > endpoint , Object body ) { return sendBody ( endpoint , ExchangePattern . InOut , body ) ; } public Object requestBodyAndHeader ( Endpoint < E > endpoint , Object body , String header , Object headerValue ) { return sendBodyAndHeader ( endpoint , ExchangePattern . InOut , body , header , headerValue ) ; } public E request ( String endpoint , Processor processor ) { return send ( endpoint , ExchangePattern . InOut , processor ) ; } public Object requestBody ( String endpoint , Object body ) { return sendBody ( endpoint , ExchangePattern . InOut , body ) ; } public Object requestBodyAndHeader ( String endpoint , Object body , String header , Object headerValue ) { return sendBodyAndHeader ( endpoint , ExchangePattern . InOut , body , header , headerValue ) ; } public Object sendBody ( Object body ) { return sendBody ( getMandatoryDefaultEndpoint ( ) , body ) ; } public E send ( E exchange ) { return send ( getMandatoryDefaultEndpoint ( ) , exchange ) ; } public E send ( Processor processor ) { return send ( getMandatoryDefaultEndpoint ( ) , processor ) ; } public Object sendBodyAndHeader ( Object body , String header , Object headerValue ) { return sendBodyAndHeader ( getMandatoryDefaultEndpoint ( ) , body , header , headerValue ) ; } public Object sendBodyAndHeaders ( Object body , Map < String , Object > headers ) { return sendBodyAndHeaders ( getMandatoryDefaultEndpoint ( ) , body , headers ) ; } public Producer < E > getProducer ( Endpoint < E > endpoint ) { return producerCache . getProducer ( endpoint ) ; } public CamelContext getContext ( ) { return context ; } public Endpoint < E > getDefaultEndpoint ( ) { return defaultEndpoint ; } public void setDefaultEndpoint ( Endpoint < E > defaultEndpoint ) { this . defaultEndpoint = defaultEndpoint ; } public void setDefaultEndpointUri ( String endpointUri ) { setDefaultEndpoint ( getContext ( ) . getEndpoint ( endpointUri ) ) ; } public boolean isUseEndpointCache ( ) { return useEndpointCache ; } public void setUseEndpointCache ( boolean useEndpointCache ) { this . useEndpointCache = useEndpointCache ; } protected Processor createBodyAndHeaderProcessor ( final Object body , final String header , final Object headerValue ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setHeader ( header , headerValue ) ; in . setBody ( body ) ; } } ; } protected Processor createSetBodyProcessor ( final Object body ) { return new Processor ( ) { public void process ( Exchange exchange ) { Message in = exchange . getIn ( ) ; in . setBody ( body ) ; } } ; } protected Endpoint resolveMandatoryEndpoint ( String endpointUri ) { Endpoint endpoint = null ; if ( isUseEndpointCache ( ) ) { synchronized ( endpointCache ) { endpoint = endpointCache . get ( endpointUri ) ; if ( endpoint == null ) { endpoint = context . getEndpoint ( endpointUri ) ; if ( endpoint != null ) { endpointCache . put ( endpointUri , endpoint ) ; } } } } else { endpoint = context . getEndpoint ( endpointUri ) ; } if ( endpoint == null ) { throw new NoSuchEndpointException ( endpointUri ) ; } return endpoint ; } protected Endpoint < E > getMandatoryDefaultEndpoint ( ) { Endpoint < E > answer = getDefaultEndpoint ( ) ; ObjectHelper . notNull ( answer , "defaultEndpoint" ) ; return answer ; } protected void doStart ( ) throws Exception { producerCache . start ( ) ; } protected void doStop ( ) throws Exception { producerCache . stop ( ) ; } protected Object extractResultBody ( E result ) { Object answer = null ; if ( result != null ) { answer = result . getOut ( ) . getBody ( ) ; if ( answer == null ) { answer = result . getIn ( ) . getBody ( ) ; } } return answer ; } } 	1
package org . apache . camel . bam . model ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; public class EntitySupport { private Long id ; @ Id @ GeneratedValue public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public String toString ( ) { return getClass ( ) . getName ( ) + "[" + id + "]" ; } } 	0
package org . apache . camel . component . file . strategy ; import java . io . File ; import org . apache . camel . component . file . FileEndpoint ; import org . apache . camel . component . file . FileExchange ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeleteFileProcessStrategy extends FileProcessStrategySupport { private static final transient Log LOG = LogFactory . getLog ( DeleteFileProcessStrategy . class ) ; public DeleteFileProcessStrategy ( ) { } public DeleteFileProcessStrategy ( boolean lockFile ) { super ( lockFile ) ; } public void commit ( FileEndpoint endpoint , FileExchange exchange , File file ) throws Exception { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Deleting file: " + file ) ; } file . delete ( ) ; super . commit ( endpoint , exchange , file ) ; } } 	1
package org . apache . camel ; public class ResolveEndpointFailedException extends RuntimeCamelException { private final String uri ; public ResolveEndpointFailedException ( String uri , Throwable cause ) { super ( "Failed to resolve endpoint: " + uri + " due to: " + cause , cause ) ; this . uri = uri ; } public String getUri ( ) { return uri ; } } 	0
package org . apache . camel . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . lang . annotation . Annotation ; import java . net . URL ; import java . net . URLDecoder ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . jar . JarEntry ; import java . util . jar . JarInputStream ; public class ResolverUtil < T > { private static final transient Log LOG = LogFactory . getLog ( ResolverUtil . class ) ; public static interface Test { boolean matches ( Class type ) ; } public static class IsA implements Test { private Class parent ; public IsA ( Class parentType ) { this . parent = parentType ; } public boolean matches ( Class type ) { return type != null && parent . isAssignableFrom ( type ) ; } @ Override public String toString ( ) { return "is assignable to " + parent . getSimpleName ( ) ; } } public static class AnnotatedWith implements Test { private Class < ? extends Annotation > annotation ; public AnnotatedWith ( Class < ? extends Annotation > annotation ) { this . annotation = annotation ; } public boolean matches ( Class type ) { return type != null && type . isAnnotationPresent ( annotation ) ; } @ Override public String toString ( ) { return "annotated with @" + annotation . getSimpleName ( ) ; } } private Set < Class < ? extends T > > matches = new HashSet < Class < ? extends T > > ( ) ; private Set < ClassLoader > classLoaders ; public Set < Class < ? extends T > > getClasses ( ) { return matches ; } public Set < ClassLoader > getClassLoaders ( ) { if ( classLoaders == null ) { classLoaders = new HashSet < ClassLoader > ( ) ; classLoaders . add ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } return classLoaders ; } public void setClassLoaders ( Set < ClassLoader > classLoaders ) { this . classLoaders = classLoaders ; } public void findImplementations ( Class parent , String ... packageNames ) { if ( packageNames == null ) { return ; } LOG . debug ( "Searching for implementations of " + parent . getName ( ) + " in packages: " + Arrays . asList ( packageNames ) ) ; Test test = new IsA ( parent ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } LOG . debug ( "Found: " + getClasses ( ) ) ; } public void findAnnotated ( Class < ? extends Annotation > annotation , String ... packageNames ) { if ( packageNames == null ) { return ; } Test test = new AnnotatedWith ( annotation ) ; for ( String pkg : packageNames ) { find ( test , pkg ) ; } } public void find ( Test test , String packageName ) { packageName = packageName . replace ( '.' , '/' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; for ( ClassLoader classLoader : set ) { LOG . trace ( "Searching: " + classLoader ) ; find ( test , packageName , classLoader ) ; } } protected void find ( Test test , String packageName , ClassLoader loader ) { Enumeration < URL > urls ; try { urls = loader . getResources ( packageName ) ; } catch ( IOException ioe ) { LOG . warn ( "Could not read package: " + packageName , ioe ) ; return ; } while ( urls . hasMoreElements ( ) ) { try { URL url = urls . nextElement ( ) ; String urlPath = url . getFile ( ) ; urlPath = URLDecoder . decode ( urlPath , "UTF-8" ) ; if ( urlPath . startsWith ( "file:" ) ) { urlPath = urlPath . substring ( 5 ) ; } if ( urlPath . indexOf ( '!' ) > 0 ) { urlPath = urlPath . substring ( 0 , urlPath . indexOf ( '!' ) ) ; } LOG . debug ( "Scanning for classes in [" + urlPath + "] matching criteria: " + test ) ; File file = new File ( urlPath ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageName , file ) ; } else { loadImplementationsInJar ( test , packageName , file ) ; } } catch ( IOException ioe ) { LOG . warn ( "could not read entries" , ioe ) ; } } } private void loadImplementationsInDirectory ( Test test , String parent , File location ) { File [ ] files = location . listFiles ( ) ; StringBuilder builder = null ; for ( File file : files ) { builder = new StringBuilder ( 100 ) ; String name = file . getName ( ) ; if ( name != null ) { name = name . trim ( ) ; } builder . append ( parent ) . append ( "/" ) . append ( name ) ; String packageOrClass = parent == null ? name : builder . toString ( ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageOrClass , file ) ; } else if ( name . endsWith ( ".class" ) ) { addIfMatching ( test , packageOrClass ) ; } } } private void loadImplementationsInJar ( Test test , String parent , File jarfile ) { try { JarEntry entry ; JarInputStream jarStream = new JarInputStream ( new FileInputStream ( jarfile ) ) ; while ( ( entry = jarStream . getNextJarEntry ( ) ) != null ) { String name = entry . getName ( ) ; if ( name != null ) { name = name . trim ( ) ; } if ( ! entry . isDirectory ( ) && name . startsWith ( parent ) && name . endsWith ( ".class" ) ) { addIfMatching ( test , name ) ; } } } catch ( IOException ioe ) { LOG . error ( "Could not search jar file '" + jarfile + "' for classes matching criteria: " + test + "due to an IOException: " + ioe . getMessage ( ) ) ; } } protected void addIfMatching ( Test test , String fqn ) { try { String externalName = fqn . substring ( 0 , fqn . indexOf ( '.' ) ) . replace ( '/' , '.' ) ; Set < ClassLoader > set = getClassLoaders ( ) ; boolean found = false ; for ( ClassLoader classLoader : set ) { LOG . trace ( "Checking to see if class " + externalName + " matches criteria [" + test + "]" ) ; try { Class type = classLoader . loadClass ( externalName ) ; if ( test . matches ( type ) ) { matches . add ( ( Class < T > ) type ) ; } found = true ; break ; } catch ( ClassNotFoundException e ) { LOG . debug ( "Could not find class '" + fqn + "' in class loader: " + classLoader + ". Reason: " + e , e ) ; } } if ( ! found ) { LOG . warn ( "Could not find class '" + fqn + "' in any class loaders: " + set ) ; } } catch ( Throwable t ) { LOG . warn ( "Could not examine class '" + fqn + "' due to a " + t . getClass ( ) . getName ( ) + " with message: " + t . getMessage ( ) ) ; } } } 	1
package org . apache . camel . component . jms ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . util . ObjectHelper ; import org . springframework . core . task . TaskExecutor ; import org . springframework . jms . core . JmsOperations ; import org . springframework . jms . core . JmsTemplate ; import org . springframework . jms . core . JmsTemplate102 ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer ; import org . springframework . jms . listener . DefaultMessageListenerContainer102 ; import org . springframework . jms . listener . SimpleMessageListenerContainer ; import org . springframework . jms . listener . SimpleMessageListenerContainer102 ; import org . springframework . jms . listener . serversession . ServerSessionFactory ; import org . springframework . jms . listener . serversession . ServerSessionMessageListenerContainer ; import org . springframework . jms . listener . serversession . ServerSessionMessageListenerContainer102 ; import org . springframework . jms . support . converter . MessageConverter ; import org . springframework . transaction . PlatformTransactionManager ; import javax . jms . ConnectionFactory ; import javax . jms . ExceptionListener ; public class JmsConfiguration implements Cloneable { protected static final String TRANSACTED = "TRANSACTED" ; protected static final String CLIENT_ACKNOWLEDGE = "CLIENT_ACKNOWLEDGE" ; protected static final String AUTO_ACKNOWLEDGE = "AUTO_ACKNOWLEDGE" ; protected static final String DUPS_OK_ACKNOWLEDGE = "DUPS_OK_ACKNOWLEDGE" ; private ConnectionFactory connectionFactory ; private ConnectionFactory templateConnectionFactory ; private ConnectionFactory listenerConnectionFactory ; private int acknowledgementMode = - 1 ; private String acknowledgementModeName = AUTO_ACKNOWLEDGE ; private ExceptionListener exceptionListener ; private ConsumerType consumerType = ConsumerType . Default ; private boolean autoStartup = true ; private boolean acceptMessagesWhileStopping ; private String clientId ; private String durableSubscriptionName ; private boolean subscriptionDurable ; private boolean exposeListenerSession = true ; private TaskExecutor taskExecutor ; private boolean pubSubNoLocal ; private int concurrentConsumers = 1 ; private int maxMessagesPerTask = 1 ; private ServerSessionFactory serverSessionFactory ; private int cacheLevel = - 1 ; private String cacheLevelName = "CACHE_CONSUMER" ; private long recoveryInterval = - 1 ; private long receiveTimeout = - 1 ; private int idleTaskExecutionLimit = 1 ; private int maxConcurrentConsumers = 1 ; private boolean useVersion102 = false ; private boolean explicitQosEnabled = false ; private boolean deliveryPersistent = true ; private long timeToLive = - 1 ; private MessageConverter messageConverter ; private boolean messageIdEnabled = true ; private boolean messageTimestampEnabled = true ; private int priority = - 1 ; private boolean transacted ; private PlatformTransactionManager transactionManager ; private String transactionName ; private int transactionTimeout = - 1 ; public JmsConfiguration ( ) { } public JmsConfiguration ( ConnectionFactory connectionFactory ) { this . connectionFactory = connectionFactory ; } public JmsConfiguration copy ( ) { try { return ( JmsConfiguration ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } } public JmsOperations createJmsOperations ( boolean pubSubDomain , String destination ) { ConnectionFactory factory = getTemplateConnectionFactory ( ) ; JmsTemplate template = useVersion102 ? new JmsTemplate102 ( factory , pubSubDomain ) : new JmsTemplate ( factory ) ; template . setPubSubDomain ( pubSubDomain ) ; template . setDefaultDestinationName ( destination ) ; template . setExplicitQosEnabled ( explicitQosEnabled ) ; template . setDeliveryPersistent ( deliveryPersistent ) ; if ( messageConverter != null ) { template . setMessageConverter ( messageConverter ) ; } template . setMessageIdEnabled ( messageIdEnabled ) ; template . setMessageTimestampEnabled ( messageTimestampEnabled ) ; if ( priority >= 0 ) { template . setPriority ( priority ) ; } template . setPubSubNoLocal ( pubSubNoLocal ) ; if ( receiveTimeout >= 0 ) { template . setReceiveTimeout ( receiveTimeout ) ; } if ( timeToLive >= 0 ) { template . setTimeToLive ( timeToLive ) ; } template . setSessionTransacted ( transacted ) ; if ( acknowledgementMode >= 0 ) { template . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { template . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } return template ; } public AbstractMessageListenerContainer createMessageListenerContainer ( ) { AbstractMessageListenerContainer container = chooseMessageListenerContainerImplementation ( ) ; configureMessageListenerContainer ( container ) ; return container ; } protected void configureMessageListenerContainer ( AbstractMessageListenerContainer container ) { container . setConnectionFactory ( getListenerConnectionFactory ( ) ) ; if ( autoStartup ) { container . setAutoStartup ( true ) ; } if ( clientId != null ) { container . setClientId ( clientId ) ; } container . setSubscriptionDurable ( subscriptionDurable ) ; if ( durableSubscriptionName != null ) { container . setDurableSubscriptionName ( durableSubscriptionName ) ; } if ( durableSubscriptionName != null && clientId != null ) { container . setSubscriptionDurable ( true ) ; } if ( exceptionListener != null ) { container . setExceptionListener ( exceptionListener ) ; } container . setAcceptMessagesWhileStopping ( acceptMessagesWhileStopping ) ; container . setExposeListenerSession ( exposeListenerSession ) ; container . setSessionTransacted ( transacted ) ; if ( acknowledgementMode >= 0 ) { container . setSessionAcknowledgeMode ( acknowledgementMode ) ; } else if ( acknowledgementModeName != null ) { container . setSessionAcknowledgeModeName ( acknowledgementModeName ) ; } if ( container instanceof DefaultMessageListenerContainer ) { DefaultMessageListenerContainer listenerContainer = ( DefaultMessageListenerContainer ) container ; if ( concurrentConsumers >= 0 ) { listenerContainer . setConcurrentConsumers ( concurrentConsumers ) ; } if ( cacheLevel >= 0 ) { listenerContainer . setCacheLevel ( cacheLevel ) ; } else if ( cacheLevelName != null ) { listenerContainer . setCacheLevelName ( cacheLevelName ) ; } else { listenerContainer . setCacheLevel ( DefaultMessageListenerContainer . CACHE_CONSUMER ) ; } if ( idleTaskExecutionLimit >= 0 ) { listenerContainer . setIdleTaskExecutionLimit ( idleTaskExecutionLimit ) ; } if ( maxConcurrentConsumers >= 0 ) { listenerContainer . setMaxConcurrentConsumers ( maxConcurrentConsumers ) ; } if ( maxMessagesPerTask >= 0 ) { listenerContainer . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } listenerContainer . setPubSubNoLocal ( pubSubNoLocal ) ; if ( receiveTimeout >= 0 ) { listenerContainer . setReceiveTimeout ( receiveTimeout ) ; } if ( recoveryInterval >= 0 ) { listenerContainer . setRecoveryInterval ( recoveryInterval ) ; } if ( taskExecutor != null ) { listenerContainer . setTaskExecutor ( taskExecutor ) ; } if ( transactionManager != null ) { listenerContainer . setTransactionManager ( transactionManager ) ; } if ( transactionName != null ) { listenerContainer . setTransactionName ( transactionName ) ; } if ( transactionTimeout >= 0 ) { listenerContainer . setTransactionTimeout ( transactionTimeout ) ; } } else if ( container instanceof ServerSessionMessageListenerContainer ) { ServerSessionMessageListenerContainer listenerContainer = ( ServerSessionMessageListenerContainer ) container ; if ( maxMessagesPerTask >= 0 ) { listenerContainer . setMaxMessagesPerTask ( maxMessagesPerTask ) ; } if ( serverSessionFactory != null ) { listenerContainer . setServerSessionFactory ( serverSessionFactory ) ; } } else if ( container instanceof SimpleMessageListenerContainer ) { SimpleMessageListenerContainer listenerContainer = ( SimpleMessageListenerContainer ) container ; if ( concurrentConsumers >= 0 ) { listenerContainer . setConcurrentConsumers ( concurrentConsumers ) ; } listenerContainer . setPubSubNoLocal ( pubSubNoLocal ) ; if ( taskExecutor != null ) { listenerContainer . setTaskExecutor ( taskExecutor ) ; } } } public ConnectionFactory getConnectionFactory ( ) { if ( connectionFactory == null ) { connectionFactory = createConnectionFactory ( ) ; } return connectionFactory ; } public void setConnectionFactory ( ConnectionFactory connectionFactory ) { this . connectionFactory = connectionFactory ; } public ConnectionFactory getListenerConnectionFactory ( ) { if ( listenerConnectionFactory == null ) { listenerConnectionFactory = createListenerConnectionFactory ( ) ; } return listenerConnectionFactory ; } public void setListenerConnectionFactory ( ConnectionFactory listenerConnectionFactory ) { this . listenerConnectionFactory = listenerConnectionFactory ; } public ConnectionFactory getTemplateConnectionFactory ( ) { if ( templateConnectionFactory == null ) { templateConnectionFactory = createTemplateConnectionFactory ( ) ; } return templateConnectionFactory ; } public void setTemplateConnectionFactory ( ConnectionFactory templateConnectionFactory ) { this . templateConnectionFactory = templateConnectionFactory ; } public boolean isUseVersion102 ( ) { return useVersion102 ; } public void setUseVersion102 ( boolean useVersion102 ) { this . useVersion102 = useVersion102 ; } public boolean isAutoStartup ( ) { return autoStartup ; } public void setAutoStartup ( boolean autoStartup ) { this . autoStartup = autoStartup ; } public boolean isAcceptMessagesWhileStopping ( ) { return acceptMessagesWhileStopping ; } public void setAcceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping ) { this . acceptMessagesWhileStopping = acceptMessagesWhileStopping ; } public String getClientId ( ) { return clientId ; } public void setClientId ( String consumerClientId ) { this . clientId = consumerClientId ; } public String getDurableSubscriptionName ( ) { return durableSubscriptionName ; } public void setDurableSubscriptionName ( String durableSubscriptionName ) { this . durableSubscriptionName = durableSubscriptionName ; } public ExceptionListener getExceptionListener ( ) { return exceptionListener ; } public void setExceptionListener ( ExceptionListener exceptionListener ) { this . exceptionListener = exceptionListener ; } public boolean isSubscriptionDurable ( ) { return subscriptionDurable ; } public void setSubscriptionDurable ( boolean subscriptionDurable ) { this . subscriptionDurable = subscriptionDurable ; } public String getAcknowledgementModeName ( ) { return acknowledgementModeName ; } public void setAcknowledgementModeName ( String consumerAcknowledgementMode ) { this . acknowledgementModeName = consumerAcknowledgementMode ; this . acknowledgementMode = - 1 ; } public boolean isExposeListenerSession ( ) { return exposeListenerSession ; } public void setExposeListenerSession ( boolean exposeListenerSession ) { this . exposeListenerSession = exposeListenerSession ; } public TaskExecutor getTaskExecutor ( ) { return taskExecutor ; } public void setTaskExecutor ( TaskExecutor taskExecutor ) { this . taskExecutor = taskExecutor ; } public boolean isPubSubNoLocal ( ) { return pubSubNoLocal ; } public void setPubSubNoLocal ( boolean pubSubNoLocal ) { this . pubSubNoLocal = pubSubNoLocal ; } public int getConcurrentConsumers ( ) { return concurrentConsumers ; } public void setConcurrentConsumers ( int concurrentConsumers ) { this . concurrentConsumers = concurrentConsumers ; } public int getMaxMessagesPerTask ( ) { return maxMessagesPerTask ; } public void setMaxMessagesPerTask ( int maxMessagesPerTask ) { this . maxMessagesPerTask = maxMessagesPerTask ; } public ServerSessionFactory getServerSessionFactory ( ) { return serverSessionFactory ; } public void setServerSessionFactory ( ServerSessionFactory serverSessionFactory ) { this . serverSessionFactory = serverSessionFactory ; } public int getCacheLevel ( ) { return cacheLevel ; } public void setCacheLevel ( int cacheLevel ) { this . cacheLevel = cacheLevel ; } public String getCacheLevelName ( ) { return cacheLevelName ; } public void setCacheLevelName ( String cacheName ) { this . cacheLevelName = cacheName ; } public long getRecoveryInterval ( ) { return recoveryInterval ; } public void setRecoveryInterval ( long recoveryInterval ) { this . recoveryInterval = recoveryInterval ; } public long getReceiveTimeout ( ) { return receiveTimeout ; } public void setReceiveTimeout ( long receiveTimeout ) { this . receiveTimeout = receiveTimeout ; } public PlatformTransactionManager getTransactionManager ( ) { return transactionManager ; } public void setTransactionManager ( PlatformTransactionManager transactionManager ) { this . transactionManager = transactionManager ; } public String getTransactionName ( ) { return transactionName ; } public void setTransactionName ( String transactionName ) { this . transactionName = transactionName ; } public int getTransactionTimeout ( ) { return transactionTimeout ; } public void setTransactionTimeout ( int transactionTimeout ) { this . transactionTimeout = transactionTimeout ; } public int getIdleTaskExecutionLimit ( ) { return idleTaskExecutionLimit ; } public void setIdleTaskExecutionLimit ( int idleTaskExecutionLimit ) { this . idleTaskExecutionLimit = idleTaskExecutionLimit ; } public int getMaxConcurrentConsumers ( ) { return maxConcurrentConsumers ; } public void setMaxConcurrentConsumers ( int maxConcurrentConsumers ) { this . maxConcurrentConsumers = maxConcurrentConsumers ; } public boolean isExplicitQosEnabled ( ) { return explicitQosEnabled ; } public void setExplicitQosEnabled ( boolean explicitQosEnabled ) { this . explicitQosEnabled = explicitQosEnabled ; } public boolean isDeliveryPersistent ( ) { return deliveryPersistent ; } public void setDeliveryPersistent ( boolean deliveryPersistent ) { this . deliveryPersistent = deliveryPersistent ; } public long getTimeToLive ( ) { return timeToLive ; } public void setTimeToLive ( long timeToLive ) { this . timeToLive = timeToLive ; } public MessageConverter getMessageConverter ( ) { return messageConverter ; } public void setMessageConverter ( MessageConverter messageConverter ) { this . messageConverter = messageConverter ; } public boolean isMessageIdEnabled ( ) { return messageIdEnabled ; } public void setMessageIdEnabled ( boolean messageIdEnabled ) { this . messageIdEnabled = messageIdEnabled ; } public boolean isMessageTimestampEnabled ( ) { return messageTimestampEnabled ; } public void setMessageTimestampEnabled ( boolean messageTimestampEnabled ) { this . messageTimestampEnabled = messageTimestampEnabled ; } public int getPriority ( ) { return priority ; } public void setPriority ( int priority ) { this . priority = priority ; } public ConsumerType getConsumerType ( ) { return consumerType ; } public void setConsumerType ( ConsumerType consumerType ) { this . consumerType = consumerType ; } public int getAcknowledgementMode ( ) { return acknowledgementMode ; } public void setAcknowledgementMode ( int consumerAcknowledgementMode ) { this . acknowledgementMode = consumerAcknowledgementMode ; this . acknowledgementModeName = null ; } public boolean isTransacted ( ) { return transacted ; } public void setTransacted ( boolean consumerTransacted ) { this . transacted = consumerTransacted ; } protected AbstractMessageListenerContainer chooseMessageListenerContainerImplementation ( ) { switch ( consumerType ) { case Simple : return isUseVersion102 ( ) ? new SimpleMessageListenerContainer102 ( ) : new SimpleMessageListenerContainer ( ) ; case ServerSessionPool : return isUseVersion102 ( ) ? new ServerSessionMessageListenerContainer102 ( ) : new ServerSessionMessageListenerContainer ( ) ; case Default : return isUseVersion102 ( ) ? new DefaultMessageListenerContainer102 ( ) : new DefaultMessageListenerContainer ( ) ; default : throw new IllegalArgumentException ( "Unknown consumer type: " + consumerType ) ; } } protected ConnectionFactory createConnectionFactory ( ) { ObjectHelper . notNull ( connectionFactory , "connectionFactory" ) ; return null ; } protected ConnectionFactory createListenerConnectionFactory ( ) { return getConnectionFactory ( ) ; } protected ConnectionFactory createTemplateConnectionFactory ( ) { return getConnectionFactory ( ) ; } } 	0
package org . apache . camel . builder . xml ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . spi . Language ; import javax . xml . namespace . QName ; public class XPathLanguage implements Language { private QName resultType ; public Predicate < Exchange > createPredicate ( String expression ) { XPathBuilder builder = XPathBuilder . xpath ( expression ) ; configureBuilder ( builder ) ; return builder ; } public Expression < Exchange > createExpression ( String expression ) { XPathBuilder builder = XPathBuilder . xpath ( expression ) ; configureBuilder ( builder ) ; return builder ; } public QName getResultType ( ) { return resultType ; } public void setResultType ( QName resultType ) { this . resultType = resultType ; } protected void configureBuilder ( XPathBuilder builder ) { if ( resultType != null ) { builder . setResultType ( resultType ) ; } } } 	1
package org . apache . camel . spring . xml ; import org . apache . camel . spring . CamelContextFactoryBean ; import org . apache . camel . spring . EndpointFactoryBean ; import org . apache . camel . spring . CamelBeanPostProcessor ; import static org . apache . camel . util . ObjectHelper . isNotNullOrBlank ; import org . apache . camel . builder . xml . XPathBuilder ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import org . springframework . beans . factory . parsing . BeanComponentDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . util . xml . DomUtils ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import java . util . Set ; import java . util . HashSet ; public class CamelNamespaceHandler extends NamespaceHandlerSupport { protected CamelBeanDefinitionParser routesParser = new CamelBeanDefinitionParser ( this ) ; protected BeanDefinitionParser endpointParser = new BeanDefinitionParser ( EndpointFactoryBean . class ) ; protected BeanDefinitionParser beanPostProcessorParser = new BeanDefinitionParser ( CamelBeanPostProcessor . class ) ; protected Set < String > parserElementNames = new HashSet < String > ( ) ; public void init ( ) { registerParser ( "routes" , routesParser ) ; registerParser ( "routeBuilder" , routesParser ) ; registerParser ( "endpoint" , endpointParser ) ; registerParser ( "camelContext" , new BeanDefinitionParser ( CamelContextFactoryBean . class ) { @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { super . doParse ( element , parserContext , builder ) ; String contextId = element . getAttribute ( "id" ) ; Element routes = element . getOwnerDocument ( ) . createElement ( "routes" ) ; NodeList list = element . getChildNodes ( ) ; for ( int size = list . getLength ( ) , i = 0 ; i < size ; i ++ ) { Node child = list . item ( i ) ; if ( child instanceof Element ) { Element childElement = ( Element ) child ; if ( child . getLocalName ( ) . equals ( "beanPostProcessor" ) ) { String beanPostProcessorId = contextId + ":beanPostProcessor" ; childElement . setAttribute ( "id" , beanPostProcessorId ) ; BeanDefinition definition = beanPostProcessorParser . parse ( childElement , parserContext ) ; definition . getPropertyValues ( ) . addPropertyValue ( "camelContext" , new RuntimeBeanReference ( contextId ) ) ; } else { element . removeChild ( child ) ; routes . appendChild ( child ) ; } } } String routeId = contextId + ":routes" ; routes . setAttribute ( "id" , routeId ) ; BeanDefinition definition = routesParser . parse ( routes , parserContext ) ; definition . getPropertyValues ( ) . addPropertyValue ( "context" , new RuntimeBeanReference ( contextId ) ) ; parserContext . registerComponent ( new BeanComponentDefinition ( definition , routeId ) ) ; list = routes . getElementsByTagName ( "endpoint" ) ; for ( int size = list . getLength ( ) , i = 0 ; i < size ; i ++ ) { Element node = ( Element ) list . item ( i ) ; definition = endpointParser . parse ( node , parserContext ) ; String id = node . getAttribute ( "id" ) ; if ( isNotNullOrBlank ( id ) ) { definition . getPropertyValues ( ) . addPropertyValue ( "context" , new RuntimeBeanReference ( contextId ) ) ; parserContext . registerComponent ( new BeanComponentDefinition ( definition , id ) ) ; } } } } ) ; registerParser ( "xpath" , new BeanDefinitionParser ( XPathBuilder . class ) { @ Override protected void doParse ( Element element , ParserContext parserContext , BeanDefinitionBuilder builder ) { String xpath = DomUtils . getTextValue ( element ) ; builder . addConstructorArg ( xpath ) ; super . doParse ( element , parserContext , builder ) ; builder . addPropertyValue ( "namespacesFromDom" , element ) ; } } ) ; registerScriptParser ( "script" , null ) ; registerScriptParser ( "groovy" , "groovy" ) ; registerScriptParser ( "ruby" , "jruby" ) ; registerScriptParser ( "javaScript" , "js" ) ; registerScriptParser ( "python" , "python" ) ; registerScriptParser ( "php" , "php" ) ; } protected void registerScriptParser ( String elementName , String engineName ) { registerParser ( elementName , new ScriptDefinitionParser ( engineName ) ) ; } protected void registerParser ( String name , org . springframework . beans . factory . xml . BeanDefinitionParser parser ) { parserElementNames . add ( name ) ; registerBeanDefinitionParser ( name , parser ) ; } public Set < String > getParserElementNames ( ) { return parserElementNames ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . model . ExceptionType ; import java . util . IdentityHashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; public abstract class ErrorHandlerSupport extends ServiceSupport implements ErrorHandler { private Map < Class , ExceptionType > exceptionPolicices = new IdentityHashMap < Class , ExceptionType > ( ) ; public void addExceptionPolicy ( ExceptionType exception ) { Processor processor = exception . getErrorHandler ( ) ; addChildService ( processor ) ; List < Class > list = exception . getExceptionClasses ( ) ; for ( Class exceptionType : list ) { exceptionPolicices . put ( exceptionType , exception ) ; } } protected boolean customProcessorForException ( Exchange exchange , Throwable exception ) throws Exception { ExceptionType policy = getExceptionPolicy ( exchange , exception ) ; Processor processor = policy . getErrorHandler ( ) ; if ( processor != null ) { processor . process ( exchange ) ; return true ; } return false ; } protected ExceptionType getExceptionPolicy ( Exchange exchange , Throwable exception ) { Set < Map . Entry < Class , ExceptionType > > entries = exceptionPolicices . entrySet ( ) ; for ( Map . Entry < Class , ExceptionType > entry : entries ) { Class type = entry . getKey ( ) ; if ( type . isInstance ( exception ) ) { return entry . getValue ( ) ; } } return null ; } } 	1
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingErrorHandler ; import org . apache . camel . processor . LoggingLevel ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class LoggingErrorHandlerBuilder implements ErrorHandlerBuilder { private Log log = LogFactory . getLog ( Logger . class ) ; private LoggingLevel level = LoggingLevel . INFO ; public LoggingErrorHandlerBuilder ( ) { } public LoggingErrorHandlerBuilder ( Log log ) { this . log = log ; } public LoggingErrorHandlerBuilder ( Log log , LoggingLevel level ) { this . log = log ; this . level = level ; } public ErrorHandlerBuilder copy ( ) { LoggingErrorHandlerBuilder answer = new LoggingErrorHandlerBuilder ( ) ; answer . setLog ( getLog ( ) ) ; answer . setLevel ( getLevel ( ) ) ; return answer ; } public Processor createErrorHandler ( Processor processor ) { return new LoggingErrorHandler ( processor , log , level ) ; } public LoggingLevel getLevel ( ) { return level ; } public void setLevel ( LoggingLevel level ) { this . level = level ; } public Log getLog ( ) { return log ; } public void setLog ( Log log ) { this . log = log ; } } 	0
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . CatchProcessor ; import org . apache . camel . util . ObjectHelper ; @ XmlRootElement ( name = "catch" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class CatchType extends ProcessorType { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElement ( name = "exception" ) private List < String > exceptions = new ArrayList < String > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; @ XmlTransient private List < Class > exceptionClasses ; public CatchType ( ) { } public CatchType ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public CatchType ( Class exceptionType ) { exceptionClasses = new ArrayList < Class > ( ) ; exceptionClasses . add ( exceptionType ) ; } @ Override public String toString ( ) { return "Catch[ " + getExceptionClasses ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return getExceptionClasses ( ) . toString ( ) ; } @ Override public CatchProcessor createProcessor ( RouteContext routeContext ) throws Exception { Processor childProcessor = routeContext . createProcessor ( this ) ; return new CatchProcessor ( getExceptionClasses ( ) , childProcessor ) ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public List < Class > getExceptionClasses ( ) { if ( exceptionClasses == null ) { exceptionClasses = createExceptionClasses ( ) ; } return exceptionClasses ; } public void setExceptionClasses ( List < Class > exceptionClasses ) { this . exceptionClasses = exceptionClasses ; } public List < String > getExceptions ( ) { return exceptions ; } public void setExceptions ( List < String > exceptions ) { this . exceptions = exceptions ; } protected List < Class > createExceptionClasses ( ) { List < String > list = getExceptions ( ) ; List < Class > answer = new ArrayList < Class > ( list . size ( ) ) ; for ( String name : list ) { Class type = ObjectHelper . loadClass ( name , getClass ( ) . getClassLoader ( ) ) ; answer . add ( type ) ; } return answer ; } } 	1
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; public class ProcessorBuilder { public static Processor setBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setBody(" + expression + ")" ; } } ; } public static Processor setOutBody ( final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object newBody = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setBody ( newBody ) ; } @ Override public String toString ( ) { return "setOutBody(" + expression + ")" ; } } ; } public static Processor setHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getIn ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setOutHeader ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . getOut ( ) . setHeader ( name , value ) ; } @ Override public String toString ( ) { return "setOutHeader(" + name + ", " + expression + ")" ; } } ; } public static Processor setProperty ( final String name , final Expression expression ) { return new Processor ( ) { public void process ( Exchange exchange ) { Object value = expression . evaluate ( exchange ) ; exchange . setProperty ( name , value ) ; } @ Override public String toString ( ) { return "setProperty(" + name + ", " + expression + ")" ; } } ; } } 	0
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . util . * ; @ Converter public class CollectionConverter { private CollectionConverter ( ) { } @ Converter public static Object [ ] toArray ( Collection value ) { if ( value == null ) { return null ; } return value . toArray ( ) ; } @ Converter public static List toList ( Object [ ] array ) { return Arrays . asList ( array ) ; } @ Converter public static List toList ( Collection collection ) { return new ArrayList ( collection ) ; } @ Converter public static Set toSet ( Object [ ] array ) { Set answer = new HashSet ( ) ; for ( Object element : array ) { answer . add ( element ) ; } return answer ; } @ Converter public static Set toSet ( Collection collection ) { return new HashSet ( collection ) ; } @ Converter public static Set toSet ( Map map ) { return map . entrySet ( ) ; } @ Converter public static Properties toProperties ( Map map ) { Properties answer = new Properties ( ) ; answer . putAll ( map ) ; return answer ; } @ Converter public static Hashtable toHashtable ( Map map ) { return new Hashtable ( map ) ; } @ Converter public static HashMap toHashMap ( Map map ) { return new HashMap ( map ) ; } } 	1
package org . apache . camel . builder ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD ) public @ interface Fluent { String value ( ) default "" ; boolean nestedActions ( ) default false ; boolean callOnElementEnd ( ) default false ; } 	0
package org . apache . camel . impl ; import org . apache . camel . Service ; import org . apache . camel . util . ServiceHelper ; import java . util . ArrayList ; import java . util . Collection ; import java . util . concurrent . atomic . AtomicBoolean ; import org . springframework . jmx . export . annotation . ManagedAttribute ; import org . springframework . jmx . export . annotation . ManagedOperation ; import org . springframework . jmx . export . annotation . ManagedResource ; public abstract class ServiceSupport implements Service { private static int threadCounter ; private AtomicBoolean started = new AtomicBoolean ( false ) ; private AtomicBoolean starting = new AtomicBoolean ( false ) ; private AtomicBoolean stopping = new AtomicBoolean ( false ) ; private AtomicBoolean stopped = new AtomicBoolean ( false ) ; private Collection childServices ; public void start ( ) throws Exception { if ( started . compareAndSet ( false , true ) ) { starting . set ( true ) ; try { if ( childServices != null ) { ServiceHelper . startServices ( childServices ) ; } doStart ( ) ; } finally { starting . set ( false ) ; } } } public void stop ( ) throws Exception { if ( started . get ( ) && stopping . compareAndSet ( false , true ) ) { try { doStop ( ) ; } finally { if ( childServices != null ) { ServiceHelper . stopServices ( childServices ) ; } stopped . set ( true ) ; started . set ( false ) ; stopping . set ( false ) ; } } } public boolean isStarted ( ) { return started . get ( ) ; } public boolean isStarting ( ) { return starting . get ( ) ; } public boolean isStopping ( ) { return stopping . get ( ) ; } protected boolean isRunAllowed ( ) { return ! ( stopping . get ( ) || stopped . get ( ) ) ; } public boolean isStopped ( ) { return stopped . get ( ) ; } protected abstract void doStart ( ) throws Exception ; protected abstract void doStop ( ) throws Exception ; protected String getThreadName ( String prefix ) { return prefix + " thread:" + nextThreadCounter ( ) ; } protected static synchronized int nextThreadCounter ( ) { return ++ threadCounter ; } protected void addChildService ( Object childService ) { if ( childServices == null ) { childServices = new ArrayList ( ) ; } childServices . add ( childService ) ; } protected boolean removeChildService ( Object childService ) { if ( childServices != null ) { return childServices . remove ( childService ) ; } else { return false ; } } } 	1
package org . apache . camel . spring ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . builder . RouteBuilder ; import org . springframework . context . ApplicationContext ; public abstract class SpringRouteBuilder extends RouteBuilder { private ApplicationContext applicationContext ; public < T > T bean ( Class < T > type , String beanName ) { ApplicationContext context = getApplicationContext ( ) ; return ( T ) context . getBean ( beanName , type ) ; } public < T > T bean ( Class < T > type ) { ApplicationContext context = getApplicationContext ( ) ; String [ ] names = context . getBeanNamesForType ( type , true , true ) ; if ( names != null ) { int count = names . length ; if ( count == 1 ) { return ( T ) context . getBean ( names [ 0 ] ) ; } else if ( count > 1 ) { throw new IllegalArgumentException ( "Too many beans in the application context of type: " + type + ". Found: " + count ) ; } } throw new IllegalArgumentException ( "No bean available in the application context of type: " + type ) ; } public ApplicationContext getApplicationContext ( ) { if ( applicationContext == null ) { CamelContext camelContext = getContext ( ) ; if ( camelContext instanceof SpringCamelContext ) { SpringCamelContext springCamelContext = ( SpringCamelContext ) camelContext ; return springCamelContext . getApplicationContext ( ) ; } else { throw new IllegalArgumentException ( "This SpringBuilder is not being used with a SpringCamelContext and there is no applicationContext property configured" ) ; } } return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } } 	0
package org . apache . camel . model . dataformat ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlTransient ; import javax . xml . bind . annotation . XmlType ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . spi . DataFormat ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . util . IntrospectionSupport ; @ XmlType ( name = "dataFormatType" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class DataFormatType { @ XmlTransient private DataFormat dataFormat ; @ XmlTransient private String dataFormatTypeName ; public DataFormatType ( ) { } public DataFormatType ( DataFormat dataFormat ) { this . dataFormat = dataFormat ; } protected DataFormatType ( String dataFormatTypeName ) { this . dataFormatTypeName = dataFormatTypeName ; } public DataFormat getDataFormat ( RouteContext routeContext ) { if ( dataFormat == null ) { dataFormat = createDataFormat ( routeContext ) ; ObjectHelper . notNull ( dataFormat , "dataFormat" ) ; configureDataFormat ( dataFormat ) ; } return dataFormat ; } protected DataFormat createDataFormat ( RouteContext routeContext ) { if ( dataFormatTypeName != null ) { Class type = ObjectHelper . loadClass ( dataFormatTypeName , getClass ( ) . getClassLoader ( ) ) ; if ( type == null ) { throw new IllegalArgumentException ( "The class " + dataFormatTypeName + " is not on the classpath! Cannot use the dataFormat " + this ) ; } return ( DataFormat ) ObjectHelper . newInstance ( type ) ; } return null ; } protected void configureDataFormat ( DataFormat dataFormat ) { } protected void setProperty ( DataFormat dataFormat , String name , Object value ) { try { IntrospectionSupport . setProperty ( dataFormat , name , value ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Failed to set property " + name + " on " + dataFormat + ". Reason: " + e , e ) ; } } } 	1
package org . apache . camel . component . mina ; import org . apache . camel . Producer ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . mina . common . ConnectFuture ; import org . apache . mina . common . IoConnector ; import org . apache . mina . common . IoHandler ; import org . apache . mina . common . IoHandlerAdapter ; import org . apache . mina . common . IoSession ; import java . net . SocketAddress ; public class MinaProducer extends DefaultProducer { private static final transient Log log = LogFactory . getLog ( MinaProducer . class ) ; private IoSession session ; private MinaEndpoint endpoint ; public MinaProducer ( MinaEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) { if ( session == null ) { throw new IllegalStateException ( "Not started yet!" ) ; } Object body = exchange . getIn ( ) . getBody ( ) ; if ( body == null ) { log . warn ( "No payload for exchange: " + exchange ) ; } else { session . write ( body ) ; } } @ Override protected void doStart ( ) throws Exception { SocketAddress address = endpoint . getAddress ( ) ; IoConnector connector = endpoint . getConnector ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Creating connector to address: " + address + " using connector: " + connector ) ; } IoHandler ioHandler = new IoHandlerAdapter ( ) { @ Override public void messageReceived ( IoSession ioSession , Object object ) throws Exception { super . messageReceived ( ioSession , object ) ; } } ; ConnectFuture future = connector . connect ( address , ioHandler , endpoint . getConfig ( ) ) ; future . join ( ) ; session = future . getSession ( ) ; } @ Override protected void doStop ( ) throws Exception { if ( session != null ) { session . close ( ) . join ( 2000 ) ; } } } 	0
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import javax . xml . transform . stream . StreamSource ; public class BytesSource extends StreamSource { private byte [ ] data ; public BytesSource ( byte [ ] data ) { this . data = data ; } public BytesSource ( byte [ ] data , String systemId ) { this . data = data ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { return new ByteArrayInputStream ( data ) ; } public Reader getReader ( ) { return new InputStreamReader ( getInputStream ( ) ) ; } public byte [ ] getData ( ) { return data ; } public String toString ( ) { return "BytesSource[" + new String ( data ) + "]" ; } } 	1
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . Reader ; import java . io . Serializable ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; public class StringSource extends StreamSource implements Serializable { private final String text ; private String encoding = "UTF-8" ; public StringSource ( String text ) { if ( text == null ) { throw new NullPointerException ( "text can not be null" ) ; } this . text = text ; } public StringSource ( String text , String systemId ) { this ( text ) ; setSystemId ( systemId ) ; } public StringSource ( String text , String systemId , String encoding ) { this . text = text ; this . encoding = encoding ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { try { return new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } public Reader getReader ( ) { return new StringReader ( text ) ; } public String toString ( ) { return "StringSource[" + text + "]" ; } public String getText ( ) { return text ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Predicate ; import org . apache . camel . Route ; import org . apache . camel . impl . DefaultCamelContext ; import org . apache . camel . model . InterceptType ; import org . apache . camel . model . OtherwiseType ; import org . apache . camel . model . ProcessorType ; import org . apache . camel . model . RouteType ; import org . apache . camel . model . RoutesType ; import org . apache . camel . model . ExceptionType ; import org . apache . camel . processor . DelegateProcessor ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; public abstract class RouteBuilder extends BuilderSupport { private AtomicBoolean initalized = new AtomicBoolean ( false ) ; private RoutesType routeCollection = new RoutesType ( ) ; private List < Route > routes = new ArrayList < Route > ( ) ; public RouteBuilder ( ) { this ( null ) ; } public RouteBuilder ( CamelContext context ) { super ( context ) ; } @ Override public String toString ( ) { return routeCollection . toString ( ) ; } public abstract void configure ( ) throws Exception ; public RouteType from ( String uri ) { RouteType answer = routeCollection . from ( uri ) ; configureRoute ( answer ) ; return answer ; } public RouteType from ( Endpoint endpoint ) { RouteType answer = routeCollection . from ( endpoint ) ; configureRoute ( answer ) ; return answer ; } public RouteBuilder errorHandler ( ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return this ; } public RouteBuilder inheritErrorHandler ( boolean value ) { routeCollection . setInheritErrorHandlerFlag ( value ) ; return this ; } public RouteBuilder intercept ( DelegateProcessor interceptor ) { routeCollection . intercept ( interceptor ) ; return this ; } public InterceptType intercept ( ) { return routeCollection . intercept ( ) ; } public OtherwiseType intercept ( Predicate predicate ) { return routeCollection . intercept ( predicate ) ; } public ExceptionType exception ( Class exceptionType ) { return routeCollection . exception ( exceptionType ) ; } public CamelContext getContext ( ) { CamelContext context = super . getContext ( ) ; if ( context == null ) { context = createContainer ( ) ; setContext ( context ) ; } return context ; } public List < Route > getRouteList ( ) throws Exception { checkInitialized ( ) ; return routes ; } protected void checkInitialized ( ) throws Exception { if ( initalized . compareAndSet ( false , true ) ) { configure ( ) ; populateRoutes ( routes ) ; } } protected void populateRoutes ( List < Route > routes ) throws Exception { CamelContext camelContext = getContext ( ) ; if ( camelContext == null ) { throw new IllegalArgumentException ( "No CamelContext has been injected!" ) ; } routeCollection . setCamelContext ( camelContext ) ; camelContext . addRouteDefinitions ( routeCollection . getRoutes ( ) ) ; } public void setRouteCollection ( RoutesType routeCollection ) { this . routeCollection = routeCollection ; } protected CamelContext createContainer ( ) { return new DefaultCamelContext ( ) ; } protected void configureRoute ( RouteType route ) { route . setGroup ( getClass ( ) . getName ( ) ) ; } } 	1
package org . apache . camel . component . mock ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . camel . Component ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . Message ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class MockEndpoint extends DefaultEndpoint < Exchange > { private static final transient Log log = LogFactory . getLog ( MockEndpoint . class ) ; private int expectedCount = - 1 ; private Map < Integer , Processor > processors = new HashMap < Integer , Processor > ( ) ; private List < Exchange > receivedExchanges = new ArrayList < Exchange > ( ) ; private List < Throwable > failures = new ArrayList < Throwable > ( ) ; private List < Runnable > tests = new ArrayList < Runnable > ( ) ; private CountDownLatch latch ; private long sleepForEmptyTest = 0L ; private int expectedMinimumCount = - 1 ; public static void assertWait ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { long start = System . currentTimeMillis ( ) ; long left = unit . toMillis ( timeout ) ; long end = start + left ; for ( MockEndpoint endpoint : endpoints ) { if ( ! endpoint . await ( left , TimeUnit . MILLISECONDS ) ) throw new AssertionError ( "Timeout waiting for endpoints to receive enough messages. " + endpoint . getEndpointUri ( ) + " timed out." ) ; left = end - System . currentTimeMillis ( ) ; if ( left <= 0 ) left = 0 ; } } public static void assertIsSatisfied ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { assertWait ( timeout , unit , endpoints ) ; for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void expectsMessageCount ( int count , MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . expectsMessageCount ( count ) ; } } public MockEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } public Exchange createExchange ( ) { return new DefaultExchange ( getContext ( ) ) ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { throw new UnsupportedOperationException ( "You cannot consume from this endpoint" ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) { onExchange ( exchange ) ; } } ; } public void assertIsSatisfied ( ) throws InterruptedException { assertIsSatisfied ( sleepForEmptyTest ) ; } public void assertIsSatisfied ( long timeoutForEmptyEndpoints ) throws InterruptedException { if ( latch != null ) { latch . await ( 10 , TimeUnit . SECONDS ) ; } else if ( expectedCount == 0 ) { if ( timeoutForEmptyEndpoints > 0 ) { Thread . sleep ( timeoutForEmptyEndpoints ) ; } } if ( expectedCount >= 0 ) { int receivedCounter = getReceivedCounter ( ) ; assertEquals ( "Received message count" , expectedCount , receivedCounter ) ; } if ( expectedMinimumCount >= 0 ) { int receivedCounter = getReceivedCounter ( ) ; assertTrue ( "Received message count " + receivedCounter + ", expected at least " + expectedCount , expectedCount <= receivedCounter ) ; } for ( Runnable test : tests ) { test . run ( ) ; } for ( Throwable failure : failures ) { if ( failure != null ) { log . error ( "Caught on " + getEndpointUri ( ) + " Exception: " + failure , failure ) ; fail ( "Failed due to caught exception: " + failure ) ; } } } public void expectedMessageCount ( int expectedCount ) { this . expectedCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedCount ) ; } } public void expectedMinimumMessageCount ( int expectedCount ) { this . expectedMinimumCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedMinimumCount ) ; } } public void expectedBodiesReceived ( final List bodies ) { expectedMessageCount ( bodies . size ( ) ) ; expects ( new Runnable ( ) { public void run ( ) { int counter = 0 ; for ( Object expectedBody : bodies ) { Exchange exchange = getReceivedExchanges ( ) . get ( counter ++ ) ; assertTrue ( "No exchange received for counter: " + counter , exchange != null ) ; Message in = exchange . getIn ( ) ; Object actualBody = ( expectedBody != null ) ? in . getBody ( expectedBody . getClass ( ) ) : in . getBody ( ) ; assertEquals ( "Body of message: " + counter , expectedBody , actualBody ) ; log . debug ( getEndpointUri ( ) + " >>>> message: " + counter + " with body: " + actualBody ) ; } } } ) ; } public void expectedBodiesReceived ( Object ... bodies ) { List bodyList = new ArrayList ( ) ; for ( Object body : bodies ) { bodyList . add ( body ) ; } expectedBodiesReceived ( bodyList ) ; } public void expects ( Runnable runnable ) { tests . add ( runnable ) ; } public AssertionClause message ( final int messageIndex ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { applyAssertionOn ( MockEndpoint . this , messageIndex , assertExchangeReceived ( messageIndex ) ) ; } } ; expects ( clause ) ; return clause ; } public AssertionClause allMessages ( ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { applyAssertionOn ( MockEndpoint . this , index ++ , exchange ) ; } } } ; expects ( clause ) ; return clause ; } public Exchange assertExchangeReceived ( int index ) { int count = getReceivedCounter ( ) ; assertTrue ( "Not enough messages received. Was: " + count , count > index ) ; return getReceivedExchanges ( ) . get ( index ) ; } public List < Throwable > getFailures ( ) { return failures ; } public int getReceivedCounter ( ) { return getReceivedExchanges ( ) . size ( ) ; } public List < Exchange > getReceivedExchanges ( ) { return receivedExchanges ; } public int getExpectedCount ( ) { return expectedCount ; } public long getSleepForEmptyTest ( ) { return sleepForEmptyTest ; } public void setSleepForEmptyTest ( long sleepForEmptyTest ) { this . sleepForEmptyTest = sleepForEmptyTest ; } protected synchronized void onExchange ( Exchange exchange ) { try { log . debug ( getEndpointUri ( ) + " >>>> " + exchange ) ; receivedExchanges . add ( exchange ) ; Processor processor = processors . get ( getReceivedCounter ( ) ) ; if ( processor != null ) { processor . process ( exchange ) ; } if ( latch != null ) { latch . countDown ( ) ; } } catch ( Exception e ) { failures . add ( e ) ; } } protected void assertEquals ( String message , Object expectedValue , Object actualValue ) { if ( ! ObjectHelper . equals ( expectedValue , actualValue ) ) { fail ( message + ". Expected: <" + expectedValue + "> but was: <" + actualValue + ">" ) ; } } protected void assertTrue ( String message , boolean predicate ) { if ( ! predicate ) { fail ( message ) ; } } protected void fail ( Object message ) { throw new AssertionError ( getEndpointUri ( ) + " " + message ) ; } public int getExpectedMinimumCount ( ) { return expectedMinimumCount ; } public void await ( ) throws InterruptedException { if ( latch != null ) { latch . await ( ) ; } } public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { if ( latch != null ) { return latch . await ( timeout , unit ) ; } return true ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . Message ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . UnitOfWork ; import org . apache . camel . util . UuidGenerator ; import java . util . HashMap ; import java . util . Map ; public class DefaultExchange implements Exchange { private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator ( ) ; protected final CamelContext context ; private Map < String , Object > properties ; private Message in ; private Message out ; private Message fault ; private Throwable exception ; private String exchangeId = DefaultExchange . DEFAULT_ID_GENERATOR . generateId ( ) ; private UnitOfWork unitOfWork ; private ExchangePattern pattern ; public DefaultExchange ( CamelContext context ) { this ( context , ExchangePattern . InOnly ) ; } public DefaultExchange ( CamelContext context , ExchangePattern pattern ) { this . context = context ; this . pattern = pattern ; } @ Override public String toString ( ) { return "Exchange[" + in + "]" ; } public Exchange copy ( ) { Exchange exchange = newInstance ( ) ; exchange . copyFrom ( this ) ; return exchange ; } public void copyFrom ( Exchange exchange ) { if ( exchange == this ) { return ; } setProperties ( safeCopy ( exchange . getProperties ( ) ) ) ; safeCopy ( getIn ( ) , exchange , exchange . getIn ( ) ) ; Message copyOut = exchange . getOut ( false ) ; if ( copyOut != null ) { safeCopy ( getOut ( true ) , exchange , copyOut ) ; } Message copyFault = exchange . getFault ( false ) ; if ( copyFault != null ) { safeCopy ( getFault ( true ) , exchange , copyFault ) ; } setException ( exchange . getException ( ) ) ; unitOfWork = exchange . getUnitOfWork ( ) ; pattern = exchange . getPattern ( ) ; } private static void safeCopy ( Message message , Exchange exchange , Message that ) { if ( message != null ) { message . copyFrom ( that ) ; } } private static Map < String , Object > safeCopy ( Map < String , Object > properties ) { if ( properties == null ) { return null ; } return new HashMap < String , Object > ( properties ) ; } private static Message safeCopy ( Exchange exchange , Message message ) { if ( message == null ) { return null ; } Message answer = message . copy ( ) ; if ( answer instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) answer ; messageSupport . setExchange ( exchange ) ; } return answer ; } public Exchange newInstance ( ) { return new DefaultExchange ( context ) ; } public CamelContext getContext ( ) { return context ; } public Object getProperty ( String name ) { if ( properties != null ) { return properties . get ( name ) ; } return null ; } public < T > T getProperty ( String name , Class < T > type ) { Object value = getProperty ( name ) ; return getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setProperty ( String name , Object value ) { getProperties ( ) . put ( name , value ) ; } public Object removeProperty ( String name ) { return getProperties ( ) . remove ( name ) ; } public Map < String , Object > getProperties ( ) { if ( properties == null ) { properties = new HashMap < String , Object > ( ) ; } return properties ; } public void setProperties ( Map < String , Object > properties ) { this . properties = properties ; } public Message getIn ( ) { if ( in == null ) { in = createInMessage ( ) ; configureMessage ( in ) ; } return in ; } public void setIn ( Message in ) { this . in = in ; configureMessage ( in ) ; } public Message getOut ( ) { return getOut ( true ) ; } public Message getOut ( boolean lazyCreate ) { if ( out == null && lazyCreate ) { out = createOutMessage ( ) ; configureMessage ( out ) ; } return out ; } public void setOut ( Message out ) { this . out = out ; configureMessage ( out ) ; } public Throwable getException ( ) { return exception ; } public void setException ( Throwable exception ) { this . exception = exception ; } public ExchangePattern getPattern ( ) { return pattern ; } public void setPattern ( ExchangePattern pattern ) { this . pattern = pattern ; } public void throwException ( ) throws Exception { if ( exception == null ) { return ; } if ( exception instanceof Exception ) { throw ( Exception ) exception ; } if ( exception instanceof RuntimeException ) { throw ( RuntimeException ) exception ; } throw new RuntimeCamelException ( exception ) ; } public Message getFault ( ) { return getFault ( true ) ; } public Message getFault ( boolean lazyCreate ) { if ( fault == null && lazyCreate ) { fault = createFaultMessage ( ) ; configureMessage ( fault ) ; } return fault ; } public void setFault ( Message fault ) { this . fault = fault ; configureMessage ( fault ) ; } public String getExchangeId ( ) { return exchangeId ; } public void setExchangeId ( String id ) { this . exchangeId = id ; } public boolean isFailed ( ) { Message faultMessage = getFault ( false ) ; if ( faultMessage != null ) { Object faultBody = faultMessage . getBody ( ) ; if ( faultBody != null ) { return true ; } } return getException ( ) != null ; } public UnitOfWork getUnitOfWork ( ) { return unitOfWork ; } public void setUnitOfWork ( UnitOfWork unitOfWork ) { this . unitOfWork = unitOfWork ; } protected Message createInMessage ( ) { return new DefaultMessage ( ) ; } protected Message createOutMessage ( ) { return new DefaultMessage ( ) ; } protected Message createFaultMessage ( ) { return new DefaultMessage ( ) ; } protected void configureMessage ( Message message ) { if ( message instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) message ; messageSupport . setExchange ( this ) ; } } } 	1
package org . apache . camel . spring . xml ; import org . springframework . beans . SimpleTypeConverter ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . config . RuntimeBeanReference ; import java . lang . reflect . InvocationTargetException ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class BuilderAction { private final MethodInfo methodInfo ; private final HashMap < String , Object > parameterValues ; public BuilderAction ( MethodInfo methodInfo , HashMap < String , Object > parameterValues ) { this . methodInfo = methodInfo ; this . parameterValues = parameterValues ; } public Object invoke ( BeanFactory beanFactory , Object rootBuilder , Object contextBuilder ) { SimpleTypeConverter converter = new SimpleTypeConverter ( ) ; Object args [ ] = new Object [ methodInfo . parameters . size ( ) ] ; int pos = 0 ; for ( Map . Entry < String , Class > entry : methodInfo . parameters . entrySet ( ) ) { String paramName = entry . getKey ( ) ; Class paramClass = entry . getValue ( ) ; Object value = parameterValues . get ( paramName ) ; if ( value != null ) { value = replaceBeanReferences ( beanFactory , rootBuilder , value ) ; args [ pos ] = converter . convertIfNecessary ( value , paramClass ) ; } } try { return methodInfo . method . invoke ( contextBuilder , args ) ; } catch ( InvocationTargetException e ) { throw new IllegalArgumentException ( e . getCause ( ) ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Throwable e ) { throw new IllegalArgumentException ( e ) ; } } protected Object replaceBeanReferences ( BeanFactory beanFactory , Object rootBuilder , Object value ) { if ( value . getClass ( ) == RuntimeBeanReference . class ) { String beanName = ( ( RuntimeBeanReference ) value ) . getBeanName ( ) ; value = beanFactory . getBean ( beanName ) ; } if ( value . getClass ( ) == BuilderStatement . class ) { BuilderStatement bs = ( BuilderStatement ) value ; value = bs . create ( beanFactory , rootBuilder ) ; } if ( value instanceof List ) { List list = ( List ) value ; for ( int i = 0 , size = list . size ( ) ; i < size ; i ++ ) { list . set ( i , replaceBeanReferences ( beanFactory , rootBuilder , list . get ( i ) ) ) ; } } return value ; } public String getName ( ) { return methodInfo . getName ( ) ; } public MethodInfo getMethodInfo ( ) { return methodInfo ; } } 	0
package org . apache . camel . builder . xml ; public class DomResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new DomResultHandler ( ) ; } } 	1
package org . apache . camel . impl . converter ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . ReflectionInjector ; import org . apache . camel . spi . Injector ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; public class DefaultTypeConverter implements TypeConverter , TypeConverterRegistry { private static final transient Log log = LogFactory . getLog ( DefaultTypeConverter . class ) ; private Map < TypeMapping , TypeConverter > typeMappings = new HashMap < TypeMapping , TypeConverter > ( ) ; private Injector injector ; private List < TypeConverterLoader > typeConverterLoaders = new ArrayList < TypeConverterLoader > ( ) ; private List < TypeConverter > fallbackConverters = new ArrayList < TypeConverter > ( ) ; private boolean loaded ; public DefaultTypeConverter ( ) { typeConverterLoaders . add ( new AnnotationTypeConverterLoader ( ) ) ; fallbackConverters . add ( new PropertyEditorTypeConverter ( ) ) ; fallbackConverters . add ( new ToStringTypeConverter ( ) ) ; fallbackConverters . add ( new ArrayTypeConverter ( ) ) ; } public DefaultTypeConverter ( Injector injector ) { this ( ) ; this . injector = injector ; } public < T > T convertTo ( Class < T > toType , Object value ) { if ( toType . isInstance ( value ) ) { return toType . cast ( value ) ; } checkLoaded ( ) ; TypeConverter converter = getOrFindTypeConverter ( toType , value ) ; if ( converter != null ) { return converter . convertTo ( toType , value ) ; } for ( TypeConverter fallback : fallbackConverters ) { T rc = fallback . convertTo ( toType , value ) ; if ( rc != null ) { return rc ; } } if ( boolean . class . isAssignableFrom ( toType ) ) { return ( T ) Boolean . FALSE ; } return null ; } public void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) { TypeMapping key = new TypeMapping ( toType , fromType ) ; synchronized ( typeMappings ) { TypeConverter converter = typeMappings . get ( key ) ; if ( converter != null ) { log . warn ( "Overriding type converter from: " + converter + " to: " + typeConverter ) ; } typeMappings . put ( key , typeConverter ) ; } } public TypeConverter getTypeConverter ( Class toType , Class fromType ) { TypeMapping key = new TypeMapping ( toType , fromType ) ; synchronized ( typeMappings ) { return typeMappings . get ( key ) ; } } public Injector getInjector ( ) { if ( injector == null ) { injector = new ReflectionInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } protected < T > TypeConverter getOrFindTypeConverter ( Class toType , Object value ) { Class fromType = null ; if ( value != null ) { fromType = value . getClass ( ) ; } TypeMapping key = new TypeMapping ( toType , fromType ) ; TypeConverter converter ; synchronized ( typeMappings ) { converter = typeMappings . get ( key ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromType , value ) ; if ( converter != null ) { typeMappings . put ( key , converter ) ; } } } return converter ; } protected TypeConverter findTypeConverter ( Class toType , Class fromType , Object value ) { if ( fromType != null ) { Class fromSuperClass = fromType . getSuperclass ( ) ; if ( fromSuperClass != null && ! fromSuperClass . equals ( Object . class ) ) { TypeConverter converter = getTypeConverter ( toType , fromSuperClass ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromSuperClass , value ) ; } if ( converter != null ) { return converter ; } } for ( Class type : fromType . getInterfaces ( ) ) { TypeConverter converter = getTypeConverter ( toType , type ) ; if ( converter != null ) { return converter ; } } if ( fromType . isArray ( ) && ! fromType . getComponentType ( ) . isPrimitive ( ) ) { if ( ! fromType . equals ( Object [ ] . class ) ) { fromSuperClass = Object [ ] . class ; TypeConverter converter = getTypeConverter ( toType , fromSuperClass ) ; if ( converter == null ) { converter = findTypeConverter ( toType , fromSuperClass , value ) ; } if ( converter != null ) { return converter ; } } } } if ( fromType != null ) { Set < Map . Entry < TypeMapping , TypeConverter > > entries = typeMappings . entrySet ( ) ; for ( Map . Entry < TypeMapping , TypeConverter > entry : entries ) { TypeMapping key = entry . getKey ( ) ; Class aToType = key . getToType ( ) ; if ( toType . isAssignableFrom ( aToType ) ) { if ( fromType . isAssignableFrom ( key . getFromType ( ) ) ) { return entry . getValue ( ) ; } } } } return null ; } protected synchronized void checkLoaded ( ) { if ( ! loaded ) { loaded = true ; for ( TypeConverterLoader typeConverterLoader : typeConverterLoaders ) { try { typeConverterLoader . load ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( e ) ; } } } } protected static class TypeMapping { Class toType ; Class fromType ; public TypeMapping ( Class toType , Class fromType ) { this . toType = toType ; this . fromType = fromType ; } public Class getFromType ( ) { return fromType ; } public Class getToType ( ) { return toType ; } @ Override public boolean equals ( Object object ) { if ( object instanceof TypeMapping ) { TypeMapping that = ( TypeMapping ) object ; return ObjectHelper . equals ( this . fromType , that . fromType ) && ObjectHelper . equals ( this . toType , that . toType ) ; } return false ; } @ Override public int hashCode ( ) { int answer = toType . hashCode ( ) ; if ( fromType != null ) { answer *= 37 + fromType . hashCode ( ) ; } return answer ; } @ Override public String toString ( ) { return "[" + fromType + "=>" + toType + "]" ; } } } 	0
package org . apache . camel . component . bean ; import org . apache . camel . * ; import org . apache . camel . builder . ExpressionBuilder ; import org . apache . camel . language . LanguageAnnotation ; import static org . apache . camel . util . ExchangeHelper . convertToType ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; public class BeanInfo { private static final transient Log LOG = LogFactory . getLog ( BeanInfo . class ) ; private final CamelContext camelContext ; private Class type ; private ParameterMappingStrategy strategy ; private Map < String , MethodInfo > operations = new ConcurrentHashMap < String , MethodInfo > ( ) ; private MethodInfo defaultMethod ; private List < MethodInfo > operationsWithBody = new ArrayList < MethodInfo > ( ) ; public BeanInfo ( CamelContext camelContext , Class type , ParameterMappingStrategy strategy ) { this . camelContext = camelContext ; this . type = type ; this . strategy = strategy ; introspect ( getType ( ) ) ; if ( operations . size ( ) == 1 ) { Collection < MethodInfo > methodInfos = operations . values ( ) ; for ( MethodInfo methodInfo : methodInfos ) { defaultMethod = methodInfo ; } } } public Class getType ( ) { return type ; } public CamelContext getCamelContext ( ) { return camelContext ; } public MethodInvocation createInvocation ( Method method , Object pojo , Exchange exchange ) throws RuntimeCamelException { MethodInfo methodInfo = introspect ( type , method ) ; if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , exchange ) ; } return null ; } public MethodInvocation createInvocation ( Object pojo , Exchange exchange ) throws RuntimeCamelException , AmbiguousMethodCallException { MethodInfo methodInfo = null ; String name = exchange . getIn ( ) . getHeader ( BeanProcessor . METHOD_NAME , String . class ) ; if ( name != null ) { methodInfo = operations . get ( name ) ; } if ( methodInfo == null ) { methodInfo = chooseMethod ( pojo , exchange ) ; } if ( methodInfo == null ) { methodInfo = defaultMethod ; } if ( methodInfo != null ) { return methodInfo . createMethodInvocation ( pojo , exchange ) ; } return null ; } protected void introspect ( Class clazz ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( isValidMethod ( clazz , method ) ) { introspect ( clazz , method ) ; } } Class superclass = clazz . getSuperclass ( ) ; if ( superclass != null && ! superclass . equals ( Object . class ) ) { introspect ( superclass ) ; } } protected MethodInfo introspect ( Class clazz , Method method ) { Class [ ] parameterTypes = method . getParameterTypes ( ) ; Annotation [ ] [ ] parametersAnnotations = method . getParameterAnnotations ( ) ; final Expression [ ] parameterExpressions = new Expression [ parameterTypes . length ] ; List < ParameterInfo > parameters = new ArrayList < ParameterInfo > ( ) ; List < ParameterInfo > bodyParameters = new ArrayList < ParameterInfo > ( ) ; boolean hasCustomAnnotation = false ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { Class parameterType = parameterTypes [ i ] ; Annotation [ ] parameterAnnotations = parametersAnnotations [ i ] ; Expression expression = createParameterUnmarshalExpression ( clazz , method , parameterType , parameterAnnotations ) ; hasCustomAnnotation |= expression != null ; if ( expression == null ) { hasCustomAnnotation |= ObjectHelper . hasAnnotation ( parameterAnnotations , Body . class ) ; if ( bodyParameters . isEmpty ( ) ) { expression = ExpressionBuilder . bodyExpression ( parameterType ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "No expression available for method: " + method . toString ( ) + " which already has a body so ignoring parameter: " + i + " so ignoring method" ) ; } return null ; } } ParameterInfo parameterInfo = new ParameterInfo ( i , parameterType , parameterAnnotations , expression ) ; parameters . add ( parameterInfo ) ; if ( isPossibleBodyParameter ( parameterAnnotations ) ) { bodyParameters . add ( parameterInfo ) ; } } String opName = method . getName ( ) ; MethodInfo methodInfo = new MethodInfo ( clazz , method , parameters , bodyParameters , hasCustomAnnotation ) ; operations . put ( opName , methodInfo ) ; if ( methodInfo . hasBodyParameter ( ) ) { operationsWithBody . add ( methodInfo ) ; } return methodInfo ; } protected MethodInfo chooseMethod ( Object pojo , Exchange exchange ) throws AmbiguousMethodCallException { if ( operationsWithBody . size ( ) == 1 ) { return operationsWithBody . get ( 0 ) ; } else if ( ! operationsWithBody . isEmpty ( ) ) { Message in = exchange . getIn ( ) ; Object body = in . getBody ( ) ; if ( body != null ) { Class bodyType = body . getClass ( ) ; List < MethodInfo > possibles = new ArrayList < MethodInfo > ( ) ; for ( MethodInfo methodInfo : operationsWithBody ) { if ( methodInfo . bodyParameterMatches ( bodyType ) ) { possibles . add ( methodInfo ) ; } } if ( possibles . size ( ) == 1 ) { return possibles . get ( 0 ) ; } else if ( possibles . isEmpty ( ) ) { Object newBody = null ; MethodInfo matched = null ; for ( MethodInfo methodInfo : operationsWithBody ) { Object value = convertToType ( exchange , methodInfo . getBodyParameterType ( ) , body ) ; if ( value != null ) { if ( newBody != null ) { throw new AmbiguousMethodCallException ( exchange , Arrays . asList ( matched , methodInfo ) ) ; } else { newBody = value ; matched = methodInfo ; } } } if ( matched != null ) { in . setBody ( newBody ) ; return matched ; } } else { MethodInfo chosen = null ; for ( MethodInfo possible : possibles ) { if ( possible . isHasCustomAnnotation ( ) ) { if ( chosen != null ) { chosen = null ; break ; } else { chosen = possible ; } } } if ( chosen != null ) { return chosen ; } throw new AmbiguousMethodCallException ( exchange , possibles ) ; } } return null ; } return null ; } protected Expression createParameterUnmarshalExpression ( Class clazz , Method method , Class parameterType , Annotation [ ] parameterAnnotation ) { for ( Annotation annotation : parameterAnnotation ) { Expression answer = createParameterUnmarshalExpressionForAnnotation ( clazz , method , parameterType , annotation ) ; if ( answer != null ) { return answer ; } } return strategy . getDefaultParameterTypeExpression ( parameterType ) ; } protected boolean isPossibleBodyParameter ( Annotation [ ] annotations ) { if ( annotations != null ) { for ( Annotation annotation : annotations ) { if ( ( annotation instanceof Property ) || ( annotation instanceof Header ) ) { return false ; } } } return true ; } protected Expression createParameterUnmarshalExpressionForAnnotation ( Class clazz , Method method , Class parameterType , Annotation annotation ) { if ( annotation instanceof Property ) { Property propertyAnnotation = ( Property ) annotation ; return ExpressionBuilder . propertyExpression ( propertyAnnotation . name ( ) ) ; } else if ( annotation instanceof Properties ) { return ExpressionBuilder . propertiesExpresion ( ) ; } else if ( annotation instanceof Header ) { Header headerAnnotation = ( Header ) annotation ; return ExpressionBuilder . headerExpression ( headerAnnotation . name ( ) ) ; } else if ( annotation instanceof Headers ) { return ExpressionBuilder . headersExpresion ( ) ; } else { LanguageAnnotation languageAnnotation = annotation . annotationType ( ) . getAnnotation ( LanguageAnnotation . class ) ; if ( languageAnnotation != null ) { Class < ? > type = languageAnnotation . factory ( ) ; Object object = camelContext . getInjector ( ) . newInstance ( type ) ; if ( object instanceof AnnotationExpressionFactory ) { AnnotationExpressionFactory expressionFactory = ( AnnotationExpressionFactory ) object ; return expressionFactory . createExpression ( camelContext , annotation , languageAnnotation , parameterType ) ; } else { LOG . error ( "Ignoring bad annotation: " + languageAnnotation + "on method: " + method + " which declares a factory: " + type . getName ( ) + " which does not implement " + AnnotationExpressionFactory . class . getName ( ) ) ; } } } return null ; } protected boolean isValidMethod ( Class clazz , Method method ) { return Modifier . isPublic ( method . getModifiers ( ) ) ; } } 	1
package org . apache . camel . processor . idempotent ; public interface MessageIdRepository { boolean contains ( String messageId ) ; } 	0
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Predicate ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . FilterProcessor ; @ XmlRootElement ( name = "filter" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class FilterType extends ExpressionNode { public FilterType ( ) { } public FilterType ( ExpressionType expression ) { super ( expression ) ; } public FilterType ( Predicate predicate ) { super ( predicate ) ; } @ Override public String toString ( ) { return "Filter[ " + getExpression ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public FilterProcessor createProcessor ( RouteContext routeContext ) throws Exception { return createFilterProcessor ( routeContext ) ; } } 	1
package org . apache . camel . spring . spi ; import static org . apache . camel . util . ObjectHelper . notNull ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . spi . ComponentResolver ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . context . ApplicationContext ; public class SpringComponentResolver implements ComponentResolver { private final ApplicationContext applicationContext ; private final ComponentResolver nextResolver ; public SpringComponentResolver ( ApplicationContext applicationContext , ComponentResolver nextResolver ) { notNull ( applicationContext , "applicationContext" ) ; this . applicationContext = applicationContext ; this . nextResolver = nextResolver ; } public Component resolveComponent ( String name , CamelContext context ) throws Exception { Object bean = null ; try { bean = applicationContext . getBean ( name ) ; } catch ( NoSuchBeanDefinitionException e ) { } if ( bean != null ) { if ( bean instanceof Component ) { return ( Component ) bean ; } else { throw new IllegalArgumentException ( "Bean with name: " + name + " in spring context is not a Component: " + bean ) ; } } if ( nextResolver == null ) { return null ; } return nextResolver . resolveComponent ( name , context ) ; } } 	0
package org . apache . camel . processor . idempotent ; import java . util . HashMap ; import java . util . Map ; import org . apache . camel . util . LRUCache ; public class MemoryMessageIdRepository implements MessageIdRepository { private Map cache ; public MemoryMessageIdRepository ( Map set ) { this . cache = set ; } public static MessageIdRepository memoryMessageIdRepository ( ) { return memoryMessageIdRepository ( new HashMap ( ) ) ; } public static MessageIdRepository memoryMessageIdRepository ( int cacheSize ) { return memoryMessageIdRepository ( new LRUCache ( cacheSize ) ) ; } public static MessageIdRepository memoryMessageIdRepository ( Map cache ) { return new MemoryMessageIdRepository ( cache ) ; } public boolean contains ( String messageId ) { synchronized ( cache ) { if ( cache . containsKey ( messageId ) ) { return true ; } else { cache . put ( messageId , messageId ) ; return false ; } } } } 	1
package org . apache . camel . component . cxf ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . apache . cxf . message . Message ; import org . apache . cxf . transport . Destination ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . transport . local . LocalTransportFactory ; public class CxfConsumer extends DefaultConsumer < CxfExchange > { private CxfEndpoint endpoint ; private final LocalTransportFactory transportFactory ; private Destination destination ; public CxfConsumer ( CxfEndpoint endpoint , Processor processor , LocalTransportFactory transportFactory ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; this . transportFactory = transportFactory ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; destination = transportFactory . getDestination ( endpoint . getEndpointInfo ( ) ) ; destination . setMessageObserver ( new MessageObserver ( ) { public void onMessage ( Message message ) { incomingCxfMessage ( message ) ; } } ) ; } @ Override protected void doStop ( ) throws Exception { if ( destination != null ) { destination . shutdown ( ) ; } super . doStop ( ) ; } protected void incomingCxfMessage ( Message message ) { try { CxfExchange exchange = endpoint . createExchange ( message ) ; getProcessor ( ) . process ( exchange ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } 	0
package org . apache . camel . language ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . RuntimeCamelException ; public class ExpressionEvaluationException extends RuntimeCamelException { private final Expression < Exchange > expression ; private final Exchange exchange ; public ExpressionEvaluationException ( Expression < Exchange > expression , Exchange exchange , Throwable cause ) { super ( cause ) ; this . expression = expression ; this . exchange = exchange ; } public Expression < Exchange > getExpression ( ) { return expression ; } } 	1
package org . apache . camel . component . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . Consumer ; import org . apache . camel . Producer ; import org . apache . camel . Component ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; public class ProcessorEndpoint extends DefaultEndpoint < Exchange > { private final Processor processor ; private final LoadBalancer loadBalancer ; protected ProcessorEndpoint ( String endpointUri , Component component , Processor processor , LoadBalancer loadBalancer ) { super ( endpointUri , component ) ; this . processor = processor ; this . loadBalancer = loadBalancer ; } public Exchange createExchange ( ) { return new DefaultExchange ( getContext ( ) ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) throws Exception { onExchange ( exchange ) ; } } ; } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { return new ProcessorEndpointConsumer ( this , processor ) ; } public Processor getProcessor ( ) { return processor ; } public LoadBalancer getLoadBalancer ( ) { return loadBalancer ; } protected void onExchange ( Exchange exchange ) throws Exception { processor . process ( exchange ) ; loadBalancer . process ( exchange ) ; } public boolean isSingleton ( ) { return true ; } } 	0
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . config . BatchResequencerConfig ; import org . apache . camel . model . config . StreamResequencerConfig ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . Resequencer ; import org . apache . camel . processor . StreamResequencer ; @ XmlRootElement ( name = "resequencer" ) public class ResequencerType extends ProcessorType < ProcessorType > { @ XmlElementRef private List < InterceptorType > interceptors = new ArrayList < InterceptorType > ( ) ; @ XmlElementRef private List < ExpressionType > expressions = new ArrayList < ExpressionType > ( ) ; @ XmlElementRef private List < ProcessorType < ? > > outputs = new ArrayList < ProcessorType < ? > > ( ) ; private BatchResequencerConfig batchConfig ; private StreamResequencerConfig streamConfig ; @ XmlTransient private List < Expression > expressionList ; public ResequencerType ( ) { this ( null ) ; } public ResequencerType ( List < Expression > expressions ) { this . expressionList = expressions ; this . batch ( ) ; } public ResequencerType stream ( ) { return stream ( StreamResequencerConfig . getDefault ( ) ) ; } public ResequencerType batch ( ) { return batch ( BatchResequencerConfig . getDefault ( ) ) ; } public ResequencerType stream ( StreamResequencerConfig config ) { this . streamConfig = config ; this . batchConfig = null ; return this ; } public ResequencerType batch ( BatchResequencerConfig config ) { this . batchConfig = config ; this . streamConfig = null ; return this ; } @ Override public String toString ( ) { return "Resequencer[ " + getExpressions ( ) + " -> " + getOutputs ( ) + "]" ; } @ Override public String getLabel ( ) { return ExpressionType . getLabel ( getExpressions ( ) ) ; } public List < ExpressionType > getExpressions ( ) { return expressions ; } public List < InterceptorType > getInterceptors ( ) { return interceptors ; } public void setInterceptors ( List < InterceptorType > interceptors ) { this . interceptors = interceptors ; } public List < ProcessorType < ? > > getOutputs ( ) { return outputs ; } public void setOutputs ( List < ProcessorType < ? > > outputs ) { this . outputs = outputs ; } public BatchResequencerConfig getBatchConfig ( ) { return batchConfig ; } public BatchResequencerConfig getBatchConfig ( BatchResequencerConfig defaultConfig ) { return batchConfig ; } public StreamResequencerConfig getStreamConfig ( ) { return streamConfig ; } @ XmlElement ( name = "batch-config" , required = false ) public void setBatchConfig ( BatchResequencerConfig batchConfig ) { batch ( batchConfig ) ; } @ XmlElement ( name = "stream-config" , required = false ) public void setStreamConfig ( StreamResequencerConfig streamConfig ) { stream ( streamConfig ) ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return createStreamResequencer ( routeContext , streamConfig ) ; } @ Override public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { if ( batchConfig != null ) { routes . add ( createBatchResequencerRoute ( routeContext ) ) ; } else { super . addRoutes ( routeContext , routes ) ; } } private Route < Exchange > createBatchResequencerRoute ( RouteContext routeContext ) throws Exception { final Resequencer resequencer = createBatchResequencer ( routeContext , batchConfig ) ; return new Route < Exchange > ( routeContext . getEndpoint ( ) , resequencer ) { @ Override public String toString ( ) { return "BatchResequencerRoute[" + getEndpoint ( ) + " -> " + resequencer . getProcessor ( ) + "]" ; } } ; } protected Resequencer createBatchResequencer ( RouteContext routeContext , BatchResequencerConfig config ) throws Exception { Processor processor = routeContext . createProcessor ( this ) ; Resequencer resequencer = new Resequencer ( routeContext . getEndpoint ( ) , processor , resolveExpressionList ( routeContext ) ) ; resequencer . setBatchSize ( config . getBatchSize ( ) ) ; resequencer . setBatchTimeout ( config . getBatchTimeout ( ) ) ; return resequencer ; } protected StreamResequencer createStreamResequencer ( RouteContext routeContext , StreamResequencerConfig config ) throws Exception { config . getComparator ( ) . setExpressions ( resolveExpressionList ( routeContext ) ) ; Processor processor = routeContext . createProcessor ( this ) ; StreamResequencer resequencer = new StreamResequencer ( processor , config . getComparator ( ) , config . getCapacity ( ) ) ; resequencer . setTimeout ( config . getTimeout ( ) ) ; return resequencer ; } private List < Expression > resolveExpressionList ( RouteContext routeContext ) { if ( expressionList == null ) { expressionList = new ArrayList < Expression > ( ) ; for ( ExpressionType expression : expressions ) { expressionList . add ( expression . createExpression ( routeContext ) ) ; } } if ( expressionList . isEmpty ( ) ) { throw new IllegalArgumentException ( "No expressions configured for: " + this ) ; } return expressionList ; } } 	1
package org . apache . camel . builder . xml ; import java . util . Map ; import java . util . HashMap ; import java . util . Set ; public class NamespaceBuilder { private Map < String , String > namespaces = new HashMap < String , String > ( ) ; public static NamespaceBuilder namespaceContext ( ) { return new NamespaceBuilder ( ) ; } public static NamespaceBuilder namespaceContext ( String prefix , String uri ) { return new NamespaceBuilder ( ) . namespace ( prefix , uri ) ; } public NamespaceBuilder namespace ( String prefix , String uri ) { namespaces . put ( prefix , uri ) ; return this ; } public XPathBuilder xpath ( String xpath ) { XPathBuilder answer = XPathBuilder . xpath ( xpath ) ; Set < Map . Entry < String , String > > entries = namespaces . entrySet ( ) ; for ( Map . Entry < String , String > entry : entries ) { answer . namespace ( entry . getKey ( ) , entry . getValue ( ) ) ; } return answer ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . Message ; import java . util . HashMap ; import java . util . Map ; public class DefaultMessage extends MessageSupport { private Map < String , Object > headers ; @ Override public String toString ( ) { return "Message: " + getBody ( ) ; } public Object getHeader ( String name ) { return getHeaders ( ) . get ( name ) ; } public < T > T getHeader ( String name , Class < T > type ) { Object value = getHeader ( name ) ; return getExchange ( ) . getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setHeader ( String name , Object value ) { if ( headers == null ) { headers = createHeaders ( ) ; } headers . put ( name , value ) ; } public Object removeHeader ( String name ) { if ( headers != null ) { return headers . remove ( name ) ; } else { return null ; } } public Map < String , Object > getHeaders ( ) { if ( headers == null ) { headers = createHeaders ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public DefaultMessage newInstance ( ) { return new DefaultMessage ( ) ; } protected Map < String , Object > createHeaders ( ) { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; populateInitialHeaders ( map ) ; return map ; } protected void populateInitialHeaders ( Map < String , Object > map ) { } } 	1
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . Collections ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . spi . Policy ; public class PolicyBuilder implements ProcessorFactory { private final ArrayList < Policy > policies = new ArrayList < Policy > ( ) ; private final FromBuilder parent ; private FromBuilder target ; public PolicyBuilder ( FromBuilder parent ) { this . parent = parent ; } @ Fluent ( "policy" ) public PolicyBuilder add ( @ FluentArg ( "ref" ) Policy interceptor ) { policies . add ( interceptor ) ; return this ; } @ Fluent ( callOnElementEnd = true ) public FromBuilder target ( ) { this . target = new FromBuilder ( parent ) ; return target ; } public Processor createProcessor ( ) throws Exception { if ( target == null ) throw new RuntimeCamelException ( "target not provided." ) ; Processor last = target . createProcessor ( ) ; Collections . reverse ( policies ) ; for ( Policy p : policies ) { last = p . wrap ( last ) ; } return last ; } } 	0
package org . apache . camel . builder ; import java . util . ArrayList ; import java . util . List ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . SendProcessor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class BuilderSupport { private CamelContext context ; private ErrorHandlerBuilder errorHandlerBuilder ; private boolean inheritErrorHandler = true ; protected BuilderSupport ( CamelContext context ) { this . context = context ; } protected BuilderSupport ( BuilderSupport parent ) { this . context = parent . getContext ( ) ; this . inheritErrorHandler = parent . inheritErrorHandler ; if ( inheritErrorHandler && parent . errorHandlerBuilder != null ) { this . errorHandlerBuilder = parent . errorHandlerBuilder . copy ( ) ; } } public ValueBuilder header ( String name ) { return Builder . header ( name ) ; } public ValueBuilder body ( ) { return Builder . body ( ) ; } public < T > ValueBuilder body ( Class < T > type ) { return Builder . bodyAs ( type ) ; } public ValueBuilder outBody ( ) { return Builder . outBody ( ) ; } public < T > ValueBuilder outBody ( Class < T > type ) { return Builder . outBodyAs ( type ) ; } public ValueBuilder faultBody ( ) { return Builder . faultBody ( ) ; } public < T > ValueBuilder faultBodyAs ( Class < T > type ) { return Builder . faultBodyAs ( type ) ; } public ValueBuilder systemProperty ( String name ) { return Builder . systemProperty ( name ) ; } public ValueBuilder systemProperty ( String name , String defaultValue ) { return Builder . systemProperty ( name , defaultValue ) ; } public ValueBuilder constant ( Object value ) { return Builder . constant ( value ) ; } public Endpoint endpoint ( String uri ) throws NoSuchEndpointException { if ( uri == null ) { throw new IllegalArgumentException ( "uri parameter cannot be null" ) ; } Endpoint endpoint = getContext ( ) . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } return endpoint ; } public List < Endpoint > endpoints ( String ... uris ) throws NoSuchEndpointException { List < Endpoint > endpoints = new ArrayList < Endpoint > ( ) ; for ( String uri : uris ) { endpoints . add ( endpoint ( uri ) ) ; } return endpoints ; } public List < Endpoint > endpoints ( Endpoint ... endpoints ) { List < Endpoint > answer = new ArrayList < Endpoint > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint ) ; } return answer ; } public NoErrorHandlerBuilder noErrorHandler ( ) { return new NoErrorHandlerBuilder ( ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( ) { return new LoggingErrorHandlerBuilder ( ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( String log ) { return loggingErrorHandler ( LogFactory . getLog ( log ) ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( Log log ) { return new LoggingErrorHandlerBuilder ( log ) ; } public LoggingErrorHandlerBuilder loggingErrorHandler ( Log log , LoggingLevel level ) { return new LoggingErrorHandlerBuilder ( log , level ) ; } public DeadLetterChannelBuilder deadLetterChannel ( ) { return new DeadLetterChannelBuilder ( ) ; } public DeadLetterChannelBuilder deadLetterChannel ( String deadLetterUri ) { return deadLetterChannel ( endpoint ( deadLetterUri ) ) ; } public DeadLetterChannelBuilder deadLetterChannel ( Endpoint deadLetterEndpoint ) { return new DeadLetterChannelBuilder ( new SendProcessor ( deadLetterEndpoint ) ) ; } public CamelContext getContext ( ) { return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public ErrorHandlerBuilder getErrorHandlerBuilder ( ) { if ( errorHandlerBuilder == null ) { errorHandlerBuilder = createErrorHandlerBuilder ( ) ; } return errorHandlerBuilder ; } protected ErrorHandlerBuilder createErrorHandlerBuilder ( ) { if ( isInheritErrorHandler ( ) ) { return new DeadLetterChannelBuilder ( ) ; } else { return new NoErrorHandlerBuilder ( ) ; } } public void setErrorHandlerBuilder ( ErrorHandlerBuilder errorHandlerBuilder ) { this . errorHandlerBuilder = errorHandlerBuilder ; } public boolean isInheritErrorHandler ( ) { return inheritErrorHandler ; } public void setInheritErrorHandler ( boolean inheritErrorHandler ) { this . inheritErrorHandler = inheritErrorHandler ; } } 	1
package org . apache . camel . bam . processor ; import org . apache . camel . Exchange ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . bam . rules . ProcessRules ; public class ProcessContext { private Exchange exchange ; private ProcessRules processRules ; private ActivityRules activityRules ; private ProcessInstance processInstance ; private ActivityState activityState ; public ProcessContext ( Exchange exchange , ActivityRules activityRules , ActivityState activityState ) { this . exchange = exchange ; this . activityRules = activityRules ; this . activityState = activityState ; this . processRules = activityRules . getProcessRules ( ) ; this . processInstance = activityState . getProcessInstance ( ) ; } public ActivityRules getActivity ( ) { return activityRules ; } public void setActivity ( ActivityRules activityRules ) { this . activityRules = activityRules ; } public ActivityState getActivityState ( ) { return activityState ; } public void setActivityState ( ActivityState activityState ) { this . activityState = activityState ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public ProcessRules getProcessDefinition ( ) { return processRules ; } public void setProcessDefinition ( ProcessRules processRules ) { this . processRules = processRules ; } public ProcessInstance getProcessInstance ( ) { return processInstance ; } public void setProcessInstance ( ProcessInstance processInstance ) { this . processInstance = processInstance ; } public ActivityState getActivityState ( ActivityRules activityRules ) { return getProcessInstance ( ) . getActivityState ( activityRules ) ; } public void onStarted ( ActivityState activityState ) { } public void onCompleted ( ActivityState activityState ) { } } 	0
package org . apache . camel ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class Route < E extends Exchange > { private final Map < String , Object > properties = new HashMap < String , Object > ( 16 ) ; private Endpoint < E > endpoint ; private List < Service > services = new ArrayList < Service > ( ) ; public Route ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Route ( Endpoint < E > endpoint , Service ... services ) { this ( endpoint ) ; for ( Service service : services ) { addService ( service ) ; } } @ Override public String toString ( ) { return "Route" ; } public Endpoint < E > getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint < E > endpoint ) { this . endpoint = endpoint ; } public Map < String , Object > getProperties ( ) { return properties ; } public List < Service > getServicesForRoute ( ) throws Exception { List < Service > servicesForRoute = new ArrayList < Service > ( getServices ( ) ) ; addServices ( servicesForRoute ) ; return servicesForRoute ; } public List < Service > getServices ( ) { return services ; } public void setServices ( List < Service > services ) { this . services = services ; } public void addService ( Service service ) { getServices ( ) . add ( service ) ; } protected void addServices ( List < Service > services ) throws Exception { } } 	1
package org . apache . camel . util ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import java . util . Comparator ; import java . util . List ; public class ExpressionListComparator < E extends Exchange > implements Comparator < E > { private final List < Expression < E > > expressions ; public ExpressionListComparator ( List < Expression < E > > expressions ) { this . expressions = expressions ; } public int compare ( E e1 , E e2 ) { for ( Expression < E > expression : expressions ) { Object o1 = expression . evaluate ( e1 ) ; Object o2 = expression . evaluate ( e2 ) ; int answer = ObjectHelper . compare ( o1 , o2 ) ; if ( answer != 0 ) { return answer ; } } return 0 ; } } 	0
package org . apache . camel . converter . jaxp ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . Reader ; import java . io . Serializable ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import javax . xml . transform . stream . StreamSource ; public class StringSource extends StreamSource implements Serializable { private final String text ; private String encoding = "UTF-8" ; public StringSource ( String text ) { if ( text == null ) { throw new NullPointerException ( "text can not be null" ) ; } this . text = text ; } public StringSource ( String text , String systemId ) { this ( text ) ; setSystemId ( systemId ) ; } public StringSource ( String text , String systemId , String encoding ) { this . text = text ; this . encoding = encoding ; setSystemId ( systemId ) ; } public InputStream getInputStream ( ) { try { return new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } public Reader getReader ( ) { return new StringReader ( text ) ; } public String toString ( ) { return "StringSource[" + text + "]" ; } public String getText ( ) { return text ; } } 	1
package org . apache . camel ; public class RuntimeCamelException extends RuntimeException { private static final long serialVersionUID = 8046489554418284257L ; public RuntimeCamelException ( ) { } public RuntimeCamelException ( String message ) { super ( message ) ; } public RuntimeCamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public RuntimeCamelException ( Throwable cause ) { super ( cause ) ; } } 	0
package org . apache . camel . component . mock ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Collection ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . camel . * ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . util . ExpressionComparator ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class MockEndpoint extends DefaultEndpoint < Exchange > { private static final transient Log LOG = LogFactory . getLog ( MockEndpoint . class ) ; private int expectedCount = - 1 ; private int counter ; private Map < Integer , Processor > processors = new HashMap < Integer , Processor > ( ) ; private List < Exchange > receivedExchanges = new CopyOnWriteArrayList < Exchange > ( ) ; private List < Throwable > failures = new CopyOnWriteArrayList < Throwable > ( ) ; private List < Runnable > tests = new CopyOnWriteArrayList < Runnable > ( ) ; private CountDownLatch latch ; private long sleepForEmptyTest = 1000L ; private long defaulResultWaitMillis = 20000L ; private int expectedMinimumCount = - 1 ; private List expectedBodyValues ; private List actualBodyValues = new ArrayList ( ) ; public MockEndpoint ( String endpointUri , Component component ) { super ( endpointUri , component ) ; } public static void assertWait ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { long start = System . currentTimeMillis ( ) ; long left = unit . toMillis ( timeout ) ; long end = start + left ; for ( MockEndpoint endpoint : endpoints ) { if ( ! endpoint . await ( left , TimeUnit . MILLISECONDS ) ) { throw new AssertionError ( "Timeout waiting for endpoints to receive enough messages. " + endpoint . getEndpointUri ( ) + " timed out." ) ; } left = end - System . currentTimeMillis ( ) ; if ( left <= 0 ) { left = 0 ; } } } public static void assertIsSatisfied ( long timeout , TimeUnit unit , MockEndpoint ... endpoints ) throws InterruptedException { assertWait ( timeout , unit , endpoints ) ; for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . assertIsSatisfied ( ) ; } } public static void assertIsSatisfied ( CamelContext context ) throws InterruptedException { Collection < Endpoint > endpoints = context . getSingletonEndpoints ( ) ; for ( Endpoint endpoint : endpoints ) { if ( endpoint instanceof MockEndpoint ) { MockEndpoint mockEndpoint = ( MockEndpoint ) endpoint ; mockEndpoint . assertIsSatisfied ( ) ; } } } public static void expectsMessageCount ( int count , MockEndpoint ... endpoints ) throws InterruptedException { for ( MockEndpoint endpoint : endpoints ) { endpoint . expectsMessageCount ( count ) ; } } public Consumer < Exchange > createConsumer ( Processor processor ) throws Exception { throw new UnsupportedOperationException ( "You cannot consume from this endpoint" ) ; } public Producer < Exchange > createProducer ( ) throws Exception { return new DefaultProducer < Exchange > ( this ) { public void process ( Exchange exchange ) { onExchange ( exchange ) ; } } ; } public void whenExchangeReceived ( int index , Processor processor ) { this . processors . put ( index , processor ) ; } public void assertIsSatisfied ( ) throws InterruptedException { assertIsSatisfied ( sleepForEmptyTest ) ; } public void assertIsSatisfied ( long timeoutForEmptyEndpoints ) throws InterruptedException { LOG . info ( "Asserting: " + this + " is satisfied" ) ; if ( expectedCount >= 0 ) { if ( expectedCount != getReceivedCounter ( ) ) { if ( expectedCount == 0 ) { if ( timeoutForEmptyEndpoints > 0 ) { LOG . debug ( "Sleeping for: " + timeoutForEmptyEndpoints + " millis to check there really are no messages received" ) ; Thread . sleep ( timeoutForEmptyEndpoints ) ; } } else { waitForCompleteLatch ( ) ; } } assertEquals ( "Received message count" , expectedCount , getReceivedCounter ( ) ) ; } else if ( expectedMinimumCount > 0 && getReceivedCounter ( ) < expectedMinimumCount ) { waitForCompleteLatch ( ) ; } if ( expectedMinimumCount >= 0 ) { int receivedCounter = getReceivedCounter ( ) ; assertTrue ( "Received message count " + receivedCounter + ", expected at least " + expectedCount , expectedCount <= receivedCounter ) ; } for ( Runnable test : tests ) { test . run ( ) ; } for ( Throwable failure : failures ) { if ( failure != null ) { LOG . error ( "Caught on " + getEndpointUri ( ) + " Exception: " + failure , failure ) ; fail ( "Failed due to caught exception: " + failure ) ; } } } public void assertIsNotSatisfied ( ) throws InterruptedException { try { assertIsSatisfied ( ) ; fail ( "Expected assertion failure!" ) ; } catch ( AssertionError e ) { LOG . info ( "Caught expected failure: " + e ) ; } } public void expectedMessageCount ( int expectedCount ) { this . expectedCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedCount ) ; } } public void expectedMinimumMessageCount ( int expectedCount ) { this . expectedMinimumCount = expectedCount ; if ( expectedCount <= 0 ) { latch = null ; } else { latch = new CountDownLatch ( expectedMinimumCount ) ; } } public void expectedBodiesReceived ( final List bodies ) { expectedMessageCount ( bodies . size ( ) ) ; this . expectedBodyValues = bodies ; this . actualBodyValues = new ArrayList ( ) ; expects ( new Runnable ( ) { public void run ( ) { for ( int i = 0 ; i < expectedBodyValues . size ( ) ; i ++ ) { Exchange exchange = getReceivedExchanges ( ) . get ( i ) ; assertTrue ( "No exchange received for counter: " + i , exchange != null ) ; Object expectedBody = expectedBodyValues . get ( i ) ; Object actualBody = actualBodyValues . get ( i ) ; assertEquals ( "Body of message: " + i , expectedBody , actualBody ) ; } } } ) ; } public void expectedBodiesReceived ( Object ... bodies ) { List bodyList = new ArrayList ( ) ; for ( Object body : bodies ) { bodyList . add ( body ) ; } expectedBodiesReceived ( bodyList ) ; } public void expectsAscending ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertMessagesAscending ( expression ) ; } } ) ; } public void expectsDescending ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertMessagesDescending ( expression ) ; } } ) ; } public void expectsNoDuplicates ( final Expression < Exchange > expression ) { expects ( new Runnable ( ) { public void run ( ) { assertNoDuplicates ( expression ) ; } } ) ; } public void assertMessagesAscending ( Expression < Exchange > expression ) { assertMessagesSorted ( expression , true ) ; } public void assertMessagesDescending ( Expression < Exchange > expression ) { assertMessagesSorted ( expression , false ) ; } protected void assertMessagesSorted ( Expression < Exchange > expression , boolean ascending ) { String type = ascending ? "ascending" : "descending" ; ExpressionComparator comparator = new ExpressionComparator ( expression ) ; List < Exchange > list = getReceivedExchanges ( ) ; for ( int i = 1 ; i < list . size ( ) ; i ++ ) { int j = i - 1 ; Exchange e1 = list . get ( j ) ; Exchange e2 = list . get ( i ) ; int result = comparator . compare ( e1 , e2 ) ; if ( result == 0 ) { fail ( "Messages not " + type + ". Messages" + j + " and " + i + " are equal with value: " + expression . evaluate ( e1 ) + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } else { if ( ! ascending ) { result = result * - 1 ; } if ( result > 0 ) { fail ( "Messages not " + type + ". Message " + j + " has value: " + expression . evaluate ( e1 ) + " and message " + i + " has value: " + expression . evaluate ( e2 ) + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } } } } public void assertNoDuplicates ( Expression < Exchange > expression ) { Map < Object , Exchange > map = new HashMap < Object , Exchange > ( ) ; List < Exchange > list = getReceivedExchanges ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Exchange e2 = list . get ( i ) ; Object key = expression . evaluate ( e2 ) ; Exchange e1 = map . get ( key ) ; if ( e1 != null ) { fail ( "Duplicate message found on message " + i + " has value: " + key + " for expression: " + expression + ". Exchanges: " + e1 + " and " + e2 ) ; } else { map . put ( key , e2 ) ; } } } public void expects ( Runnable runnable ) { tests . add ( runnable ) ; } public AssertionClause message ( final int messageIndex ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { applyAssertionOn ( MockEndpoint . this , messageIndex , assertExchangeReceived ( messageIndex ) ) ; } } ; expects ( clause ) ; return clause ; } public AssertionClause allMessages ( ) { AssertionClause clause = new AssertionClause ( ) { public void run ( ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { applyAssertionOn ( MockEndpoint . this , index ++ , exchange ) ; } } } ; expects ( clause ) ; return clause ; } public Exchange assertExchangeReceived ( int index ) { int count = getReceivedCounter ( ) ; assertTrue ( "Not enough messages received. Was: " + count , count > index ) ; return getReceivedExchanges ( ) . get ( index ) ; } public List < Throwable > getFailures ( ) { return failures ; } public int getReceivedCounter ( ) { return getReceivedExchanges ( ) . size ( ) ; } public List < Exchange > getReceivedExchanges ( ) { return receivedExchanges ; } public int getExpectedCount ( ) { return expectedCount ; } public long getSleepForEmptyTest ( ) { return sleepForEmptyTest ; } public void setSleepForEmptyTest ( long sleepForEmptyTest ) { this . sleepForEmptyTest = sleepForEmptyTest ; } public long getDefaulResultWaitMillis ( ) { return defaulResultWaitMillis ; } public void setDefaulResultWaitMillis ( long defaulResultWaitMillis ) { this . defaulResultWaitMillis = defaulResultWaitMillis ; } protected synchronized void onExchange ( Exchange exchange ) { try { Message in = exchange . getIn ( ) ; Object actualBody = in . getBody ( ) ; if ( expectedBodyValues != null ) { int index = actualBodyValues . size ( ) ; if ( expectedBodyValues . size ( ) > index ) { Object expectedBody = expectedBodyValues . get ( index ) ; if ( expectedBody != null ) { actualBody = in . getBody ( expectedBody . getClass ( ) ) ; } actualBodyValues . add ( actualBody ) ; } } LOG . debug ( getEndpointUri ( ) + " >>>> " + ( ++ counter ) + " : " + exchange + " with body: " + actualBody ) ; receivedExchanges . add ( exchange ) ; Processor processor = processors . get ( getReceivedCounter ( ) ) ; if ( processor != null ) { processor . process ( exchange ) ; } if ( latch != null ) { latch . countDown ( ) ; } } catch ( Exception e ) { failures . add ( e ) ; } } protected void waitForCompleteLatch ( ) throws InterruptedException { if ( latch == null ) { fail ( "Should have a latch!" ) ; } LOG . debug ( "Waiting on the latch for: " + defaulResultWaitMillis + " millis" ) ; latch . await ( defaulResultWaitMillis , TimeUnit . MILLISECONDS ) ; } protected void assertEquals ( String message , Object expectedValue , Object actualValue ) { if ( ! ObjectHelper . equals ( expectedValue , actualValue ) ) { fail ( message + ". Expected: <" + expectedValue + "> but was: <" + actualValue + ">" ) ; } } protected void assertTrue ( String message , boolean predicate ) { if ( ! predicate ) { fail ( message ) ; } } protected void fail ( Object message ) { if ( LOG . isDebugEnabled ( ) ) { List < Exchange > list = getReceivedExchanges ( ) ; int index = 0 ; for ( Exchange exchange : list ) { LOG . debug ( "Received[" + ( ++ index ) + "]: " + exchange ) ; } } throw new AssertionError ( getEndpointUri ( ) + " " + message ) ; } public int getExpectedMinimumCount ( ) { return expectedMinimumCount ; } public void await ( ) throws InterruptedException { if ( latch != null ) { latch . await ( ) ; } } public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { if ( latch != null ) { return latch . await ( timeout , unit ) ; } return true ; } public boolean isSingleton ( ) { return true ; } } 	1
package org . apache . camel . impl ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; public abstract class ScheduledPollConsumer < E extends Exchange > extends DefaultConsumer < E > implements Runnable { private static final transient Log log = LogFactory . getLog ( ScheduledPollConsumer . class ) ; private final ScheduledExecutorService executor ; private long initialDelay = 1000 ; private long delay = 500 ; private TimeUnit timeUnit = TimeUnit . MILLISECONDS ; private boolean useFixedDelay ; private ScheduledFuture < ? > future ; public ScheduledPollConsumer ( DefaultEndpoint < E > endpoint , Processor processor ) { this ( endpoint , processor , endpoint . getExecutorService ( ) ) ; } public ScheduledPollConsumer ( Endpoint < E > endpoint , Processor processor , ScheduledExecutorService executor ) { super ( endpoint , processor ) ; this . executor = executor ; if ( executor == null ) { throw new IllegalArgumentException ( "A non null ScheduledExecutorService must be provided." ) ; } } public void run ( ) { log . debug ( "Starting to poll" ) ; try { poll ( ) ; } catch ( Exception e ) { log . warn ( "Caught: " + e , e ) ; } } public long getInitialDelay ( ) { return initialDelay ; } public void setInitialDelay ( long initialDelay ) { this . initialDelay = initialDelay ; } public long getDelay ( ) { return delay ; } public void setDelay ( long delay ) { this . delay = delay ; } public TimeUnit getTimeUnit ( ) { return timeUnit ; } public void setTimeUnit ( TimeUnit timeUnit ) { this . timeUnit = timeUnit ; } public boolean isUseFixedDelay ( ) { return useFixedDelay ; } public void setUseFixedDelay ( boolean useFixedDelay ) { this . useFixedDelay = useFixedDelay ; } protected abstract void poll ( ) throws Exception ; @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; if ( isUseFixedDelay ( ) ) { future = executor . scheduleWithFixedDelay ( this , getInitialDelay ( ) , getDelay ( ) , getTimeUnit ( ) ) ; } else { future = executor . scheduleAtFixedRate ( this , getInitialDelay ( ) , getDelay ( ) , getTimeUnit ( ) ) ; } } @ Override protected void doStop ( ) throws Exception { if ( future != null ) { future . cancel ( false ) ; } super . doStop ( ) ; } } 	0
package org . apache . camel . builder . xml ; public class StringResultHandlerFactory implements ResultHandlerFactory { public ResultHandler createResult ( ) { return new StringResultHandler ( ) ; } } 	1
package org . apache . camel . processor ; import org . apache . camel . Processor ; import org . apache . camel . Exchange ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . util . ServiceHelper ; import java . util . Collection ; public class CompositeProcessor extends ServiceSupport implements Processor { private final Collection < Processor > processors ; public CompositeProcessor ( Collection < Processor > processors ) { this . processors = processors ; } public void process ( Exchange exchange ) throws Exception { for ( Processor processor : processors ) { processor . process ( exchange ) ; } } @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( "[ " ) ; boolean first = true ; for ( Processor processor : processors ) { if ( first ) { first = false ; } else { builder . append ( ", " ) ; } builder . append ( processor . toString ( ) ) ; } builder . append ( " ]" ) ; return builder . toString ( ) ; } public Collection < Processor > getProcessors ( ) { return processors ; } protected void doStart ( ) throws Exception { ServiceHelper . startServices ( processors ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( processors ) ; } } 	0
package org . apache . camel . builder . xml ; import javax . xml . transform . Result ; import org . apache . camel . Message ; public interface ResultHandler { Result getResult ( ) ; void setBody ( Message in ) ; } 	1
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class RuntimeJmsException extends RuntimeException { private static final long serialVersionUID = - 2141493732308871761L ; public RuntimeJmsException ( String message , JMSException cause ) { super ( message , cause ) ; } } 	0
package org . apache . camel . processor ; import java . util . List ; import org . apache . camel . Processor ; public class CatchProcessor extends DelegateProcessor { private List < Class > exceptions ; public CatchProcessor ( List < Class > exceptions , Processor processor ) { super ( processor ) ; this . exceptions = exceptions ; } @ Override public String toString ( ) { return "Catch[" + exceptions + " -> " + getProcessor ( ) + "]" ; } public boolean catches ( Throwable e ) { for ( Class type : exceptions ) { if ( type . isInstance ( e ) ) { return true ; } } return false ; } public List < Class > getExceptions ( ) { return exceptions ; } } 	1
package org . apache . camel . impl . converter ; public interface TypeConverterLoader { void load ( TypeConverterRegistry registry ) throws Exception ; } 	0
package org . apache . camel ; public interface AsyncProcessor extends Processor { boolean process ( Exchange exchange , AsyncCallback callback ) ; } 	1
package org . apache . camel . component . jmx ; import javax . management . Notification ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; public class JMXExchange extends DefaultExchange { public JMXExchange ( CamelContext camelContext , Notification notification ) { super ( camelContext ) ; setIn ( new JMXMessage ( notification ) ) ; } } 	0
package org . apache . camel . model ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ThreadPoolExecutor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElementRef ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlTransient ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . ThreadProcessor ; @ XmlRootElement ( name = "thread" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class ThreadType extends ProcessorType { @ XmlAttribute private int coreSize = 1 ; @ XmlAttribute private boolean daemon = true ; @ XmlAttribute private long keepAliveTime ; @ XmlAttribute private int maxSize = 1 ; @ XmlAttribute private String name = "Thread Processor" ; @ XmlAttribute private int priority = Thread . NORM_PRIORITY ; @ XmlAttribute private long stackSize ; @ XmlElementRef private List < ProcessorType > outputs = new ArrayList < ProcessorType > ( ) ; @ XmlTransient private BlockingQueue < Runnable > taskQueue ; @ XmlTransient private ThreadGroup threadGroup ; @ XmlTransient private ThreadPoolExecutor executor ; public ThreadType ( ) { } public ThreadType ( int coreSize ) { this . coreSize = coreSize ; this . maxSize = coreSize ; } public ThreadType ( ThreadPoolExecutor executor ) { this . executor = executor ; } @ Override public List getInterceptors ( ) { return Collections . EMPTY_LIST ; } @ Override public List getOutputs ( ) { return outputs ; } @ Override public String toString ( ) { return "Thread[" + getLabel ( ) + "]" ; } @ Override public String getLabel ( ) { return "coreSize=" + coreSize ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { ThreadProcessor thread = new ThreadProcessor ( ) ; thread . setExecutor ( executor ) ; thread . setCoreSize ( coreSize ) ; thread . setDaemon ( daemon ) ; thread . setKeepAliveTime ( keepAliveTime ) ; thread . setMaxSize ( maxSize ) ; thread . setName ( name ) ; thread . setPriority ( priority ) ; thread . setStackSize ( stackSize ) ; thread . setTaskQueue ( taskQueue ) ; thread . setThreadGroup ( threadGroup ) ; ArrayList < Processor > pipe = new ArrayList < Processor > ( 2 ) ; pipe . add ( thread ) ; pipe . add ( createOutputsProcessor ( routeContext , outputs ) ) ; return new Pipeline ( pipe ) ; } public ThreadType coreSize ( int coreSize ) { setCoreSize ( coreSize ) ; return this ; } public ThreadType daemon ( boolean daemon ) { setDaemon ( daemon ) ; return this ; } public ThreadType keepAliveTime ( long keepAliveTime ) { setKeepAliveTime ( keepAliveTime ) ; return this ; } public ThreadType maxSize ( int maxSize ) { setMaxSize ( maxSize ) ; return this ; } public ThreadType name ( String name ) { setName ( name ) ; return this ; } public ThreadType priority ( int priority ) { setPriority ( priority ) ; return this ; } public ThreadType stackSize ( long stackSize ) { setStackSize ( stackSize ) ; return this ; } public ThreadType taskQueue ( BlockingQueue < Runnable > taskQueue ) { setTaskQueue ( taskQueue ) ; return this ; } public ThreadType threadGroup ( ThreadGroup threadGroup ) { setThreadGroup ( threadGroup ) ; return this ; } public ThreadType executor ( ThreadPoolExecutor executor ) { setExecutor ( executor ) ; return this ; } public void setCoreSize ( int coreSize ) { this . coreSize = coreSize ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public void setKeepAliveTime ( long keepAliveTime ) { this . keepAliveTime = keepAliveTime ; } public void setMaxSize ( int maxSize ) { this . maxSize = maxSize ; } public void setName ( String name ) { this . name = name ; } public void setPriority ( int priority ) { this . priority = priority ; } public void setStackSize ( long stackSize ) { this . stackSize = stackSize ; } public void setTaskQueue ( BlockingQueue < Runnable > taskQueue ) { this . taskQueue = taskQueue ; } public void setThreadGroup ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; } public ThreadPoolExecutor getExecutor ( ) { return executor ; } public void setExecutor ( ThreadPoolExecutor executor ) { this . executor = executor ; } } 	1
package org . apache . camel . component . jms ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; import javax . jms . Message ; public class JmsExchange extends DefaultExchange { private JmsBinding binding ; public JmsExchange ( CamelContext context , JmsBinding binding ) { super ( context ) ; this . binding = binding ; } public JmsExchange ( CamelContext context , JmsBinding binding , Message message ) { this ( context , binding ) ; setIn ( new JmsMessage ( message ) ) ; } @ Override public JmsMessage getIn ( ) { return ( JmsMessage ) super . getIn ( ) ; } @ Override public JmsMessage getOut ( ) { return ( JmsMessage ) super . getOut ( ) ; } @ Override public JmsMessage getOut ( boolean lazyCreate ) { return ( JmsMessage ) super . getOut ( lazyCreate ) ; } @ Override public JmsMessage getFault ( ) { return ( JmsMessage ) super . getFault ( ) ; } public JmsBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new JmsExchange ( getContext ( ) , binding ) ; } public Message getInMessage ( ) { return getIn ( ) . getJmsMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getJmsMessage ( ) ; } public Message getFaultMessage ( ) { return getOut ( ) . getJmsMessage ( ) ; } @ Override protected JmsMessage createInMessage ( ) { return new JmsMessage ( ) ; } @ Override protected JmsMessage createOutMessage ( ) { return new JmsMessage ( ) ; } } 	0
package org . apache . camel . util ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . NoSuchEndpointException ; import org . apache . camel . spi . Injector ; import static org . apache . camel . util . ObjectHelper . notNull ; public class CamelContextHelper { private CamelContextHelper ( ) { } public static Endpoint getMandatoryEndpoint ( CamelContext camelContext , String uri ) throws NoSuchEndpointException { Endpoint endpoint = camelContext . getEndpoint ( uri ) ; if ( endpoint == null ) { throw new NoSuchEndpointException ( uri ) ; } else { return endpoint ; } } public static < T > T convertTo ( CamelContext context , Class < T > type , Object value ) { notNull ( context , "camelContext" ) ; return context . getTypeConverter ( ) . convertTo ( type , value ) ; } public static < T > T mandatoryConvertTo ( CamelContext context , Class < T > type , Object value ) { T answer = convertTo ( context , type , value ) ; if ( answer == null ) { throw new IllegalArgumentException ( "Value " + value + " converted to " + type . getName ( ) + " cannot be null" ) ; } return answer ; } public static < T > T newInstance ( CamelContext context , Class < T > beanType ) { return context . getInjector ( ) . newInstance ( beanType ) ; } } 	1
package org . apache . camel ; public interface TypeConverter { < T > T convertTo ( Class < T > type , Object value ) ; } 	0
package org . apache . camel . spi ; public interface Injector { < T > T newInstance ( Class < T > type ) ; } 	1
package org . apache . camel . impl ; import org . apache . camel . Route ; import org . apache . camel . Endpoint ; import org . apache . camel . Processor ; import org . apache . camel . Service ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import java . util . List ; public class PollingConsumerRoute < E extends Exchange > extends Route < E > { private Processor processor ; public PollingConsumerRoute ( Endpoint endpoint , Processor processor ) { super ( endpoint ) ; this . processor = processor ; } @ Override public String toString ( ) { return "PollingConsumerRoute[" + getEndpoint ( ) + " -> " + processor + "]" ; } public Processor getProcessor ( ) { return processor ; } public void setProcessor ( Processor processor ) { this . processor = processor ; } protected void addServices ( List < Service > services ) throws Exception { Processor processor = getProcessor ( ) ; if ( processor instanceof Service ) { Service service = ( Service ) processor ; services . add ( service ) ; } Endpoint < E > endpoint = getEndpoint ( ) ; PollingConsumer < E > consumer = endpoint . createPollingConsumer ( ) ; if ( consumer != null ) { services . add ( consumer ) ; } } } 	0
package org . apache . camel . component . bean ; import java . util . List ; import org . apache . camel . CamelExchangeException ; import org . apache . camel . Exchange ; public class AmbiguousMethodCallException extends CamelExchangeException { private final List < MethodInfo > methods ; public AmbiguousMethodCallException ( Exchange exchange , List < MethodInfo > methods ) { super ( "Ambiguous method invocations possible: " + methods , exchange ) ; this . methods = methods ; } public List < MethodInfo > getMethods ( ) { return methods ; } } 	1
package org . apache . camel . util ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; public class CollectionHelper { public static void appendValue ( Map map , Object key , Object value ) { Object oldValue = map . get ( key ) ; if ( oldValue != null ) { List list ; if ( oldValue instanceof List ) { list = ( List ) oldValue ; } else { list = new ArrayList ( ) ; list . add ( oldValue ) ; } list . add ( value ) ; } else { map . put ( key , value ) ; } } } 	0
package org . apache . camel . builder . xml ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . stream . StreamSource ; import org . apache . camel . Exchange ; import org . apache . camel . ExpectedBodyTypeException ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeTransformException ; import org . apache . camel . converter . jaxp . XmlConverter ; import static org . apache . camel . util . ObjectHelper . notNull ; public class XsltBuilder implements Processor { private Map < String , Object > parameters = new HashMap < String , Object > ( ) ; private XmlConverter converter = new XmlConverter ( ) ; private Transformer transformer ; private ResultHandlerFactory resultHandlerFactory = new StringResultHandlerFactory ( ) ; private boolean failOnNullBody = true ; public XsltBuilder ( ) { } public XsltBuilder ( Transformer transformer ) { this . transformer = transformer ; } @ Override public String toString ( ) { return "XSLT[" + transformer + "]" ; } public synchronized void process ( Exchange exchange ) throws Exception { Transformer transformer = getTransformer ( ) ; if ( transformer == null ) { throw new IllegalArgumentException ( "No transformer configured!" ) ; } configureTransformer ( transformer , exchange ) ; Source source = getSource ( exchange ) ; ResultHandler resultHandler = resultHandlerFactory . createResult ( ) ; Result result = resultHandler . getResult ( ) ; transformer . transform ( source , result ) ; resultHandler . setBody ( exchange . getIn ( ) ) ; } public static XsltBuilder xslt ( Transformer transformer ) { return new XsltBuilder ( transformer ) ; } public static XsltBuilder xslt ( Source xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; XsltBuilder answer = new XsltBuilder ( ) ; answer . setTransformerSource ( xslt ) ; return answer ; } public static XsltBuilder xslt ( File xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public static XsltBuilder xslt ( URL xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( xslt . openStream ( ) ) ; } public static XsltBuilder xslt ( InputStream xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public XsltBuilder outputBytes ( ) { setResultHandlerFactory ( new StreamResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder outputString ( ) { setResultHandlerFactory ( new StringResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder outputDOM ( ) { setResultHandlerFactory ( new DomResultHandlerFactory ( ) ) ; return this ; } public XsltBuilder parameter ( String name , Object value ) { parameters . put ( name , value ) ; return this ; } public Map < String , Object > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , Object > parameters ) { this . parameters = parameters ; } public Transformer getTransformer ( ) { return transformer ; } public void setTransformer ( Transformer transformer ) { this . transformer = transformer ; } public boolean isFailOnNullBody ( ) { return failOnNullBody ; } public void setFailOnNullBody ( boolean failOnNullBody ) { this . failOnNullBody = failOnNullBody ; } public ResultHandlerFactory getResultHandlerFactory ( ) { return resultHandlerFactory ; } public void setResultHandlerFactory ( ResultHandlerFactory resultHandlerFactory ) { this . resultHandlerFactory = resultHandlerFactory ; } public void setTransformerSource ( Source source ) throws TransformerConfigurationException { setTransformer ( converter . getTransformerFactory ( ) . newTransformer ( source ) ) ; } protected Source getSource ( Exchange exchange ) { Message in = exchange . getIn ( ) ; Source source = in . getBody ( Source . class ) ; if ( source == null ) { if ( isFailOnNullBody ( ) ) { throw new ExpectedBodyTypeException ( exchange , Source . class ) ; } else { try { source = converter . toSource ( converter . createDocument ( ) ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeTransformException ( e ) ; } } } return source ; } protected void configureTransformer ( Transformer transformer , Exchange exchange ) { transformer . clearParameters ( ) ; addParameters ( transformer , exchange . getProperties ( ) ) ; addParameters ( transformer , exchange . getIn ( ) . getHeaders ( ) ) ; addParameters ( transformer , getParameters ( ) ) ; transformer . setParameter ( "exchange" , exchange ) ; transformer . setParameter ( "in" , exchange . getIn ( ) ) ; transformer . setParameter ( "out" , exchange . getOut ( ) ) ; } protected void addParameters ( Transformer transformer , Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { transformer . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	1
package org . apache . camel . spi ; public interface Provider < T > { T get ( ) ; } 	0
package org . apache . camel . impl . converter ; import java . lang . reflect . Method ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . impl . CachingInjector ; import org . apache . camel . util . ObjectHelper ; public class InstanceMethodTypeConverter implements TypeConverter { private final CachingInjector injector ; private final Method method ; public InstanceMethodTypeConverter ( CachingInjector injector , Method method ) { this . injector = injector ; this . method = method ; } @ Override public String toString ( ) { return "InstanceMethodTypeConverter: " + method ; } public synchronized < T > T convertTo ( Class < T > type , Object value ) { Object instance = injector . newInstance ( ) ; if ( instance == null ) { throw new RuntimeCamelException ( "Could not instantiate aninstance of: " + type . getName ( ) ) ; } return ( T ) ObjectHelper . invokeMethod ( method , instance , value ) ; } } 	1
package org . apache . camel . component . queue ; import org . apache . camel . Consumer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . impl . ServiceSupport ; import java . util . concurrent . TimeUnit ; public class QueueEndpointConsumer < E extends Exchange > extends ServiceSupport implements Consumer < E > , Runnable { private QueueEndpoint < E > endpoint ; private Processor processor ; private Thread thread ; public QueueEndpointConsumer ( QueueEndpoint < E > endpoint , Processor processor ) { this . endpoint = endpoint ; this . processor = processor ; } @ Override public String toString ( ) { return "QueueEndpointConsumer: " + endpoint . getEndpointUri ( ) ; } public void run ( ) { while ( ! isStopping ( ) ) { E exchange ; try { exchange = endpoint . getQueue ( ) . poll ( 1000 , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { break ; } if ( exchange != null && ! isStopping ( ) ) { try { processor . process ( exchange ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } } } protected void doStart ( ) throws Exception { thread = new Thread ( this , endpoint . getEndpointUri ( ) ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { thread . join ( ) ; } } 	0
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "simple" ) public class SimpleExpression extends ExpressionType { public SimpleExpression ( ) { } public SimpleExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "simple" ; } } 	1
package org . apache . camel . builder ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; public interface ProcessorFactory { public Processor createProcessor ( ) throws Exception ; } 	0
package org . apache . camel . processor ; import java . util . Collection ; import java . util . Iterator ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . PollingConsumer ; import org . apache . camel . Processor ; import org . apache . camel . impl . LoggingExceptionHandler ; import org . apache . camel . impl . ServiceSupport ; import org . apache . camel . spi . ExceptionHandler ; import org . apache . camel . util . ServiceHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BatchProcessor extends ServiceSupport implements Runnable { public static final long DEFAULT_BATCH_TIMEOUT = 1000L ; public static final int DEFAULT_BATCH_SIZE = 100 ; private static final transient Log LOG = LogFactory . getLog ( Resequencer . class ) ; private Endpoint endpoint ; private Processor processor ; private Collection < Exchange > collection ; private long batchTimeout = DEFAULT_BATCH_TIMEOUT ; private int batchSize = DEFAULT_BATCH_SIZE ; private PollingConsumer consumer ; private ExceptionHandler exceptionHandler ; public BatchProcessor ( Endpoint endpoint , Processor processor , Collection < Exchange > collection ) { this . endpoint = endpoint ; this . processor = processor ; this . collection = collection ; } @ Override public String toString ( ) { return "BatchProcessor[to: " + processor + "]" ; } public void run ( ) { LOG . debug ( "Starting thread for " + this ) ; while ( isRunAllowed ( ) ) { try { processBatch ( ) ; } catch ( Exception e ) { getExceptionHandler ( ) . handleException ( e ) ; } } collection . clear ( ) ; } public ExceptionHandler getExceptionHandler ( ) { if ( exceptionHandler == null ) { exceptionHandler = new LoggingExceptionHandler ( getClass ( ) ) ; } return exceptionHandler ; } public void setExceptionHandler ( ExceptionHandler exceptionHandler ) { this . exceptionHandler = exceptionHandler ; } public int getBatchSize ( ) { return batchSize ; } public void setBatchSize ( int batchSize ) { this . batchSize = batchSize ; } public long getBatchTimeout ( ) { return batchTimeout ; } public void setBatchTimeout ( long batchTimeout ) { this . batchTimeout = batchTimeout ; } public Endpoint getEndpoint ( ) { return endpoint ; } public Processor getProcessor ( ) { return processor ; } protected synchronized void processBatch ( ) throws Exception { long start = System . currentTimeMillis ( ) ; long end = start + batchTimeout ; for ( int i = 0 ; i < batchSize ; i ++ ) { long timeout = end - System . currentTimeMillis ( ) ; Exchange exchange = consumer . receive ( timeout ) ; if ( exchange == null ) { break ; } collection . add ( exchange ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Finsihed batch size: " + batchSize + " timeout: " + batchTimeout + " so sending set: " + collection ) ; } Iterator < Exchange > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { Exchange exchange = iter . next ( ) ; iter . remove ( ) ; processExchange ( exchange ) ; } } protected void processExchange ( Exchange exchange ) throws Exception { processor . process ( exchange ) ; } protected void doStart ( ) throws Exception { consumer = endpoint . createPollingConsumer ( ) ; ServiceHelper . startServices ( processor , consumer ) ; Thread thread = new Thread ( this , this + " Polling Thread" ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { ServiceHelper . stopServices ( consumer , processor ) ; collection . clear ( ) ; } protected Collection < Exchange > getCollection ( ) { return collection ; } } 	1
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; public class DefaultComponentResolver < E extends Exchange > implements ComponentResolver < E > { protected static final FactoryFinder componentFactory = new FactoryFinder ( "META-INF/services/org/apache/camel/component/" ) ; public Component < E > resolveComponent ( String name , CamelContext context ) { Class type ; try { type = componentFactory . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { return null ; } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no EndpointResolver registered for scheme : " + name , e ) ; } if ( type == null ) { return null ; } if ( Component . class . isAssignableFrom ( type ) ) { return ( Component < E > ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Component implementation. Found: " + type . getName ( ) ) ; } } } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . NoSuchLanguageException ; import org . apache . camel . spi . Language ; import org . apache . camel . spi . LanguageResolver ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; public class DefaultLanguageResolver implements LanguageResolver { protected static final FactoryFinder LANGUAGE_FACTORY = new FactoryFinder ( "META-INF/services/org/apache/camel/language/" ) ; protected static final FactoryFinder LANGUAGE_RESOLVER = new FactoryFinder ( "META-INF/services/org/apache/camel/language/resolver/" ) ; public Language resolveLanguage ( String name , CamelContext context ) { Class type = null ; try { type = LANGUAGE_FACTORY . findClass ( name ) ; } catch ( NoFactoryAvailableException e ) { } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Language registered for scheme : " + name , e ) ; } if ( type != null ) { if ( Language . class . isAssignableFrom ( type ) ) { return ( Language ) context . getInjector ( ) . newInstance ( type ) ; } else { throw new IllegalArgumentException ( "Type is not a Language implementation. Found: " + type . getName ( ) ) ; } } return noSpecificLanguageFound ( name , context ) ; } protected Language noSpecificLanguageFound ( String name , CamelContext context ) { Class type = null ; try { type = LANGUAGE_RESOLVER . findClass ( "default" ) ; } catch ( NoFactoryAvailableException e ) { } catch ( Throwable e ) { throw new IllegalArgumentException ( "Invalid URI, no Language registered for scheme : " + name , e ) ; } if ( type != null ) { if ( LanguageResolver . class . isAssignableFrom ( type ) ) { LanguageResolver resolver = ( LanguageResolver ) context . getInjector ( ) . newInstance ( type ) ; return resolver . resolveLanguage ( name , context ) ; } else { throw new IllegalArgumentException ( "Type is not a LanguageResolver implementation. Found: " + type . getName ( ) ) ; } } throw new NoSuchLanguageException ( name ) ; } } 	1
package org . apache . camel . component . cxf . transport ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . CamelTemplate ; import org . apache . cxf . Bus ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; public class CamelTransportBase { private String replyDestination ; CamelTemplate < Exchange > template ; private final CamelContext camelContext ; Bus bus ; EndpointInfo endpointInfo ; public CamelTransportBase ( CamelContext camelContext , Bus bus , EndpointInfo endpointInfo , boolean b , String baseBeanNameSuffix ) { this . camelContext = camelContext ; this . bus = bus ; this . endpointInfo = endpointInfo ; this . template = new CamelTemplate < Exchange > ( camelContext ) ; } public void populateIncomingContext ( Exchange exchange , MessageImpl inMessage , String camelServerRequestHeaders ) { } public String getReplyDestination ( ) { return replyDestination ; } public void setMessageProperties ( Message inMessage , Exchange reply ) { } public void close ( ) { if ( template != null ) { try { template . stop ( ) ; } catch ( Exception e ) { } } } protected void marshal ( Object payload , String replyTo , Exchange exchange ) { org . apache . camel . Message message = exchange . getIn ( ) ; message . setBody ( payload ) ; if ( replyTo != null ) { message . setHeader ( CamelConstants . CAMEL_CORRELATION_ID , replyTo ) ; } } public byte [ ] unmarshal ( Exchange exchange ) { return exchange . getIn ( ) . getBody ( byte [ ] . class ) ; } } 	0
package org . apache . camel ; public interface Endpoint < E extends Exchange > { boolean isSingleton ( ) ; String getEndpointUri ( ) ; E createExchange ( ) ; E createExchange ( ExchangePattern pattern ) ; E createExchange ( Exchange exchange ) ; CamelContext getContext ( ) ; Producer < E > createProducer ( ) throws Exception ; Consumer < E > createConsumer ( Processor processor ) throws Exception ; PollingConsumer < E > createPollingConsumer ( ) throws Exception ; } 	1
package org . apache . camel . util ; import org . apache . camel . spi . Injector ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; import java . util . concurrent . ConcurrentHashMap ; public class FactoryFinder { private final String path ; private final ConcurrentHashMap classMap = new ConcurrentHashMap ( ) ; public FactoryFinder ( ) { this ( "META-INF/services/org/apache/camel/" ) ; } public FactoryFinder ( String path ) { this . path = path ; } public Object newInstance ( String key ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { return newInstance ( key , ( String ) null ) ; } public Object newInstance ( String key , String propertyPrefix ) throws IllegalAccessException , InstantiationException , IOException , ClassNotFoundException { Class clazz = findClass ( key , propertyPrefix ) ; return clazz . newInstance ( ) ; } public Object newInstance ( String key , Injector injector ) throws IOException , ClassNotFoundException { return newInstance ( key , injector , null ) ; } public Object newInstance ( String key , Injector injector , String propertyPrefix ) throws IOException , ClassNotFoundException { Class type = findClass ( key , propertyPrefix ) ; return injector . newInstance ( type ) ; } public Class findClass ( String key ) throws ClassNotFoundException , IOException { return findClass ( key , null ) ; } public Class findClass ( String key , String propertyPrefix ) throws ClassNotFoundException , IOException { if ( propertyPrefix == null ) { propertyPrefix = "" ; } Class clazz = ( Class ) classMap . get ( propertyPrefix + key ) ; if ( clazz == null ) { clazz = newInstance ( doFindFactoryProperies ( key ) , propertyPrefix ) ; classMap . put ( propertyPrefix + key , clazz ) ; } return clazz ; } private Class newInstance ( Properties properties , String propertyPrefix ) throws ClassNotFoundException , IOException { String className = properties . getProperty ( propertyPrefix + "class" ) ; if ( className == null ) { throw new IOException ( "Expected property is missing: " + propertyPrefix + "class" ) ; } Class clazz = null ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader != null ) { try { clazz = loader . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { } } if ( clazz == null ) { clazz = FactoryFinder . class . getClassLoader ( ) . loadClass ( className ) ; } return clazz ; } private Properties doFindFactoryProperies ( String key ) throws IOException { String uri = path + key ; ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader == null ) { classLoader = getClass ( ) . getClassLoader ( ) ; } InputStream in = classLoader . getResourceAsStream ( uri ) ; if ( in == null ) { in = FactoryFinder . class . getClassLoader ( ) . getResourceAsStream ( uri ) ; if ( in == null ) { throw new NoFactoryAvailableException ( uri ) ; } } BufferedInputStream reader = null ; try { reader = new BufferedInputStream ( in ) ; Properties properties = new Properties ( ) ; properties . load ( reader ) ; return properties ; } finally { try { reader . close ( ) ; } catch ( Exception e ) { } } } } 	0
package org . apache . camel . model . language ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = "xquery" ) public class XQueryExpression extends ExpressionType { public XQueryExpression ( ) { } public XQueryExpression ( String expression ) { super ( expression ) ; } public String getLanguage ( ) { return "xquery" ; } } 	1
package org . apache . camel . spring ; import org . apache . camel . impl . ServiceSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . ClassPathXmlApplicationContext ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; public class Main extends ServiceSupport { private static final Log log = LogFactory . getLog ( Main . class ) ; private String applicationContextUri = "META-INF/spring/*.xml" ; private AbstractApplicationContext applicationContext ; private List < Option > options = new ArrayList < Option > ( ) ; private CountDownLatch latch = new CountDownLatch ( 1 ) ; private AtomicBoolean completed = new AtomicBoolean ( false ) ; public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . parseArguments ( args ) ; main . run ( ) ; } public Main ( ) { addOption ( new Option ( "h" , "help" , "Displays the help screen" ) { protected void doProcess ( String arg , LinkedList < String > remainingArgs ) { showOptions ( ) ; completed ( ) ; } } ) ; addOption ( new ParameterOption ( "a" , "applicationContext" , "Sets the classpath based pring ApplicationContext" , "applicationContext" ) { protected void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) { setApplicationContextUri ( parameter ) ; } } ) ; } public void run ( ) { if ( ! completed . get ( ) ) { try { start ( ) ; waitUntilCompleted ( ) ; stop ( ) ; } catch ( Exception e ) { log . error ( "Failed: " + e , e ) ; } } } public void completed ( ) { completed . set ( true ) ; latch . countDown ( ) ; } public void showOptions ( ) { System . out . println ( "Apache Camel Runner takes the following options" ) ; System . out . println ( ) ; for ( Option option : options ) { System . out . println ( "  " + option . getAbbreviation ( ) + " or " + option . getFullName ( ) + " = " + option . getDescription ( ) ) ; } } public void parseArguments ( String [ ] arguments ) { LinkedList < String > args = new LinkedList < String > ( Arrays . asList ( arguments ) ) ; boolean valid = true ; while ( ! args . isEmpty ( ) ) { String arg = args . removeFirst ( ) ; boolean handled = false ; for ( Option option : options ) { if ( option . processOption ( arg , args ) ) { handled = true ; break ; } } if ( ! handled ) { System . out . println ( "Unknown option: " + arg ) ; System . out . println ( ) ; valid = false ; break ; } } if ( ! valid ) { showOptions ( ) ; completed ( ) ; } } public void addOption ( Option option ) { options . add ( option ) ; } public abstract class Option { private String abbreviation ; private String fullName ; private String description ; protected Option ( String abbreviation , String fullName , String description ) { this . abbreviation = "-" + abbreviation ; this . fullName = "-" + fullName ; this . description = description ; } public boolean processOption ( String arg , LinkedList < String > remainingArgs ) { if ( arg . equalsIgnoreCase ( abbreviation ) || fullName . startsWith ( arg ) ) { doProcess ( arg , remainingArgs ) ; return true ; } return false ; } public String getAbbreviation ( ) { return abbreviation ; } public String getDescription ( ) { return description ; } public String getFullName ( ) { return fullName ; } protected abstract void doProcess ( String arg , LinkedList < String > remainingArgs ) ; } public abstract class ParameterOption extends Option { private String parameterName ; protected ParameterOption ( String abbreviation , String fullName , String description , String parameterName ) { super ( abbreviation , fullName , description ) ; this . parameterName = parameterName ; } protected void doProcess ( String arg , LinkedList < String > remainingArgs ) { if ( remainingArgs . isEmpty ( ) ) { System . err . println ( "Expected fileName for " ) ; showOptions ( ) ; completed ( ) ; } else { String parameter = remainingArgs . removeFirst ( ) ; doProcess ( arg , parameter , remainingArgs ) ; } } protected abstract void doProcess ( String arg , String parameter , LinkedList < String > remainingArgs ) ; } public AbstractApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( AbstractApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public String getApplicationContextUri ( ) { return applicationContextUri ; } public void setApplicationContextUri ( String applicationContextUri ) { this . applicationContextUri = applicationContextUri ; } protected void doStart ( ) throws Exception { log . info ( "Apache Camel " + getVersion ( ) + " starting" ) ; if ( applicationContext == null ) { applicationContext = createDefaultApplicationContext ( ) ; } applicationContext . start ( ) ; } protected AbstractApplicationContext createDefaultApplicationContext ( ) { return new ClassPathXmlApplicationContext ( getApplicationContextUri ( ) ) ; } protected void doStop ( ) throws Exception { log . info ( "Apache Camel terminating" ) ; if ( applicationContext != null ) { applicationContext . close ( ) ; } } protected void waitUntilCompleted ( ) { while ( ! completed . get ( ) ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { } } } protected String getVersion ( ) { Package aPackage = Package . getPackage ( "org.apache.camel" ) ; if ( aPackage != null ) { String version = aPackage . getImplementationVersion ( ) ; if ( version == null ) { version = aPackage . getSpecificationVersion ( ) ; if ( version == null ) { version = "" ; } } return version ; } return "" ; } } 	0
package org . apache . camel . processor ; import java . util . List ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . RejectedExecutionHandler ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . AsyncCallback ; import org . apache . camel . AsyncProcessor ; import org . apache . camel . Exchange ; import org . apache . camel . Service ; import org . apache . camel . util . AsyncProcessorHelper ; public class ThreadProcessor implements AsyncProcessor , Service { private ThreadPoolExecutor executor ; private long stackSize ; private ThreadGroup threadGroup ; private int priority = Thread . NORM_PRIORITY ; private boolean daemon = true ; private String name = "Thread Processor" ; private BlockingQueue < Runnable > taskQueue ; private long keepAliveTime ; private int maxSize = 1 ; private int coreSize = 1 ; private final AtomicBoolean shutdown = new AtomicBoolean ( true ) ; ; class ProcessCall implements Runnable { private final Exchange exchange ; private final AsyncCallback callback ; public ProcessCall ( Exchange exchange , AsyncCallback callback ) { this . exchange = exchange ; this . callback = callback ; } public void run ( ) { if ( shutdown . get ( ) ) { exchange . setException ( new RejectedExecutionException ( ) ) ; callback . done ( false ) ; } else { callback . done ( false ) ; } } } public void process ( Exchange exchange ) throws Exception { AsyncProcessorHelper . process ( this , exchange ) ; } public boolean process ( final Exchange exchange , final AsyncCallback callback ) { if ( shutdown . get ( ) ) { throw new IllegalStateException ( "ThreadProcessor is not running." ) ; } ProcessCall call = new ProcessCall ( exchange , callback ) ; executor . execute ( call ) ; return false ; } public void start ( ) throws Exception { shutdown . set ( false ) ; getExecutor ( ) . setRejectedExecutionHandler ( new RejectedExecutionHandler ( ) { public void rejectedExecution ( Runnable runnable , ThreadPoolExecutor executor ) { ProcessCall call = ( ProcessCall ) runnable ; call . exchange . setException ( new RejectedExecutionException ( ) ) ; call . callback . done ( false ) ; } } ) ; } public void stop ( ) throws Exception { shutdown . set ( true ) ; executor . shutdown ( ) ; executor . awaitTermination ( 0 , TimeUnit . SECONDS ) ; } public long getStackSize ( ) { return stackSize ; } public void setStackSize ( long stackSize ) { this . stackSize = stackSize ; } public ThreadGroup getThreadGroup ( ) { return threadGroup ; } public void setThreadGroup ( ThreadGroup threadGroup ) { this . threadGroup = threadGroup ; } public int getPriority ( ) { return priority ; } public void setPriority ( int priority ) { this . priority = priority ; } public boolean isDaemon ( ) { return daemon ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public long getKeepAliveTime ( ) { return keepAliveTime ; } public void setKeepAliveTime ( long keepAliveTime ) { this . keepAliveTime = keepAliveTime ; } public int getMaxSize ( ) { return maxSize ; } public void setMaxSize ( int maxSize ) { this . maxSize = maxSize ; } public int getCoreSize ( ) { return coreSize ; } public void setCoreSize ( int coreSize ) { this . coreSize = coreSize ; } public BlockingQueue < Runnable > getTaskQueue ( ) { if ( taskQueue == null ) { taskQueue = new ArrayBlockingQueue < Runnable > ( 1000 ) ; } return taskQueue ; } public void setTaskQueue ( BlockingQueue < Runnable > taskQueue ) { this . taskQueue = taskQueue ; } public ThreadPoolExecutor getExecutor ( ) { if ( executor == null ) { executor = new ThreadPoolExecutor ( getCoreSize ( ) , getMaxSize ( ) , getKeepAliveTime ( ) , TimeUnit . MILLISECONDS , getTaskQueue ( ) , new ThreadFactory ( ) { public Thread newThread ( Runnable runnable ) { Thread thread ; if ( getStackSize ( ) > 0 ) { thread = new Thread ( getThreadGroup ( ) , runnable , getName ( ) , getStackSize ( ) ) ; } else { thread = new Thread ( getThreadGroup ( ) , runnable , getName ( ) ) ; } thread . setDaemon ( isDaemon ( ) ) ; thread . setPriority ( getPriority ( ) ) ; return thread ; } } ) ; } return executor ; } public void setExecutor ( ThreadPoolExecutor executor ) { this . executor = executor ; } } 	1
package org . apache . camel . component . jbi ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultExchange ; import javax . jbi . messaging . MessageExchange ; import javax . jbi . messaging . NormalizedMessage ; public class JbiExchange extends DefaultExchange { private final JbiBinding binding ; private MessageExchange messageExchange ; public JbiExchange ( CamelContext context , JbiBinding binding ) { super ( context ) ; this . binding = binding ; } public JbiExchange ( CamelContext context , JbiBinding binding , MessageExchange messageExchange ) { super ( context ) ; this . binding = binding ; this . messageExchange = messageExchange ; setIn ( new JbiMessage ( messageExchange . getMessage ( "in" ) ) ) ; setOut ( new JbiMessage ( messageExchange . getMessage ( "out" ) ) ) ; setFault ( new JbiMessage ( messageExchange . getMessage ( "fault" ) ) ) ; } @ Override public JbiMessage getIn ( ) { return ( JbiMessage ) super . getIn ( ) ; } @ Override public JbiMessage getOut ( ) { return ( JbiMessage ) super . getOut ( ) ; } @ Override public JbiMessage getOut ( boolean lazyCreate ) { return ( JbiMessage ) super . getOut ( lazyCreate ) ; } @ Override public JbiMessage getFault ( ) { return ( JbiMessage ) super . getFault ( ) ; } public JbiBinding getBinding ( ) { return binding ; } public MessageExchange getMessageExchange ( ) { return messageExchange ; } public NormalizedMessage getInMessage ( ) { return getIn ( ) . getNormalizedMessage ( ) ; } public NormalizedMessage getOutMessage ( ) { return getOut ( ) . getNormalizedMessage ( ) ; } public NormalizedMessage getFaultMessage ( ) { return getFault ( ) . getNormalizedMessage ( ) ; } @ Override protected JbiMessage createInMessage ( ) { return new JbiMessage ( ) ; } @ Override protected JbiMessage createOutMessage ( ) { return new JbiMessage ( ) ; } } 	0
package org . apache . camel . component . bean ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . ExchangePattern ; import org . apache . camel . impl . DefaultExchange ; public class BeanExchange extends DefaultExchange { public BeanExchange ( CamelContext context , ExchangePattern pattern ) { super ( context , pattern ) ; } public BeanInvocation getInvocation ( ) { return getIn ( ) . getBody ( BeanInvocation . class ) ; } public void setInvocation ( BeanInvocation invocation ) { getIn ( ) . setBody ( invocation ) ; } @ Override public Exchange newInstance ( ) { return new BeanExchange ( getContext ( ) , getPattern ( ) ) ; } } 	1
package org . apache . camel . impl . converter ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . TypeConverter ; import org . apache . camel . util . ObjectHelper ; import org . apache . camel . impl . CachingInjector ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; public class InstanceMethodTypeConverter implements TypeConverter { private final CachingInjector injector ; private final Method method ; public InstanceMethodTypeConverter ( CachingInjector injector , Method method ) { this . injector = injector ; this . method = method ; } @ Override public String toString ( ) { return "InstanceMethodTypeConverter: " + method ; } public synchronized < T > T convertTo ( Class < T > type , Object value ) { Object instance = injector . newInstance ( ) ; if ( instance == null ) { throw new RuntimeCamelException ( "Could not instantiate aninstance of: " + type . getName ( ) ) ; } return ( T ) ObjectHelper . invokeMethod ( method , instance , value ) ; } } 	0
package org . apache . camel . model ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . Predicate ; import org . apache . camel . builder . PredicateBuilder ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . processor . Interceptor ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import java . util . Collection ; @ XmlRootElement ( name = "intercept" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class InterceptType extends OutputType < ProcessorType > { @ Override public String toString ( ) { return "Intercept[" + getOutputs ( ) + "]" ; } public void addRoutes ( RouteContext routeContext , Collection < Route > routes ) throws Exception { Interceptor interceptor = new Interceptor ( ) ; routeContext . intercept ( interceptor ) ; final Processor interceptRoute = routeContext . createProcessor ( this ) ; interceptor . setInterceptorLogic ( interceptRoute ) ; } public OtherwiseType when ( Predicate predicate ) { return choice ( ) . when ( PredicateBuilder . not ( predicate ) ) . proceed ( ) . otherwise ( ) ; } } 	1
package org . apache . camel . spi ; import java . io . IOException ; import java . io . InputStream ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; public abstract class XmlUnmarshaller implements Unmarshaller { public Object unmarshal ( InputStream stream ) throws IOException { return unmarshal ( new StreamSource ( stream ) ) ; } abstract public Object unmarshal ( Source stream ) throws IOException ; } 	0
package org . apache . camel . model ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . impl . RouteContext ; import org . apache . camel . model . language . ExpressionType ; import org . apache . camel . processor . RecipientList ; @ XmlRootElement ( name = "recipientList" ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class RecipientListType extends ExpressionNode { public RecipientListType ( ) { } public RecipientListType ( ExpressionType expression ) { super ( expression ) ; } public RecipientListType ( Expression expression ) { super ( expression ) ; } @ Override public String toString ( ) { return "RecipientList[ " + getExpression ( ) + "]" ; } @ Override public Processor createProcessor ( RouteContext routeContext ) throws Exception { return new RecipientList ( getExpression ( ) . createExpression ( routeContext ) ) ; } } 	1
package org . apache . camel . builder . script ; import org . apache . camel . RuntimeCamelException ; public class ScriptEvaluationException extends RuntimeCamelException { public ScriptEvaluationException ( String message ) { super ( message ) ; } public ScriptEvaluationException ( String message , Throwable cause ) { super ( message , cause ) ; } public ScriptEvaluationException ( Throwable cause ) { super ( cause ) ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . spi . ExchangeConverter ; public class DefaultExchangeConverter implements ExchangeConverter { public < T > T convertTo ( Class < T > type , Exchange exchange ) { return null ; } } 	1
package org . apache . camel . spi ; import org . apache . camel . Component ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . impl . DefaultComponentResolver ; public interface ComponentResolver < E extends Exchange > { Component < E > resolveComponent ( String name , CamelContext context ) throws Exception ; } 	0
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; @ Converter public class NIOConverter { private NIOConverter ( ) { } @ Converter public static byte [ ] toByteArray ( ByteBuffer buffer ) { return buffer . array ( ) ; } @ Converter public static String toString ( ByteBuffer buffer ) { return IOConverter . toString ( buffer . array ( ) ) ; } @ Converter public static ByteBuffer toByteBuffer ( byte [ ] data ) { return ByteBuffer . wrap ( data ) ; } @ Converter public static ByteBuffer toByteBuffer ( File file ) throws IOException { byte [ ] buf = new byte [ ( int ) file . length ( ) ] ; InputStream in = new BufferedInputStream ( new FileInputStream ( file ) ) ; in . read ( buf ) ; return ByteBuffer . wrap ( buf ) ; } @ Converter public static ByteBuffer toByteBuffer ( String value ) { ByteBuffer buf = ByteBuffer . allocate ( value . length ( ) ) ; byte [ ] bytes = value . getBytes ( ) ; buf . put ( bytes ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Short value ) { ByteBuffer buf = ByteBuffer . allocate ( 2 ) ; buf . putShort ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Integer value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Long value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putLong ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Float value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putFloat ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Double value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putDouble ( value ) ; return buf ; } @ Converter public static InputStream toInputStream ( ByteBuffer bufferbuffer ) { return IOConverter . toInputStream ( toByteArray ( bufferbuffer ) ) ; } } 	1
package org . apache . camel . component . http ; import java . util . Map ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; public class HttpComponent extends DefaultComponent < HttpExchange > { private CamelServlet camelServlet ; public void connect ( HttpConsumer consumer ) throws Exception { camelServlet . connect ( consumer ) ; } public void disconnect ( HttpConsumer consumer ) throws Exception { camelServlet . disconnect ( consumer ) ; } public CamelServlet getCamelServlet ( ) { return camelServlet ; } public void setCamelServlet ( CamelServlet camelServlet ) { this . camelServlet = camelServlet ; } @ Override protected Endpoint < HttpExchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new HttpEndpoint ( uri , this ) ; } } 	0
package org . apache . camel . util ; import java . io . UnsupportedEncodingException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class URISupport { public static class CompositeData { public String host ; String scheme ; String path ; URI components [ ] ; Map parameters ; String fragment ; public URI [ ] getComponents ( ) { return components ; } public String getFragment ( ) { return fragment ; } public Map getParameters ( ) { return parameters ; } public String getScheme ( ) { return scheme ; } public String getPath ( ) { return path ; } public String getHost ( ) { return host ; } public URI toURI ( ) throws URISyntaxException { StringBuffer sb = new StringBuffer ( ) ; if ( scheme != null ) { sb . append ( scheme ) ; sb . append ( ':' ) ; } if ( host != null && host . length ( ) != 0 ) { sb . append ( host ) ; } else { sb . append ( '(' ) ; for ( int i = 0 ; i < components . length ; i ++ ) { if ( i != 0 ) { sb . append ( ',' ) ; } sb . append ( components [ i ] . toString ( ) ) ; } sb . append ( ')' ) ; } if ( path != null ) { sb . append ( '/' ) ; sb . append ( path ) ; } if ( ! parameters . isEmpty ( ) ) { sb . append ( "?" ) ; sb . append ( createQueryString ( parameters ) ) ; } if ( fragment != null ) { sb . append ( "#" ) ; sb . append ( fragment ) ; } return new URI ( sb . toString ( ) ) ; } } public static Map parseQuery ( String uri ) throws URISyntaxException { try { Map rc = new HashMap ( ) ; if ( uri != null ) { String [ ] parameters = uri . split ( "&" ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) { int p = parameters [ i ] . indexOf ( "=" ) ; if ( p >= 0 ) { String name = URLDecoder . decode ( parameters [ i ] . substring ( 0 , p ) , "UTF-8" ) ; String value = URLDecoder . decode ( parameters [ i ] . substring ( p + 1 ) , "UTF-8" ) ; rc . put ( name , value ) ; } else { rc . put ( parameters [ i ] , null ) ; } } } return rc ; } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static Map parseParamters ( URI uri ) throws URISyntaxException { String query = uri . getQuery ( ) ; if ( query == null ) { String schemeSpecificPart = uri . getSchemeSpecificPart ( ) ; int idx = schemeSpecificPart . lastIndexOf ( '?' ) ; if ( idx < 0 ) { return Collections . EMPTY_MAP ; } else { query = schemeSpecificPart . substring ( idx + 1 ) ; } } else { query = stripPrefix ( query , "?" ) ; } return parseQuery ( query ) ; } public static URI removeQuery ( URI uri ) throws URISyntaxException { return createURIWithQuery ( uri , null ) ; } public static URI createURIWithQuery ( URI uri , String query ) throws URISyntaxException { return new URI ( uri . getScheme ( ) , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) , query , uri . getFragment ( ) ) ; } public static CompositeData parseComposite ( URI uri ) throws URISyntaxException { CompositeData rc = new CompositeData ( ) ; rc . scheme = uri . getScheme ( ) ; String ssp = stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) . trim ( ) ; parseComposite ( uri , rc , ssp ) ; rc . fragment = uri . getFragment ( ) ; return rc ; } private static void parseComposite ( URI uri , CompositeData rc , String ssp ) throws URISyntaxException { String componentString ; String params ; if ( ! checkParenthesis ( ssp ) ) { throw new URISyntaxException ( uri . toString ( ) , "Not a matching number of '(' and ')' parenthesis" ) ; } int p ; int intialParen = ssp . indexOf ( "(" ) ; if ( intialParen == 0 ) { rc . host = ssp . substring ( 0 , intialParen ) ; p = rc . host . indexOf ( "/" ) ; if ( p >= 0 ) { rc . path = rc . host . substring ( p ) ; rc . host = rc . host . substring ( 0 , p ) ; } p = ssp . lastIndexOf ( ")" ) ; componentString = ssp . substring ( intialParen + 1 , p ) ; params = ssp . substring ( p + 1 ) . trim ( ) ; } else { componentString = ssp ; params = "" ; } String components [ ] = splitComponents ( componentString ) ; rc . components = new URI [ components . length ] ; for ( int i = 0 ; i < components . length ; i ++ ) { rc . components [ i ] = new URI ( components [ i ] . trim ( ) ) ; } p = params . indexOf ( "?" ) ; if ( p >= 0 ) { if ( p > 0 ) { rc . path = stripPrefix ( params . substring ( 0 , p ) , "/" ) ; } rc . parameters = parseQuery ( params . substring ( p + 1 ) ) ; } else { if ( params . length ( ) > 0 ) { rc . path = stripPrefix ( params , "/" ) ; } rc . parameters = Collections . EMPTY_MAP ; } } private static String [ ] splitComponents ( String str ) { ArrayList l = new ArrayList ( ) ; int last = 0 ; int depth = 0 ; char chars [ ] = str . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '(' : depth ++ ; break ; case ')' : depth -- ; break ; case ',' : if ( depth == 0 ) { String s = str . substring ( last , i ) ; l . add ( s ) ; last = i + 1 ; } break ; default : } } String s = str . substring ( last ) ; if ( s . length ( ) != 0 ) { l . add ( s ) ; } String rc [ ] = new String [ l . size ( ) ] ; l . toArray ( rc ) ; return rc ; } public static String stripPrefix ( String value , String prefix ) { if ( value . startsWith ( prefix ) ) { return value . substring ( prefix . length ( ) ) ; } return value ; } public static URI stripScheme ( URI uri ) throws URISyntaxException { return new URI ( stripPrefix ( uri . getSchemeSpecificPart ( ) . trim ( ) , "//" ) ) ; } public static String createQueryString ( Map options ) throws URISyntaxException { try { if ( options . size ( ) > 0 ) { StringBuffer rc = new StringBuffer ( ) ; boolean first = true ; for ( Iterator iter = options . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { if ( first ) { first = false ; } else { rc . append ( "&" ) ; } String key = ( String ) iter . next ( ) ; String value = ( String ) options . get ( key ) ; rc . append ( URLEncoder . encode ( key , "UTF-8" ) ) ; rc . append ( "=" ) ; rc . append ( URLEncoder . encode ( value , "UTF-8" ) ) ; } return rc . toString ( ) ; } else { return "" ; } } catch ( UnsupportedEncodingException e ) { throw ( URISyntaxException ) new URISyntaxException ( e . toString ( ) , "Invalid encoding" ) . initCause ( e ) ; } } public static URI createRemainingURI ( URI originalURI , Map params ) throws URISyntaxException { String s = createQueryString ( params ) ; if ( s . length ( ) == 0 ) { s = null ; } return createURIWithQuery ( originalURI , s ) ; } public static URI changeScheme ( URI bindAddr , String scheme ) throws URISyntaxException { return new URI ( scheme , bindAddr . getUserInfo ( ) , bindAddr . getHost ( ) , bindAddr . getPort ( ) , bindAddr . getPath ( ) , bindAddr . getQuery ( ) , bindAddr . getFragment ( ) ) ; } public static boolean checkParenthesis ( String str ) { boolean result = true ; if ( str != null ) { int open = 0 ; int closed = 0 ; int i = 0 ; while ( ( i = str . indexOf ( '(' , i ) ) >= 0 ) { i ++ ; open ++ ; } i = 0 ; while ( ( i = str . indexOf ( ')' , i ) ) >= 0 ) { i ++ ; closed ++ ; } result = open == closed ; } return result ; } public int indexOfParenthesisMatch ( String str ) { int result = - 1 ; return result ; } } 	1
package org . apache . camel . component . mail ; import org . springframework . mail . MailAuthenticationException ; import org . springframework . mail . MailException ; import org . springframework . mail . MailSendException ; import org . springframework . mail . javamail . JavaMailSenderImpl ; import javax . mail . AuthenticationFailedException ; import javax . mail . MessagingException ; import javax . mail . Transport ; import javax . mail . Folder ; import javax . mail . Store ; public class JavaMailConnection extends JavaMailSenderImpl { public Folder getFolder ( String protocol , String folderName ) { try { Store store = getSession ( ) . getStore ( protocol ) ; store . connect ( getHost ( ) , getPort ( ) , getUsername ( ) , getPassword ( ) ) ; return store . getFolder ( folderName ) ; } catch ( MessagingException e ) { throw new MailSendException ( "Mail server connection failed" , e ) ; } } } 	0
package org . apache . camel ; public class CamelException extends Exception { public CamelException ( ) { } public CamelException ( String message ) { super ( message ) ; } public CamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public CamelException ( Throwable cause ) { super ( cause ) ; } } 	1
package org . apache . camel . builder ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . processor . Pipeline ; import java . util . Collection ; public class PipelineBuilder extends FromBuilder { private final Collection < Endpoint > endpoints ; public PipelineBuilder ( FromBuilder parent , Collection < Endpoint > endpoints ) { super ( parent ) ; this . endpoints = endpoints ; } @ Override public Processor createProcessor ( ) throws Exception { return new Pipeline ( endpoints ) ; } } 	0
package org . apache . camel . impl ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import org . apache . camel . AsyncCallback ; import org . apache . camel . Exchange ; import org . apache . camel . spi . Synchronization ; import org . apache . camel . spi . UnitOfWork ; public class DefaultUnitOfWork implements UnitOfWork { private List < Synchronization > synchronizations ; private List < AsyncCallback > asyncCallbacks ; private CountDownLatch latch ; public DefaultUnitOfWork ( ) { } public synchronized void addSynchronization ( Synchronization synchronization ) { if ( synchronizations == null ) { synchronizations = new ArrayList < Synchronization > ( ) ; } synchronizations . add ( synchronization ) ; } public synchronized void removeSynchronization ( Synchronization synchronization ) { if ( synchronizations != null ) { synchronizations . remove ( synchronization ) ; } } public void reset ( ) { } public void done ( Exchange exchange ) { if ( synchronizations != null ) { boolean failed = exchange . isFailed ( ) ; for ( Synchronization synchronization : synchronizations ) { if ( failed ) { synchronization . onFailure ( exchange ) ; } else { synchronization . onComplete ( exchange ) ; } } } } public boolean isSynchronous ( ) { return asyncCallbacks == null || asyncCallbacks . isEmpty ( ) ; } } 	1
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . util . IntrospectionSupport ; import org . apache . camel . util . URISupport ; import org . apache . camel . util . ObjectHelper ; import java . net . URI ; import java . util . Map ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . ThreadFactory ; public abstract class DefaultComponent < E extends Exchange > extends ServiceSupport implements Component < E > { private int defaultThreadPoolSize = 5 ; private CamelContext camelContext ; private ScheduledExecutorService executorService ; public DefaultComponent ( ) { } public DefaultComponent ( CamelContext context ) { this . camelContext = context ; } public Endpoint < E > createEndpoint ( String uri ) throws Exception { ObjectHelper . notNull ( getCamelContext ( ) , "camelContext" ) ; URI u = new URI ( uri ) ; String path = u . getHost ( ) ; if ( path == null ) { path = u . getSchemeSpecificPart ( ) ; } Map parameters = URISupport . parseParamters ( u ) ; Endpoint < E > endpoint = createEndpoint ( uri , path , parameters ) ; if ( endpoint == null ) { return null ; } if ( parameters != null ) { if ( endpoint instanceof ScheduledPollEndpoint ) { ScheduledPollEndpoint scheduledPollEndpoint = ( ScheduledPollEndpoint ) endpoint ; scheduledPollEndpoint . configureProperties ( parameters ) ; } IntrospectionSupport . setProperties ( endpoint , parameters ) ; } return endpoint ; } public CamelContext getCamelContext ( ) { return camelContext ; } public void setCamelContext ( CamelContext context ) { this . camelContext = context ; } public ScheduledExecutorService getExecutorService ( ) { if ( executorService == null ) { executorService = createExecutorService ( ) ; } return executorService ; } public void setExecutorService ( ScheduledExecutorService executorService ) { this . executorService = executorService ; } protected ScheduledExecutorService createExecutorService ( ) { return new ScheduledThreadPoolExecutor ( defaultThreadPoolSize , new ThreadFactory ( ) { int counter ; public synchronized Thread newThread ( Runnable runnable ) { Thread thread = new Thread ( runnable ) ; thread . setName ( "Thread" + ( ++ counter ) + " " + DefaultComponent . this . toString ( ) ) ; return thread ; } } ) ; } protected void doStart ( ) throws Exception { } protected void doStop ( ) throws Exception { if ( executorService != null ) { executorService . shutdown ( ) ; } } abstract protected Endpoint < E > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception ; } 	0
package org . apache . camel . builder ; import org . apache . camel . Expression ; import org . apache . camel . Processor ; import org . apache . camel . processor . DeadLetterChannel ; import org . apache . camel . processor . Logger ; import org . apache . camel . processor . LoggingLevel ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . processor . RedeliveryPolicy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DeadLetterChannelBuilder extends ErrorHandlerBuilderSupport { private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy ( ) ; private ProcessorFactory deadLetterFactory ; private Processor defaultDeadLetterEndpoint ; private Expression defaultDeadLetterEndpointExpression ; private String defaultDeadLetterEndpointUri = "log:org.apache.camel.DeadLetterChannel?level=error" ; private Logger logger = DeadLetterChannel . createDefaultLogger ( ) ; public DeadLetterChannelBuilder ( ) { } public DeadLetterChannelBuilder ( Processor processor ) { this ( new ConstantProcessorBuilder ( processor ) ) ; } public DeadLetterChannelBuilder ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public ErrorHandlerBuilder copy ( ) { DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder ( deadLetterFactory ) ; answer . setRedeliveryPolicy ( getRedeliveryPolicy ( ) . copy ( ) ) ; return answer ; } public Processor createErrorHandler ( Processor processor ) throws Exception { Processor deadLetter = getDeadLetterFactory ( ) . createProcessor ( ) ; DeadLetterChannel answer = new DeadLetterChannel ( processor , deadLetter , getRedeliveryPolicy ( ) , getLogger ( ) ) ; configure ( answer ) ; return answer ; } public DeadLetterChannelBuilder backOffMultiplier ( double backOffMultiplier ) { getRedeliveryPolicy ( ) . backOffMultiplier ( backOffMultiplier ) ; return this ; } public DeadLetterChannelBuilder collisionAvoidancePercent ( short collisionAvoidancePercent ) { getRedeliveryPolicy ( ) . collisionAvoidancePercent ( collisionAvoidancePercent ) ; return this ; } public DeadLetterChannelBuilder initialRedeliveryDelay ( long initialRedeliveryDelay ) { getRedeliveryPolicy ( ) . initialRedeliveryDelay ( initialRedeliveryDelay ) ; return this ; } public DeadLetterChannelBuilder maximumRedeliveries ( int maximumRedeliveries ) { getRedeliveryPolicy ( ) . maximumRedeliveries ( maximumRedeliveries ) ; return this ; } public DeadLetterChannelBuilder useCollisionAvoidance ( ) { getRedeliveryPolicy ( ) . useCollisionAvoidance ( ) ; return this ; } public DeadLetterChannelBuilder useExponentialBackOff ( ) { getRedeliveryPolicy ( ) . useExponentialBackOff ( ) ; return this ; } public DeadLetterChannelBuilder logger ( Logger logger ) { setLogger ( logger ) ; return this ; } public DeadLetterChannelBuilder loggingLevel ( LoggingLevel level ) { getLogger ( ) . setLevel ( level ) ; return this ; } public DeadLetterChannelBuilder log ( Log log ) { getLogger ( ) . setLog ( log ) ; return this ; } public DeadLetterChannelBuilder log ( String log ) { return log ( LogFactory . getLog ( log ) ) ; } public DeadLetterChannelBuilder log ( Class log ) { return log ( LogFactory . getLog ( log ) ) ; } public RedeliveryPolicy getRedeliveryPolicy ( ) { return redeliveryPolicy ; } public void setRedeliveryPolicy ( RedeliveryPolicy redeliveryPolicy ) { this . redeliveryPolicy = redeliveryPolicy ; } public ProcessorFactory getDeadLetterFactory ( ) { if ( deadLetterFactory == null ) { deadLetterFactory = new ProcessorFactory ( ) { public Processor createProcessor ( ) { return getDefaultDeadLetterEndpoint ( ) ; } } ; } return deadLetterFactory ; } public void setDeadLetterFactory ( ProcessorFactory deadLetterFactory ) { this . deadLetterFactory = deadLetterFactory ; } public Processor getDefaultDeadLetterEndpoint ( ) { if ( defaultDeadLetterEndpoint == null ) { defaultDeadLetterEndpoint = new RecipientList ( getDefaultDeadLetterEndpointExpression ( ) ) ; } return defaultDeadLetterEndpoint ; } public void setDefaultDeadLetterEndpoint ( Processor defaultDeadLetterEndpoint ) { this . defaultDeadLetterEndpoint = defaultDeadLetterEndpoint ; } public Expression getDefaultDeadLetterEndpointExpression ( ) { if ( defaultDeadLetterEndpointExpression == null ) { defaultDeadLetterEndpointExpression = ExpressionBuilder . constantExpression ( getDefaultDeadLetterEndpointUri ( ) ) ; } return defaultDeadLetterEndpointExpression ; } public void setDefaultDeadLetterEndpointExpression ( Expression defaultDeadLetterEndpointExpression ) { this . defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression ; } public String getDefaultDeadLetterEndpointUri ( ) { return defaultDeadLetterEndpointUri ; } public void setDefaultDeadLetterEndpointUri ( String defaultDeadLetterEndpointUri ) { this . defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri ; } public Logger getLogger ( ) { return logger ; } public void setLogger ( Logger logger ) { this . logger = logger ; } } 	1
package org . apache . camel . bam ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . model . ProcessInstance ; import org . apache . camel . bam . rules . ActivityRules ; import org . apache . camel . bam . rules . TemporalRule ; import org . apache . camel . util . ObjectHelper ; import java . util . Date ; public abstract class TimeExpression { private ActivityRules activityRules ; private ActivityBuilder builder ; private ActivityLifecycle lifecycle ; public TimeExpression ( ActivityBuilder builder , ActivityLifecycle lifecycle ) { this . lifecycle = lifecycle ; this . builder = builder ; this . activityRules = builder . getActivityRules ( ) ; } public boolean isActivityLifecycle ( ActivityRules activityRules , ActivityLifecycle lifecycle ) { return ObjectHelper . equals ( activityRules , this . activityRules ) && ObjectHelper . equals ( lifecycle , this . lifecycle ) ; } public TemporalRule after ( TimeExpression expression ) { TemporalRule rule = new TemporalRule ( expression , this ) ; rule . getSecond ( ) . getActivityRules ( ) . addRule ( rule ) ; return rule ; } public Date evaluate ( ProcessInstance processInstance ) { ActivityState state = processInstance . getActivityState ( activityRules ) ; if ( state != null ) { return evaluate ( processInstance , state ) ; } return null ; } public abstract Date evaluate ( ProcessInstance instance , ActivityState state ) ; public ActivityBuilder getBuilder ( ) { return builder ; } public ActivityRules getActivityRules ( ) { return activityRules ; } public ActivityLifecycle getLifecycle ( ) { return lifecycle ; } public ActivityState getActivityState ( ProcessInstance instance ) { return instance . getActivityState ( activityRules ) ; } public ActivityState getOrCreateActivityState ( ProcessInstance instance ) { return instance . getOrCreateActivityState ( activityRules ) ; } } 	0
package org . apache . camel . spi ; import org . apache . camel . TypeConverter ; public interface TypeConverterAware { void setTypeConverter ( TypeConverter parentTypeConverter ) ; } 	1
