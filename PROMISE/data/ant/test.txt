package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; public class ToStringTypeConverter implements TypeConverter { public < T > T convertTo ( Class < T > toType , Object value ) { if ( value != null ) { if ( toType . equals ( String . class ) ) { return ( T ) value . toString ( ) ; } } return null ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ServiceSupport ; import java . util . ArrayList ; import java . util . Collection ; public class MulticastProcessor extends ServiceSupport implements Processor { private Collection < Producer > producers ; public static < E extends Exchange > Collection < Producer > toProducers ( Collection < Endpoint > endpoints ) throws Exception { Collection < Producer > answer = new ArrayList < Producer > ( ) ; for ( Endpoint endpoint : endpoints ) { answer . add ( endpoint . createProducer ( ) ) ; } return answer ; } public MulticastProcessor ( Collection < Endpoint > endpoints ) throws Exception { this . producers = toProducers ( endpoints ) ; } @ Override public String toString ( ) { return "Multicast" + getEndpoints ( ) ; } public void process ( Exchange exchange ) throws Exception { for ( Producer producer : producers ) { Exchange copy = copyExchangeStrategy ( producer , exchange ) ; producer . process ( copy ) ; } } protected void doStop ( ) throws Exception { for ( Producer producer : producers ) { producer . stop ( ) ; } } protected void doStart ( ) throws Exception { for ( Producer producer : producers ) { producer . start ( ) ; } } public Collection < Producer > getProducers ( ) { return producers ; } public Collection < Endpoint > getEndpoints ( ) { Collection < Endpoint > answer = new ArrayList < Endpoint > ( ) ; for ( Producer producer : producers ) { answer . add ( producer . getEndpoint ( ) ) ; } return answer ; } protected Exchange copyExchangeStrategy ( Producer producer , Exchange exchange ) { return producer . createExchange ( exchange ) ; } } 	0
package org . apache . camel . component . jms ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . impl . DefaultConsumer ; import org . springframework . jms . listener . AbstractMessageListenerContainer ; import javax . jms . MessageListener ; public class JmsConsumer extends DefaultConsumer < JmsExchange > { private final AbstractMessageListenerContainer listenerContainer ; public JmsConsumer ( JmsEndpoint endpoint , Processor processor , AbstractMessageListenerContainer listenerContainer ) { super ( endpoint , processor ) ; this . listenerContainer = listenerContainer ; MessageListener messageListener = createMessageListener ( endpoint , processor ) ; this . listenerContainer . setMessageListener ( messageListener ) ; } public AbstractMessageListenerContainer getListenerContainer ( ) { return listenerContainer ; } protected MessageListener createMessageListener ( JmsEndpoint endpoint , Processor processor ) { EndpointMessageListener < JmsExchange > messageListener = new EndpointMessageListener < JmsExchange > ( endpoint , processor ) ; messageListener . setBinding ( endpoint . getBinding ( ) ) ; return messageListener ; } @ Override protected void doStart ( ) throws Exception { super . doStart ( ) ; listenerContainer . afterPropertiesSet ( ) ; listenerContainer . start ( ) ; } @ Override protected void doStop ( ) throws Exception { listenerContainer . stop ( ) ; listenerContainer . destroy ( ) ; super . doStop ( ) ; } } 	0
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; public class DefaultCamelContext extends ServiceSupport implements CamelContext , Service { private Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; private Map < String , Component > components = new HashMap < String , Component > ( ) ; private List < Route > routes ; private List < Service > servicesToClose = new ArrayList < Service > ( ) ; private TypeConverter typeConverter ; private ExchangeConverter exchangeConverter ; private Injector injector ; private ComponentResolver componentResolver ; private boolean autoCreateComponents = true ; public void addComponent ( String componentName , final Component component ) { if ( component == null ) { throw new IllegalArgumentException ( "Component cannot be null" ) ; } synchronized ( components ) { if ( components . containsKey ( componentName ) ) { throw new IllegalArgumentException ( "Component previously added: " + componentName ) ; } component . setCamelContext ( this ) ; components . put ( componentName , component ) ; } } public Component getComponent ( String name ) { synchronized ( components ) { Component component = components . get ( name ) ; if ( component == null && autoCreateComponents ) { try { component = getComponentResolver ( ) . resolveComponent ( name , this ) ; if ( component != null ) { addComponent ( name , component ) ; if ( isStarted ( ) ) { startServices ( component ) ; } } } catch ( Exception e ) { throw new RuntimeCamelException ( "Could not auto create component: " + name , e ) ; } } return component ; } } public < T extends Component > T getComponent ( String name , Class < T > componentType ) { Component component = getComponent ( name ) ; if ( componentType . isInstance ( component ) ) { return componentType . cast ( component ) ; } else { throw new IllegalArgumentException ( "The component is not of type: " + componentType + " but is: " + component ) ; } } public Component removeComponent ( String componentName ) { synchronized ( components ) { return components . remove ( componentName ) ; } } public Component getOrCreateComponent ( String componentName , Callable < Component > factory ) { synchronized ( components ) { Component component = components . get ( componentName ) ; if ( component == null ) { try { component = factory . call ( ) ; if ( component == null ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component, it returned null." ) ; } components . put ( componentName , component ) ; component . setCamelContext ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component" , e ) ; } } return component ; } } public Collection < Endpoint > getSingletonEndpoints ( ) { synchronized ( endpoints ) { return new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } } public Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { startServices ( endpoint ) ; oldEndpoint = endpoints . remove ( uri ) ; endpoints . put ( uri , endpoint ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint removeSingletonEndpoint ( String uri ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { oldEndpoint = endpoints . remove ( uri ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint getEndpoint ( String uri ) { Endpoint answer ; synchronized ( endpoints ) { answer = endpoints . get ( uri ) ; if ( answer == null ) { try { String splitURI [ ] = ObjectHelper . splitOnCharacter ( uri , ":" , 2 ) ; if ( splitURI [ 1 ] == null ) { throw new IllegalArgumentException ( "Invalid URI, it did not contain a scheme: " + uri ) ; } String scheme = splitURI [ 0 ] ; Component component = getComponent ( scheme ) ; if ( component != null ) { answer = component . createEndpoint ( uri ) ; if ( answer != null && answer . isSingleton ( ) ) { if ( answer != null ) { startServices ( answer ) ; endpoints . put ( uri , answer ) ; } } } } catch ( Exception e ) { throw new ResolveEndpointFailedException ( uri , e ) ; } } } return answer ; } public < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) { Endpoint endpoint = getEndpoint ( name ) ; if ( endpointType . isInstance ( endpoint ) ) { return endpointType . cast ( endpoint ) ; } else { throw new IllegalArgumentException ( "The endpoint is not of type: " + endpointType + " but is: " + endpoint ) ; } } public List < Route > getRoutes ( ) { return routes ; } public void setRoutes ( List < Route > routes ) { this . routes = routes ; } public void addRoutes ( Collection < Route > routes ) throws Exception { if ( this . routes == null ) { this . routes = new ArrayList < Route > ( routes ) ; } else { this . routes . addAll ( routes ) ; } if ( isStarted ( ) ) { startRoutes ( routes ) ; } } public void addRoutes ( RouteBuilder builder ) throws Exception { builder . setContext ( this ) ; addRoutes ( builder . getRouteList ( ) ) ; } public ExchangeConverter getExchangeConverter ( ) { if ( exchangeConverter == null ) { exchangeConverter = createExchangeConverter ( ) ; } return exchangeConverter ; } public void setExchangeConverter ( ExchangeConverter exchangeConverter ) { this . exchangeConverter = exchangeConverter ; } public TypeConverter getTypeConverter ( ) { if ( typeConverter == null ) { typeConverter = createTypeConverter ( ) ; } return typeConverter ; } public void setTypeConverter ( TypeConverter typeConverter ) { this . typeConverter = typeConverter ; } public Injector getInjector ( ) { if ( injector == null ) { injector = createInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } public ComponentResolver getComponentResolver ( ) { if ( componentResolver == null ) { componentResolver = createComponentResolver ( ) ; } return componentResolver ; } public void setComponentResolver ( ComponentResolver componentResolver ) { this . componentResolver = componentResolver ; } protected void doStart ( ) throws Exception { if ( components != null ) { for ( Component component : components . values ( ) ) { startServices ( component ) ; } } startRoutes ( routes ) ; } protected void doStop ( ) throws Exception { stopServices ( servicesToClose ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { stopServices ( component ) ; } } } protected void startRoutes ( Collection < Route > routeList ) throws Exception { if ( routeList != null ) { for ( Route < Exchange > route : routeList ) { List < Service > services = route . getServicesForRoute ( ) ; servicesToClose . addAll ( services ) ; startServices ( services ) ; } } } protected ExchangeConverter createExchangeConverter ( ) { return new DefaultExchangeConverter ( ) ; } protected TypeConverter createTypeConverter ( ) { return new DefaultTypeConverter ( ) ; } protected Injector createInjector ( ) { FactoryFinder finder = new FactoryFinder ( ) ; try { return ( Injector ) finder . newInstance ( "Injector" ) ; } catch ( NoFactoryAvailableException e ) { return new ReflectionInjector ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } protected ComponentResolver createComponentResolver ( ) { return new DefaultComponentResolver ( ) ; } public boolean isAutoCreateComponents ( ) { return autoCreateComponents ; } public void setAutoCreateComponents ( boolean autoCreateComponents ) { this . autoCreateComponents = autoCreateComponents ; } } 	1
package org . apache . camel . spi ; public interface ExceptionHandler { void handleException ( Throwable exception ) ; } 	0
package org . apache . camel . component . mock ; import org . apache . camel . Exchange ; import org . apache . camel . Endpoint ; import org . apache . camel . impl . DefaultComponent ; import java . util . Map ; public class MockComponent extends DefaultComponent < Exchange > { @ Override protected Endpoint < Exchange > createEndpoint ( String uri , String remaining , Map parameters ) throws Exception { return new MockEndpoint ( uri , this ) ; } } 	0
package org . apache . camel . spring ; import org . apache . camel . CamelContext ; import org . apache . camel . builder . RouteBuilder ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . beans . factory . FactoryBean ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import java . util . ArrayList ; import java . util . List ; public class CamelContextFactoryBean implements FactoryBean , InitializingBean , DisposableBean , ApplicationContextAware { private CamelContext context ; private RouteBuilder routeBuilder ; private List < RouteBuilder > additionalBuilders = new ArrayList < RouteBuilder > ( ) ; private String [ ] packages = { } ; private ApplicationContext applicationContext ; public Object getObject ( ) throws Exception { return getContext ( ) ; } public Class getObjectType ( ) { return SpringCamelContext . class ; } public boolean isSingleton ( ) { return true ; } public void afterPropertiesSet ( ) throws Exception { getContext ( ) ; findRouteBuiders ( ) ; installRoutes ( ) ; getContext ( ) . start ( ) ; } public void destroy ( ) throws Exception { getContext ( ) . stop ( ) ; } public CamelContext getContext ( ) throws Exception { if ( context == null ) { context = new SpringCamelContext ( getApplicationContext ( ) ) ; } return context ; } public void setContext ( CamelContext context ) { this . context = context ; } public RouteBuilder getRouteBuilder ( ) { return routeBuilder ; } public void setRouteBuilder ( RouteBuilder routeBuilder ) { this . routeBuilder = routeBuilder ; } public void setRouteBuilders ( RouteBuilder [ ] builders ) { for ( RouteBuilder builder : builders ) { additionalBuilders . add ( builder ) ; } } public ApplicationContext getApplicationContext ( ) { return applicationContext ; } public void setApplicationContext ( ApplicationContext applicationContext ) { this . applicationContext = applicationContext ; } public String [ ] getPackages ( ) { return packages ; } public void setPackages ( String [ ] packages ) { this . packages = packages ; } protected void installRoutes ( ) throws Exception { for ( RouteBuilder routeBuilder : additionalBuilders ) { getContext ( ) . addRoutes ( routeBuilder ) ; } if ( routeBuilder != null ) { getContext ( ) . addRoutes ( routeBuilder ) ; } } protected void findRouteBuiders ( ) throws IllegalAccessException , InstantiationException { if ( packages != null && packages . length > 0 ) { RouteBuilderFinder finder = new RouteBuilderFinder ( this ) ; finder . appendBuilders ( additionalBuilders ) ; } } } 	0
package org . apache . camel . component . cxf . transport ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . cxf . Bus ; import org . apache . cxf . common . logging . LogUtils ; import org . apache . cxf . configuration . Configurable ; import org . apache . cxf . io . AbstractCachedOutputStream ; import org . apache . cxf . message . Message ; import org . apache . cxf . message . MessageImpl ; import org . apache . cxf . service . model . EndpointInfo ; import org . apache . cxf . transport . AbstractConduit ; import org . apache . cxf . transport . AbstractDestination ; import org . apache . cxf . transport . Conduit ; import org . apache . cxf . transport . ConduitInitiator ; import org . apache . cxf . transport . MessageObserver ; import org . apache . cxf . ws . addressing . EndpointReferenceType ; import org . apache . cxf . wsdl . EndpointReferenceUtils ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . logging . Level ; import java . util . logging . Logger ; public class CamelDestination extends AbstractDestination implements Configurable { protected static final String BASE_BEAN_NAME_SUFFIX = ".camel-destination-base" ; private static final Logger LOG = LogUtils . getL7dLogger ( CamelDestination . class ) ; CamelContext camelContext ; String camelUri ; final ConduitInitiator conduitInitiator ; private CamelTransportBase base ; private Endpoint endpoint ; public CamelDestination ( CamelContext camelContext , Bus bus , ConduitInitiator ci , EndpointInfo info ) throws IOException { super ( getTargetReference ( info , bus ) , info ) ; this . camelContext = camelContext ; base = new CamelTransportBase ( camelContext , bus , endpointInfo , true , BASE_BEAN_NAME_SUFFIX ) ; conduitInitiator = ci ; initConfig ( ) ; } protected Logger getLogger ( ) { return LOG ; } protected Conduit getInbuiltBackChannel ( Message inMessage ) { return new BackChannelConduit ( EndpointReferenceUtils . getAnonymousEndpointReference ( ) , inMessage ) ; } public void activate ( ) { getLogger ( ) . log ( Level . INFO , "CamelDestination activate().... " ) ; try { getLogger ( ) . log ( Level . FINE , "establishing Camel connection" ) ; endpoint = camelContext . getEndpoint ( camelUri ) ; } catch ( Exception ex ) { getLogger ( ) . log ( Level . SEVERE , "Camel connect failed with EException : " , ex ) ; } } public void deactivate ( ) { base . close ( ) ; } public void shutdown ( ) { getLogger ( ) . log ( Level . FINE , "CamelDestination shutdown()" ) ; this . deactivate ( ) ; } protected void incoming ( Exchange exchange ) { getLogger ( ) . log ( Level . FINE , "server received request: " , exchange ) ; byte [ ] bytes = base . unmarshal ( exchange ) ; MessageImpl inMessage = new MessageImpl ( ) ; inMessage . setContent ( InputStream . class , new ByteArrayInputStream ( bytes ) ) ; base . populateIncomingContext ( exchange , inMessage , CamelConstants . CAMEL_SERVER_REQUEST_HEADERS ) ; inMessage . put ( CamelConstants . CAMEL_REQUEST_MESSAGE , exchange ) ; inMessage . setDestination ( this ) ; incomingObserver . onMessage ( inMessage ) ; } public String getBeanName ( ) { return endpointInfo . getName ( ) . toString ( ) + ".camel-destination" ; } private void initConfig ( ) { } protected class ConsumerProcessor implements Processor { public void process ( Exchange exchange ) { try { incoming ( exchange ) ; } catch ( Throwable ex ) { getLogger ( ) . log ( Level . WARNING , "Failed to process incoming message : " , ex ) ; } } } protected class BackChannelConduit extends AbstractConduit { protected Message inMessage ; BackChannelConduit ( EndpointReferenceType ref , Message message ) { super ( ref ) ; inMessage = message ; } public void setMessageObserver ( MessageObserver observer ) { } public void prepare ( Message message ) throws IOException { message . put ( CamelConstants . CAMEL_REQUEST_MESSAGE , inMessage . get ( CamelConstants . CAMEL_REQUEST_MESSAGE ) ) ; message . setContent ( OutputStream . class , new CamelOutputStream ( inMessage ) ) ; } protected Logger getLogger ( ) { return LOG ; } } private class CamelOutputStream extends AbstractCachedOutputStream { private Message inMessage ; private Producer < Exchange > replyTo ; private Producer < Exchange > sender ; public CamelOutputStream ( Message m ) { super ( ) ; inMessage = m ; } private void commitOutputMessage ( ) throws IOException { final String replyToUri = getReplyToDestination ( inMessage ) ; base . template . send ( replyToUri , new Processor ( ) { public void process ( Exchange reply ) { base . marshal ( currentStream . toString ( ) , replyToUri , reply ) ; setReplyCorrelationID ( inMessage , reply ) ; base . setMessageProperties ( inMessage , reply ) ; getLogger ( ) . log ( Level . FINE , "just server sending reply: " , reply ) ; } } ) ; } @ Override protected void doFlush ( ) throws IOException { } @ Override protected void doClose ( ) throws IOException { commitOutputMessage ( ) ; } @ Override protected void onWrite ( ) throws IOException { } } protected String getReplyToDestination ( Message inMessage ) { if ( inMessage . get ( CamelConstants . CAMEL_REBASED_REPLY_TO ) != null ) { return ( String ) inMessage . get ( CamelConstants . CAMEL_REBASED_REPLY_TO ) ; } else { return base . getReplyDestination ( ) ; } } protected void setReplyCorrelationID ( Message inMessage , Exchange reply ) { Object value = inMessage . get ( CamelConstants . CAMEL_CORRELATION_ID ) ; if ( value != null ) { reply . getIn ( ) . setHeader ( CamelConstants . CAMEL_CORRELATION_ID , value ) ; } } } 	0
package org . apache . camel . component . xmpp ; import org . apache . camel . impl . DefaultExchange ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . jivesoftware . smack . packet . Message ; public class XmppExchange extends DefaultExchange { private XmppBinding binding ; public XmppExchange ( CamelContext context , XmppBinding binding ) { super ( context ) ; this . binding = binding ; } public XmppExchange ( CamelContext context , XmppBinding binding , Message message ) { this ( context , binding ) ; setIn ( new XmppMessage ( message ) ) ; } @ Override public XmppMessage getIn ( ) { return ( XmppMessage ) super . getIn ( ) ; } @ Override public XmppMessage getOut ( ) { return ( XmppMessage ) super . getOut ( ) ; } @ Override public XmppMessage getOut ( boolean lazyCreate ) { return ( XmppMessage ) super . getOut ( lazyCreate ) ; } @ Override public XmppMessage getFault ( ) { return ( XmppMessage ) super . getFault ( ) ; } public XmppBinding getBinding ( ) { return binding ; } @ Override public Exchange newInstance ( ) { return new XmppExchange ( getContext ( ) , binding ) ; } public Message getInMessage ( ) { return getIn ( ) . getXmppMessage ( ) ; } public Message getOutMessage ( ) { return getOut ( ) . getXmppMessage ( ) ; } public Message getFaultMessage ( ) { return getOut ( ) . getXmppMessage ( ) ; } @ Override protected XmppMessage createInMessage ( ) { return new XmppMessage ( ) ; } @ Override protected XmppMessage createOutMessage ( ) { return new XmppMessage ( ) ; } } 	0
package org . apache . camel . component . http ; import java . util . HashMap ; import org . mortbay . jetty . Connector ; import org . mortbay . jetty . Server ; import org . mortbay . jetty . nio . SelectChannelConnector ; import org . mortbay . jetty . security . SslSocketConnector ; import org . mortbay . jetty . servlet . Context ; import org . mortbay . jetty . servlet . ServletHolder ; public class JettyHttpComponent extends HttpComponent { Server server ; class ConnectorRef { Connector connector ; int refCount = 0 ; public ConnectorRef ( Connector connector ) { this . connector = connector ; increment ( ) ; } public int increment ( ) { return ++ refCount ; } public int decrement ( ) { return -- refCount ; } } final HashMap < String , ConnectorRef > connectors = new HashMap < String , ConnectorRef > ( ) ; @ Override protected void doStart ( ) throws Exception { server = createServer ( ) ; super . doStart ( ) ; } private Server createServer ( ) throws Exception { setCamelServlet ( new CamelServlet ( ) ) ; Server server = new Server ( ) ; Context context = new Context ( Context . NO_SECURITY | Context . NO_SESSIONS ) ; context . setContextPath ( "/" ) ; ServletHolder holder = new ServletHolder ( ) ; holder . setServlet ( getCamelServlet ( ) ) ; context . addServlet ( holder , "/*" ) ; server . setHandler ( context ) ; server . start ( ) ; return server ; } @ Override protected void doStop ( ) throws Exception { for ( ConnectorRef connectorRef : connectors . values ( ) ) { connectorRef . connector . stop ( ) ; } connectors . clear ( ) ; server . stop ( ) ; super . doStop ( ) ; } @ Override public void connect ( HttpConsumer consumer ) throws Exception { HttpEndpoint endpoint = ( HttpEndpoint ) consumer . getEndpoint ( ) ; String connectorKey = endpoint . getProtocol ( ) + ":" + endpoint . getPort ( ) ; synchronized ( connectors ) { ConnectorRef connectorRef = connectors . get ( connectorKey ) ; if ( connectorRef == null ) { Connector connector ; if ( "https" . equals ( endpoint . getProtocol ( ) ) ) { connector = new SslSocketConnector ( ) ; } else { connector = new SelectChannelConnector ( ) ; } connector . setPort ( endpoint . getPort ( ) ) ; server . addConnector ( connector ) ; connector . start ( ) ; connectorRef = new ConnectorRef ( connector ) ; } else { connectorRef . increment ( ) ; } } super . connect ( consumer ) ; } @ Override public void disconnect ( HttpConsumer consumer ) throws Exception { super . disconnect ( consumer ) ; HttpEndpoint endpoint = ( HttpEndpoint ) consumer . getEndpoint ( ) ; String connectorKey = endpoint . getProtocol ( ) + ":" + endpoint . getPort ( ) ; synchronized ( connectors ) { ConnectorRef connectorRef = connectors . get ( connectorKey ) ; if ( connectorRef != null ) { if ( connectorRef . decrement ( ) == 0 ) { server . removeConnector ( connectorRef . connector ) ; connectorRef . connector . stop ( ) ; connectors . remove ( connectorKey ) ; } } } } } 	0
package org . apache . camel ; public class CamelException extends Exception { public CamelException ( ) { } public CamelException ( String message ) { super ( message ) ; } public CamelException ( String message , Throwable cause ) { super ( message , cause ) ; } public CamelException ( Throwable cause ) { super ( cause ) ; } } 	0
package org . apache . camel . processor . loadbalancer ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import java . util . List ; public class RoundRobinLoadBalancer extends QueueLoadBalancer { private int counter = - 1 ; protected synchronized Processor chooseProcessor ( List < Processor > processors , Exchange exchange ) { int size = processors . size ( ) ; if ( ++ counter >= size ) { counter = 0 ; } return processors . get ( counter ) ; } } 	0
package org . apache . camel . bam . model ; import javax . persistence . CascadeType ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . Id ; import javax . persistence . ManyToOne ; @ Entity public class ActivityDefinition extends EntitySupport { private String name ; private ProcessDefinition processDefinition ; @ Override @ Id @ GeneratedValue public Long getId ( ) { return super . getId ( ) ; } @ Override public String toString ( ) { return "Activity[" + getId ( ) + " name: " + getName ( ) + "]" ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } @ ManyToOne ( fetch = FetchType . LAZY , cascade = { CascadeType . PERSIST } ) public ProcessDefinition getProcessDefinition ( ) { return processDefinition ; } public void setProcessDefinition ( ProcessDefinition processDefinition ) { this . processDefinition = processDefinition ; } } 	0
package org . apache . camel . component . http ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; public class HttpBinding { public void writeResponse ( HttpExchange exchange ) { } public Object parseBody ( HttpMessage httpMessage ) throws IOException { HttpServletRequest request = httpMessage . getRequest ( ) ; return request . getReader ( ) ; } } 	0
package org . apache . camel . processor ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . Service ; import org . apache . camel . impl . ServiceSupport ; public class SendProcessor extends ServiceSupport implements Processor , Service { private Endpoint destination ; private Producer producer ; public SendProcessor ( Endpoint destination ) { this . destination = destination ; } protected void doStop ( ) throws Exception { if ( producer != null ) { try { producer . stop ( ) ; } finally { producer = null ; } } } protected void doStart ( ) throws Exception { this . producer = destination . createProducer ( ) ; } public void process ( Exchange exchange ) throws Exception { if ( producer == null ) { throw new IllegalStateException ( "No producer, this processor has not been started!" ) ; } producer . process ( exchange ) ; } public Endpoint getDestination ( ) { return destination ; } @ Override public String toString ( ) { return "sendTo(" + destination + ")" ; } } 	0
package org . apache . camel . component . http ; import java . net . URI ; import java . net . URISyntaxException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . impl . DefaultEndpoint ; public class HttpEndpoint extends DefaultEndpoint < HttpExchange > { private HttpBinding binding ; private HttpComponent component ; private URI httpUri ; protected HttpEndpoint ( String uri , HttpComponent component ) throws URISyntaxException { super ( uri , component ) ; this . component = component ; this . httpUri = new URI ( uri ) ; } public HttpProducer createProducer ( ) throws Exception { return new HttpProducer ( this ) ; } public Consumer < HttpExchange > createConsumer ( Processor processor ) throws Exception { return new HttpConsumer ( this , processor ) ; } public HttpExchange createExchange ( ) { return new HttpExchange ( this ) ; } public HttpExchange createExchange ( HttpServletRequest request , HttpServletResponse response ) { return new HttpExchange ( this , request , response ) ; } public HttpBinding getBinding ( ) { if ( binding == null ) { binding = new HttpBinding ( ) ; } return binding ; } public void setBinding ( HttpBinding binding ) { this . binding = binding ; } public boolean isSingleton ( ) { return true ; } public void connect ( HttpConsumer consumer ) throws Exception { component . connect ( consumer ) ; } public void disconnect ( HttpConsumer consumer ) throws Exception { component . disconnect ( consumer ) ; } public String getPath ( ) { return httpUri . getPath ( ) ; } public int getPort ( ) { if ( httpUri . getPort ( ) == - 1 ) { if ( "https" . equals ( getProtocol ( ) ) ) { return 443 ; } else { return 80 ; } } return httpUri . getPort ( ) ; } public String getProtocol ( ) { return httpUri . getScheme ( ) ; } } 	0
package org . apache . camel . processor ; public enum LoggingLevel { DEBUG , ERROR , FATAL , INFO , TRACE , WARN ; } 	0
package org . apache . camel . component . quartz ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultEndpoint ; import org . apache . camel . processor . loadbalancer . LoadBalancer ; import org . apache . camel . processor . loadbalancer . RoundRobinLoadBalancer ; import org . apache . camel . util . ObjectHelper ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . quartz . JobDetail ; import org . quartz . JobExecutionContext ; import org . quartz . JobExecutionException ; import org . quartz . Scheduler ; import org . quartz . SchedulerException ; import org . quartz . Trigger ; import org . quartz . SimpleTrigger ; import java . util . Date ; import java . util . Map ; import java . util . Set ; public class QuartzEndpoint extends DefaultEndpoint < QuartzExchange > { public static final String ENDPOINT_KEY = "org.apache.camel.quartz" ; private static final transient Log log = LogFactory . getLog ( QuartzEndpoint . class ) ; private Scheduler scheduler ; private LoadBalancer loadBalancer ; private Trigger trigger ; private JobDetail jobDetail ; private boolean started ; public QuartzEndpoint ( String endpointUri , QuartzComponent component , Scheduler scheduler ) { super ( endpointUri , component ) ; this . scheduler = scheduler ; } public void addTriggers ( Map < Trigger , JobDetail > triggerMap ) throws SchedulerException { if ( triggerMap != null ) { Set < Map . Entry < Trigger , JobDetail > > entries = triggerMap . entrySet ( ) ; for ( Map . Entry < Trigger , JobDetail > entry : entries ) { Trigger key = entry . getKey ( ) ; JobDetail value = entry . getValue ( ) ; ObjectHelper . notNull ( key , "key" ) ; ObjectHelper . notNull ( value , "value" ) ; addTrigger ( key , value ) ; } } } public void addTrigger ( Trigger trigger , JobDetail detail ) throws SchedulerException { if ( trigger . getName ( ) == null ) { trigger . setName ( detail . getName ( ) ) ; } if ( trigger . getGroup ( ) == null ) { trigger . setGroup ( detail . getGroup ( ) ) ; } if ( trigger . getStartTime ( ) == null ) { trigger . setStartTime ( new Date ( ) ) ; } detail . getJobDataMap ( ) . put ( ENDPOINT_KEY , this ) ; Class jobClass = detail . getJobClass ( ) ; if ( jobClass == null ) { detail . setJobClass ( CamelJob . class ) ; } if ( detail . getName ( ) == null ) { detail . setName ( getEndpointUri ( ) ) ; } getScheduler ( ) . scheduleJob ( detail , trigger ) ; } public void removeTrigger ( Trigger trigger , JobDetail jobDetail ) throws SchedulerException { getScheduler ( ) . unscheduleJob ( trigger . getName ( ) , trigger . getGroup ( ) ) ; } public void onJobExecute ( JobExecutionContext jobExecutionContext ) throws JobExecutionException { if ( log . isDebugEnabled ( ) ) { log . debug ( "Firing Quartz Job with context: " + jobExecutionContext ) ; } QuartzExchange exchange = createExchange ( jobExecutionContext ) ; try { getLoadBalancer ( ) . process ( exchange ) ; } catch ( JobExecutionException e ) { throw e ; } catch ( Exception e ) { throw new JobExecutionException ( e ) ; } } public QuartzExchange createExchange ( ) { return new QuartzExchange ( getContext ( ) , null ) ; } public QuartzExchange createExchange ( JobExecutionContext jobExecutionContext ) { return new QuartzExchange ( getContext ( ) , jobExecutionContext ) ; } public Producer < QuartzExchange > createProducer ( ) throws Exception { throw new UnsupportedOperationException ( "You cannot send messages to this endpoint" ) ; } public QuartzConsumer createConsumer ( Processor processor ) throws Exception { return new QuartzConsumer ( this , processor ) ; } @ Override public QuartzComponent getComponent ( ) { return ( QuartzComponent ) super . getComponent ( ) ; } public boolean isSingleton ( ) { return true ; } public Scheduler getScheduler ( ) { return scheduler ; } public LoadBalancer getLoadBalancer ( ) { if ( loadBalancer == null ) { loadBalancer = createLoadBalancer ( ) ; } return loadBalancer ; } public void setLoadBalancer ( LoadBalancer loadBalancer ) { this . loadBalancer = loadBalancer ; } public JobDetail getJobDetail ( ) { if ( jobDetail == null ) { jobDetail = createJobDetail ( ) ; } return jobDetail ; } public void setJobDetail ( JobDetail jobDetail ) { this . jobDetail = jobDetail ; } public Trigger getTrigger ( ) { if ( trigger == null ) { trigger = createTrigger ( ) ; } return trigger ; } public void setTrigger ( Trigger trigger ) { this . trigger = trigger ; } public synchronized void consumerStarted ( QuartzConsumer consumer ) throws SchedulerException { getLoadBalancer ( ) . addProcessor ( consumer . getProcessor ( ) ) ; if ( ! started ) { addTrigger ( getTrigger ( ) , getJobDetail ( ) ) ; started = true ; } } public synchronized void consumerStopped ( QuartzConsumer consumer ) throws SchedulerException { getLoadBalancer ( ) . removeProcessor ( consumer . getProcessor ( ) ) ; if ( getLoadBalancer ( ) . getProcessors ( ) . isEmpty ( ) && started ) { removeTrigger ( getTrigger ( ) , getJobDetail ( ) ) ; started = false ; } } protected LoadBalancer createLoadBalancer ( ) { return new RoundRobinLoadBalancer ( ) ; } protected JobDetail createJobDetail ( ) { return new JobDetail ( ) ; } protected Trigger createTrigger ( ) { return new SimpleTrigger ( ) ; } } 	0
package org . apache . camel . util ; import java . util . LinkedHashMap ; import java . util . Map ; public class LRUCache < K , V > extends LinkedHashMap < K , V > { private static final long serialVersionUID = - 342098639681884413L ; private int maxCacheSize = 10000 ; public LRUCache ( int maximumCacheSize ) { this ( maximumCacheSize , maximumCacheSize , 0.75f , true ) ; } public LRUCache ( int initialCapacity , int maximumCacheSize , float loadFactor , boolean accessOrder ) { super ( initialCapacity , loadFactor , accessOrder ) ; this . maxCacheSize = maximumCacheSize ; } public int getMaxCacheSize ( ) { return maxCacheSize ; } protected boolean removeEldestEntry ( Map . Entry entry ) { return size ( ) > maxCacheSize ; } } 	0
package org . apache . camel ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . annotation . ElementType ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD , ElementType . METHOD , ElementType . CONSTRUCTOR } ) public @ interface EndpointInject { String uri ( ) default "" ; String name ( ) default "" ; } 	0
package org . apache . camel . builder ; import static org . apache . camel . util . ObjectHelper . compare ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . impl . PredicateSupport ; import org . apache . camel . impl . BinaryPredicateSupport ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class PredicateBuilder { public static < E extends Exchange > Predicate < E > and ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) && right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") and (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > or ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) || right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") or (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > isEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isNotEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ! ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return "<" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) <= 0 ; } protected String getOperationText ( ) { return "<=" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) > 0 ; } protected String getOperationText ( ) { return ">" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return ">=" ; } } ; } public static < E extends Exchange > Predicate < E > contains ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . contains ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "contains" ; } } ; } public static < E extends Exchange > Predicate < E > isNull ( final Expression < E > expression ) { return isEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isNotNull ( final Expression < E > expression ) { return isNotEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isInstanceOf ( final Expression < E > expression , final Class type ) { notNull ( expression , "expression" ) ; notNull ( type , "type" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return type . isInstance ( value ) ; } @ Override public String toString ( ) { return expression + " instanceof " + type . getName ( ) ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final String regex ) { return regex ( expression , Pattern . compile ( regex ) ) ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final Pattern pattern ) { notNull ( expression , "expression" ) ; notNull ( pattern , "pattern" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; if ( value != null ) { Matcher matcher = pattern . matcher ( value . toString ( ) ) ; return matcher . matches ( ) ; } return false ; } @ Override public String toString ( ) { return expression + ".matches(" + pattern + ")" ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } } 	1
package org . apache . camel . impl . converter ; import org . apache . camel . TypeConverter ; import org . apache . camel . spi . Injector ; public interface TypeConverterRegistry { void addTypeConverter ( Class toType , Class fromType , TypeConverter typeConverter ) ; Injector getInjector ( ) ; } 	0
package org . apache . camel . spring . xml ; import java . util . ArrayList ; import org . springframework . beans . factory . BeanFactory ; public class BuilderStatement { private ArrayList < BuilderAction > actions ; private Class returnType ; public Object create ( BeanFactory beanFactory , Object rootBuilder ) { Object currentBuilder = rootBuilder ; BuilderAction lastAction = null ; for ( BuilderAction action : actions ) { if ( currentBuilder == null ) { throw new IllegalArgumentException ( "Invalid configuration.  The '" + lastAction . getName ( ) + "' action cannot be followed by the '" + action . getName ( ) + "' action." ) ; } currentBuilder = action . invoke ( beanFactory , rootBuilder , currentBuilder ) ; lastAction = action ; } return currentBuilder ; } public ArrayList < BuilderAction > getActions ( ) { return actions ; } public void setActions ( ArrayList < BuilderAction > actions ) { this . actions = actions ; } public Class getReturnType ( ) { return returnType ; } public void setReturnType ( Class returnType ) { this . returnType = returnType ; } } 	0
package org . apache . camel . spi ; import org . apache . camel . Exchange ; public interface ExchangeConverter { < T > T convertTo ( Class < T > type , Exchange exchange ) ; } 	0
package org . apache . camel . component . jms ; import javax . jms . JMSException ; public class MessagePropertyNamesAccessException extends RuntimeJmsException { private static final long serialVersionUID = - 6744171518099741324L ; public MessagePropertyNamesAccessException ( JMSException e ) { super ( "Failed to acess the JMS message property names" , e ) ; } } 	0
package org . apache . camel . component . rmi ; import java . rmi . AccessException ; import java . rmi . NotBoundException ; import java . rmi . Remote ; import java . rmi . RemoteException ; import java . rmi . registry . Registry ; import org . apache . camel . component . pojo . PojoEndpoint ; import org . apache . camel . component . pojo . PojoExchange ; import org . apache . camel . impl . DefaultProducer ; import org . apache . camel . Exchange ; public class RmiProducer extends DefaultProducer { private final RmiEndpoint endpoint ; private Remote remote ; public RmiProducer ( RmiEndpoint endpoint ) throws AccessException , RemoteException , NotBoundException { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) throws AccessException , RemoteException , NotBoundException { PojoExchange pojoExchange = endpoint . toExchangeType ( exchange ) ; PojoEndpoint . invoke ( getRemote ( ) , pojoExchange ) ; exchange . copyFrom ( pojoExchange ) ; } public Remote getRemote ( ) throws AccessException , RemoteException , NotBoundException { if ( remote == null ) { Registry registry = endpoint . getRegistry ( ) ; remote = registry . lookup ( endpoint . getName ( ) ) ; } return remote ; } } 	0
package org . apache . camel . builder ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . Processor ; import org . apache . camel . Route ; import org . apache . camel . impl . EventDrivenConsumerRoute ; import org . apache . camel . processor . CompositeProcessor ; import org . apache . camel . processor . DelegateProcessor ; import org . apache . camel . processor . MulticastProcessor ; import org . apache . camel . processor . Pipeline ; import org . apache . camel . processor . RecipientList ; import org . apache . camel . processor . idempotent . IdempotentConsumer ; import org . apache . camel . processor . idempotent . MessageIdRepository ; import org . apache . camel . spi . Policy ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; public class FromBuilder extends BuilderSupport implements ProcessorFactory { public static final String DEFAULT_TRACE_CATEGORY = "org.apache.camel.TRACE" ; private RouteBuilder builder ; private Endpoint from ; private List < Processor > processors = new ArrayList < Processor > ( ) ; private List < ProcessorFactory > processFactories = new ArrayList < ProcessorFactory > ( ) ; private FromBuilder routeBuilder ; public FromBuilder ( RouteBuilder builder , Endpoint from ) { super ( builder ) ; this . builder = builder ; this . from = from ; } public FromBuilder ( FromBuilder parent ) { super ( parent ) ; this . builder = parent . getBuilder ( ) ; this . from = parent . getFrom ( ) ; } @ Fluent public ProcessorFactory to ( @ FluentArg ( "uri" ) String uri ) { return to ( endpoint ( uri ) ) ; } @ Fluent public ProcessorFactory to ( @ FluentArg ( "ref" ) Endpoint endpoint ) { ToBuilder answer = new ToBuilder ( this , endpoint ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent public ProcessorFactory to ( String ... uris ) { return to ( endpoints ( uris ) ) ; } @ Fluent public ProcessorFactory to ( @ FluentArg ( value = "endpoint" , attribute = false , element = true ) Endpoint ... endpoints ) { return to ( endpoints ( endpoints ) ) ; } @ Fluent public ProcessorFactory to ( @ FluentArg ( value = "endpoint" , attribute = false , element = true ) Collection < Endpoint > endpoints ) { return addProcessBuilder ( new MulticastBuilder ( this , endpoints ) ) ; } @ Fluent public ProcessorFactory pipeline ( @ FluentArg ( "uris" ) String ... uris ) { return pipeline ( endpoints ( uris ) ) ; } @ Fluent public ProcessorFactory pipeline ( @ FluentArg ( "endpoints" ) Endpoint ... endpoints ) { return pipeline ( endpoints ( endpoints ) ) ; } @ Fluent public ProcessorFactory pipeline ( @ FluentArg ( "endpoints" ) Collection < Endpoint > endpoints ) { return addProcessBuilder ( new PipelineBuilder ( this , endpoints ) ) ; } @ Fluent public IdempotentConsumerBuilder idempotentConsumer ( @ FluentArg ( "messageIdExpression" ) Expression messageIdExpression , @ FluentArg ( "MessageIdRepository" ) MessageIdRepository messageIdRepository ) { return ( IdempotentConsumerBuilder ) addProcessBuilder ( new IdempotentConsumerBuilder ( this , messageIdExpression , messageIdRepository ) ) ; } @ Fluent public FilterBuilder filter ( @ FluentArg ( value = "predicate" , element = true ) Predicate predicate ) { FilterBuilder answer = new FilterBuilder ( this , predicate ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent ( nestedActions = true ) public ChoiceBuilder choice ( ) { ChoiceBuilder answer = new ChoiceBuilder ( this ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent public RecipientListBuilder recipientList ( @ FluentArg ( value = "recipients" , element = true ) Expression receipients ) { RecipientListBuilder answer = new RecipientListBuilder ( this , receipients ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent public SplitterBuilder splitter ( @ FluentArg ( value = "recipients" , element = true ) Expression receipients ) { SplitterBuilder answer = new SplitterBuilder ( this , receipients ) ; addProcessBuilder ( answer ) ; return answer ; } public ResequencerBuilder resequencer ( Expression < Exchange > expression ) { return resequencer ( Collections . < Expression < Exchange > > singletonList ( expression ) ) ; } @ Fluent public ResequencerBuilder resequencer ( @ FluentArg ( value = "expressions" ) List < Expression < Exchange > > expressions ) { ResequencerBuilder answer = new ResequencerBuilder ( this , expressions ) ; setRouteBuilder ( answer ) ; return answer ; } @ Fluent public ResequencerBuilder resequencer ( Expression < Exchange > ... expressions ) { List < Expression < Exchange > > list = new ArrayList < Expression < Exchange > > ( ) ; for ( Expression < Exchange > expression : expressions ) { list . add ( expression ) ; } return resequencer ( list ) ; } @ Fluent public FromBuilder errorHandler ( @ FluentArg ( "handler" ) ErrorHandlerBuilder errorHandlerBuilder ) { setErrorHandlerBuilder ( errorHandlerBuilder ) ; return this ; } @ Fluent public FromBuilder inheritErrorHandler ( @ FluentArg ( "condition" ) boolean condition ) { setInheritErrorHandler ( condition ) ; return this ; } @ Fluent ( nestedActions = true ) public InterceptorBuilder intercept ( ) { InterceptorBuilder answer = new InterceptorBuilder ( this ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent public FromBuilder trace ( ) { return trace ( DEFAULT_TRACE_CATEGORY ) ; } @ Fluent public FromBuilder trace ( @ FluentArg ( "category" ) String category ) { final Log log = LogFactory . getLog ( category ) ; return intercept ( new DelegateProcessor ( ) { @ Override public void process ( Exchange exchange ) throws Exception { log . trace ( exchange ) ; processNext ( exchange ) ; } } ) ; } @ Fluent public FromBuilder intercept ( @ FluentArg ( "interceptor" ) DelegateProcessor interceptor ) { InterceptorBuilder answer = new InterceptorBuilder ( this ) ; answer . add ( interceptor ) ; addProcessBuilder ( answer ) ; return answer . target ( ) ; } @ Fluent ( nestedActions = true ) public PolicyBuilder policies ( ) { PolicyBuilder answer = new PolicyBuilder ( this ) ; addProcessBuilder ( answer ) ; return answer ; } @ Fluent public FromBuilder policy ( @ FluentArg ( "policy" ) Policy policy ) { PolicyBuilder answer = new PolicyBuilder ( this ) ; answer . add ( policy ) ; addProcessBuilder ( answer ) ; return answer . target ( ) ; } @ Fluent public FromBuilder process ( @ FluentArg ( "ref" ) Processor processor ) { addProcessorBuilder ( processor ) ; return this ; } @ Fluent public FromBuilder setBody ( Expression expression ) { addProcessorBuilder ( ProcessorBuilder . setBody ( expression ) ) ; return this ; } @ Fluent public FromBuilder setOutBody ( Expression expression ) { addProcessorBuilder ( ProcessorBuilder . setOutBody ( expression ) ) ; return this ; } @ Fluent public FromBuilder setHeader ( String name , Expression expression ) { addProcessorBuilder ( ProcessorBuilder . setHeader ( name , expression ) ) ; return this ; } @ Fluent public FromBuilder setOutHeader ( String name , Expression expression ) { addProcessorBuilder ( ProcessorBuilder . setOutHeader ( name , expression ) ) ; return this ; } @ Fluent public FromBuilder setProperty ( String name , Expression expression ) { addProcessorBuilder ( ProcessorBuilder . setProperty ( name , expression ) ) ; return this ; } @ Fluent public FromBuilder convertBodyTo ( Class type ) { addProcessorBuilder ( ProcessorBuilder . setBody ( Builder . body ( ) . convertTo ( type ) ) ) ; return this ; } @ Fluent public FromBuilder convertOutBodyTo ( Class type ) { addProcessorBuilder ( ProcessorBuilder . setOutBody ( Builder . outBody ( ) . convertTo ( type ) ) ) ; return this ; } public RouteBuilder getBuilder ( ) { return builder ; } public Endpoint getFrom ( ) { return from ; } public List < Processor > getProcessors ( ) { return processors ; } public ProcessorFactory addProcessBuilder ( ProcessorFactory processFactory ) { processFactories . add ( processFactory ) ; return processFactory ; } protected void addProcessorBuilder ( Processor processor ) { addProcessBuilder ( new ConstantProcessorBuilder ( processor ) ) ; } public void addProcessor ( Processor processor ) { processors . add ( processor ) ; } public Route createRoute ( ) throws Exception { if ( routeBuilder != null ) { return routeBuilder . createRoute ( ) ; } Processor processor = createProcessor ( ) ; if ( processor == null ) { throw new IllegalArgumentException ( "No processor created for: " + this ) ; } return new EventDrivenConsumerRoute ( getFrom ( ) , processor ) ; } public Processor createProcessor ( ) throws Exception { List < Processor > answer = new ArrayList < Processor > ( ) ; for ( ProcessorFactory processFactory : processFactories ) { Processor processor = makeProcessor ( processFactory ) ; if ( processor == null ) { throw new IllegalArgumentException ( "No processor created for processBuilder: " + processFactory ) ; } answer . add ( processor ) ; } if ( answer . size ( ) == 0 ) { return null ; } Processor processor = null ; if ( answer . size ( ) == 1 ) { processor = answer . get ( 0 ) ; } else { processor = new CompositeProcessor ( answer ) ; } return processor ; } protected Processor makeProcessor ( ProcessorFactory processFactory ) throws Exception { Processor processor = processFactory . createProcessor ( ) ; processor = wrapProcessor ( processor ) ; return wrapInErrorHandler ( processor ) ; } protected Processor wrapInErrorHandler ( Processor processor ) throws Exception { return getErrorHandlerBuilder ( ) . createErrorHandler ( processor ) ; } protected Processor wrapProcessor ( Processor processor ) { return processor ; } protected FromBuilder getRouteBuilder ( ) { return routeBuilder ; } protected void setRouteBuilder ( FromBuilder routeBuilder ) { this . routeBuilder = routeBuilder ; } } 	0
package org . apache . camel . bam . processor ; import org . apache . camel . bam . model . ActivityState ; import org . apache . camel . bam . rules . ProcessRules ; import org . apache . camel . impl . ServiceSupport ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . orm . jpa . JpaCallback ; import org . springframework . orm . jpa . JpaTemplate ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionTemplate ; import javax . persistence . EntityManager ; import javax . persistence . LockModeType ; import javax . persistence . PersistenceException ; import java . util . Date ; import java . util . List ; public class ActivityMonitorEngine extends ServiceSupport implements Runnable { private static final Log log = LogFactory . getLog ( ActivityMonitorEngine . class ) ; private JpaTemplate template ; private TransactionTemplate transactionTemplate ; private ProcessRules rules ; private int escalateLevel = 0 ; private long windowMillis = 1000L ; private Thread thread ; private boolean useLocking = false ; public ActivityMonitorEngine ( JpaTemplate template , TransactionTemplate transactionTemplate , ProcessRules rules ) { this . template = template ; this . transactionTemplate = transactionTemplate ; this . rules = rules ; } public boolean isUseLocking ( ) { return useLocking ; } public void setUseLocking ( boolean useLocking ) { this . useLocking = useLocking ; } public void run ( ) { log . debug ( "Starting to poll for timeout events" ) ; while ( ! isStopped ( ) ) { try { long now = System . currentTimeMillis ( ) ; long nextPoll = now + windowMillis ; final Date timeNow = new Date ( now ) ; transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( TransactionStatus status ) { List < ActivityState > list = template . find ( "select x from " + ActivityState . class . getName ( ) + " x where x.escalationLevel = ?1 and x.timeOverdue < ?2" , escalateLevel , timeNow ) ; for ( ActivityState activityState : list ) { fireExpiredEvent ( activityState ) ; } } } ) ; long timeToSleep = nextPoll - System . currentTimeMillis ( ) ; if ( timeToSleep > 0 ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sleeping for " + timeToSleep + " millis" ) ; } try { Thread . sleep ( timeToSleep ) ; } catch ( InterruptedException e ) { log . debug ( "Caught: " + e , e ) ; } } } catch ( Exception e ) { log . error ( "Caught: " + e , e ) ; } } } protected void fireExpiredEvent ( final ActivityState activityState ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Trying to fire expiration of: " + activityState ) ; } template . execute ( new JpaCallback ( ) { public Object doInJpa ( EntityManager entityManager ) throws PersistenceException { if ( isUseLocking ( ) ) { log . info ( "Attempting to lock: " + activityState ) ; entityManager . lock ( activityState , LockModeType . WRITE ) ; log . info ( "Grabbed lock: " + activityState ) ; } try { rules . processExpired ( activityState ) ; } catch ( Exception e ) { log . error ( "Failed to process expiration of: " + activityState + ". Reason: " + e , e ) ; } activityState . setEscalationLevel ( escalateLevel + 1 ) ; return null ; } } ) ; } protected void doStart ( ) throws Exception { rules . start ( ) ; thread = new Thread ( this , "ActivityMonitorEngine" ) ; thread . start ( ) ; } protected void doStop ( ) throws Exception { if ( thread != null ) { thread = null ; } rules . stop ( ) ; } } 	0
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . ZipOutputStream ; import java . io . File ; import java . io . IOException ; public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { setDestFile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "WEB-INF/web.xml" ) ; super . addFileset ( fs ) ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "webxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "WEB-INF/web.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a WEB-INF/web.xml which will be ignored " + "(please use webxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	1
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import java . net . MalformedURLException ; import java . net . HttpURLConnection ; import java . net . URLConnection ; import java . net . URL ; public class Http extends ProjectComponent implements Condition { private String spec = null ; public void setUrl ( String url ) { spec = url ; } private int errorsBeginAt = 400 ; public void SetErrorsBeginAt ( int errorsBeginAt ) { this . errorsBeginAt = errorsBeginAt ; } public boolean eval ( ) throws BuildException { if ( spec == null ) { throw new BuildException ( "No url specified in http condition" ) ; } log ( "Checking for " + spec , Project . MSG_VERBOSE ) ; try { URL url = new URL ( spec ) ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpURLConnection ) { HttpURLConnection http = ( HttpURLConnection ) conn ; int code = http . getResponseCode ( ) ; log ( "Result code for " + spec + " was " + code , Project . MSG_VERBOSE ) ; if ( code > 0 && code < errorsBeginAt ) { return true ; } else { return false ; } } } catch ( java . io . IOException e ) { return false ; } } catch ( MalformedURLException e ) { throw new BuildException ( "Badly formed URL: " + spec , e ) ; } return true ; } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileUtils ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class FixCRLF extends MatchingTask { private static final int UNDEF = - 1 ; private static final int NOTJAVA = 0 ; private static final int LOOKING = 1 ; private static final int IN_CHAR_CONST = 2 ; private static final int IN_STR_CONST = 3 ; private static final int IN_SINGLE_COMMENT = 4 ; private static final int IN_MULTI_COMMENT = 5 ; private static final int ASIS = 0 ; private static final int CR = 1 ; private static final int LF = 2 ; private static final int CRLF = 3 ; private static final int ADD = 1 ; private static final int REMOVE = - 1 ; private static final int SPACES = - 1 ; private static final int TABS = 1 ; private static final int INBUFLEN = 8192 ; private static final int LINEBUFLEN = 200 ; private static final char CTRLZ = '' ; private int tablength = 8 ; private String spaces = "        " ; private StringBuffer linebuf = new StringBuffer ( 1024 ) ; private StringBuffer linebuf2 = new StringBuffer ( 1024 ) ; private int eol ; private String eolstr ; private int ctrlz ; private int tabs ; private boolean javafiles = false ; private File srcDir ; private File destDir = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private String encoding = null ; public FixCRLF ( ) { tabs = ASIS ; if ( Os . isFamily ( "mac" ) ) { ctrlz = REMOVE ; eol = CR ; eolstr = "\r" ; } else if ( Os . isFamily ( "dos" ) ) { ctrlz = ASIS ; eol = CRLF ; eolstr = "\r\n" ; } else { ctrlz = REMOVE ; eol = LF ; eolstr = "\n" ; } } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setJavafiles ( boolean javafiles ) { this . javafiles = javafiles ; } public void setEol ( CrLf attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "asis" ) ) { eol = ASIS ; } else if ( option . equals ( "cr" ) ) { eol = CR ; eolstr = "\r" ; } else if ( option . equals ( "lf" ) ) { eol = LF ; eolstr = "\n" ; } else { eol = CRLF ; eolstr = "\r\n" ; } } public void setCr ( AddAsisRemove attr ) { log ( "DEPRECATED: The cr attribute has been deprecated," , Project . MSG_WARN ) ; log ( "Please use the eol attribute instead" , Project . MSG_WARN ) ; String option = attr . getValue ( ) ; CrLf c = new CrLf ( ) ; if ( option . equals ( "remove" ) ) { c . setValue ( "lf" ) ; } else if ( option . equals ( "asis" ) ) { c . setValue ( "asis" ) ; } else { c . setValue ( "crlf" ) ; } setEol ( c ) ; } public void setTab ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { tabs = SPACES ; } else if ( option . equals ( "asis" ) ) { tabs = ASIS ; } else { tabs = TABS ; } } public void setTablength ( int tlength ) throws BuildException { if ( tlength < 2 || tlength > 80 ) { throw new BuildException ( "tablength must be between 2 and 80" , location ) ; } tablength = tlength ; StringBuffer sp = new StringBuffer ( ) ; for ( int i = 0 ; i < tablength ; i ++ ) { sp . append ( ' ' ) ; } spaces = sp . toString ( ) ; } public void setEof ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { ctrlz = REMOVE ; } else if ( option . equals ( "asis" ) ) { ctrlz = ASIS ; } else { ctrlz = ADD ; } } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void execute ( ) throws BuildException { if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } log ( "options:" + " eol=" + ( eol == ASIS ? "asis" : eol == CR ? "cr" : eol == LF ? "lf" : "crlf" ) + " tab=" + ( tabs == TABS ? "add" : tabs == ASIS ? "asis" : "remove" ) + " eof=" + ( ctrlz == ADD ? "add" : ctrlz == ASIS ? "asis" : "remove" ) + " tablength=" + tablength + " encoding=" + ( encoding == null ? "default" : encoding ) , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { processFile ( files [ i ] ) ; } } private Reader getReader ( File f ) throws IOException { return ( encoding == null ) ? new FileReader ( f ) : new InputStreamReader ( new FileInputStream ( f ) , encoding ) ; } private void processFile ( String file ) throws BuildException { File srcFile = new File ( srcDir , file ) ; File destD = destDir == null ? srcDir : destDir ; File tmpFile = null ; BufferedWriter outWriter ; OneLiner . BufferLine line ; OneLiner lines = new OneLiner ( srcFile ) ; try { try { tmpFile = fileUtils . createTempFile ( "fixcrlf" , "" , destD ) ; Writer writer = ( encoding == null ) ? new FileWriter ( tmpFile ) : new OutputStreamWriter ( new FileOutputStream ( tmpFile ) , encoding ) ; outWriter = new BufferedWriter ( writer ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } while ( lines . hasMoreElements ( ) ) { int endComment ; try { line = ( OneLiner . BufferLine ) lines . nextElement ( ) ; } catch ( NoSuchElementException e ) { throw new BuildException ( e ) ; } String lineString = line . getLineString ( ) ; int linelen = line . length ( ) ; if ( tabs == ASIS ) { try { outWriter . write ( lineString ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int ptr ; while ( ( ptr = line . getNext ( ) ) < linelen ) { switch ( lines . getState ( ) ) { case NOTJAVA : notInConstant ( line , line . length ( ) , outWriter ) ; break ; case IN_MULTI_COMMENT : endComment = lineString . indexOf ( "*/" , line . getNext ( ) ) ; if ( endComment >= 0 ) { endComment += 2 ; lines . setState ( LOOKING ) ; } else { endComment = linelen ; } notInConstant ( line , endComment , outWriter ) ; break ; case IN_SINGLE_COMMENT : notInConstant ( line , line . length ( ) , outWriter ) ; lines . setState ( LOOKING ) ; break ; case IN_CHAR_CONST : case IN_STR_CONST : int begin = line . getNext ( ) ; char terminator = ( lines . getState ( ) == IN_STR_CONST ? '\"' : '\'' ) ; endOfCharConst ( line , terminator ) ; while ( line . getNext ( ) < line . getLookahead ( ) ) { if ( line . getNextCharInc ( ) == '\t' ) { line . setColumn ( line . getColumn ( ) + tablength - ( line . getColumn ( ) % tablength ) ) ; } else { line . incColumn ( ) ; } } try { outWriter . write ( line . substring ( begin , line . getNext ( ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } lines . setState ( LOOKING ) ; break ; case LOOKING : nextStateChange ( line ) ; notInConstant ( line , line . getLookahead ( ) , outWriter ) ; break ; } } } try { outWriter . write ( eolstr ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { if ( ctrlz == ASIS ) { outWriter . write ( lines . getEofStr ( ) ) ; } else if ( ctrlz == ADD ) { outWriter . write ( CTRLZ ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { outWriter . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { lines . close ( ) ; lines = null ; } catch ( IOException e ) { throw new BuildException ( "Unable to close source file " + srcFile ) ; } File destFile = new File ( destD , file ) ; if ( destFile . exists ( ) ) { log ( "destFile exists" , Project . MSG_DEBUG ) ; if ( ! fileUtils . contentEquals ( destFile , tmpFile ) ) { log ( destFile + " is being written" , Project . MSG_DEBUG ) ; if ( ! destFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + destFile ) ; } if ( ! tmpFile . renameTo ( destFile ) ) { throw new BuildException ( "Failed to transform " + srcFile + " to " + destFile + ". Couldn't rename temporary file: " + tmpFile ) ; } } else { log ( destFile + " is not written, as the contents are identical" , Project . MSG_DEBUG ) ; if ( ! tmpFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + tmpFile ) ; } } } else { log ( "destFile does not exist" , Project . MSG_DEBUG ) ; if ( ! tmpFile . renameTo ( destFile ) ) { throw new BuildException ( "Failed to transform " + srcFile + " to " + destFile + ". Couldn't rename temporary file: " + tmpFile ) ; } } tmpFile = null ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { if ( lines != null ) { lines . close ( ) ; } } catch ( IOException io ) { log ( "Error closing " + srcFile , Project . MSG_ERR ) ; } if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private void nextStateChange ( OneLiner . BufferLine bufline ) throws BuildException { int eol = bufline . length ( ) ; int ptr = bufline . getNext ( ) ; while ( ptr < eol ) { switch ( bufline . getChar ( ptr ++ ) ) { case '\'' : bufline . setState ( IN_CHAR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '\"' : bufline . setState ( IN_STR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '/' : if ( ptr < eol ) { if ( bufline . getChar ( ptr ) == '*' ) { bufline . setState ( IN_MULTI_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } else if ( bufline . getChar ( ptr ) == '/' ) { bufline . setState ( IN_SINGLE_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } } break ; } } bufline . setLookahead ( ptr ) ; } private void endOfCharConst ( OneLiner . BufferLine bufline , char terminator ) throws BuildException { int ptr = bufline . getNext ( ) ; int eol = bufline . length ( ) ; char c ; ptr ++ ; while ( ptr < eol ) { if ( ( c = bufline . getChar ( ptr ++ ) ) == '\\' ) { ptr ++ ; } else { if ( c == terminator ) { bufline . setLookahead ( ptr ) ; return ; } } } throw new BuildException ( "endOfCharConst: unterminated char constant" ) ; } private void notInConstant ( OneLiner . BufferLine bufline , int end , BufferedWriter outWriter ) { int nextTab ; int nextStop ; int tabspaces ; String line = bufline . substring ( bufline . getNext ( ) , end ) ; int place = 0 ; int col = bufline . getColumn ( ) ; linebuf . setLength ( 0 ) ; while ( ( nextTab = line . indexOf ( ( int ) '\t' , place ) ) >= 0 ) { linebuf . append ( line . substring ( place , nextTab ) ) ; col += nextTab - place ; tabspaces = tablength - ( col % tablength ) ; linebuf . append ( spaces . substring ( 0 , tabspaces ) ) ; col += tabspaces ; place = nextTab + 1 ; } linebuf . append ( line . substring ( place , line . length ( ) ) ) ; String linestring = new String ( linebuf . toString ( ) ) ; if ( tabs == REMOVE ) { try { outWriter . write ( linestring ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int tabCol ; linebuf2 . setLength ( 0 ) ; place = 0 ; col = bufline . getColumn ( ) ; int placediff = col - 0 ; nextStop = col + ( tablength - col % tablength ) ; if ( nextStop - col < 2 ) { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; place = nextStop - placediff ; nextStop += tablength ; } for ( ; nextStop - placediff <= linestring . length ( ) ; nextStop += tablength ) { for ( tabCol = nextStop ; -- tabCol - placediff >= place && linestring . charAt ( tabCol - placediff ) == ' ' ; ) { ; } if ( nextStop - tabCol > 2 ) { linebuf2 . append ( linestring . substring ( place , ++ tabCol - placediff ) ) ; linebuf2 . append ( '\t' ) ; } else { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; } place = nextStop - placediff ; } linebuf2 . append ( linestring . substring ( place , linestring . length ( ) ) ) ; try { outWriter . write ( linebuf2 . toString ( ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } bufline . setColumn ( bufline . getColumn ( ) + linestring . length ( ) ) ; bufline . setNext ( end ) ; } class OneLiner implements Enumeration { private int state = javafiles ? LOOKING : NOTJAVA ; private StringBuffer eolStr = new StringBuffer ( LINEBUFLEN ) ; private StringBuffer eofStr = new StringBuffer ( ) ; private BufferedReader reader ; private StringBuffer line = new StringBuffer ( ) ; private boolean reachedEof = false ; public OneLiner ( File srcFile ) throws BuildException { try { reader = new BufferedReader ( getReader ( srcFile ) , INBUFLEN ) ; nextLine ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected void nextLine ( ) throws BuildException { int ch = - 1 ; int eolcount = 0 ; eolStr . setLength ( 0 ) ; line . setLength ( 0 ) ; try { ch = reader . read ( ) ; while ( ch != - 1 && ch != '\r' && ch != '\n' ) { line . append ( ( char ) ch ) ; ch = reader . read ( ) ; } if ( ch == - 1 && line . length ( ) == 0 ) { reachedEof = true ; return ; } switch ( ( char ) ch ) { case '\r' : ++ eolcount ; eolStr . append ( '\r' ) ; reader . mark ( 2 ) ; switch ( ( ch = reader . read ( ) ) ) { case '\r' : if ( ( char ) ( ch = reader . read ( ) ) == '\n' ) { eolcount += 2 ; eolStr . append ( "\r\n" ) ; } else { reader . reset ( ) ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; case - 1 : break ; default : reader . reset ( ) ; break ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; } if ( eolcount == 0 ) { int i = line . length ( ) ; while ( -- i >= 0 && line . charAt ( i ) == CTRLZ ) { } if ( i < line . length ( ) - 1 ) { eofStr . append ( line . toString ( ) . substring ( i + 1 ) ) ; if ( i < 0 ) { line . setLength ( 0 ) ; reachedEof = true ; } else { line . setLength ( i + 1 ) ; } } } } catch ( IOException e ) { throw new BuildException ( e ) ; } } public String getEofStr ( ) { return eofStr . toString ( ) ; } public int getState ( ) { return state ; } public void setState ( int state ) { this . state = state ; } public boolean hasMoreElements ( ) { return ! reachedEof ; } public Object nextElement ( ) throws NoSuchElementException { if ( ! hasMoreElements ( ) ) { throw new NoSuchElementException ( "OneLiner" ) ; } BufferLine tmpLine = new BufferLine ( line . toString ( ) , eolStr . toString ( ) ) ; nextLine ( ) ; return tmpLine ; } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } class BufferLine { private int next = 0 ; private int column = 0 ; private int lookahead = UNDEF ; private String line ; private String eolStr ; public BufferLine ( String line , String eolStr ) throws BuildException { next = 0 ; column = 0 ; this . line = line ; this . eolStr = eolStr ; } public int getNext ( ) { return next ; } public void setNext ( int next ) { this . next = next ; } public int getLookahead ( ) { return lookahead ; } public void setLookahead ( int lookahead ) { this . lookahead = lookahead ; } public char getChar ( int i ) { return line . charAt ( i ) ; } public char getNextChar ( ) { return getChar ( next ) ; } public char getNextCharInc ( ) { return getChar ( next ++ ) ; } public int getColumn ( ) { return column ; } public void setColumn ( int col ) { column = col ; } public int incColumn ( ) { return column ++ ; } public int length ( ) { return line . length ( ) ; } public int getEolLength ( ) { return eolStr . length ( ) ; } public String getLineString ( ) { return line ; } public String getEol ( ) { return eolStr ; } public String substring ( int begin ) { return line . substring ( begin ) ; } public String substring ( int begin , int end ) { return line . substring ( begin , end ) ; } public void setState ( int state ) { OneLiner . this . setState ( state ) ; } public int getState ( ) { return OneLiner . this . getState ( ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } public static class CrLf extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" } ; } } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Vector ; public class XmlProperty extends org . apache . tools . ant . Task { private File src ; private String prefix = "" ; private boolean keepRoot = true ; private boolean validate = false ; private boolean collapseAttributes = false ; private org . w3c . dom . Document document ; public XmlProperty ( ) { super ( ) ; } public void init ( ) { super . init ( ) ; } public void execute ( ) throws BuildException { BufferedInputStream configurationStream = null ; try { configurationStream = new BufferedInputStream ( new FileInputStream ( src ) ) ; DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setValidating ( validate ) ; factory . setNamespaceAware ( false ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; document = builder . parse ( configurationStream ) ; Element topElement = document . getDocumentElement ( ) ; NodeList topChildren = topElement . getChildNodes ( ) ; int numChildren = topChildren . getLength ( ) ; log ( "Using prefix: \"" + prefix + "\"" , Project . MSG_DEBUG ) ; if ( keepRoot ) { addNodeRecursively ( topElement , prefix ) ; } else { for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( topChildren . item ( i ) , prefix ) ; } } } catch ( SAXException sxe ) { Exception x = sxe ; if ( sxe . getException ( ) != null ) x = sxe . getException ( ) ; throw new BuildException ( x ) ; } catch ( ParserConfigurationException pce ) { throw new BuildException ( pce ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe ) ; } finally { if ( configurationStream != null ) { try { configurationStream . close ( ) ; } catch ( Exception e ) { } } } } void addNodeRecursively ( org . w3c . dom . Node node , String prefix ) { if ( node . hasAttributes ( ) ) { org . w3c . dom . NamedNodeMap nodeAttributes = node . getAttributes ( ) ; for ( int i = 0 ; i < nodeAttributes . getLength ( ) ; i ++ ) { Node attributeNode = nodeAttributes . item ( i ) ; String attributeName ; if ( collapseAttributes ) { attributeName = prefix + ( prefix . trim ( ) . equals ( "" ) ? "" : "." ) + node . getNodeName ( ) + "." + attributeNode . getNodeName ( ) ; } else { attributeName = prefix + ( prefix . trim ( ) . equals ( "" ) ? "" : "." ) + node . getNodeName ( ) + "(" + attributeNode . getNodeName ( ) + ")" ; } String attributeValue = attributeNode . getNodeValue ( ) ; log ( attributeName + ":" + attributeValue , Project . MSG_DEBUG ) ; project . setNewProperty ( attributeName , attributeValue ) ; } } if ( node . getNodeType ( ) == Node . TEXT_NODE ) { String nodeText = node . getNodeValue ( ) ; if ( nodeText . trim ( ) . length ( ) != 0 ) { log ( prefix + ":" + nodeText , Project . MSG_DEBUG ) ; project . setNewProperty ( prefix , nodeText ) ; } } if ( node . hasChildNodes ( ) ) { prefix += ( ( prefix . trim ( ) . equals ( "" ) ? "" : "." ) + node . getNodeName ( ) ) ; org . w3c . dom . NodeList nodeChildren = node . getChildNodes ( ) ; int numChildren = nodeChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( nodeChildren . item ( i ) , prefix ) ; } } } public void setFile ( File src ) { this . src = src ; } public void setPrefix ( String prefix ) { this . prefix = prefix . trim ( ) ; } public void setKeeproot ( boolean keepRoot ) { this . keepRoot = keepRoot ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public void setCollapseAttributes ( boolean collapseAttributes ) { this . collapseAttributes = collapseAttributes ; } } 	1
package org . apache . tools . ant ; import java . lang . reflect . Method ; public class TaskAdapter extends Task { private Object proxy ; public static void checkTaskClass ( final Class taskClass , final Project project ) { try { final Method executeM = taskClass . getMethod ( "execute" , null ) ; if ( ! Void . TYPE . equals ( executeM . getReturnType ( ) ) ) { final String message = "return type of execute() should be " + "void but was \"" + executeM . getReturnType ( ) + "\" in " + taskClass ; project . log ( message , Project . MSG_WARN ) ; } } catch ( NoSuchMethodException e ) { final String message = "No public execute() in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } } public void execute ( ) throws BuildException { Method setProjectM = null ; try { Class c = proxy . getClass ( ) ; setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( proxy , new Object [ ] { project } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception ex ) { log ( "Error setting project in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } Method executeM = null ; try { Class c = proxy . getClass ( ) ; executeM = c . getMethod ( "execute" , new Class [ 0 ] ) ; if ( executeM == null ) { log ( "No public execute() in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( "No public execute() in " + proxy . getClass ( ) ) ; } executeM . invoke ( proxy , null ) ; return ; } catch ( java . lang . reflect . InvocationTargetException ie ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_ERR ) ; Throwable t = ie . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( ( BuildException ) t ) ; } else { throw new BuildException ( t ) ; } } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return this . proxy ; } } 	1
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . io . File ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . io . IOException ; public abstract class DefaultCompilerAdapter implements CompilerAdapter { protected Path src ; protected File destDir ; protected String encoding ; protected boolean debug = false ; protected boolean optimize = false ; protected boolean deprecation = false ; protected boolean depend = false ; protected boolean verbose = false ; protected String target ; protected Path bootclasspath ; protected Path extdirs ; protected Path compileClasspath ; protected Path compileSourcepath ; protected Project project ; protected Location location ; protected boolean includeAntRuntime ; protected boolean includeJavaRuntime ; protected String memoryInitialSize ; protected String memoryMaximumSize ; protected File [ ] compileList ; protected static String lSep = System . getProperty ( "line.separator" ) ; protected Javac attributes ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; public void setJavac ( Javac attributes ) { this . attributes = attributes ; src = attributes . getSrcdir ( ) ; destDir = attributes . getDestdir ( ) ; encoding = attributes . getEncoding ( ) ; debug = attributes . getDebug ( ) ; optimize = attributes . getOptimize ( ) ; deprecation = attributes . getDeprecation ( ) ; depend = attributes . getDepend ( ) ; verbose = attributes . getVerbose ( ) ; target = attributes . getTarget ( ) ; bootclasspath = attributes . getBootclasspath ( ) ; extdirs = attributes . getExtdirs ( ) ; compileList = attributes . getFileList ( ) ; compileClasspath = attributes . getClasspath ( ) ; compileSourcepath = attributes . getSourcepath ( ) ; project = attributes . getProject ( ) ; location = attributes . getLocation ( ) ; includeAntRuntime = attributes . getIncludeantruntime ( ) ; includeJavaRuntime = attributes . getIncludejavaruntime ( ) ; memoryInitialSize = attributes . getMemoryInitialSize ( ) ; memoryMaximumSize = attributes . getMemoryMaximumSize ( ) ; } public Javac getJavac ( ) { return attributes ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( project ) ; if ( destDir != null ) { classpath . setLocation ( destDir ) ; } if ( compileClasspath == null ) { if ( includeAntRuntime ) { classpath . addExisting ( Path . systemClasspath ) ; } } else { if ( includeAntRuntime ) { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "ignore" ) ) ; } } if ( includeJavaRuntime ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd ) { return setupJavacCommandlineSwitches ( cmd , false ) ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd , boolean useDebugLevel ) { Path classpath = getCompileClasspath ( ) ; Path sourcepath = null ; if ( compileSourcepath != null ) { sourcepath = compileSourcepath ; } else { sourcepath = src ; } String memoryParameterPrefix = assumeJava11 ( ) ? "-J-" : "-J-X" ; if ( memoryInitialSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryInitialSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "ms" + memoryInitialSize ) ; } } if ( memoryMaximumSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryMaximumSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "mx" + memoryMaximumSize ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; if ( assumeJava11 ( ) ) { Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; cp . append ( sourcepath ) ; cmd . createArgument ( ) . setPath ( cp ) ; } else { cmd . createArgument ( ) . setPath ( classpath ) ; if ( sourcepath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( sourcepath ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } if ( bootclasspath != null && bootclasspath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bootclasspath ) ; } if ( extdirs != null && extdirs . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } } if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { if ( useDebugLevel && ! assumeJava11 ( ) ) { String debugLevel = attributes . getDebugLevel ( ) ; if ( debugLevel != null ) { cmd . createArgument ( ) . setValue ( "-g:" + debugLevel ) ; } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else if ( ! assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-g:none" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( depend ) { if ( assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } else if ( assumeJava12 ( ) ) { cmd . createArgument ( ) . setValue ( "-Xdepend" ) ; } else { attributes . log ( "depend attribute is not supported by the " + "modern compiler" , Project . MSG_WARN ) ; } } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; return cmd ; } protected Commandline setupModernJavacCommandlineSwitches ( Commandline cmd ) { setupJavacCommandlineSwitches ( cmd , true ) ; if ( attributes . getSource ( ) != null && ! assumeJava13 ( ) ) { cmd . createArgument ( ) . setValue ( "-source" ) ; cmd . createArgument ( ) . setValue ( attributes . getSource ( ) ) ; } return cmd ; } protected Commandline setupModernJavacCommand ( ) { Commandline cmd = new Commandline ( ) ; setupModernJavacCommandlineSwitches ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected Commandline setupJavacCommand ( ) { return setupJavacCommand ( false ) ; } protected Commandline setupJavacCommand ( boolean debugLevelCheck ) { Commandline cmd = new Commandline ( ) ; setupJavacCommandlineSwitches ( cmd , debugLevelCheck ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . length != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( lSep ) ; for ( int i = 0 ; i < compileList . length ; i ++ ) { String arg = compileList [ i ] . getAbsolutePath ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg + lSep ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName ) { String [ ] commandArray = null ; File tmpFile = null ; try { if ( Commandline . toString ( args ) . length ( ) > 4096 && firstFileName >= 0 ) { PrintWriter out = null ; try { String userDirName = System . getProperty ( "user.dir" ) ; File userDir = new File ( userDirName ) ; tmpFile = fileUtils . createTempFile ( "files" , "" , userDir ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + tmpFile ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = args ; } try { Execute exe = new Execute ( new LogStreamHandler ( attributes , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; return exe . getExitValue ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running " + args [ 0 ] + " compiler" , e , location ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void addExtdirsToClasspath ( Path classpath ) { classpath . addExtdirs ( extdirs ) ; } protected void addCurrentCompilerArgs ( Commandline cmd ) { cmd . addArguments ( getJavac ( ) . getCurrentCompilerArgs ( ) ) ; } protected boolean assumeJava11 ( ) { return "javac1.1" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) ; } protected boolean assumeJava12 ( ) { return "javac1.2" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) ; } protected boolean assumeJava13 ( ) { return "javac1.3" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "modern" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . ZipOutputStream ; import java . io . File ; import java . io . IOException ; public class Ear extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { setDestFile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "appxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/application.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will" + " be ignored (please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	1
package org . apache . tools . ant . taskdefs . email ; import org . apache . tools . ant . ProjectComponent ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintStream ; public class Message extends ProjectComponent { private File messageSource = null ; private StringBuffer buffer = new StringBuffer ( ) ; private String mimeType = "text/plain" ; private boolean specified = false ; public Message ( ) { } public Message ( String text ) { addText ( text ) ; } public Message ( File file ) { messageSource = file ; } public void addText ( String text ) { buffer . append ( text ) ; } public void setSrc ( File src ) { this . messageSource = src ; } public void setMimeType ( String mimeType ) { this . mimeType = mimeType ; specified = true ; } public String getMimeType ( ) { return mimeType ; } public void print ( PrintStream out ) throws IOException { if ( messageSource != null ) { FileReader freader = new FileReader ( messageSource ) ; try { BufferedReader in = new BufferedReader ( freader ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { out . println ( getProject ( ) . replaceProperties ( line ) ) ; } } finally { freader . close ( ) ; } } else { out . println ( getProject ( ) . replaceProperties ( buffer . toString ( ) ) ) ; } } public boolean isMimeTypeSpecified ( ) { return specified ; } } 	1
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; public class EmailTask extends Task { public static final String AUTO = "auto" ; public static final String MIME = "mime" ; public static final String UU = "uu" ; public static final String PLAIN = "plain" ; public static class Encoding extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { AUTO , MIME , UU , PLAIN } ; } } private String encoding = AUTO ; private String host = "localhost" ; private int port = 25 ; private String subject = null ; private Message message = null ; private boolean failOnError = true ; private boolean includeFileNames = false ; private String messageMimeType = null ; private EmailAddress from = null ; private Vector toList = new Vector ( ) ; private Vector ccList = new Vector ( ) ; private Vector bccList = new Vector ( ) ; private Vector files = new Vector ( ) ; private Vector filesets = new Vector ( ) ; public void setEncoding ( Encoding encoding ) { this . encoding = encoding . getValue ( ) ; } public void setMailport ( int port ) { this . port = port ; } public void setMailhost ( String host ) { this . host = host ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setMessage ( String message ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( message ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageFile ( File file ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( file ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageMimeType ( String type ) { this . messageMimeType = type ; } public void addMessage ( Message message ) throws BuildException { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = message ; } public void addFrom ( EmailAddress address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = address ; } public void setFrom ( String address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = new EmailAddress ( address ) ; } public void addTo ( EmailAddress address ) { toList . addElement ( address ) ; } public void setToList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { toList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addCc ( EmailAddress address ) { ccList . addElement ( address ) ; } public void setCcList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { ccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addBcc ( EmailAddress address ) { bccList . addElement ( address ) ; } public void setBccList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { bccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setFiles ( String filenames ) { StringTokenizer t = new StringTokenizer ( filenames , ", " ) ; while ( t . hasMoreTokens ( ) ) { files . addElement ( project . resolveFile ( t . nextToken ( ) ) ) ; } } public void addFileset ( FileSet fs ) { filesets . addElement ( fs ) ; } public void setIncludefilenames ( boolean includeFileNames ) { this . includeFileNames = includeFileNames ; } public boolean getIncludeFileNames ( ) { return includeFileNames ; } public void execute ( ) { Message savedMessage = message ; Vector savedFiles = ( Vector ) files . clone ( ) ; try { Mailer mailer = null ; boolean autoFound = false ; if ( encoding . equals ( MIME ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.MimeMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using MIME mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise MIME mail" , Project . MSG_WARN ) ; } } if ( encoding . equals ( UU ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.UUMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using UU mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise UU mail" , Project . MSG_WARN ) ; } } if ( encoding . equals ( PLAIN ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { mailer = new PlainMailer ( ) ; autoFound = true ; log ( "Using plain mail" , Project . MSG_VERBOSE ) ; } if ( mailer == null ) { throw new BuildException ( "Failed to initialise encoding: " + encoding ) ; } if ( message == null ) { message = new Message ( ) ; message . setProject ( getProject ( ) ) ; } if ( from == null || from . getAddress ( ) == null ) { throw new BuildException ( "A from element is required" ) ; } if ( toList . isEmpty ( ) && ccList . isEmpty ( ) && bccList . isEmpty ( ) ) { throw new BuildException ( "At least one of to,cc or bcc must " + "be supplied" ) ; } if ( messageMimeType != null ) { if ( message . isMimeTypeSpecified ( ) ) { throw new BuildException ( "The mime type can only be " + "specified in one location" ) ; } else { message . setMimeType ( messageMimeType ) ; } } Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] includedFiles = ds . getIncludedFiles ( ) ; File baseDir = ds . getBasedir ( ) ; for ( int j = 0 ; j < includedFiles . length ; ++ j ) { File file = new File ( baseDir , includedFiles [ j ] ) ; files . addElement ( file ) ; } } log ( "Sending email: " + subject , Project . MSG_INFO ) ; log ( "From " + from , Project . MSG_VERBOSE ) ; log ( "To " + toList , Project . MSG_VERBOSE ) ; log ( "Cc " + ccList , Project . MSG_VERBOSE ) ; log ( "Bcc " + bccList , Project . MSG_VERBOSE ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setMessage ( message ) ; mailer . setFrom ( from ) ; mailer . setToList ( toList ) ; mailer . setCcList ( ccList ) ; mailer . setBccList ( bccList ) ; mailer . setFiles ( files ) ; mailer . setSubject ( subject ) ; mailer . setTask ( this ) ; mailer . setIncludeFileNames ( includeFileNames ) ; mailer . send ( ) ; int count = files . size ( ) ; log ( "Sent email with " + count + " attachment" + ( count == 1 ? "" : "s" ) , Project . MSG_INFO ) ; } catch ( BuildException e ) { log ( "Failed to send email" , Project . MSG_WARN ) ; if ( failOnError ) { throw e ; } } finally { message = savedMessage ; files = savedFiles ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . FileOutputStream ; import java . io . OutputStream ; import java . io . FileInputStream ; import java . io . BufferedOutputStream ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . tar . TarOutputStream ; import org . apache . tools . tar . TarConstants ; import org . apache . tools . tar . TarEntry ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class Tar extends MatchingTask { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; File tarFile ; File baseDir ; private TarLongFileMode longFileMode = new TarLongFileMode ( ) ; Vector filesets = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; private TarCompressionMethod compression = new TarCompressionMethod ( ) ; public TarFileSet createTarFileSet ( ) { TarFileSet fileset = new TarFileSet ( ) ; filesets . addElement ( fileset ) ; return fileset ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setDestFile ( File destFile ) { this . tarFile = destFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { log ( "DEPRECATED - The setLongfile(String) method has been deprecated." + " Use setLongfile(Tar.TarLongFileMode) instead." ) ; this . longFileMode = new TarLongFileMode ( ) ; longFileMode . setValue ( mode ) ; } public void setLongfile ( TarLongFileMode mode ) { this . longFileMode = mode ; } public void setCompression ( TarCompressionMethod mode ) { this . compression = mode ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , location ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , location ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , location ) ; } Vector savedFileSets = ( Vector ) filesets . clone ( ) ; try { if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , location ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basedir " + "attribute or some nested filesets." , location ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; if ( ! archiveIsUpToDate ( files ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( fs . getDir ( project ) , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include " + "itself" , location ) ; } } } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( compression . compress ( new BufferedOutputStream ( new FileOutputStream ( tarFile ) ) ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . isTruncateMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . isFailMode ( ) || longFileMode . isOmitMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; if ( files . length > 1 && fs . getFullpath ( ) . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only " + "be specified for " + "filesets that specify a " + "single file." ) ; } for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( fs . getDir ( project ) , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , fs ) ; } } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( tOut != null ) { try { tOut . close ( ) ; } catch ( IOException e ) { } } } } finally { filesets = savedFileSets ; } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { FileInputStream fIn = null ; String fullpath = tarFileSet . getFullpath ( ) ; if ( fullpath . length ( ) > 0 ) { vPath = fullpath ; } else { if ( vPath . length ( ) <= 0 ) { return ; } if ( file . isDirectory ( ) && ! vPath . endsWith ( "/" ) ) { vPath += "/" ; } String prefix = tarFileSet . getPrefix ( ) ; if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) ) { prefix = prefix + "/" ; } vPath = prefix + vPath ; } if ( vPath . startsWith ( "/" ) && ! tarFileSet . getPreserveLeadingSlashes ( ) ) { int l = vPath . length ( ) ; if ( l <= 1 ) { return ; } vPath = vPath . substring ( 1 , l ) ; } try { if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . isOmitMode ( ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . isWarnMode ( ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed " + "successfully by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . isFailMode ( ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , location ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setModTime ( file . lastModified ( ) ) ; if ( ! file . isDirectory ( ) ) { te . setSize ( file . length ( ) ) ; te . setMode ( tarFileSet . getMode ( ) ) ; } te . setUserName ( tarFileSet . getUserName ( ) ) ; te . setGroupName ( tarFileSet . getGroup ( ) ) ; tOut . putNextEntry ( te ) ; if ( ! file . isDirectory ( ) ) { fIn = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = fIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } tOut . closeEntry ( ) ; } finally { if ( fIn != null ) { fIn . close ( ) ; } } } protected boolean archiveIsUpToDate ( String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , baseDir , null , mm ) . length == 0 ; } public static class TarFileSet extends FileSet { private String [ ] files = null ; private int mode = 0100644 ; private String userName = "" ; private String groupName = "" ; private String prefix = "" ; private String fullpath = "" ; private boolean preserveLeadingSlashes = false ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { DirectoryScanner ds = getDirectoryScanner ( p ) ; String [ ] directories = ds . getIncludedDirectories ( ) ; String [ ] filesPerSe = ds . getIncludedFiles ( ) ; files = new String [ directories . length + filesPerSe . length ] ; System . arraycopy ( directories , 0 , files , 0 , directories . length ) ; System . arraycopy ( filesPerSe , 0 , files , directories . length , filesPerSe . length ) ; } return files ; } public void setMode ( String octalString ) { this . mode = 0100000 | Integer . parseInt ( octalString , 8 ) ; } public int getMode ( ) { return mode ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getUserName ( ) { return userName ; } public void setGroup ( String groupName ) { this . groupName = groupName ; } public String getGroup ( ) { return groupName ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public void setPreserveLeadingSlashes ( boolean b ) { this . preserveLeadingSlashes = b ; } public boolean getPreserveLeadingSlashes ( ) { return preserveLeadingSlashes ; } } public static class TarLongFileMode extends EnumeratedAttribute { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; private final String [ ] validModes = { WARN , FAIL , TRUNCATE , GNU , OMIT } ; public TarLongFileMode ( ) { super ( ) ; setValue ( WARN ) ; } public String [ ] getValues ( ) { return validModes ; } public boolean isTruncateMode ( ) { return TRUNCATE . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isWarnMode ( ) { return WARN . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isGnuMode ( ) { return GNU . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFailMode ( ) { return FAIL . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isOmitMode ( ) { return OMIT . equalsIgnoreCase ( getValue ( ) ) ; } } public static final class TarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public TarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } private OutputStream compress ( final OutputStream ostream ) throws IOException { final String value = getValue ( ) ; if ( GZIP . equals ( value ) ) { return new GZIPOutputStream ( ostream ) ; } else { if ( BZIP2 . equals ( value ) ) { ostream . write ( 'B' ) ; ostream . write ( 'Z' ) ; return new CBZip2OutputStream ( ostream ) ; } } return ostream ; } } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Environment ; import java . io . File ; import java . io . PrintStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Vector ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private Environment env = new Environment ( ) ; private boolean fork = false ; private boolean newEnvironment = false ; private File dir = null ; private File out ; private PrintStream outStream = null ; private boolean failOnError = false ; private boolean append = false ; private Long timeout = null ; public void execute ( ) throws BuildException { File savedDir = dir ; int err = - 1 ; try { if ( ( err = executeJava ( ) ) != 0 ) { if ( failOnError ) { throw new BuildException ( "Java returned: " + err , location ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } } finally { dir = savedDir ; } } public int executeJava ( ) throws BuildException { String classname = cmdl . getClassname ( ) ; if ( classname == null && cmdl . getJar ( ) == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( ! fork && cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot execute a jar in non-forked mode." + " Please set fork='true'. " ) ; } if ( fork ) { log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; } else { if ( cmdl . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( newEnvironment || null != env . getVariables ( ) ) { log ( "Changes to environment variables are ignored when same " + "JVM is used." , Project . MSG_WARN ) ; } log ( "Running in same VM " + cmdl . describeJavaCommand ( ) , Project . MSG_VERBOSE ) ; } try { if ( fork ) { return run ( cmdl . getCommandline ( ) ) ; } else { try { run ( cmdl ) ; return 0 ; } catch ( ExitException ex ) { return ex . getStatus ( ) ; } } } catch ( BuildException e ) { if ( failOnError ) { throw e ; } else { log ( e . getMessage ( ) , Project . MSG_ERR ) ; return 0 ; } } catch ( Throwable t ) { if ( failOnError ) { throw new BuildException ( t ) ; } else { log ( t . getMessage ( ) , Project . MSG_ERR ) ; return 0 ; } } } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return cmdl . createClasspath ( project ) . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setJar ( File jarfile ) throws BuildException { if ( cmdl . getClassname ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command." ) ; } cmdl . setJar ( jarfile . getAbsolutePath ( ) ) ; } public void setClassname ( String s ) throws BuildException { if ( cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command" ) ; } cmdl . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; cmdl . createArgument ( ) . setLine ( s ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; cmdl . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return cmdl . createVmArgument ( ) ; } public void setJvm ( String s ) { cmdl . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { cmdl . addSysproperty ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { this . out = out ; } public void setMaxmemory ( String max ) { cmdl . setMaxmemory ( max ) ; } public void setJVMVersion ( String value ) { cmdl . setVmversion ( value ) ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setAppend ( boolean append ) { this . append = append ; } public void setTimeout ( Long value ) { timeout = value ; } protected void handleOutput ( String line ) { if ( outStream != null ) { outStream . println ( line ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( outStream != null ) { outStream . println ( line ) ; } else { super . handleErrorOutput ( line ) ; } } private void run ( CommandlineJava command ) throws BuildException { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; exe . setTimeout ( timeout ) ; if ( out != null ) { try { outStream = new PrintStream ( new FileOutputStream ( out . getAbsolutePath ( ) , append ) ) ; exe . execute ( project ) ; } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( outStream != null ) { outStream . close ( ) ; } } } else { exe . execute ( project ) ; } } private int run ( String [ ] command ) throws BuildException { FileOutputStream fos = null ; try { Execute exe = null ; if ( out == null ) { exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , createWatchdog ( ) ) ; } else { fos = new FileOutputStream ( out . getAbsolutePath ( ) , append ) ; exe = new Execute ( new PumpStreamHandler ( fos ) , createWatchdog ( ) ) ; } exe . setAntRun ( project ) ; if ( dir == null ) { dir = project . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , location ) ; } exe . setWorkingDirectory ( dir ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; exe . setCommandline ( command ) ; try { int rc = exe . execute ( ) ; if ( exe . killedProcess ( ) ) { log ( "Timeout: killed the sub-process" , Project . MSG_WARN ) ; } return rc ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException io ) { } } } } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { cmdl . clearJavaArgs ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . util . StringUtils ; import java . io . File ; import java . io . FileOutputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . FileNotFoundException ; public class ExecTask extends Task { private String os ; private File out ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Long timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private FileOutputStream fos = null ; private ByteArrayOutputStream baos = null ; private String outputprop ; private String resultProperty ; private boolean failIfExecFails = true ; private boolean append = false ; private boolean vmLauncher = true ; public void setTimeout ( Long value ) { timeout = value ; } public void setTimeout ( Integer value ) { if ( value == null ) { timeout = null ; } else { setTimeout ( new Long ( value . intValue ( ) ) ) ; } } public void setExecutable ( String value ) { cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated. " + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { this . out = out ; } public void setOutputproperty ( String outputprop ) { this . outputprop = outputprop ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; } protected void maybeSetResultPropertyValue ( int result ) { String res = Integer . toString ( result ) ; if ( resultProperty != null ) { project . setNewProperty ( resultProperty , res ) ; } } public void setFailIfExecutionFails ( boolean flag ) { failIfExecFails = flag ; } public void setAppend ( boolean append ) { this . append = append ; } public void execute ( ) throws BuildException { File savedDir = dir ; checkConfiguration ( ) ; if ( isValidOs ( ) ) { try { runExec ( prepareExec ( ) ) ; } finally { dir = savedDir ; } } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , location ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory you specified does not " + "exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( "The directory you specified is not a " + "directory" ) ; } } protected boolean isValidOs ( ) { String myos = System . getProperty ( "os.name" ) ; log ( "Current OS is " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "This OS, " + myos + " was not found in the specified list of valid OSes: " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void setVMLauncher ( boolean vmLauncher ) { this . vmLauncher = vmLauncher ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) { dir = project . getBaseDir ( ) ; } Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( dir ) ; exe . setVMLauncher ( vmLauncher ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected final void runExecute ( Execute exe ) throws IOException { int err = - 1 ; err = exe . execute ( ) ; if ( exe . killedProcess ( ) ) { log ( "Timeout: killed the sub-process" , Project . MSG_WARN ) ; } maybeSetResultPropertyValue ( err ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( taskType + " returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } if ( baos != null ) { BufferedReader in = new BufferedReader ( new StringReader ( Execute . toString ( baos ) ) ) ; String line = null ; StringBuffer val = new StringBuffer ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( val . length ( ) != 0 ) { val . append ( StringUtils . LINE_SEP ) ; } val . append ( line ) ; } project . setNewProperty ( outputprop , val . toString ( ) ) ; } } protected void runExec ( Execute exe ) throws BuildException { log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( cmdl . getCommandline ( ) ) ; try { runExecute ( exe ) ; } catch ( IOException e ) { if ( failIfExecFails ) { throw new BuildException ( "Execute failed: " + e . toString ( ) , e , location ) ; } else { log ( "Execute failed: " + e . toString ( ) , Project . MSG_ERR ) ; } } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { if ( out != null ) { try { fos = new FileOutputStream ( out . getAbsolutePath ( ) , append ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( fos ) ; } catch ( FileNotFoundException fne ) { throw new BuildException ( "Cannot write to " + out , fne , location ) ; } catch ( IOException ioe ) { throw new BuildException ( "Cannot write to " + out , ioe , location ) ; } } else if ( outputprop != null ) { baos = new ByteArrayOutputStream ( ) ; log ( "Output redirected to ByteArray" , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( baos ) ; } else { return new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } protected void logFlush ( ) { try { if ( fos != null ) { fos . close ( ) ; } if ( baos != null ) { baos . close ( ) ; } } catch ( IOException io ) { } } } 	1
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . Method ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . taskdefs . optional . TraXLiaison ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . XMLCatalog ; import org . xml . sax . EntityResolver ; public class XSLTProcess extends MatchingTask implements XSLTLogger { private File destDir = null ; private File baseDir = null ; private String xslFile = null ; private String targetExtension = ".html" ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private String processor ; private Path classpath = null ; private XSLTLiaison liaison ; private boolean stylesheetLoaded = false ; private boolean force = false ; private FileUtils fileUtils ; private Vector outputProperties = new Vector ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; private static final String TRAX_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ; private static final String XSLP_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.XslpLiaison" ; private static final String XALAN_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.XalanLiaison" ; private boolean performDirectoryScan = true ; public XSLTProcess ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void setScanIncludedDirectories ( boolean b ) { performDirectoryScan = b ; } public void execute ( ) throws BuildException { File savedBaseDir = baseDir ; DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( xslFile == null ) { throw new BuildException ( "no stylesheet specified" , location ) ; } try { if ( baseDir == null ) { baseDir = project . resolveFile ( "." ) ; } liaison = getLiaison ( ) ; if ( liaison instanceof XSLTLoggerAware ) { ( ( XSLTLoggerAware ) liaison ) . setLogger ( this ) ; } log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; File stylesheet = project . resolveFile ( xslFile ) ; if ( ! stylesheet . exists ( ) ) { stylesheet = fileUtils . resolveFile ( baseDir , xslFile ) ; if ( stylesheet . exists ( ) ) { log ( "DEPRECATED - the style attribute should be relative " + "to the project\'s" ) ; log ( "             basedir, not the tasks\'s basedir." ) ; } } if ( inFile != null && outFile != null ) { process ( inFile , outFile , stylesheet ) ; return ; } if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } if ( performDirectoryScan ) { dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } } } } finally { liaison = null ; stylesheetLoaded = false ; baseDir = savedBaseDir ; } } public void setForce ( boolean force ) { this . force = force ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = xslFile ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( project ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProcessor ( String processor ) { this . processor = processor ; } public void addConfiguredXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog . addConfiguredXMLCatalog ( xmlCatalog ) ; } private void resolveProcessor ( String proc ) throws Exception { if ( proc . equals ( "trax" ) ) { final Class clazz = loadClass ( TRAX_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xslp" ) ) { log ( "DEPRECATED - xslp processor is deprecated. Use trax or " + "xalan instead." ) ; final Class clazz = loadClass ( XSLP_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xalan" ) ) { final Class clazz = loadClass ( XALAN_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else { liaison = ( XSLTLiaison ) loadClass ( proc ) . newInstance ( ) ; } } private Class loadClass ( String classname ) throws Exception { if ( classpath == null ) { return Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( project , classpath ) ; Class c = al . loadClass ( classname ) ; AntClassLoader . initializeClass ( c ) ; return c ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void process ( File baseDir , String xmlFile , File destDir , File stylesheet ) throws BuildException { String fileExt = targetExtension ; File outFile = null ; File inFile = null ; try { long styleSheetLastModified = stylesheet . lastModified ( ) ; inFile = new File ( baseDir , xmlFile ) ; if ( inFile . isDirectory ( ) ) { log ( "Skipping " + inFile + " it is a directory." , Project . MSG_VERBOSE ) ; return ; } int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + fileExt ) ; } else { outFile = new File ( destDir , xmlFile + fileExt ) ; } if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , File stylesheet ) throws BuildException { try { long styleSheetLastModified = stylesheet . lastModified ( ) ; log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = fileUtils . getParentFile ( targetFile ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } protected XSLTLiaison getLiaison ( ) { if ( liaison == null ) { if ( processor != null ) { try { resolveProcessor ( processor ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } else { try { resolveProcessor ( "trax" ) ; } catch ( Throwable e1 ) { try { resolveProcessor ( "xalan" ) ; } catch ( Throwable e2 ) { try { resolveProcessor ( "xslp" ) ; } catch ( Throwable e3 ) { e3 . printStackTrace ( ) ; e2 . printStackTrace ( ) ; throw new BuildException ( e1 ) ; } } } } } return liaison ; } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public class Param { private String name = null ; private String expression = null ; public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) { throw new BuildException ( "Name attribute is missing." ) ; } return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) { throw new BuildException ( "Expression attribute is missing." ) ; } return expression ; } } public OutputProperty createOutputProperty ( ) { OutputProperty p = new OutputProperty ( ) ; outputProperties . addElement ( p ) ; return p ; } public static class OutputProperty { private String name ; private String value ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } public void init ( ) throws BuildException { super . init ( ) ; xmlCatalog . setProject ( project ) ; } protected void configureLiaison ( File stylesheet ) throws BuildException { if ( stylesheetLoaded ) { return ; } stylesheetLoaded = true ; try { log ( "Loading stylesheet " + stylesheet , Project . MSG_INFO ) ; liaison . setStylesheet ( stylesheet ) ; for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } if ( liaison instanceof TraXLiaison ) { configureTraXLiaison ( ( TraXLiaison ) liaison ) ; } } catch ( Exception ex ) { log ( "Failed to transform using stylesheet " + stylesheet , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } protected void configureTraXLiaison ( TraXLiaison liaison ) { if ( xmlCatalog != null ) { liaison . setEntityResolver ( xmlCatalog ) ; liaison . setURIResolver ( xmlCatalog ) ; } for ( Enumeration props = outputProperties . elements ( ) ; props . hasMoreElements ( ) ; ) { OutputProperty prop = ( OutputProperty ) props . nextElement ( ) ; liaison . setOutputProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } } } 	1
package org . apache . tools . ant . types ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import java . util . Stack ; public class ZipFileSet extends FileSet { private File srcFile = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; public ZipFileSet ( ) { super ( ) ; } protected ZipFileSet ( FileSet fileset ) { super ( fileset ) ; } public void setDir ( File dir ) throws BuildException { if ( srcFile != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void setSrc ( File srcFile ) { if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . srcFile = srcFile ; } public File getSrc ( ) { return srcFile ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( srcFile != null ) { ZipScanner zs = new ZipScanner ( ) ; zs . setSrc ( srcFile ) ; super . setDir ( p . getBaseDir ( ) ) ; setupDirectoryScanner ( zs , p ) ; zs . init ( ) ; return zs ; } else { return super . getDirectoryScanner ( p ) ; } } protected AbstractFileSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof FileSet ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a fileset" ; throw new BuildException ( msg ) ; } else { return ( AbstractFileSet ) o ; } } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . PrintStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . lang . reflect . Method ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; public class Ant extends Task { private File dir = null ; private String antFile = null ; private String target = null ; private String output = null ; private boolean inheritAll = true ; private boolean inheritRefs = false ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Project newProject ; private PrintStream out = null ; public void setInheritAll ( boolean value ) { inheritAll = value ; } public void setInheritRefs ( boolean value ) { inheritRefs = value ; } public void init ( ) { newProject = new Project ( ) ; newProject . setJavaVersionProperty ( ) ; newProject . addTaskDefinition ( "property" , ( Class ) project . getTaskDefinitions ( ) . get ( "property" ) ) ; } private void reinit ( ) { init ( ) ; final int count = properties . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Property p = ( Property ) properties . elementAt ( i ) ; Property newP = ( Property ) newProject . createTask ( "property" ) ; newP . setName ( p . getName ( ) ) ; if ( p . getValue ( ) != null ) { newP . setValue ( p . getValue ( ) ) ; } if ( p . getFile ( ) != null ) { newP . setFile ( p . getFile ( ) ) ; } if ( p . getResource ( ) != null ) { newP . setResource ( p . getResource ( ) ) ; } if ( p . getPrefix ( ) != null ) { newP . setPrefix ( p . getPrefix ( ) ) ; } if ( p . getRefid ( ) != null ) { newP . setRefid ( p . getRefid ( ) ) ; } if ( p . getEnvironment ( ) != null ) { newP . setEnvironment ( p . getEnvironment ( ) ) ; } if ( p . getClasspath ( ) != null ) { newP . setClasspath ( p . getClasspath ( ) ) ; } properties . setElementAt ( newP , i ) ; } } private void initializeProject ( ) { newProject . setInputHandler ( getProject ( ) . getInputHandler ( ) ) ; Vector listeners = project . getBuildListeners ( ) ; final int count = listeners . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { newProject . addBuildListener ( ( BuildListener ) listeners . elementAt ( i ) ) ; } if ( output != null ) { File outfile = null ; if ( dir != null ) { outfile = FileUtils . newFileUtils ( ) . resolveFile ( dir , output ) ; } else { outfile = getProject ( ) . resolveFile ( output ) ; } try { out = new PrintStream ( new FileOutputStream ( outfile ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; newProject . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } Hashtable taskdefs = project . getTaskDefinitions ( ) ; Enumeration et = taskdefs . keys ( ) ; while ( et . hasMoreElements ( ) ) { String taskName = ( String ) et . nextElement ( ) ; if ( taskName . equals ( "property" ) ) { continue ; } Class taskClass = ( Class ) taskdefs . get ( taskName ) ; newProject . addTaskDefinition ( taskName , taskClass ) ; } Hashtable typedefs = project . getDataTypeDefinitions ( ) ; Enumeration e = typedefs . keys ( ) ; while ( e . hasMoreElements ( ) ) { String typeName = ( String ) e . nextElement ( ) ; Class typeClass = ( Class ) typedefs . get ( typeName ) ; newProject . addDataTypeDefinition ( typeName , typeClass ) ; } getProject ( ) . copyUserProperties ( newProject ) ; if ( ! inheritAll ) { newProject . setSystemProperties ( ) ; } else { Hashtable props = getProject ( ) . getProperties ( ) ; e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = e . nextElement ( ) . toString ( ) ; if ( "basedir" . equals ( arg ) || "ant.file" . equals ( arg ) ) { continue ; } String value = props . get ( arg ) . toString ( ) ; if ( newProject . getProperty ( arg ) == null ) { newProject . setNewProperty ( arg , value ) ; } } } } protected void handleOutput ( String line ) { if ( newProject != null ) { newProject . demuxOutput ( line , false ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( newProject != null ) { newProject . demuxOutput ( line , true ) ; } else { super . handleErrorOutput ( line ) ; } } public void execute ( ) throws BuildException { File savedDir = dir ; String savedAntFile = antFile ; String savedTarget = target ; try { if ( newProject == null ) { reinit ( ) ; } if ( ( dir == null ) && ( inheritAll ) ) { dir = project . getBaseDir ( ) ; } initializeProject ( ) ; if ( dir != null ) { newProject . setBaseDir ( dir ) ; if ( savedDir != null ) { newProject . setInheritedProperty ( "basedir" , dir . getAbsolutePath ( ) ) ; } } else { dir = project . getBaseDir ( ) ; } overrideProperties ( ) ; if ( antFile == null ) { antFile = "build.xml" ; } File file = FileUtils . newFileUtils ( ) . resolveFile ( dir , antFile ) ; antFile = file . getAbsolutePath ( ) ; log ( "calling target " + ( target != null ? target : "[default]" ) + " in build file " + antFile . toString ( ) , Project . MSG_VERBOSE ) ; newProject . setUserProperty ( "ant.file" , antFile ) ; ProjectHelper . configureProject ( newProject , new File ( antFile ) ) ; if ( target == null ) { target = newProject . getDefaultTarget ( ) ; } addReferences ( ) ; if ( newProject . getBaseDir ( ) . equals ( project . getBaseDir ( ) ) && newProject . getProperty ( "ant.file" ) . equals ( project . getProperty ( "ant.file" ) ) && getOwningTarget ( ) != null && target . equals ( this . getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "ant task calling its own parent " + "target" ) ; } newProject . executeTarget ( target ) ; } finally { newProject = null ; if ( output != null && out != null ) { try { out . close ( ) ; } catch ( final Exception e ) { } } dir = savedDir ; antFile = savedAntFile ; target = savedTarget ; } } private void overrideProperties ( ) throws BuildException { Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( newProject ) ; p . execute ( ) ; } getProject ( ) . copyInheritedProperties ( newProject ) ; } private void addReferences ( ) throws BuildException { Hashtable thisReferences = ( Hashtable ) project . getReferences ( ) . clone ( ) ; Hashtable newReferences = newProject . getReferences ( ) ; Enumeration e ; if ( references . size ( ) > 0 ) { for ( e = references . elements ( ) ; e . hasMoreElements ( ) ; ) { Reference ref = ( Reference ) e . nextElement ( ) ; String refid = ref . getRefId ( ) ; if ( refid == null ) { throw new BuildException ( "the refid attribute is required" + " for reference elements" ) ; } if ( ! thisReferences . containsKey ( refid ) ) { log ( "Parent project doesn't contain any reference '" + refid + "'" , Project . MSG_WARN ) ; continue ; } thisReferences . remove ( refid ) ; String toRefid = ref . getToRefid ( ) ; if ( toRefid == null ) { toRefid = refid ; } copyReference ( refid , toRefid ) ; } } if ( inheritRefs ) { for ( e = thisReferences . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( newReferences . containsKey ( key ) ) { continue ; } copyReference ( key , key ) ; } } } private void copyReference ( String oldKey , String newKey ) { Object orig = project . getReference ( oldKey ) ; Class c = orig . getClass ( ) ; Object copy = orig ; try { Method cloneM = c . getMethod ( "clone" , new Class [ 0 ] ) ; if ( cloneM != null ) { copy = cloneM . invoke ( orig , new Object [ 0 ] ) ; } } catch ( Exception e ) { } if ( copy instanceof ProjectComponent ) { ( ( ProjectComponent ) copy ) . setProject ( newProject ) ; } else { try { Method setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( copy , new Object [ ] { newProject } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception e2 ) { String msg = "Error setting new project instance for " + "reference with id " + oldKey ; throw new BuildException ( msg , e2 , location ) ; } } newProject . addReference ( newKey , copy ) ; } public void setDir ( File d ) { this . dir = d ; } public void setAntfile ( String s ) { this . antFile = s ; } public void setTarget ( String s ) { this . target = s ; } public void setOutput ( String s ) { this . output = s ; } public Property createProperty ( ) { if ( newProject == null ) { reinit ( ) ; } Property p = new Property ( true , getProject ( ) ) ; p . setProject ( newProject ) ; p . setTaskName ( "property" ) ; properties . addElement ( p ) ; return p ; } public void addReference ( Reference r ) { references . addElement ( r ) ; } public static class Reference extends org . apache . tools . ant . types . Reference { public Reference ( ) { super ( ) ; } private String targetid = null ; public void setToRefid ( String targetid ) { this . targetid = targetid ; } public String getToRefid ( ) { return targetid ; } } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import java . io . File ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . FileReader ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import java . sql . Connection ; import java . sql . Statement ; import java . sql . SQLException ; import java . sql . SQLWarning ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; public class SQLExec extends JDBCTask { public static class DelimiterType extends EnumeratedAttribute { public static final String NORMAL = "normal" ; public static final String ROW = "row" ; public String [ ] getValues ( ) { return new String [ ] { NORMAL , ROW } ; } } private int goodSql = 0 ; private int totalSql = 0 ; private Connection conn = null ; private Vector filesets = new Vector ( ) ; private Statement statement = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private File output = null ; private String onError = "abort" ; private String encoding = null ; private boolean append = false ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . delimiterType = delimiterType . getValue ( ) ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setOutput ( File output ) { this . output = output ; } public void setAppend ( boolean append ) { this . append = append ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void execute ( ) throws BuildException { Vector savedTransaction = ( Vector ) transactions . clone ( ) ; String savedSqlCommand = sqlCommand ; sqlCommand = sqlCommand . trim ( ) ; try { if ( srcFile == null && sqlCommand . length ( ) == 0 && filesets . isEmpty ( ) ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file or fileset, " + "transactions or sql statement " + "must be set!" , location ) ; } } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , location ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File srcDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { Transaction t = createTransaction ( ) ; t . setSrc ( new File ( srcDir , srcFiles [ j ] ) ) ; } } Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; conn = getConnection ( ) ; if ( ! isValidRdbms ( conn ) ) { return ; } try { statement = conn . createStatement ( ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getAbsolutePath ( ) , append ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! isAutocommit ( ) ) { log ( "Commiting transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } catch ( SQLException e ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } finally { transactions = savedTransaction ; sqlCommand = savedSqlCommand ; } } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { String sql = "" ; String line = "" ; BufferedReader in = new BufferedReader ( reader ) ; while ( ( line = in . readLine ( ) ) != null ) { line = line . trim ( ) ; line = project . replaceProperties ( line ) ; if ( line . startsWith ( "//" ) ) { continue ; } if ( line . startsWith ( "--" ) ) { continue ; } StringTokenizer st = new StringTokenizer ( line ) ; if ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( "REM" . equalsIgnoreCase ( token ) ) { continue ; } } sql += " " + line ; sql = sql . trim ( ) ; if ( line . indexOf ( "--" ) >= 0 ) { sql += "\n" ; } if ( ( delimiterType . equals ( DelimiterType . NORMAL ) && sql . endsWith ( delimiter ) ) || ( delimiterType . equals ( DelimiterType . ROW ) && line . equals ( delimiter ) ) ) { log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; execSQL ( sql . substring ( 0 , sql . length ( ) - delimiter . length ( ) ) , out ) ; sql = "" ; } } if ( ! sql . equals ( "" ) ) { execSQL ( sql , out ) ; } } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) { return ; } try { totalSql ++ ; if ( ! statement . execute ( sql ) ) { log ( statement . getUpdateCount ( ) + " rows affected" , Project . MSG_VERBOSE ) ; } else { if ( print ) { printResults ( out ) ; } } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) { throw e ; } log ( e . toString ( ) , Project . MSG_ERR ) ; } } protected void printResults ( PrintStream out ) throws java . sql . SQLException { ResultSet rs = null ; do { rs = statement . getResultSet ( ) ; if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line . setLength ( 0 ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line . setLength ( 0 ) ; } } } while ( statement . getMoreResults ( ) ) ; out . println ( ) ; } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private File tSrcFile = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { this . tSrcFile = src ; } public void addText ( String sql ) { this . tSqlCommand += sql ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcFile != null ) { log ( "Executing file: " + tSrcFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; Reader reader = ( encoding == null ) ? new FileReader ( tSrcFile ) : new InputStreamReader ( new FileInputStream ( tSrcFile ) , encoding ) ; try { runStatements ( reader , out ) ; } finally { reader . close ( ) ; } } } } } 	1
package org . apache . tools . ant ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . io . File ; import java . io . FileInputStream ; import java . io . PrintStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Vector ; import java . util . Properties ; import java . util . Enumeration ; public class Main { public static final String DEFAULT_BUILD_FILENAME = "build.xml" ; private int msgOutputLevel = Project . MSG_INFO ; private File buildFile ; private static PrintStream out = System . out ; private static PrintStream err = System . err ; private Vector targets = new Vector ( 5 ) ; private Properties definedProps = new Properties ( ) ; private Vector listeners = new Vector ( 5 ) ; private Vector propertyFiles = new Vector ( 5 ) ; private String loggerClassname = null ; private String inputHandlerClassname = null ; private boolean emacsMode = false ; private boolean readyToRun = false ; private boolean projectHelp = false ; private static boolean isLogFileUsed = false ; private static void printMessage ( Throwable t ) { String message = t . getMessage ( ) ; if ( message != null ) { System . err . println ( message ) ; } } public static void start ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { Main m = null ; try { Diagnostics . validateVersion ( ) ; m = new Main ( args ) ; } catch ( Throwable exc ) { printMessage ( exc ) ; System . exit ( 1 ) ; } if ( additionalUserProperties != null ) { for ( Enumeration e = additionalUserProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String property = additionalUserProperties . getProperty ( key ) ; m . definedProps . put ( key , property ) ; } } try { m . runBuild ( coreLoader ) ; System . exit ( 0 ) ; } catch ( BuildException be ) { if ( m . err != System . err ) { printMessage ( be ) ; } System . exit ( 1 ) ; } catch ( Throwable exc ) { exc . printStackTrace ( ) ; printMessage ( exc ) ; System . exit ( 1 ) ; } finally { if ( isLogFileUsed ) { if ( out != null ) { try { out . close ( ) ; } catch ( final Exception e ) { } } if ( err != null ) { try { err . close ( ) ; } catch ( final Exception e ) { } } } } } public static void main ( String [ ] args ) { start ( args , null , null ) ; } protected Main ( String [ ] args ) throws BuildException { String searchForThis = null ; PrintStream logTo = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( "-help" ) ) { printUsage ( ) ; return ; } else if ( arg . equals ( "-version" ) ) { printVersion ( ) ; return ; } else if ( arg . equals ( "-diagnostics" ) ) { Diagnostics . doReport ( System . out ) ; return ; } else if ( arg . equals ( "-quiet" ) || arg . equals ( "-q" ) ) { msgOutputLevel = Project . MSG_WARN ; } else if ( arg . equals ( "-verbose" ) || arg . equals ( "-v" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_VERBOSE ; } else if ( arg . equals ( "-debug" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_DEBUG ; } else if ( arg . equals ( "-logfile" ) || arg . equals ( "-l" ) ) { try { File logFile = new File ( args [ i + 1 ] ) ; i ++ ; logTo = new PrintStream ( new FileOutputStream ( logFile ) ) ; isLogFileUsed = true ; } catch ( IOException ioe ) { String msg = "Cannot write on the specified log file. " + "Make sure the path exists and you have write " + "permissions." ; System . out . println ( msg ) ; return ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a log file when " + "using the -log argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-buildfile" ) || arg . equals ( "-file" ) || arg . equals ( "-f" ) ) { try { buildFile = new File ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a buildfile when " + "using the -buildfile argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-listener" ) ) { try { listeners . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a classname when " + "using the -listener argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . startsWith ( "-D" ) ) { String name = arg . substring ( 2 , arg . length ( ) ) ; String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( posEq + 1 ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < args . length - 1 ) { value = args [ ++ i ] ; } definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( loggerClassname != null ) { System . out . println ( "Only one logger class may " + " be specified." ) ; return ; } try { loggerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { System . out . println ( "You must specify a classname when " + "using the -logger argument" ) ; return ; } } else if ( arg . equals ( "-inputhandler" ) ) { if ( inputHandlerClassname != null ) { System . out . println ( "Only one input handler class may " + "be specified." ) ; return ; } try { inputHandlerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { System . out . println ( "You must specify a classname when " + "using the -inputhandler argument" ) ; return ; } } else if ( arg . equals ( "-emacs" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) ) { if ( i < args . length - 1 ) { searchForThis = args [ ++ i ] ; } else { searchForThis = DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-propertyfile" ) ) { try { propertyFiles . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a property filename when " + "using the -propertyfile argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown argument: " + arg ; System . out . println ( msg ) ; printUsage ( ) ; return ; } else { targets . addElement ( arg ) ; } } if ( buildFile == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( System . getProperty ( "user.dir" ) , searchForThis ) ; } else { buildFile = new File ( DEFAULT_BUILD_FILENAME ) ; } } if ( ! buildFile . exists ( ) ) { System . out . println ( "Buildfile: " + buildFile + " does not exist!" ) ; throw new BuildException ( "Build failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( "What? Buildfile: " + buildFile + " is a dir!" ) ; throw new BuildException ( "Build failed" ) ; } for ( int propertyFileIndex = 0 ; propertyFileIndex < propertyFiles . size ( ) ; propertyFileIndex ++ ) { String filename = ( String ) propertyFiles . elementAt ( propertyFileIndex ) ; Properties props = new Properties ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( filename ) ; props . load ( fis ) ; } catch ( IOException e ) { System . out . println ( "Could not load property file " + filename + ": " + e . getMessage ( ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } } Enumeration propertyNames = props . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String name = ( String ) propertyNames . nextElement ( ) ; if ( definedProps . getProperty ( name ) == null ) { definedProps . put ( name , props . getProperty ( name ) ) ; } } } if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Buildfile: " + buildFile ) ; } if ( logTo != null ) { out = err = logTo ; System . setOut ( out ) ; System . setErr ( out ) ; } readyToRun = true ; } private File getParentFile ( File file ) { String filename = file . getAbsolutePath ( ) ; file = new File ( filename ) ; filename = file . getParent ( ) ; if ( filename != null && msgOutputLevel >= Project . MSG_VERBOSE ) { System . out . println ( "Searching in " + filename ) ; } return ( filename == null ) ? null : new File ( filename ) ; } private File findBuildFile ( String start , String suffix ) throws BuildException { if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Searching for " + suffix + " ..." ) ; } File parent = new File ( new File ( start ) . getAbsolutePath ( ) ) ; File file = new File ( parent , suffix ) ; while ( ! file . exists ( ) ) { parent = getParentFile ( parent ) ; if ( parent == null ) { throw new BuildException ( "Could not locate a build file!" ) ; } file = new File ( parent , suffix ) ; } return file ; } private void runBuild ( ClassLoader coreLoader ) throws BuildException { if ( ! readyToRun ) { return ; } final Project project = new Project ( ) ; project . setCoreLoader ( coreLoader ) ; Throwable error = null ; try { addBuildListeners ( project ) ; addInputHandler ( project ) ; PrintStream err = System . err ; PrintStream out = System . out ; SecurityManager oldsm = null ; if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { oldsm = System . getSecurityManager ( ) ; } try { System . setOut ( new PrintStream ( new DemuxOutputStream ( project , false ) ) ) ; System . setErr ( new PrintStream ( new DemuxOutputStream ( project , true ) ) ) ; if ( ! projectHelp ) { project . fireBuildStarted ( ) ; } project . init ( ) ; project . setUserProperty ( "ant.version" , getAntVersion ( ) ) ; Enumeration e = definedProps . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) definedProps . get ( arg ) ; project . setUserProperty ( arg , value ) ; } project . setUserProperty ( "ant.file" , buildFile . getAbsolutePath ( ) ) ; ProjectHelper . configureProject ( project , buildFile ) ; if ( projectHelp ) { printDescription ( project ) ; printTargets ( project , msgOutputLevel > Project . MSG_INFO ) ; return ; } if ( targets . size ( ) == 0 ) { targets . addElement ( project . getDefaultTarget ( ) ) ; } project . executeTargets ( targets ) ; } finally { if ( oldsm != null ) { System . setSecurityManager ( oldsm ) ; } System . setOut ( out ) ; System . setErr ( err ) ; } } catch ( RuntimeException exc ) { error = exc ; throw exc ; } catch ( Error err ) { error = err ; throw err ; } finally { if ( ! projectHelp ) { project . fireBuildFinished ( error ) ; } } } protected void addBuildListeners ( Project project ) { project . addBuildListener ( createLogger ( ) ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { String className = ( String ) listeners . elementAt ( i ) ; try { BuildListener listener = ( BuildListener ) Class . forName ( className ) . newInstance ( ) ; project . addBuildListener ( listener ) ; } catch ( Throwable exc ) { throw new BuildException ( "Unable to instantiate listener " + className , exc ) ; } } } private void addInputHandler ( Project project ) { InputHandler handler = null ; if ( inputHandlerClassname == null ) { handler = new DefaultInputHandler ( ) ; } else { try { handler = ( InputHandler ) ( Class . forName ( inputHandlerClassname ) . newInstance ( ) ) ; } catch ( ClassCastException e ) { String msg = "The specified input handler class " + inputHandlerClassname + " does not implement the InputHandler interface" ; throw new BuildException ( msg ) ; } catch ( Exception e ) { String msg = "Unable to instantiate specified input handler " + "class " + inputHandlerClassname + " : " + e . getClass ( ) . getName ( ) ; throw new BuildException ( msg ) ; } } project . setInputHandler ( handler ) ; } private BuildLogger createLogger ( ) { BuildLogger logger = null ; if ( loggerClassname != null ) { try { logger = ( BuildLogger ) ( Class . forName ( loggerClassname ) . newInstance ( ) ) ; } catch ( ClassCastException e ) { System . err . println ( "The specified logger class " + loggerClassname + " does not implement the BuildLogger interface" ) ; throw new RuntimeException ( ) ; } catch ( Exception e ) { System . err . println ( "Unable to instantiate specified logger " + "class " + loggerClassname + " : " + e . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( ) ; } } else { logger = new DefaultLogger ( ) ; } logger . setMessageOutputLevel ( msgOutputLevel ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( err ) ; logger . setEmacsMode ( emacsMode ) ; return logger ; } private static void printUsage ( ) { String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "ant [options] [target [target2 [target3] ...]]" + lSep ) ; msg . append ( "Options: " + lSep ) ; msg . append ( "  -help                  print this message" + lSep ) ; msg . append ( "  -projecthelp           print project help information" + lSep ) ; msg . append ( "  -version               print the version information and exit" + lSep ) ; msg . append ( "  -diagnostics           print information that might be helpful to" + lSep ) ; msg . append ( "                         diagnose or report problems." + lSep ) ; msg . append ( "  -quiet, -q             be extra quiet" + lSep ) ; msg . append ( "  -verbose, -v           be extra verbose" + lSep ) ; msg . append ( "  -debug                 print debugging information" + lSep ) ; msg . append ( "  -emacs                 produce logging information without adornments" + lSep ) ; msg . append ( "  -logfile <file>        use given file for log" + lSep ) ; msg . append ( "    -l     <file>                ''" + lSep ) ; msg . append ( "  -logger <classname>    the class which is to perform logging" + lSep ) ; msg . append ( "  -listener <classname>  add an instance of class as a project listener" + lSep ) ; msg . append ( "  -buildfile <file>      use given buildfile" + lSep ) ; msg . append ( "    -file    <file>              ''" + lSep ) ; msg . append ( "    -f       <file>              ''" + lSep ) ; msg . append ( "  -D<property>=<value>   use value for given property" + lSep ) ; msg . append ( "  -propertyfile <name>   load all properties from file with -D" + lSep ) ; msg . append ( "                         properties taking precedence" + lSep ) ; msg . append ( "  -inputhandler <class>  the class which will handle input requests" + lSep ) ; msg . append ( "  -find <file>           search for buildfile towards the root of the" + lSep ) ; msg . append ( "                         filesystem and use it" + lSep ) ; System . out . println ( msg . toString ( ) ) ; } private static void printVersion ( ) throws BuildException { System . out . println ( getAntVersion ( ) ) ; } private static String antVersion = null ; public static synchronized String getAntVersion ( ) throws BuildException { if ( antVersion == null ) { try { Properties props = new Properties ( ) ; InputStream in = Main . class . getResourceAsStream ( "/org/apache/tools/ant/version.txt" ) ; props . load ( in ) ; in . close ( ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "Apache Ant version " ) ; msg . append ( props . getProperty ( "VERSION" ) ) ; msg . append ( " compiled on " ) ; msg . append ( props . getProperty ( "DATE" ) ) ; antVersion = msg . toString ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not load the version information:" + ioe . getMessage ( ) ) ; } catch ( NullPointerException npe ) { throw new BuildException ( "Could not load the version information." ) ; } } return antVersion ; } private static void printDescription ( Project project ) { if ( project . getDescription ( ) != null ) { project . log ( project . getDescription ( ) ) ; } } private static void printTargets ( Project project , boolean printSubTargets ) { int maxLength = 0 ; Enumeration ptargets = project . getTargets ( ) . elements ( ) ; String targetName ; String targetDescription ; Target currentTarget ; Vector topNames = new Vector ( ) ; Vector topDescriptions = new Vector ( ) ; Vector subNames = new Vector ( ) ; while ( ptargets . hasMoreElements ( ) ) { currentTarget = ( Target ) ptargets . nextElement ( ) ; targetName = currentTarget . getName ( ) ; targetDescription = currentTarget . getDescription ( ) ; if ( targetDescription == null ) { int pos = findTargetPosition ( subNames , targetName ) ; subNames . insertElementAt ( targetName , pos ) ; } else { int pos = findTargetPosition ( topNames , targetName ) ; topNames . insertElementAt ( targetName , pos ) ; topDescriptions . insertElementAt ( targetDescription , pos ) ; if ( targetName . length ( ) > maxLength ) { maxLength = targetName . length ( ) ; } } } printTargets ( project , topNames , topDescriptions , "Main targets:" , maxLength ) ; if ( topNames . size ( ) == 0 ) { printSubTargets = true ; } if ( printSubTargets ) { printTargets ( project , subNames , null , "Subtargets:" , 0 ) ; } String defaultTarget = project . getDefaultTarget ( ) ; if ( defaultTarget != null && ! "" . equals ( defaultTarget ) ) { project . log ( "Default target: " + defaultTarget ) ; } } private static int findTargetPosition ( Vector names , String name ) { int res = names . size ( ) ; for ( int i = 0 ; i < names . size ( ) && res == names . size ( ) ; i ++ ) { if ( name . compareTo ( ( String ) names . elementAt ( i ) ) < 0 ) { res = i ; } } return res ; } private static void printTargets ( Project project , Vector names , Vector descriptions , String heading , int maxlen ) { String lSep = System . getProperty ( "line.separator" ) ; String spaces = "    " ; while ( spaces . length ( ) < maxlen ) { spaces += spaces ; } StringBuffer msg = new StringBuffer ( ) ; msg . append ( heading + lSep + lSep ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { msg . append ( " " ) ; msg . append ( names . elementAt ( i ) ) ; if ( descriptions != null ) { msg . append ( spaces . substring ( 0 , maxlen - ( ( String ) names . elementAt ( i ) ) . length ( ) + 2 ) ) ; msg . append ( descriptions . elementAt ( i ) ) ; } msg . append ( lSep ) ; } project . log ( msg . toString ( ) ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; class ProcessDestroyer extends Thread { private Vector processes = new Vector ( ) ; public ProcessDestroyer ( ) { try { Class [ ] paramTypes = { Thread . class } ; Method addShutdownHook = Runtime . class . getMethod ( "addShutdownHook" , paramTypes ) ; Object [ ] args = { this } ; addShutdownHook . invoke ( Runtime . getRuntime ( ) , args ) ; } catch ( Exception e ) { } } public boolean add ( Process process ) { processes . addElement ( process ) ; return processes . contains ( process ) ; } public boolean remove ( Process process ) { return processes . removeElement ( process ) ; } public void run ( ) { synchronized ( processes ) { Enumeration e = processes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( Process ) e . nextElement ( ) ) . destroy ( ) ; } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread inputThread ; private Thread errorThread ; private OutputStream out , err ; public PumpStreamHandler ( OutputStream out , OutputStream err ) { this . out = out ; this . err = err ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { createProcessErrorPump ( is , err ) ; } public void setProcessInputStream ( OutputStream os ) { } public void start ( ) { inputThread . start ( ) ; errorThread . start ( ) ; } public void stop ( ) { try { inputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } try { err . flush ( ) ; } catch ( IOException e ) { } try { out . flush ( ) ; } catch ( IOException e ) { } } protected OutputStream getErr ( ) { return err ; } protected OutputStream getOut ( ) { return out ; } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { inputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { final Thread result = new Thread ( new StreamPumper ( is , os ) ) ; result . setDaemon ( true ) ; return result ; } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . io . PrintStream ; public class ExecuteJava implements Runnable , TimeoutObserver { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; private Method main = null ; private Long timeout = null ; private Throwable caught = null ; private boolean timedOut = false ; private Thread thread = null ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setOutput ( PrintStream out ) { } public void setTimeout ( Long timeout ) { this . timeout = timeout ; } public void execute ( Project project ) throws BuildException { final String classname = javaCommand . getExecutable ( ) ; AntClassLoader loader = null ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) } ; Class target = null ; if ( classpath == null ) { target = Class . forName ( classname ) ; } else { loader = new AntClassLoader ( project . getCoreLoader ( ) , project , classpath , false ) ; loader . setIsolated ( true ) ; loader . setThreadContextLoader ( ) ; target = loader . forceLoadClass ( classname ) ; AntClassLoader . initializeClass ( target ) ; } main = target . getMethod ( "main" , param ) ; if ( main == null ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } if ( timeout == null ) { run ( ) ; } else { thread = new Thread ( this , "ExecuteJava" ) ; Task currentThreadTask = project . getThreadTask ( Thread . currentThread ( ) ) ; project . registerThreadTask ( thread , currentThreadTask ) ; thread . setDaemon ( true ) ; Watchdog w = new Watchdog ( timeout . longValue ( ) ) ; w . addTimeoutObserver ( this ) ; synchronized ( this ) { thread . start ( ) ; w . start ( ) ; try { wait ( ) ; } catch ( InterruptedException e ) { } if ( timedOut ) { project . log ( "Timeout: sub-process interrupted" , Project . MSG_WARN ) ; } else { thread = null ; w . stop ( ) ; } } } if ( caught != null ) { throw caught ; } } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + "." + " Make sure you have it in your" + " classpath" ) ; } catch ( SecurityException e ) { throw e ; } catch ( Throwable e ) { throw new BuildException ( e ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; } if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } } } public void run ( ) { final Object [ ] argument = { javaCommand . getArguments ( ) } ; try { main . invoke ( null , argument ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof InterruptedException ) ) { caught = t ; } } catch ( Throwable t ) { caught = t ; } finally { synchronized ( this ) { notifyAll ( ) ; } } } public synchronized void timeoutOccured ( Watchdog w ) { if ( thread != null ) { timedOut = true ; thread . interrupt ( ) ; } notifyAll ( ) ; } public boolean killedProcess ( ) { return timedOut ; } } 	1
package org . apache . tools . ant . util ; import java . io . BufferedInputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . lang . reflect . Method ; import java . text . DecimalFormat ; import java . util . Random ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import java . net . URL ; import java . net . MalformedURLException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . taskdefs . condition . Os ; public class FileUtils { private static Random rand = new Random ( System . currentTimeMillis ( ) ) ; private static Object lockReflection = new Object ( ) ; private static java . lang . reflect . Method setLastModified = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; public static FileUtils newFileUtils ( ) { return new FileUtils ( ) ; } protected FileUtils ( ) { } public URL getFileURL ( File file ) throws MalformedURLException { String uri = "file:" + file . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; for ( int i = uri . indexOf ( '#' ) ; i != - 1 ; i = uri . indexOf ( '#' ) ) { uri = uri . substring ( 0 , i ) + "%23" + uri . substring ( i + 1 ) ; } if ( file . isDirectory ( ) ) { uri += "/" ; } return new URL ( uri ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , null , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified , encoding ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , encoding , project ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , null , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { copyFile ( sourceFile , destFile , filters , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , preserveLastModified , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( sourceFile , destFile , filters , null , overwrite , preserveLastModified , encoding , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { if ( overwrite || ! destFile . exists ( ) || destFile . lastModified ( ) < sourceFile . lastModified ( ) ) { if ( destFile . exists ( ) && destFile . isFile ( ) ) { destFile . delete ( ) ; } File parent = getParentFile ( destFile ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } final boolean filterSetsAvailable = ( filters != null && filters . hasFilters ( ) ) ; final boolean filterChainsAvailable = ( filterChains != null && filterChains . size ( ) > 0 ) ; if ( filterSetsAvailable || filterChainsAvailable ) { BufferedReader in = null ; BufferedWriter out = null ; try { if ( encoding == null ) { in = new BufferedReader ( new FileReader ( sourceFile ) ) ; out = new BufferedWriter ( new FileWriter ( destFile ) ) ; } else { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sourceFile ) , encoding ) ) ; out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( destFile ) , encoding ) ) ; } if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( 8192 ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } int length ; String newline = null ; String line = in . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { if ( filterSetsAvailable ) { newline = filters . replaceTokens ( line ) ; } else { newline = line ; } out . write ( newline ) ; out . newLine ( ) ; } line = in . readLine ( ) ; } } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } else { FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( sourceFile ) ; out = new FileOutputStream ( destFile ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } if ( preserveLastModified ) { setFileLastModified ( destFile , sourceFile . lastModified ( ) ) ; } } } protected final Method getSetLastModified ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return null ; } if ( setLastModified == null ) { synchronized ( lockReflection ) { if ( setLastModified == null ) { try { setLastModified = java . io . File . class . getMethod ( "setLastModified" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { throw new BuildException ( "File.setlastModified not in JDK > 1.1?" , nse ) ; } } } } return setLastModified ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return ; } Long [ ] times = new Long [ 1 ] ; if ( time < 0 ) { times [ 0 ] = new Long ( System . currentTimeMillis ( ) ) ; } else { times [ 0 ] = new Long ( time ) ; } try { getSetLastModified ( ) . invoke ( file , times ) ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new BuildException ( "Exception setting the modification time " + "of " + file , nested ) ; } catch ( Throwable other ) { throw new BuildException ( "Exception setting the modification time " + "of " + file , other ) ; } } public File resolveFile ( File file , String filename ) { filename = filename . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( ! onNetWare ) { if ( filename . startsWith ( File . separator ) || ( filename . length ( ) >= 2 && Character . isLetter ( filename . charAt ( 0 ) ) && filename . charAt ( 1 ) == ':' ) ) { return normalize ( filename ) ; } } else { int colon = filename . indexOf ( ":" ) ; if ( filename . startsWith ( File . separator ) || ( colon > - 1 ) ) { return normalize ( filename ) ; } } if ( file == null ) { return new File ( filename ) ; } File helpFile = new File ( file . getAbsolutePath ( ) ) ; StringTokenizer tok = new StringTokenizer ( filename , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String part = tok . nextToken ( ) ; if ( part . equals ( ".." ) ) { helpFile = getParentFile ( helpFile ) ; if ( helpFile == null ) { String msg = "The file or path you specified (" + filename + ") is invalid relative to " + file . getPath ( ) ; throw new BuildException ( msg ) ; } } else if ( part . equals ( "." ) ) { } else { helpFile = new File ( helpFile , part ) ; } } return new File ( helpFile . getAbsolutePath ( ) ) ; } public File normalize ( String path ) { String orig = path ; path = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; int colon = path . indexOf ( ":" ) ; if ( ! onNetWare ) { if ( ! path . startsWith ( File . separator ) && ! ( path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && colon == 1 ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } } else { if ( ! path . startsWith ( File . separator ) && ( colon == - 1 ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } } boolean dosWithDrive = false ; String root = null ; if ( ( ! onNetWare && path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && path . charAt ( 1 ) == ':' ) || ( onNetWare && colon > - 1 ) ) { dosWithDrive = true ; char [ ] ca = path . replace ( '/' , '\\' ) . toCharArray ( ) ; StringBuffer sbRoot = new StringBuffer ( ) ; for ( int i = 0 ; i < colon ; i ++ ) { sbRoot . append ( Character . toUpperCase ( ca [ i ] ) ) ; } sbRoot . append ( ':' ) ; if ( colon + 1 < path . length ( ) ) { sbRoot . append ( File . separatorChar ) ; } root = sbRoot . toString ( ) ; StringBuffer sbPath = new StringBuffer ( ) ; for ( int i = colon + 1 ; i < ca . length ; i ++ ) { if ( ( ca [ i ] != '\\' ) || ( ca [ i ] == '\\' && ca [ i - 1 ] != '\\' ) ) { sbPath . append ( ca [ i ] ) ; } } path = sbPath . toString ( ) . replace ( '\\' , File . separatorChar ) ; } else { if ( path . length ( ) == 1 ) { root = File . separator ; path = "" ; } else if ( path . charAt ( 1 ) == File . separatorChar ) { root = File . separator + File . separator ; path = path . substring ( 2 ) ; } else { root = File . separator ; path = path . substring ( 1 ) ; } } Stack s = new Stack ( ) ; s . push ( root ) ; StringTokenizer tok = new StringTokenizer ( path , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String thisToken = tok . nextToken ( ) ; if ( "." . equals ( thisToken ) ) { continue ; } else if ( ".." . equals ( thisToken ) ) { if ( s . size ( ) < 2 ) { throw new BuildException ( "Cannot resolve path " + orig ) ; } else { s . pop ( ) ; } } else { s . push ( thisToken ) ; } } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i > 1 ) { sb . append ( File . separatorChar ) ; } sb . append ( s . elementAt ( i ) ) ; } path = sb . toString ( ) ; if ( dosWithDrive ) { path = path . replace ( '/' , '\\' ) ; } return new File ( path ) ; } public File createTempFile ( String prefix , String suffix , File parentDir ) { File result = null ; String parent = null ; if ( parentDir != null ) { parent = parentDir . getPath ( ) ; } DecimalFormat fmt = new DecimalFormat ( "#####" ) ; synchronized ( rand ) { do { result = new File ( parent , prefix + fmt . format ( rand . nextInt ( ) ) + suffix ) ; } while ( result . exists ( ) ) ; } return result ; } public boolean contentEquals ( File f1 , File f2 ) throws IOException { if ( f1 . exists ( ) != f2 . exists ( ) ) { return false ; } if ( ! f1 . exists ( ) ) { return true ; } if ( f1 . isDirectory ( ) || f2 . isDirectory ( ) ) { return false ; } if ( f1 . equals ( f2 ) ) { return true ; } if ( f1 . length ( ) != f2 . length ( ) ) { return false ; } InputStream in1 = null ; InputStream in2 = null ; try { in1 = new BufferedInputStream ( new FileInputStream ( f1 ) ) ; in2 = new BufferedInputStream ( new FileInputStream ( f2 ) ) ; int expectedByte = in1 . read ( ) ; while ( expectedByte != - 1 ) { if ( expectedByte != in2 . read ( ) ) { return false ; } expectedByte = in1 . read ( ) ; } if ( in2 . read ( ) != - 1 ) { return false ; } return true ; } finally { if ( in1 != null ) { try { in1 . close ( ) ; } catch ( IOException e ) { } } if ( in2 != null ) { try { in2 . close ( ) ; } catch ( IOException e ) { } } } } public File getParentFile ( File f ) { if ( f != null ) { String p = f . getParent ( ) ; if ( p != null ) { return new File ( p ) ; } } return null ; } public static final String readFully ( Reader rdr ) throws IOException { return readFully ( rdr , 8192 ) ; } public static final String readFully ( Reader rdr , int bufferSize ) throws IOException { if ( bufferSize <= 0 ) { throw new IllegalArgumentException ( "Buffer size must be greater " + "than 0" ) ; } final char [ ] buffer = new char [ bufferSize ] ; int bufferLength = 0 ; String text = null ; StringBuffer textBuffer = null ; while ( bufferLength != - 1 ) { bufferLength = rdr . read ( buffer ) ; if ( bufferLength != - 1 ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( new String ( buffer , 0 , bufferLength ) ) ; } else { textBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; } } } if ( textBuffer != null ) { text = textBuffer . toString ( ) ; } return text ; } public boolean createNewFile ( File f ) throws IOException { if ( f != null ) { if ( f . exists ( ) ) { return false ; } FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; fos . write ( new byte [ 0 ] ) ; } finally { if ( fos != null ) { fos . close ( ) ; } } return true ; } return false ; } public boolean isSymbolicLink ( File parent , String name ) throws IOException { File resolvedParent = new File ( parent . getCanonicalPath ( ) ) ; File toTest = new File ( resolvedParent , name ) ; return ! toTest . getAbsolutePath ( ) . equals ( toTest . getCanonicalPath ( ) ) ; } public String removeLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) + File . separator ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( p . startsWith ( l ) ) { return p . substring ( l . length ( ) ) ; } else { return p ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . util . StringUtils ; public abstract class AbstractCvsTask extends Task { public static final int DEFAULT_COMPRESSION_LEVEL = 3 ; private Commandline cmd = new Commandline ( ) ; private Vector vecCommandlines = new Vector ( ) ; private String cvsRoot ; private String cvsRsh ; private String cvsPackage ; private static final String default_command = "checkout" ; private String command = null ; private boolean quiet = false ; private int compression = 0 ; private boolean noexec = false ; private int port = 0 ; private File passFile = null ; private File dest ; private boolean append = false ; private File output ; private File error ; private boolean failOnError = false ; private ExecuteStreamHandler executeStreamHandler ; private OutputStream outputStream ; private OutputStream errorStream ; public AbstractCvsTask ( ) { super ( ) ; } public void setExecuteStreamHandler ( ExecuteStreamHandler handler ) { this . executeStreamHandler = handler ; } protected ExecuteStreamHandler getExecuteStreamHandler ( ) { if ( this . executeStreamHandler == null ) { setExecuteStreamHandler ( new PumpStreamHandler ( getOutputStream ( ) , getErrorStream ( ) ) ) ; } return this . executeStreamHandler ; } protected void setOutputStream ( OutputStream outputStream ) { this . outputStream = outputStream ; } protected OutputStream getOutputStream ( ) { if ( this . outputStream == null ) { if ( output != null ) { try { setOutputStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { setOutputStream ( new LogOutputStream ( this , Project . MSG_INFO ) ) ; } } return this . outputStream ; } protected void setErrorStream ( OutputStream errorStream ) { this . errorStream = errorStream ; } protected OutputStream getErrorStream ( ) { if ( this . errorStream == null ) { if ( error != null ) { try { setErrorStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { setErrorStream ( new LogOutputStream ( this , Project . MSG_WARN ) ) ; } } return this . errorStream ; } protected void runCommand ( Commandline toExecute ) throws BuildException { Environment env = new Environment ( ) ; if ( port > 0 ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_CLIENT_PORT" ) ; var . setValue ( String . valueOf ( port ) ) ; env . addVariable ( var ) ; } if ( passFile == null ) { File defaultPassFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; if ( defaultPassFile . exists ( ) ) this . setPassfile ( defaultPassFile ) ; } if ( passFile != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_PASSFILE" ) ; var . setValue ( String . valueOf ( passFile ) ) ; env . addVariable ( var ) ; log ( "Using cvs passfile: " + String . valueOf ( passFile ) , Project . MSG_INFO ) ; } if ( cvsRsh != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_RSH" ) ; var . setValue ( String . valueOf ( cvsRsh ) ) ; env . addVariable ( var ) ; } Execute exe = new Execute ( getExecuteStreamHandler ( ) , null ) ; exe . setAntRun ( project ) ; if ( dest == null ) { dest = project . getBaseDir ( ) ; } if ( ! dest . exists ( ) ) { dest . mkdirs ( ) ; } exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; exe . setEnvironment ( env . getVariables ( ) ) ; try { String actualCommandLine = executeToString ( exe ) ; log ( actualCommandLine , Project . MSG_VERBOSE ) ; int retCode = exe . execute ( ) ; log ( "retCode=" + retCode , Project . MSG_DEBUG ) ; if ( failOnError && retCode != 0 ) { throw new BuildException ( "cvs exited with error code " + retCode + StringUtils . LINE_SEP + "Command line was [" + actualCommandLine + "]" , location ) ; } } catch ( IOException e ) { if ( failOnError ) { throw new BuildException ( e , location ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } catch ( BuildException e ) { if ( failOnError ) { throw ( e ) ; } else { Throwable t = e . getException ( ) ; if ( t == null ) { t = e ; } log ( "Caught exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e , location ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } finally { if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( IOException e ) { } } if ( errorStream != null ) { try { errorStream . close ( ) ; } catch ( IOException e ) { } } } } public void execute ( ) throws BuildException { String savedCommand = getCommand ( ) ; if ( this . getCommand ( ) == null && vecCommandlines . size ( ) == 0 ) { this . setCommand ( AbstractCvsTask . default_command ) ; } String c = this . getCommand ( ) ; Commandline cloned = null ; if ( c != null ) { cloned = ( Commandline ) cmd . clone ( ) ; cloned . createArgument ( true ) . setLine ( c ) ; this . addConfiguredCommandline ( cloned , true ) ; } try { for ( int i = 0 ; i < vecCommandlines . size ( ) ; i ++ ) { this . runCommand ( ( Commandline ) vecCommandlines . elementAt ( i ) ) ; } } finally { if ( cloned != null ) { removeCommandline ( cloned ) ; } setCommand ( savedCommand ) ; } } private String executeToString ( Execute execute ) { StringBuffer stringBuffer = new StringBuffer ( Commandline . describeCommand ( execute . getCommandline ( ) ) ) ; String newLine = StringUtils . LINE_SEP ; String [ ] variableArray = execute . getEnvironment ( ) ; if ( variableArray != null ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( newLine ) ; stringBuffer . append ( "environment:" ) ; stringBuffer . append ( newLine ) ; for ( int z = 0 ; z < variableArray . length ; z ++ ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( "\t" ) ; stringBuffer . append ( variableArray [ z ] ) ; } } return stringBuffer . toString ( ) ; } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) { root = null ; } } this . cvsRoot = root ; } public String getCvsRoot ( ) { return this . cvsRoot ; } public void setCvsRsh ( String rsh ) { if ( rsh != null ) { if ( rsh . trim ( ) . equals ( "" ) ) { rsh = null ; } } this . cvsRsh = rsh ; } public String getCvsRsh ( ) { return this . cvsRsh ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return this . port ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public File getPassFile ( ) { return this . passFile ; } public void setDest ( File dest ) { this . dest = dest ; } public File getDest ( ) { return this . dest ; } public void setPackage ( String p ) { this . cvsPackage = p ; } public String getPackage ( ) { return this . cvsPackage ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-r" ) ; addCommandArgument ( p ) ; } } public void addCommandArgument ( String arg ) { this . addCommandArgument ( cmd , arg ) ; } public void addCommandArgument ( Commandline c , String arg ) { c . createArgument ( ) . setValue ( arg ) ; } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-D" ) ; addCommandArgument ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public String getCommand ( ) { return this . command ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setAppend ( boolean value ) { this . append = value ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } protected void configureCommandline ( Commandline c ) { if ( c == null ) { return ; } c . setExecutable ( "cvs" ) ; if ( cvsPackage != null ) { c . createArgument ( ) . setLine ( cvsPackage ) ; } if ( this . compression > 0 && this . compression < 10 ) { c . createArgument ( true ) . setValue ( "-z" + this . compression ) ; } if ( quiet ) { c . createArgument ( true ) . setValue ( "-q" ) ; } if ( noexec ) { c . createArgument ( true ) . setValue ( "-n" ) ; } if ( cvsRoot != null ) { c . createArgument ( true ) . setLine ( "-d" + cvsRoot ) ; } } protected void removeCommandline ( Commandline c ) { vecCommandlines . removeElement ( c ) ; } public void addConfiguredCommandline ( Commandline c ) { this . addConfiguredCommandline ( c , false ) ; } public void addConfiguredCommandline ( Commandline c , boolean insertAtStart ) { if ( c == null ) { return ; } this . configureCommandline ( c ) ; if ( insertAtStart ) { vecCommandlines . insertElementAt ( c , 0 ) ; } else { vecCommandlines . addElement ( c ) ; } } public void setCompressionLevel ( int level ) { this . compression = level ; } public void setCompression ( boolean usecomp ) { setCompressionLevel ( usecomp ? AbstractCvsTask . DEFAULT_COMPRESSION_LEVEL : 0 ) ; } } 	1
package org . apache . tools . ant ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Stack ; public class XmlLogger implements BuildLogger { private int msgOutputLevel = Project . MSG_DEBUG ; private PrintStream outStream ; private static final DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private static final String STACKTRACE_TAG = "stacktrace" ; private Document doc = builder . newDocument ( ) ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private TimedElement buildElement = null ; private static class TimedElement { private long startTime ; private Element element ; } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildElement = new TimedElement ( ) ; buildElement . startTime = System . currentTimeMillis ( ) ; buildElement . element = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildElement . startTime ; buildElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . element . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; Throwable t = event . getException ( ) ; Text errText = doc . createCDATASection ( StringUtils . getStackTrace ( t ) ) ; Element stacktrace = doc . createElement ( STACKTRACE_TAG ) ; stacktrace . appendChild ( errText ) ; buildElement . element . appendChild ( stacktrace ) ; } String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } String xslUri = event . getProject ( ) . getProperty ( "ant.XmlLogger.stylesheet.uri" ) ; if ( xslUri == null ) { xslUri = "log.xsl" ; } Writer out = null ; try { OutputStream stream = outStream ; if ( stream == null ) { stream = new FileOutputStream ( outFilename ) ; } out = new OutputStreamWriter ( stream , "UTF8" ) ; out . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" ) ; if ( xslUri . length ( ) > 0 ) { out . write ( "<?xml-stylesheet type=\"text/xsl\" href=\"" + xslUri + "\"?>\n\n" ) ; } ( new DOMElementWriter ( ) ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to write log file" , exc ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { } } } buildElement = null ; } private Stack getStack ( ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack == null ) { threadStack = new Stack ( ) ; threadStacks . put ( Thread . currentThread ( ) , threadStack ) ; } return threadStack ; } public void targetStarted ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = new TimedElement ( ) ; targetElement . startTime = System . currentTimeMillis ( ) ; targetElement . element = doc . createElement ( TARGET_TAG ) ; targetElement . element . setAttribute ( NAME_ATTR , target . getName ( ) ) ; targets . put ( target , targetElement ) ; getStack ( ) . push ( targetElement ) ; } public void targetFinished ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement != null ) { long totalTime = System . currentTimeMillis ( ) - targetElement . startTime ; targetElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; TimedElement parentElement = null ; Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != targetElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished target element = " + targetElement . element ) ; } if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } if ( parentElement == null ) { buildElement . element . appendChild ( targetElement . element ) ; } else { parentElement . element . appendChild ( targetElement . element ) ; } } } public void taskStarted ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = new TimedElement ( ) ; taskElement . startTime = System . currentTimeMillis ( ) ; taskElement . element = doc . createElement ( TASK_TAG ) ; String name = event . getTask ( ) . getTaskName ( ) ; taskElement . element . setAttribute ( NAME_ATTR , name ) ; taskElement . element . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; tasks . put ( task , taskElement ) ; getStack ( ) . push ( taskElement ) ; } public void taskFinished ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = ( TimedElement ) tasks . get ( task ) ; if ( taskElement != null ) { long totalTime = System . currentTimeMillis ( ) - taskElement . startTime ; taskElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; Target target = task . getOwningTarget ( ) ; TimedElement targetElement = null ; if ( target != null ) { targetElement = ( TimedElement ) targets . get ( target ) ; } if ( targetElement == null ) { buildElement . element . appendChild ( taskElement . element ) ; } else { targetElement . element . appendChild ( taskElement . element ) ; } Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != taskElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished task element = " + taskElement . element ) ; } } } } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority > msgOutputLevel ) { return ; } Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Text messageText = doc . createCDATASection ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; TimedElement parentElement = null ; Task task = event . getTask ( ) ; Target target = event . getTarget ( ) ; if ( task != null ) { parentElement = ( TimedElement ) tasks . get ( task ) ; } if ( parentElement == null && target != null ) { parentElement = ( TimedElement ) targets . get ( target ) ; } if ( parentElement == null ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack != null ) { if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } } if ( parentElement != null ) { parentElement . element . appendChild ( messageElement ) ; } else { buildElement . element . appendChild ( messageElement ) ; } } public void setMessageOutputLevel ( int level ) { msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . outStream = new PrintStream ( output , true ) ; } public void setEmacsMode ( boolean emacsMode ) { } public void setErrorPrintStream ( PrintStream err ) { } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . taskdefs . condition . Os ; import java . io . File ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . ByteArrayOutputStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; public class Execute { public static final int INVALID = Integer . MAX_VALUE ; private String [ ] cmdl = null ; private String [ ] env = null ; private int exitValue = INVALID ; private ExecuteStreamHandler streamHandler ; private ExecuteWatchdog watchdog ; private File workingDirectory = null ; private Project project = null ; private boolean newEnvironment = false ; private boolean useVMLauncher = true ; private static String antWorkingDirectory = System . getProperty ( "user.dir" ) ; private static CommandLauncher vmLauncher = null ; private static CommandLauncher shellLauncher = null ; private static Vector procEnvironment = null ; private static ProcessDestroyer processDestroyer = new ProcessDestroyer ( ) ; static { try { vmLauncher = new Java13CommandLauncher ( ) ; } catch ( NoSuchMethodException exc ) { } if ( Os . isFamily ( "mac" ) ) { shellLauncher = new MacCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "os/2" ) ) { shellLauncher = new WinNTCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "windows" ) ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } if ( ! Os . isFamily ( "win9x" ) ) { shellLauncher = new WinNTCommandLauncher ( baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun.bat" , baseLauncher ) ; } } else if ( Os . isFamily ( "netware" ) ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } shellLauncher = new PerlScriptCommandLauncher ( "bin/antRun.pl" , baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun" , new CommandLauncher ( ) ) ; } } public static synchronized Vector getProcEnvironment ( ) { if ( procEnvironment != null ) { return procEnvironment ; } procEnvironment = new Vector ( ) ; try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Execute exe = new Execute ( new PumpStreamHandler ( out ) ) ; exe . setCommandline ( getProcEnvCommand ( ) ) ; exe . setNewenvironment ( true ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { } BufferedReader in = new BufferedReader ( new StringReader ( toString ( out ) ) ) ; String var = null ; String line , lineSep = System . getProperty ( "line.separator" ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . indexOf ( '=' ) == - 1 ) { if ( var == null ) { var = lineSep + line ; } else { var += lineSep + line ; } } else { if ( var != null ) { procEnvironment . addElement ( var ) ; } var = line ; } } if ( var != null ) { procEnvironment . addElement ( var ) ; } } catch ( java . io . IOException exc ) { exc . printStackTrace ( ) ; } return procEnvironment ; } private static String [ ] getProcEnvCommand ( ) { if ( Os . isFamily ( "os/2" ) ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else if ( Os . isFamily ( "windows" ) ) { if ( ! Os . isFamily ( "win9x" ) ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else { String [ ] cmd = { "command.com" , "/c" , "set" } ; return cmd ; } } else if ( Os . isFamily ( "z/os" ) ) { String [ ] cmd = { "/bin/env" } ; return cmd ; } else if ( Os . isFamily ( "unix" ) ) { String [ ] cmd = { "/usr/bin/env" } ; return cmd ; } else if ( Os . isFamily ( "netware" ) ) { String [ ] cmd = { "env" } ; return cmd ; } else { String [ ] cmd = null ; return cmd ; } } public static String toString ( ByteArrayOutputStream bos ) { if ( Os . isFamily ( "z/os" ) ) { try { bos . toString ( "Cp1047" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } return bos . toString ( ) ; } public Execute ( ) { this ( new PumpStreamHandler ( ) , null ) ; } public Execute ( ExecuteStreamHandler streamHandler ) { this ( streamHandler , null ) ; } public Execute ( ExecuteStreamHandler streamHandler , ExecuteWatchdog watchdog ) { this . streamHandler = streamHandler ; this . watchdog = watchdog ; } public String [ ] getCommandline ( ) { return cmdl ; } public void setCommandline ( String [ ] commandline ) { cmdl = commandline ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public String [ ] getEnvironment ( ) { if ( env == null || newEnvironment ) { return env ; } return patchEnvironment ( ) ; } public void setEnvironment ( String [ ] env ) { this . env = env ; } public void setWorkingDirectory ( File wd ) { if ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) { workingDirectory = null ; } else { workingDirectory = wd ; } } public void setAntRun ( Project project ) throws BuildException { this . project = project ; } public void setVMLauncher ( boolean useVMLauncher ) { this . useVMLauncher = useVMLauncher ; } public static Process launch ( Project project , String [ ] command , String [ ] env , File dir , boolean useVM ) throws IOException { CommandLauncher launcher = vmLauncher != null ? vmLauncher : shellLauncher ; if ( ! useVM ) { launcher = shellLauncher ; } return launcher . exec ( project , command , env , dir ) ; } public int execute ( ) throws IOException { final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; try { streamHandler . setProcessInputStream ( process . getOutputStream ( ) ) ; streamHandler . setProcessOutputStream ( process . getInputStream ( ) ) ; streamHandler . setProcessErrorStream ( process . getErrorStream ( ) ) ; } catch ( IOException e ) { process . destroy ( ) ; throw e ; } streamHandler . start ( ) ; processDestroyer . add ( process ) ; if ( watchdog != null ) { watchdog . start ( process ) ; } waitFor ( process ) ; processDestroyer . remove ( process ) ; if ( watchdog != null ) { watchdog . stop ( ) ; } streamHandler . stop ( ) ; if ( watchdog != null ) { watchdog . checkException ( ) ; } return getExitValue ( ) ; } protected void waitFor ( Process process ) { try { process . waitFor ( ) ; setExitValue ( process . exitValue ( ) ) ; } catch ( InterruptedException e ) { } } protected void setExitValue ( int value ) { exitValue = value ; } public int getExitValue ( ) { return exitValue ; } public boolean killedProcess ( ) { return watchdog != null && watchdog . killedProcess ( ) ; } private String [ ] patchEnvironment ( ) { Vector osEnv = ( Vector ) getProcEnvironment ( ) . clone ( ) ; for ( int i = 0 ; i < env . length ; i ++ ) { int pos = env [ i ] . indexOf ( '=' ) ; String key = env [ i ] . substring ( 0 , pos + 1 ) ; int size = osEnv . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { if ( ( ( String ) osEnv . elementAt ( j ) ) . startsWith ( key ) ) { osEnv . removeElementAt ( j ) ; break ; } } osEnv . addElement ( env [ i ] ) ; } String [ ] result = new String [ osEnv . size ( ) ] ; osEnv . copyInto ( result ) ; return result ; } public static void runCommand ( Task task , String [ ] cmdline ) throws BuildException { try { task . log ( Commandline . describeCommand ( cmdline ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( new LogStreamHandler ( task , Project . MSG_INFO , Project . MSG_ERR ) ) ; exe . setAntRun ( task . getProject ( ) ) ; exe . setCommandline ( cmdline ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { throw new BuildException ( cmdline [ 0 ] + " failed with return code " + retval , task . getLocation ( ) ) ; } } catch ( java . io . IOException exc ) { throw new BuildException ( "Could not launch " + cmdline [ 0 ] + ": " + exc , task . getLocation ( ) ) ; } } private static class CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { if ( project != null ) { project . log ( "Execute:CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( cmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot execute a process in different " + "directory under this JVM" ) ; } } private static class Java11CommandLauncher extends CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { String [ ] newcmd = new String [ cmd . length ] ; for ( int i = 0 ; i < cmd . length ; i ++ ) { newcmd [ i ] = Commandline . quoteArgument ( cmd [ i ] ) ; } if ( project != null ) { project . log ( "Execute:Java11CommandLauncher: " + Commandline . describeCommand ( newcmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( newcmd , env ) ; } } private static class Java13CommandLauncher extends CommandLauncher { public Java13CommandLauncher ( ) throws NoSuchMethodException { _execWithCWD = Runtime . class . getMethod ( "exec" , new Class [ ] { String [ ] . class , String [ ] . class , File . class } ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { try { if ( project != null ) { project . log ( "Execute:Java13CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } Object [ ] arguments = { cmd , env , workingDir } ; return ( Process ) _execWithCWD . invoke ( Runtime . getRuntime ( ) , arguments ) ; } catch ( InvocationTargetException exc ) { Throwable realexc = exc . getTargetException ( ) ; if ( realexc instanceof ThreadDeath ) { throw ( ThreadDeath ) realexc ; } else if ( realexc instanceof IOException ) { throw ( IOException ) realexc ; } else { throw new BuildException ( "Unable to execute command" , realexc ) ; } } catch ( Exception exc ) { throw new BuildException ( "Unable to execute command" , exc ) ; } } private Method _execWithCWD ; } private static class CommandLauncherProxy extends CommandLauncher { CommandLauncherProxy ( CommandLauncher launcher ) { _launcher = launcher ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { return _launcher . exec ( project , cmd , env ) ; } private CommandLauncher _launcher ; } private static class WinNTCommandLauncher extends CommandLauncherProxy { WinNTCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 6 ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = "cd" ; newcmd [ 3 ] = "/d" ; newcmd [ 4 ] = commandDir . getAbsolutePath ( ) ; newcmd [ 5 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class MacCommandLauncher extends CommandLauncherProxy { MacCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } System . getProperties ( ) . put ( "user.dir" , workingDir . getAbsolutePath ( ) ) ; try { return exec ( project , cmd , env ) ; } finally { System . getProperties ( ) . put ( "user.dir" , antWorkingDirectory ) ; } } } private static class ScriptCommandLauncher extends CommandLauncherProxy { ScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; _script = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + _script ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 2 ] ; newcmd [ 0 ] = antRun ; newcmd [ 1 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 2 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String _script ; } private static class PerlScriptCommandLauncher extends CommandLauncherProxy { PerlScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; _script = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + _script ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 3 ] ; newcmd [ 0 ] = "perl" ; newcmd [ 1 ] = antRun ; newcmd [ 2 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 3 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String _script ; } } 	1
package org . apache . tools . ant ; public class ExitException extends SecurityException { private int status ; public ExitException ( int status ) { super ( "ExitException: status " + status ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	1
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Cvs ; import org . apache . tools . ant . util . FileUtils ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; public class CvsTagDiff extends Task { static final String FILE_IS_NEW = " is new; current revision " ; static final String FILE_HAS_CHANGED = " changed from revision " ; static final String FILE_WAS_REMOVED = " is removed" ; private Cvs m_cvs ; private String m_package ; private String m_startTag ; private String m_endTag ; private String m_startDate ; private String m_endDate ; private File m_destfile ; private FileUtils m_fileUtils = FileUtils . newFileUtils ( ) ; public void init ( ) throws BuildException { m_cvs = ( Cvs ) getProject ( ) . createTask ( "cvs" ) ; } public void setCompressionLevel ( int level ) { m_cvs . setCompressionLevel ( level ) ; } public void setCompression ( boolean usecomp ) { m_cvs . setCompression ( usecomp ) ; } public void setCvsRoot ( String cvsRoot ) { m_cvs . setCvsRoot ( cvsRoot ) ; } public void setCvsRsh ( String rsh ) { m_cvs . setCvsRsh ( rsh ) ; } public void setPackage ( String p ) { m_package = p ; } public void setQuiet ( boolean quiet ) { m_cvs . setQuiet ( quiet ) ; } public void setPort ( int port ) { m_cvs . setPort ( port ) ; } public void setPassfile ( File f ) { m_cvs . setPassfile ( f ) ; } public void setFailOnError ( boolean b ) { m_cvs . setFailOnError ( b ) ; } public void setStartTag ( String s ) { m_startTag = s ; } public void setStartDate ( String s ) { m_startDate = s ; } public void setEndTag ( String s ) { m_endTag = s ; } public void setEndDate ( String s ) { m_endDate = s ; } public void setDestFile ( File f ) { m_destfile = f ; } public void execute ( ) throws BuildException { validate ( ) ; String rdiff = "rdiff -s " + ( m_startTag != null ? ( "-r " + m_startTag ) : ( "-D " + m_startDate ) ) + " " + ( m_endTag != null ? ( "-r " + m_endTag ) : ( "-D " + m_endDate ) ) + " " + m_package ; log ( "Cvs command is " + rdiff , Project . MSG_VERBOSE ) ; m_cvs . setCommand ( rdiff ) ; File tmpFile = null ; try { tmpFile = m_fileUtils . createTempFile ( "cvstagdiff" , ".log" , null ) ; m_cvs . setOutput ( tmpFile ) ; m_cvs . execute ( ) ; CvsTagEntry [ ] entries = parseRDiff ( tmpFile ) ; writeTagDiff ( entries ) ; } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private CvsTagEntry [ ] parseRDiff ( File tmpFile ) throws BuildException { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( tmpFile ) ) ; int headerLength = 5 + m_package . length ( ) + 1 ; Vector entries = new Vector ( ) ; String line = reader . readLine ( ) ; int index ; CvsTagEntry entry = null ; while ( null != line ) { line = line . substring ( headerLength ) ; if ( ( index = line . indexOf ( FILE_IS_NEW ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = line . substring ( index + FILE_IS_NEW . length ( ) ) ; entries . addElement ( entry = new CvsTagEntry ( filename , rev ) ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_HAS_CHANGED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; int revSeparator = line . indexOf ( " to " , index ) ; String prevRevision = line . substring ( index + FILE_HAS_CHANGED . length ( ) , revSeparator ) ; String revision = line . substring ( revSeparator + 4 ) ; entries . addElement ( entry = new CvsTagEntry ( filename , revision , prevRevision ) ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_WAS_REMOVED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; entries . addElement ( entry = new CvsTagEntry ( filename ) ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } line = reader . readLine ( ) ; } CvsTagEntry [ ] array = new CvsTagEntry [ entries . size ( ) ] ; entries . copyInto ( array ) ; return array ; } catch ( IOException e ) { throw new BuildException ( "Error in parsing" , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } } private void writeTagDiff ( CvsTagEntry [ ] entries ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( m_destfile ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; writer . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; writer . print ( "<tagdiff " ) ; if ( m_startTag != null ) { writer . print ( "startTag=\"" + m_startTag + "\" " ) ; } else { writer . print ( "startDate=\"" + m_startDate + "\" " ) ; } if ( m_endTag != null ) { writer . print ( "endTag=\"" + m_endTag + "\" " ) ; } else { writer . print ( "endDate=\"" + m_endDate + "\" " ) ; } writer . println ( ">" ) ; for ( int i = 0 , c = entries . length ; i < c ; i ++ ) { writeTagEntry ( writer , entries [ i ] ) ; } writer . println ( "</tagdiff>" ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( UnsupportedEncodingException uee ) { log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( IOException ioe ) { } } } } private void writeTagEntry ( PrintWriter writer , CvsTagEntry entry ) { writer . println ( "\t<entry>" ) ; writer . println ( "\t\t<file>" ) ; writer . println ( "\t\t\t<name>" + entry . getFile ( ) + "</name>" ) ; if ( entry . getRevision ( ) != null ) { writer . println ( "\t\t\t<revision>" + entry . getRevision ( ) + "</revision>" ) ; } if ( entry . getPreviousRevision ( ) != null ) { writer . println ( "\t\t\t<prevrevision>" + entry . getPreviousRevision ( ) + "</prevrevision>" ) ; } writer . println ( "\t\t</file>" ) ; writer . println ( "\t</entry>" ) ; } private void validate ( ) throws BuildException { if ( null == m_package ) { throw new BuildException ( "Package/module must be set." ) ; } if ( null == m_destfile ) { throw new BuildException ( "Destfile must be set." ) ; } if ( null == m_startTag && null == m_startDate ) { throw new BuildException ( "Start tag or start date must be set." ) ; } if ( null != m_startTag && null != m_startDate ) { throw new BuildException ( "Only one of start tag and start date " + "must be set." ) ; } if ( null == m_endTag && null == m_endDate ) { throw new BuildException ( "End tag or end date must be set." ) ; } if ( null != m_endTag && null != m_endDate ) { throw new BuildException ( "Only one of end tag and end date must " + "be set." ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . io . IOException ; import java . util . Date ; import java . util . Vector ; import java . util . zip . ZipInputStream ; import java . util . zip . ZipEntry ; public class Expand extends Task { private File dest ; private File source ; private boolean overwrite = true ; private Vector patternsets = new Vector ( ) ; private Vector filesets = new Vector ( ) ; public void execute ( ) throws BuildException { if ( "expand" . equals ( taskType ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } if ( source == null && filesets . size ( ) == 0 ) { throw new BuildException ( "src attribute and/or filesets must be " + "specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( dest . exists ( ) && ! dest . isDirectory ( ) ) { throw new BuildException ( "Dest must be a directory." , location ) ; } FileUtils fileUtils = FileUtils . newFileUtils ( ) ; if ( source != null ) { if ( source . isDirectory ( ) ) { throw new BuildException ( "Src must not be a directory." + " Use nested filesets instead." , location ) ; } else { expandFile ( fileUtils , source , dest ) ; } } if ( filesets . size ( ) > 0 ) { for ( int j = 0 ; j < filesets . size ( ) ; j ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( j ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { File file = new File ( fromDir , files [ i ] ) ; expandFile ( fileUtils , file , dest ) ; } } } } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; ZipInputStream zis = null ; try { zis = new ZipInputStream ( new FileInputStream ( srcF ) ) ; ZipEntry ze = null ; while ( ( ze = zis . getNextEntry ( ) ) != null ) { extractFile ( fileUtils , srcF , dir , zis , ze . getName ( ) , new Date ( ze . getTime ( ) ) , ze . isDirectory ( ) ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( IOException e ) { } } } } protected void extractFile ( FileUtils fileUtils , File srcF , File dir , InputStream compressedInputStream , String entryName , Date entryDate , boolean isDirectory ) throws IOException { if ( patternsets != null && patternsets . size ( ) > 0 ) { String name = entryName ; boolean included = false ; for ( int v = 0 ; v < patternsets . size ( ) ; v ++ ) { PatternSet p = ( PatternSet ) patternsets . elementAt ( v ) ; String [ ] incls = p . getIncludePatterns ( project ) ; if ( incls != null ) { for ( int w = 0 ; w < incls . length ; w ++ ) { boolean isIncl = DirectoryScanner . match ( incls [ w ] , name ) ; if ( isIncl ) { included = true ; break ; } } } String [ ] excls = p . getExcludePatterns ( project ) ; if ( excls != null ) { for ( int w = 0 ; w < excls . length ; w ++ ) { boolean isExcl = DirectoryScanner . match ( excls [ w ] , name ) ; if ( isExcl ) { included = false ; break ; } } } } if ( ! included ) { return ; } } File f = fileUtils . resolveFile ( dir , entryName ) ; try { if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= entryDate . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; return ; } log ( "expanding " + entryName + " to " + f , Project . MSG_VERBOSE ) ; File dirF = fileUtils . getParentFile ( f ) ; dirF . mkdirs ( ) ; if ( isDirectory ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; while ( ( length = compressedInputStream . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; fos = null ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException e ) { } } } } fileUtils . setFileLastModified ( f , entryDate . getTime ( ) ) ; } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } public void addPatternset ( PatternSet set ) { patternsets . addElement ( set ) ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . input . InputRequest ; import org . apache . tools . ant . input . MultipleChoiceInputRequest ; import org . apache . tools . ant . util . StringUtils ; public class Input extends Task { private String validargs = null ; private String message = "" ; private String addproperty = null ; public void setValidargs ( String validargs ) { this . validargs = validargs ; } public void setAddproperty ( String addproperty ) { this . addproperty = addproperty ; } public void setMessage ( String message ) { this . message = message ; } public void addText ( String msg ) { message += getProject ( ) . replaceProperties ( msg ) ; } public Input ( ) { } public void execute ( ) throws BuildException { InputRequest request = null ; if ( validargs != null ) { Vector accept = StringUtils . split ( validargs , ',' ) ; request = new MultipleChoiceInputRequest ( message , accept ) ; } else { request = new InputRequest ( message ) ; } getProject ( ) . getInputHandler ( ) . handleInput ( request ) ; if ( addproperty != null ) { project . setNewProperty ( addproperty , request . getInput ( ) ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Set ; import java . util . HashSet ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . util . FileUtils ; public class Ant extends Task { private File dir = null ; private String antFile = null ; private String target = null ; private String output = null ; private boolean inheritAll = true ; private boolean inheritRefs = false ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Project newProject ; private PrintStream out = null ; private Vector propertySets = new Vector ( ) ; public void setInheritAll ( boolean value ) { inheritAll = value ; } public void setInheritRefs ( boolean value ) { inheritRefs = value ; } public void init ( ) { newProject = new Project ( ) ; newProject . setDefaultInputStream ( getProject ( ) . getDefaultInputStream ( ) ) ; newProject . setJavaVersionProperty ( ) ; } private void reinit ( ) { init ( ) ; } private void initializeProject ( ) { newProject . setInputHandler ( getProject ( ) . getInputHandler ( ) ) ; Vector listeners = getProject ( ) . getBuildListeners ( ) ; final int count = listeners . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { newProject . addBuildListener ( ( BuildListener ) listeners . elementAt ( i ) ) ; } if ( output != null ) { File outfile = null ; if ( dir != null ) { outfile = FileUtils . newFileUtils ( ) . resolveFile ( dir , output ) ; } else { outfile = getProject ( ) . resolveFile ( output ) ; } try { out = new PrintStream ( new FileOutputStream ( outfile ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; newProject . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } getProject ( ) . initSubProject ( newProject ) ; getProject ( ) . copyUserProperties ( newProject ) ; if ( ! inheritAll ) { newProject . setSystemProperties ( ) ; } else { addAlmostAll ( getProject ( ) . getProperties ( ) ) ; } Enumeration e = propertySets . elements ( ) ; while ( e . hasMoreElements ( ) ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; addAlmostAll ( ps . getProperties ( ) ) ; } } public void handleOutput ( String output ) { if ( newProject != null ) { newProject . demuxOutput ( output , false ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( newProject != null ) { return newProject . demuxInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } public void handleFlush ( String output ) { if ( newProject != null ) { newProject . demuxFlush ( output , false ) ; } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( newProject != null ) { newProject . demuxOutput ( output , true ) ; } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( newProject != null ) { newProject . demuxFlush ( output , true ) ; } else { super . handleErrorFlush ( output ) ; } } public void execute ( ) throws BuildException { File savedDir = dir ; String savedAntFile = antFile ; String savedTarget = target ; try { if ( newProject == null ) { reinit ( ) ; } if ( ( dir == null ) && ( inheritAll ) ) { dir = getProject ( ) . getBaseDir ( ) ; } initializeProject ( ) ; if ( dir != null ) { newProject . setBaseDir ( dir ) ; if ( savedDir != null ) { newProject . setInheritedProperty ( "basedir" , dir . getAbsolutePath ( ) ) ; } } else { dir = getProject ( ) . getBaseDir ( ) ; } overrideProperties ( ) ; if ( antFile == null ) { antFile = "build.xml" ; } File file = FileUtils . newFileUtils ( ) . resolveFile ( dir , antFile ) ; antFile = file . getAbsolutePath ( ) ; log ( "calling target " + ( target != null ? target : "[default]" ) + " in build file " + antFile , Project . MSG_VERBOSE ) ; newProject . setUserProperty ( "ant.file" , antFile ) ; if ( newProject . getProperty ( "ant.file" ) . equals ( getProject ( ) . getProperty ( "ant.file" ) ) && getOwningTarget ( ) != null ) { if ( getOwningTarget ( ) . getName ( ) . equals ( "" ) ) { if ( getTaskName ( ) . equals ( "antcall" ) ) { throw new BuildException ( "antcall must not be used at" + " the top level." ) ; } else { throw new BuildException ( getTaskName ( ) + " task at the" + " top level must not invoke" + " its own build file." ) ; } } } try { ProjectHelper . configureProject ( newProject , new File ( antFile ) ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } if ( target == null ) { target = newProject . getDefaultTarget ( ) ; } if ( newProject . getProperty ( "ant.file" ) . equals ( getProject ( ) . getProperty ( "ant.file" ) ) && getOwningTarget ( ) != null ) { String owningTargetName = getOwningTarget ( ) . getName ( ) ; if ( owningTargetName . equals ( target ) ) { throw new BuildException ( getTaskName ( ) + " task calling " + "its own parent target." ) ; } else { Target other = ( Target ) getProject ( ) . getTargets ( ) . get ( target ) ; if ( other != null && other . dependsOn ( owningTargetName ) ) { throw new BuildException ( getTaskName ( ) + " task calling a target" + " that depends on" + " its parent target \'" + owningTargetName + "\'." ) ; } } } addReferences ( ) ; if ( target != null && ! "" . equals ( target ) ) { try { log ( "Entering " + antFile + "..." , Project . MSG_VERBOSE ) ; newProject . executeTarget ( target ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } finally { log ( "Exiting " + antFile + "." , Project . MSG_VERBOSE ) ; } } } finally { newProject = null ; Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( null ) ; } if ( output != null && out != null ) { try { out . close ( ) ; } catch ( final Exception ex ) { } } dir = savedDir ; antFile = savedAntFile ; target = savedTarget ; } } private void overrideProperties ( ) throws BuildException { Set set = new HashSet ( ) ; for ( int i = properties . size ( ) - 1 ; i >= 0 ; -- i ) { Property p = ( Property ) properties . get ( i ) ; if ( p . getName ( ) != null && ! p . getName ( ) . equals ( "" ) ) { if ( set . contains ( p . getName ( ) ) ) { properties . remove ( i ) ; } else { set . add ( p . getName ( ) ) ; } } } Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( newProject ) ; p . execute ( ) ; } getProject ( ) . copyInheritedProperties ( newProject ) ; } private void addReferences ( ) throws BuildException { Hashtable thisReferences = ( Hashtable ) getProject ( ) . getReferences ( ) . clone ( ) ; Hashtable newReferences = newProject . getReferences ( ) ; Enumeration e ; if ( references . size ( ) > 0 ) { for ( e = references . elements ( ) ; e . hasMoreElements ( ) ; ) { Reference ref = ( Reference ) e . nextElement ( ) ; String refid = ref . getRefId ( ) ; if ( refid == null ) { throw new BuildException ( "the refid attribute is required" + " for reference elements" ) ; } if ( ! thisReferences . containsKey ( refid ) ) { log ( "Parent project doesn't contain any reference '" + refid + "'" , Project . MSG_WARN ) ; continue ; } thisReferences . remove ( refid ) ; String toRefid = ref . getToRefid ( ) ; if ( toRefid == null ) { toRefid = refid ; } copyReference ( refid , toRefid ) ; } } if ( inheritRefs ) { for ( e = thisReferences . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( newReferences . containsKey ( key ) ) { continue ; } copyReference ( key , key ) ; } } } private void copyReference ( String oldKey , String newKey ) { Object orig = getProject ( ) . getReference ( oldKey ) ; if ( orig == null ) { log ( "No object referenced by " + oldKey + ". Can't copy to " + newKey , Project . MSG_WARN ) ; return ; } Class c = orig . getClass ( ) ; Object copy = orig ; try { Method cloneM = c . getMethod ( "clone" , new Class [ 0 ] ) ; if ( cloneM != null ) { copy = cloneM . invoke ( orig , new Object [ 0 ] ) ; log ( "Adding clone of reference " + oldKey , Project . MSG_DEBUG ) ; } } catch ( Exception e ) { } if ( copy instanceof ProjectComponent ) { ( ( ProjectComponent ) copy ) . setProject ( newProject ) ; } else { try { Method setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( copy , new Object [ ] { newProject } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception e2 ) { String msg = "Error setting new project instance for " + "reference with id " + oldKey ; throw new BuildException ( msg , e2 , getLocation ( ) ) ; } } newProject . addReference ( newKey , copy ) ; } private void addAlmostAll ( Hashtable props ) { Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = e . nextElement ( ) . toString ( ) ; if ( "basedir" . equals ( key ) || "ant.file" . equals ( key ) ) { continue ; } String value = props . get ( key ) . toString ( ) ; if ( newProject . getProperty ( key ) == null ) { newProject . setNewProperty ( key , value ) ; } } } public void setDir ( File d ) { this . dir = d ; } public void setAntfile ( String s ) { this . antFile = s ; } public void setTarget ( String s ) { if ( s . equals ( "" ) ) { throw new BuildException ( "target attribute must not be empty" ) ; } this . target = s ; } public void setOutput ( String s ) { this . output = s ; } public Property createProperty ( ) { if ( newProject == null ) { reinit ( ) ; } Property p = new Property ( true , getProject ( ) ) ; p . setProject ( newProject ) ; p . setTaskName ( "property" ) ; properties . addElement ( p ) ; return p ; } public void addReference ( Reference r ) { references . addElement ( r ) ; } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public static class Reference extends org . apache . tools . ant . types . Reference { public Reference ( ) { super ( ) ; } private String targetid = null ; public void setToRefid ( String targetid ) { this . targetid = targetid ; } public String getToRefid ( ) { return targetid ; } } } 	1
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; public class Assertions extends DataType { private Boolean enableSystemAssertions ; private ArrayList assertionList = new ArrayList ( ) ; public void addEnable ( EnabledAssertion assertion ) { checkChildrenAllowed ( ) ; assertionList . add ( assertion ) ; } public void addDisable ( DisabledAssertion assertion ) { checkChildrenAllowed ( ) ; assertionList . add ( assertion ) ; } public void setEnableSystemAssertions ( Boolean enableSystemAssertions ) { checkAttributesAllowed ( ) ; this . enableSystemAssertions = enableSystemAssertions ; } public void setRefid ( Reference ref ) { if ( assertionList . size ( ) > 0 || enableSystemAssertions != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( ref ) ; } private Assertions getFinalReference ( ) { if ( getRefid ( ) == null ) { return this ; } else { Object o = getRefid ( ) . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Assertions ) ) { throw new BuildException ( "reference is of wrong type" ) ; } return ( Assertions ) o ; } } public int size ( ) { Assertions clause = getFinalReference ( ) ; return clause . getFinalSize ( ) ; } private int getFinalSize ( ) { return assertionList . size ( ) + ( enableSystemAssertions != null ? 1 : 0 ) ; } public void applyAssertions ( List commandList ) { getProject ( ) . log ( "Applying assertions" , Project . MSG_DEBUG ) ; Assertions clause = getFinalReference ( ) ; if ( Boolean . TRUE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "Enabling system assertions" , Project . MSG_DEBUG ) ; commandList . add ( "-enablesystemassertions" ) ; } else if ( Boolean . FALSE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "disabling system assertions" , Project . MSG_DEBUG ) ; commandList . add ( "-disablesystemassertions" ) ; } Iterator it = clause . assertionList . iterator ( ) ; while ( it . hasNext ( ) ) { BaseAssertion assertion = ( BaseAssertion ) it . next ( ) ; String arg = assertion . toCommand ( ) ; getProject ( ) . log ( "adding assertion " + arg , Project . MSG_DEBUG ) ; commandList . add ( arg ) ; } } public void applyAssertions ( CommandlineJava command ) { Assertions clause = getFinalReference ( ) ; if ( Boolean . TRUE . equals ( clause . enableSystemAssertions ) ) { addVmArgument ( command , "-enablesystemassertions" ) ; } else if ( Boolean . FALSE . equals ( clause . enableSystemAssertions ) ) { addVmArgument ( command , "-disablesystemassertions" ) ; } Iterator it = clause . assertionList . iterator ( ) ; while ( it . hasNext ( ) ) { BaseAssertion assertion = ( BaseAssertion ) it . next ( ) ; String arg = assertion . toCommand ( ) ; addVmArgument ( command , arg ) ; } } private static void addVmArgument ( CommandlineJava command , String arg ) { Commandline . Argument argument ; argument = command . createVmArgument ( ) ; argument . setValue ( arg ) ; } protected Object clone ( ) throws CloneNotSupportedException { Assertions that = ( Assertions ) super . clone ( ) ; that . assertionList = ( ArrayList ) assertionList . clone ( ) ; return that ; } public abstract static class BaseAssertion { private String packageName ; private String className ; public void setClass ( String className ) { this . className = className ; } public void setPackage ( String packageName ) { this . packageName = packageName ; } protected String getClassName ( ) { return className ; } protected String getPackageName ( ) { return packageName ; } public abstract String getCommandPrefix ( ) ; public String toCommand ( ) { if ( getPackageName ( ) != null && getClassName ( ) != null ) { throw new BuildException ( "Both package and class have been set" ) ; } StringBuffer command = new StringBuffer ( getCommandPrefix ( ) ) ; if ( getPackageName ( ) != null ) { command . append ( ':' ) ; command . append ( getPackageName ( ) ) ; if ( ! command . toString ( ) . endsWith ( "..." ) ) { command . append ( "..." ) ; } } else if ( getClassName ( ) != null ) { command . append ( ':' ) ; command . append ( getClassName ( ) ) ; } return command . toString ( ) ; } } public static class EnabledAssertion extends BaseAssertion { public String getCommandPrefix ( ) { return "-ea" ; } } public static class DisabledAssertion extends BaseAssertion { public String getCommandPrefix ( ) { return "-da" ; } } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import java . io . File ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . FileReader ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import java . sql . Connection ; import java . sql . Statement ; import java . sql . SQLException ; import java . sql . SQLWarning ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; public class SQLExec extends JDBCTask { public static class DelimiterType extends EnumeratedAttribute { public static final String NORMAL = "normal" ; public static final String ROW = "row" ; public String [ ] getValues ( ) { return new String [ ] { NORMAL , ROW } ; } } private int goodSql = 0 ; private int totalSql = 0 ; private Connection conn = null ; private Vector filesets = new Vector ( ) ; private Statement statement = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private File output = null ; private String onError = "abort" ; private String encoding = null ; private boolean append = false ; private boolean keepformat = false ; private boolean escapeProcessing = true ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . delimiterType = delimiterType . getValue ( ) ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setOutput ( File output ) { this . output = output ; } public void setAppend ( boolean append ) { this . append = append ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void setKeepformat ( boolean keepformat ) { this . keepformat = keepformat ; } public void setEscapeProcessing ( boolean enable ) { escapeProcessing = enable ; } public void execute ( ) throws BuildException { Vector savedTransaction = ( Vector ) transactions . clone ( ) ; String savedSqlCommand = sqlCommand ; sqlCommand = sqlCommand . trim ( ) ; try { if ( srcFile == null && sqlCommand . length ( ) == 0 && filesets . isEmpty ( ) ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file or fileset, " + "transactions or sql statement " + "must be set!" , getLocation ( ) ) ; } } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , getLocation ( ) ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; File srcDir = fs . getDir ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { Transaction t = createTransaction ( ) ; t . setSrc ( new File ( srcDir , srcFiles [ j ] ) ) ; } } Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; conn = getConnection ( ) ; if ( ! isValidRdbms ( conn ) ) { return ; } try { statement = conn . createStatement ( ) ; statement . setEscapeProcessing ( escapeProcessing ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getAbsolutePath ( ) , append ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! isAutocommit ( ) ) { log ( "Committing transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , getLocation ( ) ) ; } catch ( SQLException e ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , getLocation ( ) ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException ex ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } finally { transactions = savedTransaction ; sqlCommand = savedSqlCommand ; } } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { StringBuffer sql = new StringBuffer ( ) ; String line = "" ; BufferedReader in = new BufferedReader ( reader ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( ! keepformat ) { line = line . trim ( ) ; } line = getProject ( ) . replaceProperties ( line ) ; if ( ! keepformat ) { if ( line . startsWith ( "//" ) ) { continue ; } if ( line . startsWith ( "--" ) ) { continue ; } StringTokenizer st = new StringTokenizer ( line ) ; if ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( "REM" . equalsIgnoreCase ( token ) ) { continue ; } } } if ( ! keepformat ) { sql . append ( " " + line ) ; } else { sql . append ( "\n" + line ) ; } if ( ! keepformat ) { if ( line . indexOf ( "--" ) >= 0 ) { sql . append ( "\n" ) ; } } if ( ( delimiterType . equals ( DelimiterType . NORMAL ) && sql . toString ( ) . endsWith ( delimiter ) ) || ( delimiterType . equals ( DelimiterType . ROW ) && line . equals ( delimiter ) ) ) { execSQL ( sql . substring ( 0 , sql . length ( ) - delimiter . length ( ) ) , out ) ; sql . replace ( 0 , sql . length ( ) , "" ) ; } } if ( ! sql . equals ( "" ) ) { execSQL ( sql . toString ( ) , out ) ; } } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) { return ; } try { totalSql ++ ; log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; boolean ret ; int updateCount = 0 , updateCountTotal = 0 ; ResultSet resultSet = null ; ret = statement . execute ( sql ) ; updateCount = statement . getUpdateCount ( ) ; resultSet = statement . getResultSet ( ) ; do { if ( ! ret ) { if ( updateCount != - 1 ) { updateCountTotal += updateCount ; } } else { if ( print ) { printResults ( out ) ; } } ret = statement . getMoreResults ( ) ; updateCount = statement . getUpdateCount ( ) ; resultSet = statement . getResultSet ( ) ; } while ( ret ) ; log ( updateCountTotal + " rows affected" , Project . MSG_VERBOSE ) ; if ( print ) { StringBuffer line = new StringBuffer ( ) ; line . append ( updateCountTotal + " rows affected" ) ; out . println ( line ) ; } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) { throw e ; } log ( e . toString ( ) , Project . MSG_ERR ) ; } } protected void printResults ( PrintStream out ) throws java . sql . SQLException { ResultSet rs = null ; rs = statement . getResultSet ( ) ; if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line = new StringBuffer ( ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line = new StringBuffer ( ) ; } } out . println ( ) ; } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private File tSrcFile = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { this . tSrcFile = src ; } public void addText ( String sql ) { this . tSqlCommand += sql ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcFile != null ) { log ( "Executing file: " + tSrcFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; Reader reader = ( encoding == null ) ? new FileReader ( tSrcFile ) : new InputStreamReader ( new FileInputStream ( tSrcFile ) , encoding ) ; try { runStatements ( reader , out ) ; } finally { reader . close ( ) ; } } } } } 	1
package org . apache . tools . ant . types ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . ArrayList ; import java . util . List ; import java . util . ListIterator ; import java . util . LinkedList ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . StringUtils ; public class Commandline implements Cloneable { private Vector arguments = new Vector ( ) ; private String executable = null ; protected static final String DISCLAIMER = StringUtils . LINE_SEP + "The \' characters around the executable and arguments are" + StringUtils . LINE_SEP + "not part of the command." + StringUtils . LINE_SEP ; public Commandline ( String toProcess ) { super ( ) ; String [ ] tmp = translateCommandline ( toProcess ) ; if ( tmp != null && tmp . length > 0 ) { setExecutable ( tmp [ 0 ] ) ; for ( int i = 1 ; i < tmp . length ; i ++ ) { createArgument ( ) . setValue ( tmp [ i ] ) ; } } } public Commandline ( ) { super ( ) ; } public static class Argument extends ProjectComponent { private String [ ] parts ; public void setValue ( String value ) { parts = new String [ ] { value } ; } public void setLine ( String line ) { if ( line == null ) { return ; } parts = translateCommandline ( line ) ; } public void setPath ( Path value ) { parts = new String [ ] { value . toString ( ) } ; } public void setPathref ( Reference value ) { Path p = new Path ( getProject ( ) ) ; p . setRefid ( value ) ; parts = new String [ ] { p . toString ( ) } ; } public void setFile ( File value ) { parts = new String [ ] { value . getAbsolutePath ( ) } ; } public String [ ] getParts ( ) { return parts ; } } public class Marker { private int position ; private int realPos = - 1 ; Marker ( int position ) { this . position = position ; } public int getPosition ( ) { if ( realPos == - 1 ) { realPos = ( executable == null ? 0 : 1 ) ; for ( int i = 0 ; i < position ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; realPos += arg . getParts ( ) . length ; } } return realPos ; } } public Argument createArgument ( ) { return this . createArgument ( false ) ; } public Argument createArgument ( boolean insertAtStart ) { Argument argument = new Argument ( ) ; if ( insertAtStart ) { arguments . insertElementAt ( argument , 0 ) ; } else { arguments . addElement ( argument ) ; } return argument ; } public void setExecutable ( String executable ) { if ( executable == null || executable . length ( ) == 0 ) { return ; } this . executable = executable . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } public String getExecutable ( ) { return executable ; } public void addArguments ( String [ ] line ) { for ( int i = 0 ; i < line . length ; i ++ ) { createArgument ( ) . setValue ( line [ i ] ) ; } } public String [ ] getCommandline ( ) { List commands = new LinkedList ( ) ; ListIterator list = commands . listIterator ( ) ; addCommandToList ( list ) ; final String [ ] result = new String [ commands . size ( ) ] ; return ( String [ ] ) commands . toArray ( result ) ; } public void addCommandToList ( ListIterator list ) { if ( executable != null ) { list . add ( executable ) ; } addArgumentsToList ( list ) ; } public String [ ] getArguments ( ) { List result = new ArrayList ( arguments . size ( ) * 2 ) ; addArgumentsToList ( result . listIterator ( ) ) ; String [ ] res = new String [ result . size ( ) ] ; return ( String [ ] ) result . toArray ( res ) ; } public void addArgumentsToList ( ListIterator list ) { for ( int i = 0 ; i < arguments . size ( ) ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; String [ ] s = arg . getParts ( ) ; if ( s != null ) { for ( int j = 0 ; j < s . length ; j ++ ) { list . add ( s [ j ] ) ; } } } } public String toString ( ) { return toString ( getCommandline ( ) ) ; } public static String quoteArgument ( String argument ) { if ( argument . indexOf ( "\"" ) > - 1 ) { if ( argument . indexOf ( "\'" ) > - 1 ) { throw new BuildException ( "Can\'t handle single and double" + " quotes in same argument" ) ; } else { return '\'' + argument + '\'' ; } } else if ( argument . indexOf ( "\'" ) > - 1 || argument . indexOf ( " " ) > - 1 ) { return '\"' + argument + '\"' ; } else { return argument ; } } public static String toString ( String [ ] line ) { if ( line == null || line . length == 0 ) { return "" ; } final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ; i ++ ) { if ( i > 0 ) { result . append ( ' ' ) ; } result . append ( quoteArgument ( line [ i ] ) ) ; } return result . toString ( ) ; } public static String [ ] translateCommandline ( String toProcess ) { if ( toProcess == null || toProcess . length ( ) == 0 ) { return new String [ 0 ] ; } final int normal = 0 ; final int inQuote = 1 ; final int inDoubleQuote = 2 ; int state = normal ; StringTokenizer tok = new StringTokenizer ( toProcess , "\"\' " , true ) ; Vector v = new Vector ( ) ; StringBuffer current = new StringBuffer ( ) ; boolean lastTokenHasBeenQuoted = false ; while ( tok . hasMoreTokens ( ) ) { String nextTok = tok . nextToken ( ) ; switch ( state ) { case inQuote : if ( "\'" . equals ( nextTok ) ) { lastTokenHasBeenQuoted = true ; state = normal ; } else { current . append ( nextTok ) ; } break ; case inDoubleQuote : if ( "\"" . equals ( nextTok ) ) { lastTokenHasBeenQuoted = true ; state = normal ; } else { current . append ( nextTok ) ; } break ; default : if ( "\'" . equals ( nextTok ) ) { state = inQuote ; } else if ( "\"" . equals ( nextTok ) ) { state = inDoubleQuote ; } else if ( " " . equals ( nextTok ) ) { if ( lastTokenHasBeenQuoted || current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; current = new StringBuffer ( ) ; } } else { current . append ( nextTok ) ; } lastTokenHasBeenQuoted = false ; break ; } } if ( lastTokenHasBeenQuoted || current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; } if ( state == inQuote || state == inDoubleQuote ) { throw new BuildException ( "unbalanced quotes in " + toProcess ) ; } String [ ] args = new String [ v . size ( ) ] ; v . copyInto ( args ) ; return args ; } public int size ( ) { return getCommandline ( ) . length ; } public Object clone ( ) { try { Commandline c = ( Commandline ) super . clone ( ) ; c . arguments = ( Vector ) arguments . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public void clear ( ) { executable = null ; arguments . removeAllElements ( ) ; } public void clearArgs ( ) { arguments . removeAllElements ( ) ; } public Marker createMarker ( ) { return new Marker ( arguments . size ( ) ) ; } public String describeCommand ( ) { return describeCommand ( this ) ; } public String describeArguments ( ) { return describeArguments ( this ) ; } public static String describeCommand ( Commandline line ) { return describeCommand ( line . getCommandline ( ) ) ; } public static String describeArguments ( Commandline line ) { return describeArguments ( line . getArguments ( ) ) ; } public static String describeCommand ( String [ ] args ) { if ( args == null || args . length == 0 ) { return "" ; } StringBuffer buf = new StringBuffer ( "Executing \'" ) ; buf . append ( args [ 0 ] ) ; buf . append ( "\'" ) ; if ( args . length > 0 ) { buf . append ( " with " ) ; buf . append ( describeArguments ( args , 1 ) ) ; } else { buf . append ( DISCLAIMER ) ; } return buf . toString ( ) ; } public static String describeArguments ( String [ ] args ) { return describeArguments ( args , 0 ) ; } protected static String describeArguments ( String [ ] args , int offset ) { if ( args == null || args . length <= offset ) { return "" ; } StringBuffer buf = new StringBuffer ( "argument" ) ; if ( args . length > offset ) { buf . append ( "s" ) ; } buf . append ( ":" ) . append ( StringUtils . LINE_SEP ) ; for ( int i = offset ; i < args . length ; i ++ ) { buf . append ( "\'" ) . append ( args [ i ] ) . append ( "\'" ) . append ( StringUtils . LINE_SEP ) ; } buf . append ( DISCLAIMER ) ; return buf . toString ( ) ; } } 	1
package org . apache . tools . ant . helper ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . URL ; import java . util . Hashtable ; import java . util . Stack ; import org . xml . sax . Locator ; import org . xml . sax . InputSource ; import org . xml . sax . SAXParseException ; import org . xml . sax . SAXException ; import org . xml . sax . Attributes ; import org . xml . sax . helpers . DefaultHandler ; import org . apache . tools . ant . util . JAXPUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . UnknownElement ; import org . xml . sax . XMLReader ; public class ProjectHelper2 extends ProjectHelper { private static AntHandler elementHandler = new ElementHandler ( ) ; private static AntHandler targetHandler = new TargetHandler ( ) ; private static AntHandler mainHandler = new MainHandler ( ) ; private static AntHandler projectHandler = new ProjectHandler ( ) ; private static FileUtils fu = FileUtils . newFileUtils ( ) ; public UnknownElement parseUnknownElement ( Project project , URL source ) throws BuildException { Target dummyTarget = new Target ( ) ; dummyTarget . setProject ( project ) ; AntXMLContext context = new AntXMLContext ( project ) ; context . addTarget ( dummyTarget ) ; context . setImplicitTarget ( dummyTarget ) ; parse ( context . getProject ( ) , source , new RootHandler ( context , elementHandler ) ) ; Task [ ] tasks = dummyTarget . getTasks ( ) ; if ( tasks . length != 1 ) { throw new BuildException ( "No tasks defined" ) ; } return ( UnknownElement ) tasks [ 0 ] ; } public void parse ( Project project , Object source ) throws BuildException { getImportStack ( ) . addElement ( source ) ; AntXMLContext context = null ; context = ( AntXMLContext ) project . getReference ( "ant.parsing.context" ) ; if ( context == null ) { context = new AntXMLContext ( project ) ; project . addReference ( "ant.parsing.context" , context ) ; project . addReference ( "ant.targets" , context . getTargets ( ) ) ; } if ( getImportStack ( ) . size ( ) > 1 ) { context . setIgnoreProjectTag ( true ) ; Target currentTarget = context . getCurrentTarget ( ) ; try { Target newCurrent = new Target ( ) ; newCurrent . setProject ( project ) ; newCurrent . setName ( "" ) ; context . setCurrentTarget ( newCurrent ) ; parse ( project , source , new RootHandler ( context , mainHandler ) ) ; newCurrent . execute ( ) ; } finally { context . setCurrentTarget ( currentTarget ) ; } } else { parse ( project , source , new RootHandler ( context , mainHandler ) ) ; context . getImplicitTarget ( ) . execute ( ) ; } } public void parse ( Project project , Object source , RootHandler handler ) throws BuildException { AntXMLContext context = handler . context ; File buildFile = null ; URL url = null ; String buildFileName = null ; if ( source instanceof File ) { buildFile = ( File ) source ; buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; context . setBuildFile ( buildFile ) ; buildFileName = buildFile . toString ( ) ; } else if ( source instanceof URL ) { if ( handler . getCurrentAntHandler ( ) != elementHandler ) { throw new BuildException ( "Source " + source . getClass ( ) . getName ( ) + " not supported by this plugin for " + " non task xml" ) ; } url = ( URL ) source ; buildFileName = url . toString ( ) ; } else { throw new BuildException ( "Source " + source . getClass ( ) . getName ( ) + " not supported by this plugin" ) ; } InputStream inputStream = null ; InputSource inputSource = null ; try { XMLReader parser = JAXPUtils . getNamespaceXMLReader ( ) ; String uri = null ; if ( buildFile != null ) { uri = fu . toURI ( buildFile . getAbsolutePath ( ) ) ; inputStream = new FileInputStream ( buildFile ) ; } else { inputStream = url . openStream ( ) ; uri = url . toString ( ) ; } inputSource = new InputSource ( inputStream ) ; if ( uri != null ) { inputSource . setSystemId ( uri ) ; } project . log ( "parsing buildfile " + buildFileName + " with URI = " + uri , Project . MSG_VERBOSE ) ; DefaultHandler hb = handler ; parser . setContentHandler ( hb ) ; parser . setEntityResolver ( hb ) ; parser . setErrorHandler ( hb ) ; parser . setDTDHandler ( hb ) ; parser . parse ( inputSource ) ; } catch ( SAXParseException exc ) { Location location = new Location ( exc . getSystemId ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( "Encoding of project file " + buildFileName + " is invalid." , exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file " + buildFileName + ": " + exc . getMessage ( ) , exc ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ioe ) { } } } } public static class AntHandler { public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { } public AntHandler onStartChild ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + qname + " \"" , context . getLocator ( ) ) ; } public void onEndChild ( String uri , String tag , String qname , AntXMLContext context ) throws SAXParseException { } public void onEndElement ( String uri , String tag , AntXMLContext context ) { } public void characters ( char [ ] buf , int start , int count , AntXMLContext context ) throws SAXParseException { String s = new String ( buf , start , count ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , context . getLocator ( ) ) ; } } protected void checkNamespace ( String uri ) { } } public static class RootHandler extends DefaultHandler { private Stack antHandlers = new Stack ( ) ; private AntHandler currentHandler = null ; private AntXMLContext context ; public RootHandler ( AntXMLContext context , AntHandler rootHandler ) { currentHandler = rootHandler ; antHandlers . push ( currentHandler ) ; this . context = context ; } public AntHandler getCurrentAntHandler ( ) { return currentHandler ; } public InputSource resolveEntity ( String publicId , String systemId ) { context . getProject ( ) . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = fu . fromURI ( systemId ) ; File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = fu . resolveFile ( context . getBuildFileParent ( ) , path ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( fu . toURI ( file . getAbsolutePath ( ) ) ) ; return inputSource ; } catch ( FileNotFoundException fne ) { context . getProject ( ) . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String uri , String tag , String qname , Attributes attrs ) throws SAXParseException { AntHandler next = currentHandler . onStartChild ( uri , tag , qname , attrs , context ) ; antHandlers . push ( currentHandler ) ; currentHandler = next ; currentHandler . onStartElement ( uri , tag , qname , attrs , context ) ; } public void setDocumentLocator ( Locator locator ) { context . setLocator ( locator ) ; } public void endElement ( String uri , String name , String qName ) throws SAXException { currentHandler . onEndElement ( uri , name , context ) ; AntHandler prev = ( AntHandler ) antHandlers . pop ( ) ; currentHandler = prev ; if ( currentHandler != null ) { currentHandler . onEndChild ( uri , name , qName , context ) ; } } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { currentHandler . characters ( buf , start , count , context ) ; } public void startPrefixMapping ( String prefix , String uri ) { context . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) { context . endPrefixMapping ( prefix ) ; } } public static class MainHandler extends AntHandler { public AntHandler onStartChild ( String uri , String name , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { if ( name . equals ( "project" ) && ( uri . equals ( "" ) || uri . equals ( ANT_CORE_URI ) ) ) { return ProjectHelper2 . projectHandler ; } else { throw new SAXParseException ( "Unexpected element \"" + qname + "\" " + name , context . getLocator ( ) ) ; } } } public static class ProjectHandler extends AntHandler { public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { String id = null ; String baseDir = null ; boolean nameAttributeSet = false ; Project project = context . getProject ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String attrUri = attrs . getURI ( i ) ; if ( attrUri != null && ! attrUri . equals ( "" ) && ! attrUri . equals ( uri ) ) { continue ; } String key = attrs . getLocalName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { if ( value != null && ! value . equals ( "" ) ) { if ( ! context . isIgnoringProjectTag ( ) ) { project . setDefault ( value ) ; } } } else if ( key . equals ( "name" ) ) { if ( value != null ) { context . setCurrentProjectName ( value ) ; nameAttributeSet = true ; if ( ! context . isIgnoringProjectTag ( ) ) { project . setName ( value ) ; project . addReference ( value , project ) ; } } } else if ( key . equals ( "id" ) ) { if ( value != null ) { if ( ! context . isIgnoringProjectTag ( ) ) { project . addReference ( value , project ) ; } } } else if ( key . equals ( "basedir" ) ) { if ( ! context . isIgnoringProjectTag ( ) ) { baseDir = value ; } } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getQName ( i ) + "\"" , context . getLocator ( ) ) ; } } String antFileProp = "ant.file." + context . getCurrentProjectName ( ) ; String dup = project . getProperty ( antFileProp ) ; if ( dup != null && nameAttributeSet ) { File dupFile = new File ( dup ) ; if ( context . isIgnoringProjectTag ( ) && ! dupFile . equals ( context . getBuildFile ( ) ) ) { project . log ( "Duplicated project name in import. Project " + context . getCurrentProjectName ( ) + " defined first in " + dup + " and again in " + context . getBuildFile ( ) , Project . MSG_WARN ) ; } } if ( context . getBuildFile ( ) != null ) { project . setUserProperty ( "ant.file." + context . getCurrentProjectName ( ) , context . getBuildFile ( ) . toString ( ) ) ; } if ( context . isIgnoringProjectTag ( ) ) { return ; } if ( project . getProperty ( "basedir" ) != null ) { project . setBasedir ( project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { project . setBasedir ( context . getBuildFileParent ( ) . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { project . setBasedir ( baseDir ) ; } else { project . setBaseDir ( fu . resolveFile ( context . getBuildFileParent ( ) , baseDir ) ) ; } } } project . addTarget ( "" , context . getImplicitTarget ( ) ) ; context . setCurrentTarget ( context . getImplicitTarget ( ) ) ; } public AntHandler onStartChild ( String uri , String name , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { if ( name . equals ( "target" ) && ( uri . equals ( "" ) || uri . equals ( ANT_CORE_URI ) ) ) { return ProjectHelper2 . targetHandler ; } else { return ProjectHelper2 . elementHandler ; } } } public static class TargetHandler extends AntHandler { public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { String name = null ; String depends = "" ; Project project = context . getProject ( ) ; Target target = new Target ( ) ; target . setProject ( project ) ; context . addTarget ( target ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String attrUri = attrs . getURI ( i ) ; if ( attrUri != null && ! attrUri . equals ( "" ) && ! attrUri . equals ( uri ) ) { continue ; } String key = attrs . getLocalName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; if ( "" . equals ( name ) ) { throw new BuildException ( "name attribute must " + "not be empty" ) ; } } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { target . setIf ( value ) ; } else if ( key . equals ( "unless" ) ) { target . setUnless ( value ) ; } else if ( key . equals ( "id" ) ) { if ( value != null && ! value . equals ( "" ) ) { context . getProject ( ) . addReference ( value , target ) ; } } else if ( key . equals ( "description" ) ) { target . setDescription ( value ) ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , context . getLocator ( ) ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without " + "a name attribute" , context . getLocator ( ) ) ; } Hashtable currentTargets = project . getTargets ( ) ; if ( currentTargets . containsKey ( name ) ) { if ( context . getCurrentProjectName ( ) != null ) { String newName = context . getCurrentProjectName ( ) + "." + name ; project . log ( "Already defined in main or a previous import, " + "define " + name + " as " + newName , Project . MSG_VERBOSE ) ; name = newName ; } else { project . log ( "Already defined in main or a previous import, " + "ignore " + name , Project . MSG_VERBOSE ) ; name = null ; } } if ( name != null ) { target . setName ( name ) ; project . addOrReplaceTarget ( name , target ) ; } if ( depends . length ( ) > 0 ) { target . setDepends ( depends ) ; } } public AntHandler onStartChild ( String uri , String name , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { return ProjectHelper2 . elementHandler ; } public void onEndElement ( String uri , String tag , AntXMLContext context ) { context . setCurrentTarget ( context . getImplicitTarget ( ) ) ; } } public static class ElementHandler extends AntHandler { public ElementHandler ( ) { } public void onStartElement ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { RuntimeConfigurable parentWrapper = context . currentWrapper ( ) ; Object parent = null ; if ( parentWrapper != null ) { parent = parentWrapper . getProxy ( ) ; } UnknownElement task = new UnknownElement ( tag ) ; task . setProject ( context . getProject ( ) ) ; task . setNamespace ( uri ) ; task . setQName ( qname ) ; task . setTaskType ( ProjectHelper . genComponentName ( task . getNamespace ( ) , tag ) ) ; task . setTaskName ( qname ) ; Location location = new Location ( context . getLocator ( ) . getSystemId ( ) , context . getLocator ( ) . getLineNumber ( ) , context . getLocator ( ) . getColumnNumber ( ) ) ; task . setLocation ( location ) ; task . setOwningTarget ( context . getCurrentTarget ( ) ) ; context . configureId ( task , attrs ) ; if ( parent != null ) { ( ( UnknownElement ) parent ) . addChild ( task ) ; } else { context . getCurrentTarget ( ) . addTask ( task ) ; } RuntimeConfigurable wrapper = new RuntimeConfigurable ( task , task . getTaskName ( ) ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String attrUri = attrs . getURI ( i ) ; if ( attrUri != null && ! attrUri . equals ( "" ) && ! attrUri . equals ( uri ) ) { continue ; } String name = attrs . getLocalName ( i ) ; String value = attrs . getValue ( i ) ; if ( name . equals ( "ant-type" ) ) { int index = value . indexOf ( ":" ) ; if ( index != - 1 ) { String prefix = value . substring ( 0 , index ) ; String mappedUri = context . getPrefixMapping ( prefix ) ; if ( mappedUri == null ) { throw new BuildException ( "Unable to find XML NS prefix " + prefix ) ; } value = ProjectHelper . genComponentName ( mappedUri , value . substring ( index + 1 ) ) ; } } wrapper . setAttribute ( name , value ) ; } if ( parentWrapper != null ) { parentWrapper . addChild ( wrapper ) ; } context . pushWrapper ( wrapper ) ; } public void characters ( char [ ] buf , int start , int count , AntXMLContext context ) throws SAXParseException { RuntimeConfigurable wrapper = context . currentWrapper ( ) ; wrapper . addText ( buf , start , count ) ; } public AntHandler onStartChild ( String uri , String tag , String qname , Attributes attrs , AntXMLContext context ) throws SAXParseException { return ProjectHelper2 . elementHandler ; } public void onEndElement ( String uri , String tag , AntXMLContext context ) { context . popWrapper ( ) ; } } } 	1
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Gcj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { Commandline cmd ; attributes . log ( "Using gcj compiler" , Project . MSG_VERBOSE ) ; cmd = setupGCJCommand ( ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } protected Commandline setupGCJCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } classpath . addExtdirs ( extdirs ) ; if ( bootclasspath == null || bootclasspath . size ( ) == 0 ) { includeJavaRuntime = true ; } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "gcj" : exec ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; if ( destDir . mkdirs ( ) ) { throw new BuildException ( "Can't make output directories. " + "Maybe permission is wrong. " ) ; } ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "--encoding=" + encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g1" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } cmd . createArgument ( ) . setValue ( "-C" ) ; addCurrentCompilerArgs ( cmd ) ; return cmd ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Enumeration ; import java . util . Locale ; import java . util . NoSuchElementException ; import java . util . Properties ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . types . EnumeratedAttribute ; public abstract class Definer extends DefBase { private String name ; private String classname ; private File file ; private String resource ; private int format = Format . PROPERTIES ; private boolean definerSet = false ; private int onError = OnError . FAIL ; private String adapter ; private String adaptTo ; private Class adapterClass ; private Class adaptToClass ; public static class OnError extends EnumeratedAttribute { public static final int FAIL = 0 , REPORT = 1 , IGNORE = 2 ; public OnError ( ) { super ( ) ; } public OnError ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return new String [ ] { "fail" , "report" , "ignore" } ; } } public static class Format extends EnumeratedAttribute { public static final int PROPERTIES = 0 , XML = 1 ; public String [ ] getValues ( ) { return new String [ ] { "properties" , "xml" } ; } } public void setOnError ( OnError onError ) { this . onError = onError . getIndex ( ) ; } public void setFormat ( Format format ) { this . format = format . getIndex ( ) ; } public String getName ( ) { return name ; } public File getFile ( ) { return file ; } public String getResource ( ) { return resource ; } public void execute ( ) throws BuildException { ClassLoader al = createLoader ( ) ; if ( ! definerSet ) { throw new BuildException ( "name, file or resource attribute of " + getTaskName ( ) + " is undefined" , getLocation ( ) ) ; } if ( name != null ) { if ( classname == null ) { throw new BuildException ( "classname attribute of " + getTaskName ( ) + " element " + "is undefined" , getLocation ( ) ) ; } addDefinition ( al , name , classname ) ; } else { if ( classname != null ) { String msg = "You must not specify classname " + "together with file or resource." ; throw new BuildException ( msg , getLocation ( ) ) ; } Enumeration urls = null ; if ( file != null ) { final URL url = fileToURL ( ) ; urls = new Enumeration ( ) { private boolean more = true ; public boolean hasMoreElements ( ) { return more ; } public Object nextElement ( ) throws NoSuchElementException { if ( more ) { more = false ; return url ; } else { throw new NoSuchElementException ( ) ; } } } ; } else { urls = resourceToURLs ( al ) ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; int format = this . format ; if ( url . toString ( ) . toLowerCase ( Locale . US ) . endsWith ( ".xml" ) ) { format = Format . XML ; } if ( format == Format . PROPERTIES ) { loadProperties ( al , url ) ; break ; } else { loadAntlib ( al , url ) ; } } } } private URL fileToURL ( ) { if ( ! ( file . exists ( ) ) ) { log ( "File " + file + " does not exist" , Project . MSG_WARN ) ; return null ; } if ( ! ( file . isFile ( ) ) ) { log ( "File " + file + " is not a file" , Project . MSG_WARN ) ; return null ; } try { return file . toURL ( ) ; } catch ( Exception ex ) { log ( "File " + file + " cannot use as URL: " + ex . toString ( ) , Project . MSG_WARN ) ; return null ; } } private Enumeration resourceToURLs ( ClassLoader classLoader ) { Enumeration ret ; try { ret = classLoader . getResources ( resource ) ; } catch ( IOException e ) { throw new BuildException ( "Could not fetch resources named " + resource , e , getLocation ( ) ) ; } if ( ! ret . hasMoreElements ( ) ) { if ( onError != OnError . IGNORE ) { log ( "Could not load definitions from resource " + resource + ". It could not be found." , Project . MSG_WARN ) ; } } return ret ; } protected void loadProperties ( ClassLoader al , URL url ) { InputStream is = null ; try { is = url . openStream ( ) ; if ( is == null ) { log ( "Could not load definitions from " + url , Project . MSG_WARN ) ; return ; } Properties props = new Properties ( ) ; props . load ( is ) ; Enumeration keys = props . keys ( ) ; while ( keys . hasMoreElements ( ) ) { name = ( ( String ) keys . nextElement ( ) ) ; classname = props . getProperty ( name ) ; addDefinition ( al , name , classname ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } private void loadAntlib ( ClassLoader classLoader , URL url ) { try { Antlib antlib = Antlib . createAntlib ( getProject ( ) , url , getURI ( ) ) ; antlib . setClassLoader ( classLoader ) ; antlib . setURI ( getURI ( ) ) ; antlib . perform ( ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } } public void setFile ( File file ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . file = file ; } public void setResource ( String res ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . resource = res ; } public void setName ( String name ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . name = name ; } public String getClassname ( ) { return classname ; } public void setClassname ( String classname ) { this . classname = classname ; } public void setAdapter ( String adapter ) { this . adapter = adapter ; } protected void setAdapterClass ( Class adapterClass ) { this . adapterClass = adapterClass ; } public void setAdaptTo ( String adaptTo ) { this . adaptTo = adaptTo ; } protected void setAdaptToClass ( Class adaptToClass ) { this . adaptToClass = adaptToClass ; } protected void addDefinition ( ClassLoader al , String name , String classname ) throws BuildException { Class cl = null ; try { try { name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; if ( onError != OnError . IGNORE ) { cl = Class . forName ( classname , true , al ) ; } if ( adapter != null ) { adapterClass = Class . forName ( adapter , true , al ) ; } if ( adaptTo != null ) { adaptToClass = Class . forName ( adaptTo , true , al ) ; } AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( classname ) ; def . setClass ( cl ) ; def . setAdapterClass ( adapterClass ) ; def . setAdaptToClass ( adaptToClass ) ; def . setClassLoader ( al ) ; if ( cl != null ) { def . checkClass ( getProject ( ) ) ; } ComponentHelper . getComponentHelper ( getProject ( ) ) . addDataTypeDefinition ( def ) ; } catch ( ClassNotFoundException cnfe ) { String msg = getTaskName ( ) + " class " + classname + " cannot be found" ; throw new BuildException ( msg , cnfe , getLocation ( ) ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = getTaskName ( ) + " A class needed by class " + classname + " cannot be found: " + ncdfe . getMessage ( ) ; throw new BuildException ( msg , ncdfe , getLocation ( ) ) ; } } catch ( BuildException ex ) { switch ( onError ) { case OnError . FAIL : throw ex ; case OnError . REPORT : log ( ex . getLocation ( ) + "Warning: " + ex . getMessage ( ) , Project . MSG_WARN ) ; break ; default : log ( ex . getLocation ( ) + ex . getMessage ( ) , Project . MSG_DEBUG ) ; } } } private void tooManyDefinitions ( ) { throw new BuildException ( "Only one of the attributes name,file,resource" + " can be set" , getLocation ( ) ) ; } } 	1
package org . apache . tools . ant ; import java . io . BufferedReader ; import java . io . File ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import org . apache . tools . ant . helper . ProjectHelper2 ; import org . apache . tools . ant . util . LoaderUtils ; import org . xml . sax . AttributeList ; public class ProjectHelper { public static final String ANT_CORE_URI = "antlib:org.apache.tools.ant" ; public static final String ANT_CURRENT_URI = "ant:current" ; public static final String ANTLIB_URI = "antlib:" ; public static final String HELPER_PROPERTY = "org.apache.tools.ant.ProjectHelper" ; public static final String SERVICE_ID = "META-INF/services/org.apache.tools.ant.ProjectHelper" ; public static void configureProject ( Project project , File buildFile ) throws BuildException { ProjectHelper helper = ProjectHelper . getProjectHelper ( ) ; project . addReference ( "ant.projectHelper" , helper ) ; helper . parse ( project , buildFile ) ; } public ProjectHelper ( ) { } private Vector importStack = new Vector ( ) ; public Vector getImportStack ( ) { return importStack ; } public void parse ( Project project , Object source ) throws BuildException { throw new BuildException ( "ProjectHelper.parse() must be implemented " + "in a helper plugin " + this . getClass ( ) . getName ( ) ) ; } public static ProjectHelper getProjectHelper ( ) throws BuildException { ProjectHelper helper = null ; String helperClass = System . getProperty ( HELPER_PROPERTY ) ; try { if ( helperClass != null ) { helper = newHelper ( helperClass ) ; } } catch ( SecurityException e ) { System . out . println ( "Unable to load ProjectHelper class \"" + helperClass + " specified in system property " + HELPER_PROPERTY ) ; } if ( helper == null ) { try { ClassLoader classLoader = LoaderUtils . getContextClassLoader ( ) ; InputStream is = null ; if ( classLoader != null ) { is = classLoader . getResourceAsStream ( SERVICE_ID ) ; } if ( is == null ) { is = ClassLoader . getSystemResourceAsStream ( SERVICE_ID ) ; } if ( is != null ) { InputStreamReader isr ; try { isr = new InputStreamReader ( is , "UTF-8" ) ; } catch ( java . io . UnsupportedEncodingException e ) { isr = new InputStreamReader ( is ) ; } BufferedReader rd = new BufferedReader ( isr ) ; String helperClassName = rd . readLine ( ) ; rd . close ( ) ; if ( helperClassName != null && ! "" . equals ( helperClassName ) ) { helper = newHelper ( helperClassName ) ; } } } catch ( Exception ex ) { System . out . println ( "Unable to load ProjectHelper " + "from service \"" + SERVICE_ID ) ; } } if ( helper != null ) { return helper ; } else { try { return new ProjectHelper2 ( ) ; } catch ( Throwable e ) { String message = "Unable to load default ProjectHelper due to " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) ; throw new BuildException ( message , e ) ; } } } private static ProjectHelper newHelper ( String helperClass ) throws BuildException { ClassLoader classLoader = LoaderUtils . getContextClassLoader ( ) ; try { Class clazz = null ; if ( classLoader != null ) { try { clazz = classLoader . loadClass ( helperClass ) ; } catch ( ClassNotFoundException ex ) { } } if ( clazz == null ) { clazz = Class . forName ( helperClass ) ; } return ( ( ProjectHelper ) clazz . newInstance ( ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public static ClassLoader getContextClassLoader ( ) { if ( ! LoaderUtils . isContextLoaderAvailable ( ) ) { return null ; } return LoaderUtils . getContextClassLoader ( ) ; } public static void configure ( Object target , AttributeList attrs , Project project ) throws BuildException { if ( target instanceof TypeAdapter ) { target = ( ( TypeAdapter ) target ) . getProxy ( ) ; } IntrospectionHelper ih = IntrospectionHelper . getHelper ( target . getClass ( ) ) ; project . addBuildListener ( ih ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String value = replaceProperties ( project , attrs . getValue ( i ) , project . getProperties ( ) ) ; try { ih . setAttribute ( project , target , attrs . getName ( i ) . toLowerCase ( Locale . US ) , value ) ; } catch ( BuildException be ) { if ( ! attrs . getName ( i ) . equals ( "id" ) ) { throw be ; } } } } public static void addText ( Project project , Object target , char [ ] buf , int start , int count ) throws BuildException { addText ( project , target , new String ( buf , start , count ) ) ; } public static void addText ( Project project , Object target , String text ) throws BuildException { if ( text == null ) { return ; } if ( target instanceof TypeAdapter ) { target = ( ( TypeAdapter ) target ) . getProxy ( ) ; } IntrospectionHelper . getHelper ( target . getClass ( ) ) . addText ( project , target , text ) ; } public static void storeChild ( Project project , Object parent , Object child , String tag ) { IntrospectionHelper ih = IntrospectionHelper . getHelper ( parent . getClass ( ) ) ; ih . storeElement ( project , parent , child , tag ) ; } public static String replaceProperties ( Project project , String value ) throws BuildException { return project . replaceProperties ( value ) ; } public static String replaceProperties ( Project project , String value , Hashtable keys ) throws BuildException { PropertyHelper ph = PropertyHelper . getPropertyHelper ( project ) ; return ph . replaceProperties ( null , value , keys ) ; } public static void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { PropertyHelper . parsePropertyStringDefault ( value , fragments , propertyRefs ) ; } public static String genComponentName ( String uri , String name ) { if ( uri == null || uri . equals ( "" ) || uri . equals ( ANT_CORE_URI ) ) { return name ; } return uri + ":" + name ; } public static String extractUriFromComponentName ( String componentName ) { if ( componentName == null ) { return "" ; } int index = componentName . lastIndexOf ( ':' ) ; if ( index == - 1 ) { return "" ; } return componentName . substring ( 0 , index ) ; } public static String extractNameFromComponentName ( String componentName ) { int index = componentName . lastIndexOf ( ':' ) ; if ( index == - 1 ) { return componentName ; } return componentName . substring ( index + 1 ) ; } public static BuildException addLocationToBuildException ( BuildException ex , Location newLocation ) { if ( ex . getLocation ( ) == null || ex . getMessage ( ) == null ) { return ex ; } String errorMessage = "Following error occured while executing this line" + System . getProperty ( "line.separator" ) + ex . getLocation ( ) . toString ( ) + ex . getMessage ( ) ; if ( newLocation == null ) { return new BuildException ( errorMessage ) ; } else { return new BuildException ( errorMessage , newLocation ) ; } } } 	1
package org . apache . tools . ant ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; public class PropertyHelper { private Project project ; private PropertyHelper next ; private Hashtable properties = new Hashtable ( ) ; private Hashtable userProperties = new Hashtable ( ) ; private Hashtable inheritedProperties = new Hashtable ( ) ; protected PropertyHelper ( ) { } public void setProject ( Project p ) { this . project = p ; } public void setNext ( PropertyHelper next ) { this . next = next ; } public PropertyHelper getNext ( ) { return next ; } public static synchronized PropertyHelper getPropertyHelper ( Project project ) { PropertyHelper helper = ( PropertyHelper ) project . getReference ( "ant.PropertyHelper" ) ; if ( helper != null ) { return helper ; } helper = new PropertyHelper ( ) ; helper . setProject ( project ) ; project . addReference ( "ant.PropertyHelper" , helper ) ; return helper ; } public boolean setPropertyHook ( String ns , String name , Object value , boolean inherited , boolean user , boolean isNew ) { if ( getNext ( ) != null ) { boolean subst = getNext ( ) . setPropertyHook ( ns , name , value , inherited , user , isNew ) ; if ( subst ) { return true ; } } return false ; } public Object getPropertyHook ( String ns , String name , boolean user ) { if ( getNext ( ) != null ) { Object o = getNext ( ) . getPropertyHook ( ns , name , user ) ; if ( o != null ) { return o ; } } if ( name . startsWith ( "toString:" ) ) { name = name . substring ( "toString:" . length ( ) ) ; Object v = project . getReference ( name ) ; if ( v == null ) { return null ; } return v . toString ( ) ; } return null ; } public void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { parsePropertyStringDefault ( value , fragments , propertyRefs ) ; } public String replaceProperties ( String ns , String value , Hashtable keys ) throws BuildException { if ( value == null ) { return null ; } Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; parsePropertyString ( value , fragments , propertyRefs ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; Object replacement = null ; if ( keys != null ) { replacement = keys . get ( propertyName ) ; } if ( replacement == null ) { replacement = getProperty ( ns , propertyName ) ; } if ( replacement == null ) { project . log ( "Property ${" + propertyName + "} has not been set" , Project . MSG_VERBOSE ) ; } fragment = ( replacement != null ) ? replacement . toString ( ) : "${" + propertyName + "}" ; } sb . append ( fragment ) ; } return sb . toString ( ) ; } public synchronized boolean setProperty ( String ns , String name , Object value , boolean verbose ) { if ( null != userProperties . get ( name ) ) { if ( verbose ) { project . log ( "Override ignored for user property " + name , Project . MSG_VERBOSE ) ; } return false ; } boolean done = setPropertyHook ( ns , name , value , false , false , false ) ; if ( done ) { return true ; } if ( null != properties . get ( name ) && verbose ) { project . log ( "Overriding previous definition of property " + name , Project . MSG_VERBOSE ) ; } if ( verbose ) { project . log ( "Setting project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; } properties . put ( name , value ) ; return true ; } public synchronized void setNewProperty ( String ns , String name , Object value ) { if ( null != properties . get ( name ) ) { project . log ( "Override ignored for property " + name , Project . MSG_VERBOSE ) ; return ; } boolean done = setPropertyHook ( ns , name , value , false , false , true ) ; if ( done ) { return ; } project . log ( "Setting project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; if ( name != null && value != null ) { properties . put ( name , value ) ; } } public synchronized void setUserProperty ( String ns , String name , Object value ) { project . log ( "Setting ro project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; userProperties . put ( name , value ) ; boolean done = setPropertyHook ( ns , name , value , false , true , false ) ; if ( done ) { return ; } properties . put ( name , value ) ; } public synchronized void setInheritedProperty ( String ns , String name , Object value ) { inheritedProperties . put ( name , value ) ; project . log ( "Setting ro project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; userProperties . put ( name , value ) ; boolean done = setPropertyHook ( ns , name , value , true , false , false ) ; if ( done ) { return ; } properties . put ( name , value ) ; } public synchronized Object getProperty ( String ns , String name ) { if ( name == null ) { return null ; } Object o = getPropertyHook ( ns , name , false ) ; if ( o != null ) { return o ; } return properties . get ( name ) ; } public synchronized Object getUserProperty ( String ns , String name ) { if ( name == null ) { return null ; } Object o = getPropertyHook ( ns , name , true ) ; if ( o != null ) { return o ; } return userProperties . get ( name ) ; } public Hashtable getProperties ( ) { Hashtable propertiesCopy = new Hashtable ( ) ; Enumeration e = properties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; Object value = properties . get ( name ) ; propertiesCopy . put ( name , value ) ; } return propertiesCopy ; } public Hashtable getUserProperties ( ) { Hashtable propertiesCopy = new Hashtable ( ) ; Enumeration e = userProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; Object value = properties . get ( name ) ; propertiesCopy . put ( name , value ) ; } return propertiesCopy ; } public void copyInheritedProperties ( Project other ) { Enumeration e = inheritedProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = e . nextElement ( ) . toString ( ) ; if ( other . getUserProperty ( arg ) != null ) { continue ; } Object value = inheritedProperties . get ( arg ) ; other . setInheritedProperty ( arg , value . toString ( ) ) ; } } public void copyUserProperties ( Project other ) { Enumeration e = userProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object arg = e . nextElement ( ) ; if ( inheritedProperties . containsKey ( arg ) ) { continue ; } Object value = userProperties . get ( arg ) ; other . setUserProperty ( arg . toString ( ) , value . toString ( ) ) ; } } static void parsePropertyStringDefault ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { int prev = 0 ; int pos ; while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos > 0 ) { fragments . addElement ( value . substring ( prev , pos ) ) ; } if ( pos == ( value . length ( ) - 1 ) ) { fragments . addElement ( "$" ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { if ( value . charAt ( pos + 1 ) == '$' ) { fragments . addElement ( "$" ) ; prev = pos + 2 ; } else { fragments . addElement ( value . substring ( pos , pos + 2 ) ) ; prev = pos + 2 ; } } else { int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new BuildException ( "Syntax error in property: " + value ) ; } String propertyName = value . substring ( pos + 2 , endName ) ; fragments . addElement ( null ) ; propertyRefs . addElement ( propertyName ) ; prev = endName + 1 ; } } if ( prev < value . length ( ) ) { fragments . addElement ( value . substring ( prev ) ) ; } } } 	1
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import java . util . List ; import java . util . LinkedList ; import java . util . ListIterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private SysProperties sysProperties = new SysProperties ( ) ; private Path classpath = null ; private Path bootclasspath = null ; private String vmVersion ; private String maxMemory = null ; private Assertions assertions = null ; private boolean executeJar = false ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; private Vector propertySets = new Vector ( ) ; public String [ ] getVariables ( ) throws BuildException { List definitions = new LinkedList ( ) ; ListIterator list = definitions . listIterator ( ) ; addDefinitionsToList ( list ) ; if ( definitions . size ( ) == 0 ) { return null ; } else { return ( String [ ] ) definitions . toArray ( new String [ 0 ] ) ; } } public void addDefinitionsToList ( ListIterator listIt ) { String [ ] props = super . getVariables ( ) ; if ( props != null ) { for ( int i = 0 ; i < props . length ; i ++ ) { listIt . add ( "-D" + props [ i ] ) ; } } Properties propertySets = mergePropertySets ( ) ; for ( Enumeration e = propertySets . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = propertySets . getProperty ( key ) ; listIt . add ( "-D" + key + "=" + value ) ; } } public int size ( ) { Properties p = mergePropertySets ( ) ; return variables . size ( ) + p . size ( ) ; } public void setSystem ( ) throws BuildException { try { sys = System . getProperties ( ) ; Properties p = new Properties ( ) ; for ( Enumeration e = sys . keys ( ) ; e . hasMoreElements ( ) ; ) { Object o = e . nextElement ( ) ; p . put ( o , sys . get ( o ) ) ; } p . putAll ( mergePropertySets ( ) ) ; for ( Enumeration e = variables . elements ( ) ; e . hasMoreElements ( ) ; ) { Environment . Variable v = ( Environment . Variable ) e . nextElement ( ) ; p . put ( v . getKey ( ) , v . getValue ( ) ) ; } System . setProperties ( p ) ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public void restoreSystem ( ) throws BuildException { if ( sys == null ) { throw new BuildException ( "Unbalanced nesting of SysProperties" ) ; } try { System . setProperties ( sys ) ; sys = null ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public Object clone ( ) { try { SysProperties c = ( SysProperties ) super . clone ( ) ; c . variables = ( Vector ) variables . clone ( ) ; c . propertySets = ( Vector ) propertySets . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { return null ; } } public void addSyspropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } private Properties mergePropertySets ( ) { Properties p = new Properties ( ) ; for ( Enumeration e = propertySets . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; p . putAll ( ps . getProperties ( ) ) ; } return p ; } } public CommandlineJava ( ) { setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; setVmversion ( JavaEnvUtils . getJavaVersion ( ) ) ; } public Commandline . Argument createArgument ( ) { return javaCommand . createArgument ( ) ; } public Commandline . Argument createVmArgument ( ) { return vmCommand . createArgument ( ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { sysProperties . addSyspropertyset ( sysp ) ; } public void setVm ( String vm ) { vmCommand . setExecutable ( vm ) ; } public void setVmversion ( String value ) { vmVersion = value ; } public Assertions getAssertions ( ) { return assertions ; } public void setAssertions ( Assertions assertions ) { this . assertions = assertions ; } public void setJar ( String jarpathname ) { javaCommand . setExecutable ( jarpathname ) ; executeJar = true ; } public String getJar ( ) { if ( executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public void setClassname ( String classname ) { javaCommand . setExecutable ( classname ) ; executeJar = false ; } public String getClassname ( ) { if ( ! executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public Path createClasspath ( Project p ) { if ( classpath == null ) { classpath = new Path ( p ) ; } return classpath ; } public Path createBootclasspath ( Project p ) { if ( bootclasspath == null ) { bootclasspath = new Path ( p ) ; } return bootclasspath ; } public String getVmversion ( ) { return vmVersion ; } public String [ ] getCommandline ( ) { List commands = new LinkedList ( ) ; final ListIterator listIterator = commands . listIterator ( ) ; addCommandsToList ( listIterator ) ; return ( String [ ] ) commands . toArray ( new String [ 0 ] ) ; } private void addCommandsToList ( final ListIterator listIterator ) { getActualVMCommand ( ) . addCommandToList ( listIterator ) ; sysProperties . addDefinitionsToList ( listIterator ) ; if ( haveBootclasspath ( true ) ) { listIterator . add ( "-Xbootclasspath:" + bootclasspath . toString ( ) ) ; } if ( haveClasspath ( ) ) { listIterator . add ( "-classpath" ) ; listIterator . add ( classpath . concatSystemClasspath ( "ignore" ) . toString ( ) ) ; } if ( getAssertions ( ) != null ) { getAssertions ( ) . applyAssertions ( this ) ; } if ( executeJar ) { listIterator . add ( "-jar" ) ; } javaCommand . addCommandToList ( listIterator ) ; } public void setMaxmemory ( String max ) { this . maxMemory = max ; } public String toString ( ) { return Commandline . toString ( getCommandline ( ) ) ; } public String describeCommand ( ) { return Commandline . describeCommand ( getCommandline ( ) ) ; } public String describeJavaCommand ( ) { return Commandline . describeCommand ( getJavaCommand ( ) ) ; } private Commandline getActualVMCommand ( ) { Commandline actualVMCommand = ( Commandline ) vmCommand . clone ( ) ; if ( maxMemory != null ) { if ( vmVersion . startsWith ( "1.1" ) ) { actualVMCommand . createArgument ( ) . setValue ( "-mx" + maxMemory ) ; } else { actualVMCommand . createArgument ( ) . setValue ( "-Xmx" + maxMemory ) ; } } return actualVMCommand ; } public int size ( ) { int size = getActualVMCommand ( ) . size ( ) + javaCommand . size ( ) + sysProperties . size ( ) ; if ( haveClasspath ( ) ) { size += 2 ; } if ( haveBootclasspath ( true ) ) { size ++ ; } if ( executeJar ) { size ++ ; } if ( getAssertions ( ) != null ) { size += getAssertions ( ) . size ( ) ; } return size ; } public Commandline getJavaCommand ( ) { return javaCommand ; } public Commandline getVmCommand ( ) { return getActualVMCommand ( ) ; } public Path getClasspath ( ) { return classpath ; } public Path getBootclasspath ( ) { return bootclasspath ; } public void setSystemProperties ( ) throws BuildException { sysProperties . setSystem ( ) ; } public void restoreSystemProperties ( ) throws BuildException { sysProperties . restoreSystem ( ) ; } public SysProperties getSystemProperties ( ) { return sysProperties ; } public Object clone ( ) { try { CommandlineJava c = ( CommandlineJava ) super . clone ( ) ; c . vmCommand = ( Commandline ) vmCommand . clone ( ) ; c . javaCommand = ( Commandline ) javaCommand . clone ( ) ; c . sysProperties = ( SysProperties ) sysProperties . clone ( ) ; if ( classpath != null ) { c . classpath = ( Path ) classpath . clone ( ) ; } if ( bootclasspath != null ) { c . bootclasspath = ( Path ) bootclasspath . clone ( ) ; } if ( assertions != null ) { c . assertions = ( Assertions ) assertions . clone ( ) ; } return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public void clearJavaArgs ( ) { javaCommand . clearArgs ( ) ; } private boolean haveClasspath ( ) { Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; return fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ; } private boolean haveBootclasspath ( boolean log ) { if ( bootclasspath != null && bootclasspath . toString ( ) . trim ( ) . length ( ) > 0 ) { if ( ! bootclasspath . toString ( ) . equals ( bootclasspath . concatSystemClasspath ( "ignore" ) . toString ( ) ) ) { if ( log ) { System . out . println ( "Ignoring bootclasspath as " + "build.sysclasspath has been set." ) ; } } else if ( vmVersion . startsWith ( "1.1" ) ) { if ( log ) { System . out . println ( "Ignoring bootclasspath as " + "the target VM doesn't support it." ) ; } } else { return true ; } } return false ; } } 	1
package org . apache . tools . ant ; import java . io . File ; import java . io . IOException ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Map ; import java . util . Set ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . SelectorScanner ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . util . FileUtils ; public class DirectoryScanner implements FileScanner , SelectorScanner , ResourceFactory { private static final boolean ON_VMS = Os . isFamily ( "openvms" ) ; protected static final String [ ] DEFAULTEXCLUDES = { "**/*~" , "**/#*#" , "**/.#*" , "**/%*%" , "**/._*" , "**/CVS" , "**/CVS/**" , "**/.cvsignore" , "**/SCCS" , "**/SCCS/**" , "**/vssver.scc" , "**/.svn" , "**/.svn/**" , "**/.DS_Store" } ; private static Vector defaultExcludes = new Vector ( ) ; static { resetDefaultExcludes ( ) ; } protected File basedir ; protected String [ ] includes ; protected String [ ] excludes ; protected FileSelector [ ] selectors = null ; protected Vector filesIncluded ; protected Vector filesNotIncluded ; protected Vector filesExcluded ; protected Vector dirsIncluded ; protected Vector dirsNotIncluded ; protected Vector dirsExcluded ; protected Vector filesDeselected ; protected Vector dirsDeselected ; protected boolean haveSlowResults = false ; protected boolean isCaseSensitive = true ; private boolean followSymlinks = true ; private static final FileUtils fileUtils = FileUtils . newFileUtils ( ) ; protected boolean everythingIncluded = true ; public DirectoryScanner ( ) { } protected static boolean matchPatternStart ( String pattern , String str ) { return SelectorUtils . matchPatternStart ( pattern , str ) ; } protected static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . matchPatternStart ( pattern , str , isCaseSensitive ) ; } protected static boolean matchPath ( String pattern , String str ) { return SelectorUtils . matchPath ( pattern , str ) ; } protected static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . matchPath ( pattern , str , isCaseSensitive ) ; } public static boolean match ( String pattern , String str ) { return SelectorUtils . match ( pattern , str ) ; } protected static boolean match ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . match ( pattern , str , isCaseSensitive ) ; } public static String [ ] getDefaultExcludes ( ) { return ( String [ ] ) defaultExcludes . toArray ( new String [ defaultExcludes . size ( ) ] ) ; } public static boolean addDefaultExclude ( String s ) { if ( defaultExcludes . indexOf ( s ) == - 1 ) { defaultExcludes . add ( s ) ; return true ; } return false ; } public static boolean removeDefaultExclude ( String s ) { return defaultExcludes . remove ( s ) ; } public static void resetDefaultExcludes ( ) { defaultExcludes = new Vector ( ) ; for ( int i = 0 ; i < DEFAULTEXCLUDES . length ; i ++ ) { defaultExcludes . add ( DEFAULTEXCLUDES [ i ] ) ; } } public void setBasedir ( String basedir ) { setBasedir ( new File ( basedir . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ) ) ; } public void setBasedir ( File basedir ) { this . basedir = basedir ; } public File getBasedir ( ) { return basedir ; } public boolean isCaseSensitive ( ) { return isCaseSensitive ; } public void setCaseSensitive ( boolean isCaseSensitive ) { this . isCaseSensitive = isCaseSensitive ; } public boolean isFollowSymlinks ( ) { return followSymlinks ; } public void setFollowSymlinks ( boolean followSymlinks ) { this . followSymlinks = followSymlinks ; } public void setIncludes ( String [ ] includes ) { if ( includes == null ) { this . includes = null ; } else { this . includes = new String [ includes . length ] ; for ( int i = 0 ; i < includes . length ; i ++ ) { String pattern ; pattern = includes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . includes [ i ] = pattern ; } } } public void setExcludes ( String [ ] excludes ) { if ( excludes == null ) { this . excludes = null ; } else { this . excludes = new String [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i ++ ) { String pattern ; pattern = excludes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . excludes [ i ] = pattern ; } } } public void setSelectors ( FileSelector [ ] selectors ) { this . selectors = selectors ; } public boolean isEverythingIncluded ( ) { return everythingIncluded ; } public void scan ( ) throws IllegalStateException { if ( basedir == null ) { throw new IllegalStateException ( "No basedir set" ) ; } if ( ! basedir . exists ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " does not exist" ) ; } if ( ! basedir . isDirectory ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " is not a directory" ) ; } if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } filesIncluded = new Vector ( ) ; filesNotIncluded = new Vector ( ) ; filesExcluded = new Vector ( ) ; filesDeselected = new Vector ( ) ; dirsIncluded = new Vector ( ) ; dirsNotIncluded = new Vector ( ) ; dirsExcluded = new Vector ( ) ; dirsDeselected = new Vector ( ) ; if ( isIncluded ( "" ) ) { if ( ! isExcluded ( "" ) ) { if ( isSelected ( "" , basedir ) ) { dirsIncluded . addElement ( "" ) ; } else { dirsDeselected . addElement ( "" ) ; } } else { dirsExcluded . addElement ( "" ) ; } } else { dirsNotIncluded . addElement ( "" ) ; } checkIncludePatterns ( ) ; clearCaches ( ) ; } private void checkIncludePatterns ( ) { Hashtable newroots = new Hashtable ( ) ; for ( int icounter = 0 ; icounter < includes . length ; icounter ++ ) { String newpattern = SelectorUtils . rtrimWildcardTokens ( includes [ icounter ] ) ; newroots . put ( newpattern , includes [ icounter ] ) ; } if ( newroots . containsKey ( "" ) ) { scandir ( basedir , "" , true ) ; } else { Enumeration enum2 = newroots . keys ( ) ; File canonBase = null ; try { canonBase = basedir . getCanonicalFile ( ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } while ( enum2 . hasMoreElements ( ) ) { String currentelement = ( String ) enum2 . nextElement ( ) ; String originalpattern = ( String ) newroots . get ( currentelement ) ; File myfile = new File ( basedir , currentelement ) ; if ( myfile . exists ( ) ) { try { File canonFile = myfile . getCanonicalFile ( ) ; String path = fileUtils . removeLeadingPath ( canonBase , canonFile ) ; if ( ! path . equals ( currentelement ) || ON_VMS ) { myfile = findFile ( basedir , currentelement ) ; if ( myfile != null ) { currentelement = fileUtils . removeLeadingPath ( basedir , myfile ) ; } } } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } if ( ( myfile == null || ! myfile . exists ( ) ) && ! isCaseSensitive ) { File f = findFileCaseInsensitive ( basedir , currentelement ) ; if ( f . exists ( ) ) { currentelement = fileUtils . removeLeadingPath ( basedir , f ) ; myfile = f ; } } if ( myfile != null && myfile . exists ( ) ) { if ( ! followSymlinks && isSymlink ( basedir , currentelement ) ) { continue ; } if ( myfile . isDirectory ( ) ) { if ( isIncluded ( currentelement ) && currentelement . length ( ) > 0 ) { accountForIncludedDir ( currentelement , myfile , true ) ; } else { if ( currentelement . length ( ) > 0 ) { if ( currentelement . charAt ( currentelement . length ( ) - 1 ) != File . separatorChar ) { currentelement = currentelement + File . separatorChar ; } } scandir ( myfile , currentelement , true ) ; } } else { if ( isCaseSensitive && originalpattern . equals ( currentelement ) ) { accountForIncludedFile ( currentelement , myfile ) ; } else if ( ! isCaseSensitive && originalpattern . equalsIgnoreCase ( currentelement ) ) { accountForIncludedFile ( currentelement , myfile ) ; } } } } } } protected void slowScan ( ) { if ( haveSlowResults ) { return ; } String [ ] excl = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( excl ) ; String [ ] notIncl = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( notIncl ) ; for ( int i = 0 ; i < excl . length ; i ++ ) { if ( ! couldHoldIncluded ( excl [ i ] ) ) { scandir ( new File ( basedir , excl [ i ] ) , excl [ i ] + File . separator , false ) ; } } for ( int i = 0 ; i < notIncl . length ; i ++ ) { if ( ! couldHoldIncluded ( notIncl [ i ] ) ) { scandir ( new File ( basedir , notIncl [ i ] ) , notIncl [ i ] + File . separator , false ) ; } } haveSlowResults = true ; } protected void scandir ( File dir , String vpath , boolean fast ) { if ( fast && hasBeenScanned ( vpath ) ) { return ; } String [ ] newfiles = dir . list ( ) ; if ( newfiles == null ) { throw new BuildException ( "IO error scanning directory " + dir . getAbsolutePath ( ) ) ; } if ( ! followSymlinks ) { Vector noLinks = new Vector ( ) ; for ( int i = 0 ; i < newfiles . length ; i ++ ) { try { if ( fileUtils . isSymbolicLink ( dir , newfiles [ i ] ) ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { dirsExcluded . addElement ( name ) ; } else { filesExcluded . addElement ( name ) ; } } else { noLinks . addElement ( newfiles [ i ] ) ; } } catch ( IOException ioe ) { String msg = "IOException caught while checking " + "for links, couldn't get canonical path!" ; System . err . println ( msg ) ; noLinks . addElement ( newfiles [ i ] ) ; } } newfiles = new String [ noLinks . size ( ) ] ; noLinks . copyInto ( newfiles ) ; } for ( int i = 0 ; i < newfiles . length ; i ++ ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { if ( isIncluded ( name ) ) { accountForIncludedDir ( name , file , fast ) ; } else { everythingIncluded = false ; dirsNotIncluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } if ( ! fast ) { scandir ( file , name + File . separator , fast ) ; } } else if ( file . isFile ( ) ) { if ( isIncluded ( name ) ) { accountForIncludedFile ( name , file ) ; } else { everythingIncluded = false ; filesNotIncluded . addElement ( name ) ; } } } } private void accountForIncludedFile ( String name , File file ) { if ( ! filesIncluded . contains ( name ) && ! filesExcluded . contains ( name ) && ! filesDeselected . contains ( name ) ) { if ( ! isExcluded ( name ) ) { if ( isSelected ( name , file ) ) { filesIncluded . addElement ( name ) ; } else { everythingIncluded = false ; filesDeselected . addElement ( name ) ; } } else { everythingIncluded = false ; filesExcluded . addElement ( name ) ; } } } private void accountForIncludedDir ( String name , File file , boolean fast ) { if ( ! dirsIncluded . contains ( name ) && ! dirsExcluded . contains ( name ) && ! dirsDeselected . contains ( name ) ) { if ( ! isExcluded ( name ) ) { if ( isSelected ( name , file ) ) { dirsIncluded . addElement ( name ) ; if ( fast ) { scandir ( file , name + File . separator , fast ) ; } } else { everythingIncluded = false ; dirsDeselected . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } } else { everythingIncluded = false ; dirsExcluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } } } protected boolean isIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPath ( includes [ i ] , name , isCaseSensitive ) ) { return true ; } } return false ; } protected boolean couldHoldIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPatternStart ( includes [ i ] , name , isCaseSensitive ) ) { if ( isMorePowerfulThanExcludes ( name , includes [ i ] ) ) { return true ; } } } return false ; } private boolean isMorePowerfulThanExcludes ( String name , String includepattern ) { String soughtexclude = name + File . separator + "**" ; for ( int counter = 0 ; counter < excludes . length ; counter ++ ) { if ( excludes [ counter ] . equals ( soughtexclude ) ) { return false ; } } return true ; } protected boolean isExcluded ( String name ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { if ( matchPath ( excludes [ i ] , name , isCaseSensitive ) ) { return true ; } } return false ; } protected boolean isSelected ( String name , File file ) { if ( selectors != null ) { for ( int i = 0 ; i < selectors . length ; i ++ ) { if ( ! selectors [ i ] . isSelected ( basedir , name , file ) ) { return false ; } } } return true ; } public String [ ] getIncludedFiles ( ) { String [ ] files = new String [ filesIncluded . size ( ) ] ; filesIncluded . copyInto ( files ) ; Arrays . sort ( files ) ; return files ; } public String [ ] getNotIncludedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesNotIncluded . size ( ) ] ; filesNotIncluded . copyInto ( files ) ; return files ; } public String [ ] getExcludedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesExcluded . size ( ) ] ; filesExcluded . copyInto ( files ) ; return files ; } public String [ ] getDeselectedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesDeselected . size ( ) ] ; filesDeselected . copyInto ( files ) ; return files ; } public String [ ] getIncludedDirectories ( ) { String [ ] directories = new String [ dirsIncluded . size ( ) ] ; dirsIncluded . copyInto ( directories ) ; Arrays . sort ( directories ) ; return directories ; } public String [ ] getNotIncludedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( directories ) ; return directories ; } public String [ ] getExcludedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( directories ) ; return directories ; } public String [ ] getDeselectedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsDeselected . size ( ) ] ; dirsDeselected . copyInto ( directories ) ; return directories ; } public void addDefaultExcludes ( ) { int excludesLength = excludes == null ? 0 : excludes . length ; String [ ] newExcludes ; newExcludes = new String [ excludesLength + defaultExcludes . size ( ) ] ; if ( excludesLength > 0 ) { System . arraycopy ( excludes , 0 , newExcludes , 0 , excludesLength ) ; } String [ ] defaultExcludesTemp = getDefaultExcludes ( ) ; for ( int i = 0 ; i < defaultExcludesTemp . length ; i ++ ) { newExcludes [ i + excludesLength ] = defaultExcludesTemp [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } excludes = newExcludes ; } public Resource getResource ( String name ) { File f = fileUtils . resolveFile ( basedir , name ) ; return new Resource ( name , f . exists ( ) , f . lastModified ( ) , f . isDirectory ( ) ) ; } private Map fileListMap = new HashMap ( ) ; private String [ ] list ( File file ) { String [ ] files = ( String [ ] ) fileListMap . get ( file ) ; if ( files == null ) { files = file . list ( ) ; if ( files != null ) { fileListMap . put ( file , files ) ; } } return files ; } private File findFileCaseInsensitive ( File base , String path ) { File f = findFileCaseInsensitive ( base , SelectorUtils . tokenizePath ( path ) ) ; return f == null ? new File ( base , path ) : f ; } private File findFileCaseInsensitive ( File base , Vector pathElements ) { if ( pathElements . size ( ) == 0 ) { return base ; } else { if ( ! base . isDirectory ( ) ) { return null ; } String [ ] files = list ( base ) ; if ( files == null ) { throw new BuildException ( "IO error scanning directory " + base . getAbsolutePath ( ) ) ; } String current = ( String ) pathElements . remove ( 0 ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . equals ( current ) ) { base = new File ( base , files [ i ] ) ; return findFileCaseInsensitive ( base , pathElements ) ; } } for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . equalsIgnoreCase ( current ) ) { base = new File ( base , files [ i ] ) ; return findFileCaseInsensitive ( base , pathElements ) ; } } } return null ; } private File findFile ( File base , String path ) { return findFile ( base , SelectorUtils . tokenizePath ( path ) ) ; } private File findFile ( File base , Vector pathElements ) { if ( pathElements . size ( ) == 0 ) { return base ; } else { if ( ! base . isDirectory ( ) ) { return null ; } String [ ] files = list ( base ) ; if ( files == null ) { throw new BuildException ( "IO error scanning directory " + base . getAbsolutePath ( ) ) ; } String current = ( String ) pathElements . remove ( 0 ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . equals ( current ) ) { base = new File ( base , files [ i ] ) ; return findFile ( base , pathElements ) ; } } } return null ; } private boolean isSymlink ( File base , String path ) { return isSymlink ( base , SelectorUtils . tokenizePath ( path ) ) ; } private boolean isSymlink ( File base , Vector pathElements ) { if ( pathElements . size ( ) > 0 ) { String current = ( String ) pathElements . remove ( 0 ) ; try { if ( fileUtils . isSymbolicLink ( base , current ) ) { return true ; } else { base = new File ( base , current ) ; return isSymlink ( base , pathElements ) ; } } catch ( IOException ioe ) { String msg = "IOException caught while checking " + "for links, couldn't get canonical path!" ; System . err . println ( msg ) ; return false ; } } return false ; } private Set scannedDirs = new HashSet ( ) ; private boolean hasBeenScanned ( String vpath ) { return ! scannedDirs . add ( vpath ) ; } private void clearCaches ( ) { fileListMap . clear ( ) ; scannedDirs . clear ( ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread outputThread ; private Thread errorThread ; private Thread inputThread ; private OutputStream out ; private OutputStream err ; private InputStream input ; public PumpStreamHandler ( OutputStream out , OutputStream err , InputStream input ) { this . out = out ; this . err = err ; this . input = input ; } public PumpStreamHandler ( OutputStream out , OutputStream err ) { this ( out , err , null ) ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { if ( err != null ) { createProcessErrorPump ( is , err ) ; } } public void setProcessInputStream ( OutputStream os ) { if ( input != null ) { inputThread = createPump ( input , os , true ) ; } else { try { os . close ( ) ; } catch ( IOException e ) { } } } public void start ( ) { outputThread . start ( ) ; errorThread . start ( ) ; if ( inputThread != null ) { inputThread . start ( ) ; } } public void stop ( ) { try { outputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } if ( inputThread != null ) { try { inputThread . join ( ) ; } catch ( InterruptedException e ) { } } try { err . flush ( ) ; } catch ( IOException e ) { } try { out . flush ( ) ; } catch ( IOException e ) { } } protected OutputStream getErr ( ) { return err ; } protected OutputStream getOut ( ) { return out ; } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { outputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { return createPump ( is , os , false ) ; } protected Thread createPump ( InputStream is , OutputStream os , boolean closeWhenExhausted ) { final Thread result = new Thread ( new StreamPumper ( is , os , closeWhenExhausted ) ) ; result . setDaemon ( true ) ; return result ; } } 	1
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . zip . UnixStat ; public class ZipFileSet extends FileSet { public static final int DEFAULT_DIR_MODE = UnixStat . DIR_FLAG | UnixStat . DEFAULT_DIR_PERM ; public static final int DEFAULT_FILE_MODE = UnixStat . FILE_FLAG | UnixStat . DEFAULT_FILE_PERM ; private File srcFile = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; private int fileMode = DEFAULT_FILE_MODE ; private int dirMode = DEFAULT_DIR_MODE ; private boolean fileModeHasBeenSet = false ; private boolean dirModeHasBeenSet = false ; public ZipFileSet ( ) { super ( ) ; } protected ZipFileSet ( FileSet fileset ) { super ( fileset ) ; } protected ZipFileSet ( ZipFileSet fileset ) { super ( fileset ) ; srcFile = fileset . srcFile ; prefix = fileset . prefix ; fullpath = fileset . fullpath ; hasDir = fileset . hasDir ; fileMode = fileset . fileMode ; dirMode = fileset . dirMode ; fileModeHasBeenSet = fileset . fileModeHasBeenSet ; dirModeHasBeenSet = fileset . dirModeHasBeenSet ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( srcFile != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void setSrc ( File srcFile ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . srcFile = srcFile ; } public File getSrc ( Project p ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( p ) ) . getSrc ( p ) ; } return srcFile ; } public void setPrefix ( String prefix ) { if ( ! prefix . equals ( "" ) && ! fullpath . equals ( "" ) ) { throw new BuildException ( "Cannot set both fullpath and prefix attributes" ) ; } this . prefix = prefix ; } public String getPrefix ( Project p ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( p ) ) . getPrefix ( p ) ; } return prefix ; } public void setFullpath ( String fullpath ) { if ( ! prefix . equals ( "" ) && ! fullpath . equals ( "" ) ) { throw new BuildException ( "Cannot set both fullpath and prefix attributes" ) ; } this . fullpath = fullpath ; } public String getFullpath ( Project p ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( p ) ) . getFullpath ( p ) ; } return fullpath ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( srcFile != null ) { ZipScanner zs = new ZipScanner ( ) ; zs . setSrc ( srcFile ) ; super . setDir ( p . getBaseDir ( ) ) ; setupDirectoryScanner ( zs , p ) ; zs . init ( ) ; return zs ; } else { return super . getDirectoryScanner ( p ) ; } } public void setFileMode ( String octalString ) { fileModeHasBeenSet = true ; this . fileMode = UnixStat . FILE_FLAG | Integer . parseInt ( octalString , 8 ) ; } public int getFileMode ( Project p ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( p ) ) . getFileMode ( p ) ; } return fileMode ; } public boolean hasFileModeBeenSet ( ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( getProject ( ) ) ) . hasFileModeBeenSet ( ) ; } return fileModeHasBeenSet ; } public void setDirMode ( String octalString ) { dirModeHasBeenSet = true ; this . dirMode = UnixStat . DIR_FLAG | Integer . parseInt ( octalString , 8 ) ; } public int getDirMode ( Project p ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( p ) ) . getDirMode ( p ) ; } return dirMode ; } public boolean hasDirModeBeenSet ( ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( getProject ( ) ) ) . hasDirModeBeenSet ( ) ; } return dirModeHasBeenSet ; } protected AbstractFileSet getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( o instanceof ZipFileSet ) { return ( AbstractFileSet ) o ; } else if ( o instanceof FileSet ) { ZipFileSet zfs = new ZipFileSet ( ( FileSet ) o ) ; zfs . setPrefix ( prefix ) ; zfs . setFullpath ( fullpath ) ; zfs . fileModeHasBeenSet = fileModeHasBeenSet ; zfs . fileMode = fileMode ; zfs . dirModeHasBeenSet = dirModeHasBeenSet ; zfs . dirMode = dirMode ; return zfs ; } else { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a zipfileset or a fileset" ; throw new BuildException ( msg ) ; } } public Object clone ( ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } } 	1
package org . apache . tools . ant ; import org . apache . tools . ant . util . LoaderUtils ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . parsers . SAXParser ; import java . io . File ; import java . io . FilenameFilter ; import java . io . PrintStream ; import java . io . InputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Properties ; import java . lang . reflect . Method ; import java . lang . reflect . InvocationTargetException ; public final class Diagnostics { private static final String TEST_CLASS = "org.apache.tools.ant.taskdefs.optional.Test" ; private Diagnostics ( ) { } public static boolean isOptionalAvailable ( ) { try { Class . forName ( TEST_CLASS ) ; } catch ( ClassNotFoundException e ) { return false ; } return true ; } public static void validateVersion ( ) throws BuildException { try { Class optional = Class . forName ( "org.apache.tools.ant.taskdefs.optional.Test" ) ; String coreVersion = getImplementationVersion ( Main . class ) ; String optionalVersion = getImplementationVersion ( optional ) ; if ( coreVersion != null && ! coreVersion . equals ( optionalVersion ) ) { throw new BuildException ( "Invalid implementation version " + "between Ant core and Ant optional tasks.\n" + " core    : " + coreVersion + "\n" + " optional: " + optionalVersion ) ; } } catch ( ClassNotFoundException e ) { } } public static File [ ] listLibraries ( ) { String home = System . getProperty ( "ant.home" ) ; if ( home == null ) { return null ; } File libDir = new File ( home , "lib" ) ; FilenameFilter filter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( ".jar" ) ; } } ; String [ ] filenames = libDir . list ( filter ) ; if ( filenames == null ) { return null ; } File [ ] files = new File [ filenames . length ] ; for ( int i = 0 ; i < filenames . length ; i ++ ) { files [ i ] = new File ( libDir , filenames [ i ] ) ; } return files ; } public static void main ( String [ ] args ) { doReport ( System . out ) ; } private static String getImplementationVersion ( Class clazz ) { try { Method method = Class . class . getMethod ( "getPackage" , new Class [ 0 ] ) ; Object pkg = method . invoke ( clazz , null ) ; if ( pkg != null ) { method = pkg . getClass ( ) . getMethod ( "getImplementationVersion" , new Class [ 0 ] ) ; Object version = method . invoke ( pkg , null ) ; return ( String ) version ; } } catch ( Exception e ) { return "?.?" ; } return null ; } private static String getXmlParserName ( ) { SAXParser saxParser = getSAXParser ( ) ; if ( saxParser == null ) { return "Could not create an XML Parser" ; } String saxParserName = saxParser . getClass ( ) . getName ( ) ; return saxParserName ; } private static SAXParser getSAXParser ( ) { SAXParserFactory saxParserFactory = SAXParserFactory . newInstance ( ) ; if ( saxParserFactory == null ) { return null ; } SAXParser saxParser = null ; try { saxParser = saxParserFactory . newSAXParser ( ) ; } catch ( Exception e ) { } return saxParser ; } private static String getXMLParserLocation ( ) { SAXParser saxParser = getSAXParser ( ) ; if ( saxParser == null ) { return null ; } String location = getClassLocation ( saxParser . getClass ( ) ) ; return location ; } private static String getClassLocation ( Class clazz ) { File f = LoaderUtils . getClassSource ( clazz ) ; return f == null ? null : f . getAbsolutePath ( ) ; } public static void doReport ( PrintStream out ) { out . println ( "------- Ant diagnostics report -------" ) ; out . println ( Main . getAntVersion ( ) ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " Implementation Version (JDK1.2+ only)" ) ; out . println ( "-------------------------------------------" ) ; out . println ( "core tasks     : " + getImplementationVersion ( Main . class ) ) ; Class optional = null ; try { optional = Class . forName ( "org.apache.tools.ant.taskdefs.optional.Test" ) ; out . println ( "optional tasks : " + getImplementationVersion ( optional ) ) ; } catch ( ClassNotFoundException e ) { out . println ( "optional tasks : not available" ) ; } out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " ANT_HOME/lib jar listing" ) ; out . println ( "-------------------------------------------" ) ; doReportLibraries ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " Tasks availability" ) ; out . println ( "-------------------------------------------" ) ; doReportTasksAvailability ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " org.apache.env.Which diagnostics" ) ; out . println ( "-------------------------------------------" ) ; doReportWhich ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " XML Parser information" ) ; out . println ( "-------------------------------------------" ) ; doReportParserInfo ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " System properties" ) ; out . println ( "-------------------------------------------" ) ; doReportSystemProperties ( out ) ; out . println ( ) ; } private static void doReportSystemProperties ( PrintStream out ) { for ( Enumeration keys = System . getProperties ( ) . keys ( ) ; keys . hasMoreElements ( ) ; ) { String key = ( String ) keys . nextElement ( ) ; out . println ( key + " : " + System . getProperty ( key ) ) ; } } private static void doReportLibraries ( PrintStream out ) { out . println ( "ant.home: " + System . getProperty ( "ant.home" ) ) ; File [ ] libs = listLibraries ( ) ; if ( libs == null ) { out . println ( "Unable to list libraries." ) ; return ; } for ( int i = 0 ; i < libs . length ; i ++ ) { out . println ( libs [ i ] . getName ( ) + " (" + libs [ i ] . length ( ) + " bytes)" ) ; } } private static void doReportWhich ( PrintStream out ) { Throwable error = null ; try { Class which = Class . forName ( "org.apache.env.Which" ) ; Method method = which . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; method . invoke ( null , new Object [ ] { new String [ ] { } } ) ; } catch ( ClassNotFoundException e ) { out . println ( "Not available." ) ; out . println ( "Download it at http://xml.apache.org/commons/" ) ; } catch ( InvocationTargetException e ) { error = e . getTargetException ( ) == null ? e : e . getTargetException ( ) ; } catch ( Throwable e ) { error = e ; } if ( error != null ) { out . println ( "Error while running org.apache.env.Which" ) ; error . printStackTrace ( ) ; } } private static void doReportTasksAvailability ( PrintStream out ) { InputStream is = Main . class . getResourceAsStream ( "/org/apache/tools/ant/taskdefs/defaults.properties" ) ; if ( is == null ) { out . println ( "None available" ) ; } else { Properties props = new Properties ( ) ; try { props . load ( is ) ; for ( Enumeration keys = props . keys ( ) ; keys . hasMoreElements ( ) ; ) { String key = ( String ) keys . nextElement ( ) ; String classname = props . getProperty ( key ) ; try { Class . forName ( classname ) ; props . remove ( key ) ; } catch ( ClassNotFoundException e ) { out . println ( key + " : Not Available" ) ; } catch ( NoClassDefFoundError e ) { String pkg = e . getMessage ( ) . replace ( '/' , '.' ) ; out . println ( key + " : Missing dependency " + pkg ) ; } catch ( Error e ) { out . println ( key + " : Initialization error" ) ; } } if ( props . size ( ) == 0 ) { out . println ( "All defined tasks are available" ) ; } } catch ( IOException e ) { out . println ( e . getMessage ( ) ) ; } } } private static void doReportParserInfo ( PrintStream out ) { String parserName = getXmlParserName ( ) ; String parserLocation = getXMLParserLocation ( ) ; if ( parserName == null ) { parserName = "unknown" ; } if ( parserLocation == null ) { parserLocation = "unknown" ; } out . println ( "XML Parser : " + parserName ) ; out . println ( "XML Parser Location: " + parserLocation ) ; } } 	1
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . DifferentSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . TypeSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . SelectorContainer ; import org . apache . tools . ant . types . selectors . SelectorScanner ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class AbstractFileSet extends DataType implements Cloneable , SelectorContainer { private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private Vector selectors = new Vector ( ) ; private File dir ; private boolean useDefaultExcludes = true ; private boolean isCaseSensitive = true ; private boolean followSymlinks = true ; public AbstractFileSet ( ) { super ( ) ; } protected AbstractFileSet ( AbstractFileSet fileset ) { this . dir = fileset . dir ; this . defaultPatterns = fileset . defaultPatterns ; this . additionalPatterns = fileset . additionalPatterns ; this . selectors = fileset . selectors ; this . useDefaultExcludes = fileset . useDefaultExcludes ; this . isCaseSensitive = fileset . isCaseSensitive ; this . followSymlinks = fileset . followSymlinks ; setProject ( fileset . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( dir != null || defaultPatterns . hasPatterns ( getProject ( ) ) ) { throw tooManyAttributes ( ) ; } if ( ! additionalPatterns . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } if ( ! selectors . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public PatternSet createPatternSet ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PatternSet patterns = new PatternSet ( ) ; additionalPatterns . addElement ( patterns ) ; return patterns ; } public PatternSet . NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExcludesFile ( ) ; } public void setFile ( File file ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } setDir ( file . getParentFile ( ) ) ; PatternSet . NameEntry include = createInclude ( ) ; include . setName ( file . getName ( ) ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludes ( excludes ) ; } public void setIncludesfile ( File incl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludesfile ( incl ) ; } public void setExcludesfile ( File excl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludesfile ( excl ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . useDefaultExcludes = useDefaultExcludes ; } public void setCaseSensitive ( boolean isCaseSensitive ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . isCaseSensitive = isCaseSensitive ; } public void setFollowSymlinks ( boolean followSymlinks ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . followSymlinks = followSymlinks ; } public boolean isFollowSymlinks ( ) { if ( isReference ( ) ) { return getRef ( getProject ( ) ) . isFollowSymlinks ( ) ; } else { return followSymlinks ; } } protected String getDataTypeName ( ) { Project project = getProject ( ) ; if ( project != null ) { Hashtable typedefs = project . getDataTypeDefinitions ( ) ; for ( Enumeration e = typedefs . keys ( ) ; e . hasMoreElements ( ) ; ) { String typeName = ( String ) e . nextElement ( ) ; Class typeClass = ( Class ) typedefs . get ( typeName ) ; if ( typeClass == getClass ( ) ) { return typeName ; } } } String classname = getClass ( ) . getName ( ) ; int dotIndex = classname . lastIndexOf ( "." ) ; if ( dotIndex == - 1 ) { return classname ; } return classname . substring ( dotIndex + 1 ) ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for " + getDataTypeName ( ) + "." ) ; } if ( ! dir . exists ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " not found." ) ; } if ( ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a directory." ) ; } DirectoryScanner ds = new DirectoryScanner ( ) ; setupDirectoryScanner ( ds , p ) ; ds . setFollowSymlinks ( followSymlinks ) ; ds . scan ( ) ; return ds ; } public void setupDirectoryScanner ( FileScanner ds , Project p ) { if ( isReference ( ) ) { getRef ( p ) . setupDirectoryScanner ( ds , p ) ; return ; } if ( ds == null ) { throw new IllegalArgumentException ( "ds cannot be null" ) ; } ds . setBasedir ( dir ) ; final int count = additionalPatterns . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Object o = additionalPatterns . elementAt ( i ) ; defaultPatterns . append ( ( PatternSet ) o , p ) ; } p . log ( getDataTypeName ( ) + ": Setup scanner in dir " + dir + " with " + defaultPatterns , Project . MSG_DEBUG ) ; ds . setIncludes ( defaultPatterns . getIncludePatterns ( p ) ) ; ds . setExcludes ( defaultPatterns . getExcludePatterns ( p ) ) ; if ( ds instanceof SelectorScanner ) { SelectorScanner ss = ( SelectorScanner ) ds ; ss . setSelectors ( getSelectors ( p ) ) ; } if ( useDefaultExcludes ) { ds . addDefaultExcludes ( ) ; } ds . setCaseSensitive ( isCaseSensitive ) ; } protected AbstractFileSet getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( ! getClass ( ) . isAssignableFrom ( o . getClass ( ) ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a " + getDataTypeName ( ) ; throw new BuildException ( msg ) ; } else { return ( AbstractFileSet ) o ; } } public boolean hasSelectors ( ) { if ( isReference ( ) && getProject ( ) != null ) { return getRef ( getProject ( ) ) . hasSelectors ( ) ; } return ! ( selectors . isEmpty ( ) ) ; } public boolean hasPatterns ( ) { if ( isReference ( ) && getProject ( ) != null ) { return getRef ( getProject ( ) ) . hasPatterns ( ) ; } if ( defaultPatterns . hasPatterns ( getProject ( ) ) ) { return true ; } Enumeration e = additionalPatterns . elements ( ) ; while ( e . hasMoreElements ( ) ) { PatternSet ps = ( PatternSet ) e . nextElement ( ) ; if ( ps . hasPatterns ( getProject ( ) ) ) { return true ; } } return false ; } public int selectorCount ( ) { if ( isReference ( ) && getProject ( ) != null ) { return getRef ( getProject ( ) ) . selectorCount ( ) ; } return selectors . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getSelectors ( p ) ; } else { FileSelector [ ] result = new FileSelector [ selectors . size ( ) ] ; selectors . copyInto ( result ) ; return result ; } } public Enumeration selectorElements ( ) { if ( isReference ( ) && getProject ( ) != null ) { return getRef ( getProject ( ) ) . selectorElements ( ) ; } return selectors . elements ( ) ; } public void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } selectors . addElement ( selector ) ; } public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addType ( TypeSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { appendSelector ( selector ) ; } public void addModified ( ModifiedSelector selector ) { appendSelector ( selector ) ; } public void add ( FileSelector selector ) { appendSelector ( selector ) ; } public String toString ( ) { DirectoryScanner ds = getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( i > 0 ) { sb . append ( ';' ) ; } sb . append ( files [ i ] ) ; } return sb . toString ( ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( getRef ( getProject ( ) ) ) . clone ( ) ; } else { try { AbstractFileSet fs = ( AbstractFileSet ) super . clone ( ) ; fs . defaultPatterns = ( PatternSet ) defaultPatterns . clone ( ) ; fs . additionalPatterns = new Vector ( additionalPatterns . size ( ) ) ; Enumeration e = additionalPatterns . elements ( ) ; while ( e . hasMoreElements ( ) ) { fs . additionalPatterns . addElement ( ( ( PatternSet ) e . nextElement ( ) ) . clone ( ) ) ; } fs . selectors = ( Vector ) fs . selectors . clone ( ) ; return fs ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . util . ArrayList ; import java . util . List ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . HashSet ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DynamicConfigurator ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class MacroInstance extends Task implements DynamicConfigurator { private MacroDef macroDef ; private Map map = new HashMap ( ) ; private Map nsElements = null ; private Map presentElements = new HashMap ( ) ; private Hashtable localProperties = new Hashtable ( ) ; public void setMacroDef ( MacroDef macroDef ) { this . macroDef = macroDef ; } public void setDynamicAttribute ( String name , String value ) { map . put ( name , value ) ; } public Object createDynamicElement ( String name ) throws BuildException { if ( getNsElements ( ) . get ( name ) == null ) { throw new BuildException ( "unsupported element " + name ) ; } if ( presentElements . get ( name ) != null ) { throw new BuildException ( "Element " + name + " already present" ) ; } Element ret = new Element ( ) ; presentElements . put ( name , ret ) ; return ret ; } private Map getNsElements ( ) { if ( nsElements == null ) { nsElements = new HashMap ( ) ; for ( Iterator i = macroDef . getElements ( ) . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; nsElements . put ( ( String ) entry . getKey ( ) , entry . getValue ( ) ) ; } } return nsElements ; } public static class Element implements TaskContainer { private List unknownElements = new ArrayList ( ) ; public void addTask ( Task nestedTask ) { unknownElements . add ( nestedTask ) ; } public List getUnknownElements ( ) { return unknownElements ; } } private static final int STATE_NORMAL = 0 ; private static final int STATE_EXPECT_BRACKET = 1 ; private static final int STATE_EXPECT_NAME = 2 ; private static final int STATE_EXPECT_EXCAPE = 3 ; private String macroSubs ( String s , Map macroMapping ) { if ( s == null ) { return null ; } StringBuffer ret = new StringBuffer ( ) ; StringBuffer macroName = null ; boolean inMacro = false ; int state = STATE_NORMAL ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { char ch = s . charAt ( i ) ; switch ( state ) { case STATE_NORMAL : if ( ch == '@' ) { state = STATE_EXPECT_BRACKET ; } else { ret . append ( ch ) ; } break ; case STATE_EXPECT_BRACKET : if ( ch == '{' ) { state = STATE_EXPECT_NAME ; macroName = new StringBuffer ( ) ; } else if ( ch == '@' ) { state = STATE_EXPECT_EXCAPE ; } else { state = STATE_NORMAL ; ret . append ( '@' ) ; ret . append ( ch ) ; } break ; case STATE_EXPECT_NAME : if ( ch == '}' ) { state = STATE_NORMAL ; String name = macroName . toString ( ) ; String value = ( String ) macroMapping . get ( name ) ; if ( value == null ) { ret . append ( "@{" + name + "}" ) ; } else { ret . append ( value ) ; } macroName = null ; } else { macroName . append ( ch ) ; } break ; case STATE_EXPECT_EXCAPE : state = STATE_NORMAL ; if ( ch == '{' ) { ret . append ( "@" ) ; } else { ret . append ( "@@" ) ; } ret . append ( ch ) ; break ; default : break ; } } switch ( state ) { case STATE_NORMAL : break ; case STATE_EXPECT_BRACKET : ret . append ( '@' ) ; break ; case STATE_EXPECT_NAME : ret . append ( "@{" ) ; ret . append ( macroName . toString ( ) ) ; break ; case STATE_EXPECT_EXCAPE : ret . append ( "@@" ) ; break ; default : break ; } return ret . toString ( ) ; } private UnknownElement copy ( UnknownElement ue ) { UnknownElement ret = new UnknownElement ( ue . getTag ( ) ) ; ret . setNamespace ( ue . getNamespace ( ) ) ; ret . setProject ( getProject ( ) ) ; ret . setQName ( ue . getQName ( ) ) ; ret . setTaskName ( ue . getTaskName ( ) ) ; ret . setLocation ( ue . getLocation ( ) ) ; if ( getOwningTarget ( ) == null ) { Target t = new Target ( ) ; t . setProject ( getProject ( ) ) ; ret . setOwningTarget ( t ) ; } else { ret . setOwningTarget ( getOwningTarget ( ) ) ; } RuntimeConfigurable rc = new RuntimeConfigurable ( ret , ue . getTaskName ( ) ) ; rc . setPolyType ( ue . getWrapper ( ) . getPolyType ( ) ) ; Map map = ue . getWrapper ( ) . getAttributeMap ( ) ; for ( Iterator i = map . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; rc . setAttribute ( ( String ) entry . getKey ( ) , macroSubs ( ( String ) entry . getValue ( ) , localProperties ) ) ; } rc . addText ( macroSubs ( ue . getWrapper ( ) . getText ( ) . toString ( ) , localProperties ) ) ; Enumeration e = ue . getWrapper ( ) . getChildren ( ) ; while ( e . hasMoreElements ( ) ) { RuntimeConfigurable r = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement unknownElement = ( UnknownElement ) r . getProxy ( ) ; String tag = unknownElement . getTaskType ( ) ; MacroDef . TemplateElement templateElement = ( MacroDef . TemplateElement ) getNsElements ( ) . get ( tag ) ; if ( templateElement == null ) { UnknownElement child = copy ( unknownElement ) ; rc . addChild ( child . getWrapper ( ) ) ; ret . addChild ( child ) ; } else { Element element = ( Element ) presentElements . get ( tag ) ; if ( element == null ) { if ( ! templateElement . isOptional ( ) ) { throw new BuildException ( "Required nested element " + templateElement . getName ( ) + " missing" ) ; } continue ; } for ( Iterator i = element . getUnknownElements ( ) . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement child = ( UnknownElement ) i . next ( ) ; rc . addChild ( child . getWrapper ( ) ) ; ret . addChild ( child ) ; } } } return ret ; } public void execute ( ) { localProperties = new Hashtable ( ) ; Set copyKeys = new HashSet ( map . keySet ( ) ) ; for ( Iterator i = macroDef . getAttributes ( ) . iterator ( ) ; i . hasNext ( ) ; ) { MacroDef . Attribute attribute = ( MacroDef . Attribute ) i . next ( ) ; String value = ( String ) map . get ( attribute . getName ( ) ) ; if ( value == null ) { value = attribute . getDefault ( ) ; value = macroSubs ( value , localProperties ) ; } if ( value == null ) { throw new BuildException ( "required attribute " + attribute . getName ( ) + " not set" ) ; } localProperties . put ( attribute . getName ( ) , value ) ; copyKeys . remove ( attribute . getName ( ) ) ; } if ( copyKeys . contains ( "id" ) ) { copyKeys . remove ( "id" ) ; } if ( copyKeys . size ( ) != 0 ) { throw new BuildException ( "Unknown attribute" + ( copyKeys . size ( ) > 1 ? "s " : " " ) + copyKeys ) ; } UnknownElement c = copy ( macroDef . getNestedTask ( ) ) ; c . init ( ) ; try { c . perform ( ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . FlatFileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . SourceFileScanner ; public class Copy extends Task { protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector filesets = new Vector ( ) ; private boolean enableMultipleMappings = false ; protected boolean filtering = false ; protected boolean preserveLastModified = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; private boolean failonerror = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; protected Hashtable completeDirMap = new Hashtable ( ) ; protected Mapper mapperElement = null ; private Vector filterChains = new Vector ( ) ; private Vector filterSets = new Vector ( ) ; private FileUtils fileUtils ; private String inputEncoding = null ; private String outputEncoding = null ; public Copy ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } protected FileUtils getFileUtils ( ) { return fileUtils ; } public void setFile ( File file ) { this . file = file ; } public void setTofile ( File destFile ) { this . destFile = destFile ; } public void setTodir ( File destDir ) { this . destDir = destDir ; } public FilterChain createFilterChain ( ) { FilterChain filterChain = new FilterChain ( ) ; filterChains . addElement ( filterChain ) ; return filterChain ; } public FilterSet createFilterSet ( ) { FilterSet filterSet = new FilterSet ( ) ; filterSets . addElement ( filterSet ) ; return filterSet ; } public void setPreserveLastModified ( String preserve ) { setPreserveLastModified ( Project . toBoolean ( preserve ) ) ; } public void setPreserveLastModified ( boolean preserve ) { preserveLastModified = preserve ; } public boolean getPreserveLastModified ( ) { return preserveLastModified ; } protected Vector getFilterSets ( ) { return filterSets ; } protected Vector getFilterChains ( ) { return filterChains ; } public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } public void setOverwrite ( boolean overwrite ) { this . forceOverwrite = overwrite ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void setEnableMultipleMappings ( boolean enableMultipleMappings ) { this . enableMultipleMappings = enableMultipleMappings ; } public boolean isEnableMultipleMapping ( ) { return enableMultipleMappings ; } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void setEncoding ( String encoding ) { this . inputEncoding = encoding ; if ( outputEncoding == null ) { outputEncoding = encoding ; } } public String getEncoding ( ) { return inputEncoding ; } public void setOutputEncoding ( String encoding ) { this . outputEncoding = encoding ; } public String getOutputEncoding ( ) { return outputEncoding ; } public void execute ( ) throws BuildException { File savedFile = file ; File savedDestFile = destFile ; File savedDestDir = destDir ; FileSet savedFileSet = null ; if ( file == null && destFile != null && filesets . size ( ) == 1 ) { savedFileSet = ( FileSet ) filesets . elementAt ( 0 ) ; } validateAttributes ( ) ; try { if ( file != null ) { if ( file . exists ( ) ) { if ( destFile == null ) { destFile = new File ( destDir , file . getName ( ) ) ; } if ( forceOverwrite || ! destFile . exists ( ) || ( file . lastModified ( ) > destFile . lastModified ( ) ) ) { fileCopyMap . put ( file . getAbsolutePath ( ) , new String [ ] { destFile . getAbsolutePath ( ) } ) ; } else { log ( file + " omitted as " + destFile + " is up to date." , Project . MSG_VERBOSE ) ; } } else { String message = "Warning: Could not find file " + file . getAbsolutePath ( ) + " to copy." ; if ( ! failonerror ) { log ( message ) ; } else { throw new BuildException ( message ) ; } } } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = null ; try { ds = fs . getDirectoryScanner ( getProject ( ) ) ; } catch ( BuildException e ) { if ( failonerror || ! e . getMessage ( ) . endsWith ( " not found." ) ) { throw e ; } else { log ( "Warning: " + e . getMessage ( ) ) ; continue ; } } File fromDir = fs . getDir ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; boolean isEverythingIncluded = ds . isEverythingIncluded ( ) && ( ! fs . hasSelectors ( ) && ! fs . hasPatterns ( ) ) ; if ( isEverythingIncluded && ! flatten && mapperElement == null ) { completeDirMap . put ( fromDir , destDir ) ; } scan ( fromDir , destDir , srcFiles , srcDirs ) ; } try { doFileOperations ( ) ; } catch ( BuildException e ) { if ( ! failonerror ) { log ( "Warning: " + e . getMessage ( ) , Project . MSG_ERR ) ; } else { throw e ; } } } finally { file = savedFile ; destFile = savedDestFile ; destDir = savedDestDir ; if ( savedFileSet != null ) { filesets . insertElementAt ( savedFileSet , 0 ) ; } fileCopyMap . clear ( ) ; dirCopyMap . clear ( ) ; completeDirMap . clear ( ) ; } } protected void validateAttributes ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source " + "- a file or a fileset." ) ; } if ( destFile != null && destDir != null ) { throw new BuildException ( "Only one of tofile and todir " + "may be set." ) ; } if ( destFile == null && destDir == null ) { throw new BuildException ( "One of tofile or todir must be set." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to copy directories." ) ; } if ( destFile != null && filesets . size ( ) > 0 ) { if ( filesets . size ( ) > 1 ) { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } else { FileSet fs = ( FileSet ) filesets . elementAt ( 0 ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; if ( srcFiles . length == 0 ) { throw new BuildException ( "Cannot perform operation from directory to file." ) ; } else if ( srcFiles . length == 1 ) { if ( file == null ) { file = new File ( ds . getBasedir ( ) , srcFiles [ 0 ] ) ; filesets . removeElementAt ( 0 ) ; } else { throw new BuildException ( "Cannot concatenate multiple " + "files into a single file." ) ; } } else { throw new BuildException ( "Cannot concatenate multiple " + "files into a single file." ) ; } } } if ( destFile != null ) { destDir = fileUtils . getParentFile ( destFile ) ; } } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else if ( flatten ) { mapper = new FlatFileNameMapper ( ) ; } else { mapper = new IdentityMapper ( ) ; } buildMap ( fromDir , toDir , files , mapper , fileCopyMap ) ; if ( includeEmpty ) { buildMap ( fromDir , toDir , dirs , mapper , dirCopyMap ) ; } } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( mapper . mapFileName ( names [ i ] ) != null ) { v . addElement ( names [ i ] ) ; } } toCopy = new String [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { SourceFileScanner ds = new SourceFileScanner ( this ) ; toCopy = ds . restrict ( names , fromDir , toDir , mapper ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; String [ ] mappedFiles = mapper . mapFileName ( toCopy [ i ] ) ; if ( ! enableMultipleMappings ) { map . put ( src . getAbsolutePath ( ) , new String [ ] { new File ( toDir , mappedFiles [ 0 ] ) . getAbsolutePath ( ) } ) ; } else { for ( int k = 0 ; k < mappedFiles . length ; k ++ ) { mappedFiles [ k ] = new File ( toDir , mappedFiles [ k ] ) . getAbsolutePath ( ) ; } map . put ( src . getAbsolutePath ( ) , mappedFiles ) ; } } } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Copying " + fileCopyMap . size ( ) + " file" + ( fileCopyMap . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String [ ] toFiles = ( String [ ] ) fileCopyMap . get ( fromFile ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = toFiles [ i ] ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-copy of " + fromFile , verbosity ) ; continue ; } try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } fileUtils . copyFile ( fromFile , toFile , executionFilters , filterChains , forceOverwrite , preserveLastModified , inputEncoding , outputEncoding , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; File targetFile = new File ( toFile ) ; if ( targetFile . exists ( ) && ! targetFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + toFile ; } throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int createCount = 0 ; while ( e . hasMoreElements ( ) ) { String [ ] dirs = ( String [ ] ) e . nextElement ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File d = new File ( dirs [ i ] ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { createCount ++ ; } } } } if ( createCount > 0 ) { log ( "Copied " + dirCopyMap . size ( ) + " empty director" + ( dirCopyMap . size ( ) == 1 ? "y" : "ies" ) + " to " + createCount + " empty director" + ( createCount == 1 ? "y" : "ies" ) + " under " + destDir . getAbsolutePath ( ) ) ; } } } } 	1
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jikes extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jikes compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } classpath . addExtdirs ( extdirs ) ; if ( bootclasspath == null || bootclasspath . size ( ) == 0 ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } String jikesPath = System . getProperty ( "jikes.class.path" ) ; if ( jikesPath != null ) { classpath . append ( new Path ( project , jikesPath ) ) ; } Commandline cmd = new Commandline ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jikes" : exec ) ; if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( depend ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } String emacsProperty = project . getProperty ( "build.compiler.emacs" ) ; if ( emacsProperty != null && Project . toBoolean ( emacsProperty ) ) { cmd . createArgument ( ) . setValue ( "+E" ) ; } String warningsProperty = project . getProperty ( "build.compiler.warnings" ) ; if ( warningsProperty != null ) { attributes . log ( "!! the build.compiler.warnings property is " + "deprecated. !!" , Project . MSG_WARN ) ; attributes . log ( "!! Use the nowarn attribute instead. !!" , Project . MSG_WARN ) ; if ( ! Project . toBoolean ( warningsProperty ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } String pedanticProperty = project . getProperty ( "build.compiler.pedantic" ) ; if ( pedanticProperty != null && Project . toBoolean ( pedanticProperty ) ) { cmd . createArgument ( ) . setValue ( "+P" ) ; } String fullDependProperty = project . getProperty ( "build.compiler.fulldepend" ) ; if ( fullDependProperty != null && Project . toBoolean ( fullDependProperty ) ) { cmd . createArgument ( ) . setValue ( "+F" ) ; } if ( attributes . getSource ( ) != null ) { cmd . createArgument ( ) . setValue ( "-source" ) ; cmd . createArgument ( ) . setValue ( attributes . getSource ( ) ) ; } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	1
package org . apache . tools . ant ; import java . io . File ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . List ; import java . util . Locale ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . taskdefs . PreSetDef ; public final class IntrospectionHelper implements BuildListener { private Hashtable attributeTypes ; private Hashtable attributeSetters ; private Hashtable nestedTypes ; private Hashtable nestedCreators ; private List addTypeMethods ; private Method addText = null ; private Class bean ; private static Hashtable helpers = new Hashtable ( ) ; private static final Hashtable PRIMITIVE_TYPE_MAP = new Hashtable ( 8 ) ; static { Class [ ] primitives = { Boolean . TYPE , Byte . TYPE , Character . TYPE , Short . TYPE , Integer . TYPE , Long . TYPE , Float . TYPE , Double . TYPE } ; Class [ ] wrappers = { Boolean . class , Byte . class , Character . class , Short . class , Integer . class , Long . class , Float . class , Double . class } ; for ( int i = 0 ; i < primitives . length ; i ++ ) { PRIMITIVE_TYPE_MAP . put ( primitives [ i ] , wrappers [ i ] ) ; } } private IntrospectionHelper ( final Class bean ) { attributeTypes = new Hashtable ( ) ; attributeSetters = new Hashtable ( ) ; nestedTypes = new Hashtable ( ) ; nestedCreators = new Hashtable ( ) ; addTypeMethods = new ArrayList ( ) ; this . bean = bean ; Method [ ] methods = bean . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final Method m = methods [ i ] ; final String name = m . getName ( ) ; Class returnType = m . getReturnType ( ) ; Class [ ] args = m . getParameterTypes ( ) ; if ( args . length == 1 && java . lang . Void . TYPE . equals ( returnType ) && ( name . equals ( "add" ) || name . equals ( "addConfigured" ) ) ) { insertAddTypeMethod ( m ) ; continue ; } if ( org . apache . tools . ant . Task . class . isAssignableFrom ( bean ) && args . length == 1 && isHiddenSetMethod ( name , args [ 0 ] ) ) { continue ; } if ( org . apache . tools . ant . TaskContainer . class . isAssignableFrom ( bean ) && args . length == 1 && "addTask" . equals ( name ) && org . apache . tools . ant . Task . class . equals ( args [ 0 ] ) ) { continue ; } if ( "addText" . equals ( name ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && java . lang . String . class . equals ( args [ 0 ] ) ) { addText = methods [ i ] ; } else if ( name . startsWith ( "set" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! args [ 0 ] . isArray ( ) ) { String propName = getPropertyName ( name , "set" ) ; if ( attributeSetters . get ( propName ) != null ) { if ( java . lang . String . class . equals ( args [ 0 ] ) ) { continue ; } } AttributeSetter as = createAttributeSetter ( m , args [ 0 ] , propName ) ; if ( as != null ) { attributeTypes . put ( propName , args [ 0 ] ) ; attributeSetters . put ( propName , as ) ; } } else if ( name . startsWith ( "create" ) && ! returnType . isArray ( ) && ! returnType . isPrimitive ( ) && args . length == 0 ) { String propName = getPropertyName ( name , "create" ) ; if ( nestedCreators . get ( propName ) == null ) { nestedTypes . put ( propName , returnType ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public boolean isPolyMorphic ( ) { return false ; } public Object getRealObject ( ) { return null ; } public Class getElementClass ( ) { return null ; } public Object create ( Project project , Object parent , Object ignore ) throws InvocationTargetException , IllegalAccessException { return m . invoke ( parent , new Object [ ] { } ) ; } public void store ( Object parent , Object child ) { } } ) ; } } else if ( name . startsWith ( "addConfigured" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { Constructor constructor = null ; try { constructor = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; } catch ( NoSuchMethodException ex ) { constructor = args [ 0 ] . getConstructor ( new Class [ ] { Project . class } ) ; } final Constructor c = constructor ; String propName = getPropertyName ( name , "addConfigured" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public boolean isPolyMorphic ( ) { return true ; } public Object getRealObject ( ) { return null ; } public Class getElementClass ( ) { return c . getDeclaringClass ( ) ; } public Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( child != null ) { return child ; } else if ( c . getParameterTypes ( ) . length == 0 ) { return c . newInstance ( new Object [ ] { } ) ; } else { return c . newInstance ( new Object [ ] { project } ) ; } } public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { m . invoke ( parent , new Object [ ] { child } ) ; } } ) ; } catch ( NoSuchMethodException nse ) { } } else if ( name . startsWith ( "add" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { Constructor constructor = null ; try { constructor = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; } catch ( NoSuchMethodException ex ) { constructor = args [ 0 ] . getConstructor ( new Class [ ] { Project . class } ) ; } final Constructor c = constructor ; String propName = getPropertyName ( name , "add" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public boolean isPolyMorphic ( ) { return true ; } public Object getRealObject ( ) { return null ; } public Class getElementClass ( ) { return c . getDeclaringClass ( ) ; } public Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( child != null ) { } else if ( c . getParameterTypes ( ) . length == 0 ) { child = c . newInstance ( new Object [ ] { } ) ; } else { child = c . newInstance ( new Object [ ] { project } ) ; } m . invoke ( parent , new Object [ ] { child } ) ; return child ; } public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { } } ) ; } catch ( NoSuchMethodException nse ) { } } } } private boolean isHiddenSetMethod ( String name , Class type ) { if ( "setLocation" . equals ( name ) && org . apache . tools . ant . Location . class . equals ( type ) ) { return true ; } if ( "setTaskType" . equals ( name ) && java . lang . String . class . equals ( type ) ) { return true ; } return false ; } public static synchronized IntrospectionHelper getHelper ( Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) helpers . get ( c ) ; if ( ih == null ) { ih = new IntrospectionHelper ( c ) ; helpers . put ( c , ih ) ; } return ih ; } public static synchronized IntrospectionHelper getHelper ( Project p , Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) helpers . get ( c ) ; if ( ih == null ) { ih = new IntrospectionHelper ( c ) ; helpers . put ( c , ih ) ; p . addBuildListener ( ih ) ; } return ih ; } public void setAttribute ( Project p , Object element , String attributeName , String value ) throws BuildException { AttributeSetter as = ( AttributeSetter ) attributeSetters . get ( attributeName ) ; if ( as == null ) { if ( element instanceof DynamicConfigurator ) { DynamicConfigurator dc = ( DynamicConfigurator ) element ; dc . setDynamicAttribute ( attributeName , value ) ; return ; } else { String msg = getElementName ( p , element ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new BuildException ( msg ) ; } } try { as . set ( p , element , value ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void addText ( Project project , Object element , String text ) throws BuildException { if ( addText == null ) { if ( text . trim ( ) . length ( ) == 0 ) { return ; } else { String msg = project . getElementName ( element ) + " doesn't support nested text data." ; throw new BuildException ( msg ) ; } } try { addText . invoke ( element , new String [ ] { text } ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void throwNotSupported ( Project project , Object parent , String elementName ) { String msg = project . getElementName ( parent ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new BuildException ( msg ) ; } private NestedCreator getNestedCreator ( Project project , String parentUri , Object parent , String elementName ) throws BuildException { String uri = ProjectHelper . extractUriFromComponentName ( elementName ) ; String name = ProjectHelper . extractNameFromComponentName ( elementName ) ; NestedCreator nc = null ; if ( uri . equals ( parentUri ) ) { nc = ( NestedCreator ) nestedCreators . get ( name . toLowerCase ( Locale . US ) ) ; } if ( nc == null ) { nc = createAddTypeCreator ( project , parent , elementName ) ; } if ( nc == null && parent instanceof DynamicConfigurator ) { DynamicConfigurator dc = ( DynamicConfigurator ) parent ; final Object nestedElement = dc . createDynamicElement ( name . toLowerCase ( Locale . US ) ) ; if ( nestedElement != null ) { nc = new NestedCreator ( ) { public boolean isPolyMorphic ( ) { return false ; } public Class getElementClass ( ) { return null ; } public Object getRealObject ( ) { return null ; } public Object create ( Project project , Object parent , Object ignore ) { return nestedElement ; } public void store ( Object parent , Object child ) { } } ; } } if ( nc == null ) { throwNotSupported ( project , parent , elementName ) ; } return nc ; } public Object createElement ( Project project , Object parent , String elementName ) throws BuildException { NestedCreator nc = getNestedCreator ( project , "" , parent , elementName ) ; try { Object nestedElement = nc . create ( project , parent , null ) ; if ( project != null ) { project . setProjectReference ( nestedElement ) ; } return nestedElement ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Creator getElementCreator ( Project project , String parentUri , Object parent , String elementName , UnknownElement ue ) { NestedCreator nc = getNestedCreator ( project , parentUri , parent , elementName ) ; return new Creator ( project , parent , nc ) ; } public boolean supportsNestedElement ( String elementName ) { return nestedCreators . containsKey ( elementName . toLowerCase ( Locale . US ) ) || DynamicConfigurator . class . isAssignableFrom ( bean ) || addTypeMethods . size ( ) != 0 ; } public boolean supportsNestedElement ( String parentUri , String elementName ) { String uri = ProjectHelper . extractUriFromComponentName ( elementName ) ; String name = ProjectHelper . extractNameFromComponentName ( elementName ) ; return ( nestedCreators . containsKey ( name . toLowerCase ( Locale . US ) ) && ( uri . equals ( parentUri ) ) ) || DynamicConfigurator . class . isAssignableFrom ( bean ) || addTypeMethods . size ( ) != 0 ; } public void storeElement ( Project project , Object parent , Object child , String elementName ) throws BuildException { if ( elementName == null ) { return ; } NestedCreator ns = ( NestedCreator ) nestedCreators . get ( elementName . toLowerCase ( Locale . US ) ) ; if ( ns == null ) { return ; } try { ns . store ( parent , child ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Class getElementType ( String elementName ) throws BuildException { Class nt = ( Class ) nestedTypes . get ( elementName ) ; if ( nt == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new BuildException ( msg ) ; } return nt ; } public Class getAttributeType ( String attributeName ) throws BuildException { Class at = ( Class ) attributeTypes . get ( attributeName ) ; if ( at == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new BuildException ( msg ) ; } return at ; } public boolean supportsCharacters ( ) { return addText != null ; } public Enumeration getAttributes ( ) { return attributeSetters . keys ( ) ; } public Enumeration getNestedElements ( ) { return nestedTypes . keys ( ) ; } private AttributeSetter createAttributeSetter ( final Method m , Class arg , final String attrName ) { final Class reflectedArg = PRIMITIVE_TYPE_MAP . containsKey ( arg ) ? ( Class ) PRIMITIVE_TYPE_MAP . get ( arg ) : arg ; if ( java . lang . String . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new String [ ] { value } ) ; } } ; } else if ( java . lang . Character . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { if ( value . length ( ) == 0 ) { throw new BuildException ( "The value \"\" is not a " + "legal value for attribute \"" + attrName + "\"" ) ; } m . invoke ( parent , new Character [ ] { new Character ( value . charAt ( 0 ) ) } ) ; } } ; } else if ( java . lang . Boolean . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Boolean [ ] { new Boolean ( Project . toBoolean ( value ) ) } ) ; } } ; } else if ( java . lang . Class . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Class [ ] { Class . forName ( value ) } ) ; } catch ( ClassNotFoundException ce ) { throw new BuildException ( ce ) ; } } } ; } else if ( java . io . File . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new File [ ] { p . resolveFile ( value ) } ) ; } } ; } else if ( org . apache . tools . ant . types . Path . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Path [ ] { new Path ( p , value ) } ) ; } } ; } else if ( EnumeratedAttribute . class . isAssignableFrom ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) reflectedArg . newInstance ( ) ; ea . setValue ( value ) ; m . invoke ( parent , new EnumeratedAttribute [ ] { ea } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } else { try { final Constructor c = reflectedArg . getConstructor ( new Class [ ] { java . lang . String . class } ) ; return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { Object attribute = c . newInstance ( new String [ ] { value } ) ; if ( p != null ) { p . setProjectReference ( attribute ) ; } m . invoke ( parent , new Object [ ] { attribute } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } catch ( NoSuchMethodException nme ) { } } return null ; } protected String getElementName ( Project project , Object element ) { return project . getElementName ( element ) ; } private String getPropertyName ( String methodName , String prefix ) { int start = prefix . length ( ) ; return methodName . substring ( start ) . toLowerCase ( Locale . US ) ; } public static final class Creator { private NestedCreator nestedCreator ; private Object parent ; private Project project ; private Object nestedObject ; private String polyType ; private Creator ( Project project , Object parent , NestedCreator nestedCreator ) { this . project = project ; this . parent = parent ; this . nestedCreator = nestedCreator ; } public void setPolyType ( String polyType ) { this . polyType = polyType ; } public Object create ( ) { if ( polyType != null ) { if ( ! nestedCreator . isPolyMorphic ( ) ) { throw new BuildException ( "Not allowed to use the polymorphic form" + " for this element" ) ; } Class elementClass = nestedCreator . getElementClass ( ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; nestedObject = ComponentHelper . getComponentHelper ( project ) . createComponent ( polyType ) ; if ( nestedObject == null ) { throw new BuildException ( "Unable to create object of type " + polyType ) ; } } try { nestedObject = nestedCreator . create ( project , parent , nestedObject ) ; if ( project != null ) { project . setProjectReference ( nestedObject ) ; } return nestedObject ; } catch ( IllegalAccessException ex ) { throw new BuildException ( ex ) ; } catch ( InstantiationException ex ) { throw new BuildException ( ex ) ; } catch ( IllegalArgumentException ex ) { if ( polyType != null ) { throw new BuildException ( "Invalid type used " + polyType ) ; } throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Object getRealObject ( ) { return nestedCreator . getRealObject ( ) ; } public void store ( ) { try { nestedCreator . store ( parent , nestedObject ) ; } catch ( IllegalAccessException ex ) { throw new BuildException ( ex ) ; } catch ( InstantiationException ex ) { throw new BuildException ( ex ) ; } catch ( IllegalArgumentException ex ) { if ( polyType != null ) { throw new BuildException ( "Invalid type used " + polyType ) ; } throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } } private interface NestedCreator { boolean isPolyMorphic ( ) ; Class getElementClass ( ) ; Object getRealObject ( ) ; Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; } private interface AttributeSetter { void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException ; } public void buildFinished ( BuildEvent event ) { attributeTypes . clear ( ) ; attributeSetters . clear ( ) ; nestedTypes . clear ( ) ; nestedCreators . clear ( ) ; addText = null ; helpers . clear ( ) ; } public void buildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } private NestedCreator createAddTypeCreator ( Project project , Object parent , String elementName ) throws BuildException { if ( addTypeMethods . size ( ) == 0 ) { return null ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; Object addedObject = null ; Method addMethod = null ; Class clazz = helper . getComponentClass ( elementName ) ; if ( clazz == null ) { return null ; } addMethod = findMatchingMethod ( clazz , addTypeMethods ) ; if ( addMethod == null ) { return null ; } addedObject = helper . createComponent ( elementName ) ; if ( addedObject == null ) { return null ; } Object rObject = addedObject ; if ( addedObject instanceof PreSetDef . PreSetDefinition ) { rObject = ( ( PreSetDef . PreSetDefinition ) addedObject ) . createObject ( project ) ; } final Method method = addMethod ; final Object nestedObject = addedObject ; final Object realObject = rObject ; return new NestedCreator ( ) { public boolean isPolyMorphic ( ) { return false ; } public Class getElementClass ( ) { return null ; } public Object create ( Project project , Object parent , Object ignore ) throws InvocationTargetException , IllegalAccessException { if ( ! method . getName ( ) . endsWith ( "Configured" ) ) { method . invoke ( parent , new Object [ ] { realObject } ) ; } return nestedObject ; } public Object getRealObject ( ) { return realObject ; } public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( method . getName ( ) . endsWith ( "Configured" ) ) { method . invoke ( parent , new Object [ ] { realObject } ) ; } } } ; } private void insertAddTypeMethod ( Method method ) { Class argClass = method . getParameterTypes ( ) [ 0 ] ; for ( int c = 0 ; c < addTypeMethods . size ( ) ; ++ c ) { Method current = ( Method ) addTypeMethods . get ( c ) ; if ( current . getParameterTypes ( ) [ 0 ] . equals ( argClass ) ) { return ; } if ( current . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( argClass ) ) { addTypeMethods . add ( c , method ) ; return ; } } addTypeMethods . add ( method ) ; } private Method findMatchingMethod ( Class paramClass , List methods ) { Class matchedClass = null ; Method matchedMethod = null ; for ( int i = 0 ; i < methods . size ( ) ; ++ i ) { Method method = ( Method ) methods . get ( i ) ; Class methodClass = method . getParameterTypes ( ) [ 0 ] ; if ( methodClass . isAssignableFrom ( paramClass ) ) { if ( matchedClass == null ) { matchedClass = methodClass ; matchedMethod = method ; } else { if ( ! methodClass . isAssignableFrom ( matchedClass ) ) { throw new BuildException ( "ambiguous: types " + matchedClass . getName ( ) + " and " + methodClass . getName ( ) + " match " + paramClass . getName ( ) ) ; } } } } return matchedMethod ; } } 	1
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; public class PropertySet extends DataType { private boolean dynamic = true ; private Vector cachedNames ; private Vector ptyRefs = new Vector ( ) ; private Vector setRefs = new Vector ( ) ; private Mapper _mapper ; public static class PropertyRef { private int count ; private String name ; private String regex ; private String prefix ; private String builtin ; public void setName ( String name ) { assertValid ( "name" , name ) ; this . name = name ; } public void setRegex ( String regex ) { assertValid ( "regex" , regex ) ; this . regex = regex ; } public void setPrefix ( String prefix ) { assertValid ( "prefix" , prefix ) ; this . prefix = prefix ; } public void setBuiltin ( BuiltinPropertySetName b ) { String builtin = b . getValue ( ) ; assertValid ( "builtin" , builtin ) ; this . builtin = builtin ; } private void assertValid ( String attr , String value ) { if ( value == null || value . length ( ) < 1 ) { throw new BuildException ( "Invalid attribute: " + attr ) ; } if ( ++ count != 1 ) { throw new BuildException ( "Attributes name, regex, and " + "prefix are mutually exclusive" ) ; } } public String toString ( ) { return "name=" + name + ", regex=" + regex + ", prefix=" + prefix + ", builtin=" + builtin ; } } public void appendName ( String name ) { PropertyRef ref = new PropertyRef ( ) ; ref . setName ( name ) ; addPropertyref ( ref ) ; } public void appendRegex ( String regex ) { PropertyRef ref = new PropertyRef ( ) ; ref . setRegex ( regex ) ; addPropertyref ( ref ) ; } public void appendPrefix ( String prefix ) { PropertyRef ref = new PropertyRef ( ) ; ref . setPrefix ( prefix ) ; addPropertyref ( ref ) ; } public void appendBuiltin ( BuiltinPropertySetName b ) { PropertyRef ref = new PropertyRef ( ) ; ref . setBuiltin ( b ) ; addPropertyref ( ref ) ; } public void setMapper ( String type , String from , String to ) { Mapper mapper = createMapper ( ) ; Mapper . MapperType mapperType = new Mapper . MapperType ( ) ; mapperType . setValue ( type ) ; mapper . setFrom ( from ) ; mapper . setTo ( to ) ; } public void addPropertyref ( PropertyRef ref ) { assertNotReference ( ) ; ptyRefs . addElement ( ref ) ; } public void addPropertyset ( PropertySet ref ) { assertNotReference ( ) ; setRefs . addElement ( ref ) ; } public Mapper createMapper ( ) { assertNotReference ( ) ; if ( _mapper != null ) { throw new BuildException ( "Too many <mapper>s!" ) ; } _mapper = new Mapper ( getProject ( ) ) ; return _mapper ; } public void setDynamic ( boolean dynamic ) { assertNotReference ( ) ; this . dynamic = dynamic ; } public boolean getDynamic ( ) { return isReference ( ) ? getRef ( ) . dynamic : dynamic ; } public Mapper getMapper ( ) { return isReference ( ) ? getRef ( ) . _mapper : _mapper ; } public Properties getProperties ( ) { Vector names = null ; Project prj = getProject ( ) ; if ( getDynamic ( ) || cachedNames == null ) { names = new Vector ( ) ; if ( isReference ( ) ) { getRef ( ) . addPropertyNames ( names , prj . getProperties ( ) ) ; } else { addPropertyNames ( names , prj . getProperties ( ) ) ; } if ( ! getDynamic ( ) ) { cachedNames = names ; } } else { names = cachedNames ; } FileNameMapper mapper = null ; Mapper myMapper = getMapper ( ) ; if ( myMapper != null ) { mapper = myMapper . getImplementation ( ) ; } Properties properties = new Properties ( ) ; for ( Enumeration e = names . elements ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; String value = prj . getProperty ( name ) ; if ( mapper != null ) { String [ ] newname = mapper . mapFileName ( name ) ; if ( newname != null ) { name = newname [ 0 ] ; } } properties . setProperty ( name , value ) ; } return properties ; } private void addPropertyNames ( Vector names , Hashtable properties ) { Project prj = getProject ( ) ; for ( Enumeration e = ptyRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertyRef ref = ( PropertyRef ) e . nextElement ( ) ; if ( ref . name != null ) { if ( prj . getProperty ( ref . name ) != null ) { names . addElement ( ref . name ) ; } } else if ( ref . prefix != null ) { for ( Enumeration p = properties . keys ( ) ; p . hasMoreElements ( ) ; ) { String name = ( String ) p . nextElement ( ) ; if ( name . startsWith ( ref . prefix ) ) { names . addElement ( name ) ; } } } else if ( ref . regex != null ) { RegexpMatcherFactory matchMaker = new RegexpMatcherFactory ( ) ; RegexpMatcher matcher = matchMaker . newRegexpMatcher ( ) ; matcher . setPattern ( ref . regex ) ; for ( Enumeration p = properties . keys ( ) ; p . hasMoreElements ( ) ; ) { String name = ( String ) p . nextElement ( ) ; if ( matcher . matches ( name ) ) { names . addElement ( name ) ; } } } else if ( ref . builtin != null ) { Enumeration e2 = null ; if ( ref . builtin . equals ( BuiltinPropertySetName . ALL ) ) { e2 = properties . keys ( ) ; } else if ( ref . builtin . equals ( BuiltinPropertySetName . SYSTEM ) ) { e2 = System . getProperties ( ) . keys ( ) ; } else if ( ref . builtin . equals ( BuiltinPropertySetName . COMMANDLINE ) ) { e2 = getProject ( ) . getUserProperties ( ) . keys ( ) ; } else { throw new BuildException ( "Impossible: Invalid builtin " + "attribute!" ) ; } while ( e2 . hasMoreElements ( ) ) { names . addElement ( e2 . nextElement ( ) ) ; } } else { throw new BuildException ( "Impossible: Invalid PropertyRef!" ) ; } } for ( Enumeration e = setRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet set = ( PropertySet ) e . nextElement ( ) ; set . addPropertyNames ( names , properties ) ; } } protected PropertySet getRef ( ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Object o = getRefid ( ) . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof PropertySet ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a propertyset" ; throw new BuildException ( msg ) ; } else { return ( PropertySet ) o ; } } public final void setRefid ( Reference r ) { if ( ! noAttributeSet ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } protected final void assertNotReference ( ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } noAttributeSet = false ; } private boolean noAttributeSet = true ; public static class BuiltinPropertySetName extends EnumeratedAttribute { static final String ALL = "all" ; static final String SYSTEM = "system" ; static final String COMMANDLINE = "commandline" ; public String [ ] getValues ( ) { return new String [ ] { ALL , SYSTEM , COMMANDLINE } ; } } } 	1
package org . apache . tools . ant ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . PrintStream ; import java . io . StringReader ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . StringUtils ; public class DefaultLogger implements BuildLogger { public static final int LEFT_COLUMN_SIZE = 12 ; protected PrintStream out ; protected PrintStream err ; protected int msgOutputLevel = Project . MSG_ERR ; private long startTime = System . currentTimeMillis ( ) ; protected static final String lSep = StringUtils . LINE_SEP ; protected boolean emacsMode = false ; public DefaultLogger ( ) { } public void setMessageOutputLevel ( int level ) { this . msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . out = new PrintStream ( output , true ) ; } public void setErrorPrintStream ( PrintStream err ) { this . err = new PrintStream ( err , true ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void buildStarted ( BuildEvent event ) { startTime = System . currentTimeMillis ( ) ; } public void buildFinished ( BuildEvent event ) { Throwable error = event . getException ( ) ; StringBuffer message = new StringBuffer ( ) ; if ( error == null ) { message . append ( StringUtils . LINE_SEP ) ; message . append ( "BUILD SUCCESSFUL" ) ; } else { message . append ( StringUtils . LINE_SEP ) ; message . append ( "BUILD FAILED" ) ; message . append ( StringUtils . LINE_SEP ) ; if ( Project . MSG_VERBOSE <= msgOutputLevel || ! ( error instanceof BuildException ) ) { message . append ( StringUtils . getStackTrace ( error ) ) ; } else { if ( error instanceof BuildException ) { message . append ( error . toString ( ) ) . append ( lSep ) ; } else { message . append ( error . getMessage ( ) ) . append ( lSep ) ; } } } message . append ( StringUtils . LINE_SEP ) ; message . append ( "Total time: " ) ; message . append ( formatTime ( System . currentTimeMillis ( ) - startTime ) ) ; String msg = message . toString ( ) ; if ( error == null ) { printMessage ( msg , out , Project . MSG_VERBOSE ) ; } else { printMessage ( msg , err , Project . MSG_ERR ) ; } log ( msg ) ; } public void targetStarted ( BuildEvent event ) { if ( Project . MSG_INFO <= msgOutputLevel && ! event . getTarget ( ) . getName ( ) . equals ( "" ) ) { String msg = StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" ; printMessage ( msg , out , event . getPriority ( ) ) ; log ( msg ) ; } } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority <= msgOutputLevel ) { StringBuffer message = new StringBuffer ( ) ; if ( event . getTask ( ) != null && ! emacsMode ) { String name = event . getTask ( ) . getTaskName ( ) ; String label = "[" + name + "] " ; int size = LEFT_COLUMN_SIZE - label . length ( ) ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = 0 ; i < size ; i ++ ) { tmp . append ( " " ) ; } tmp . append ( label ) ; label = tmp . toString ( ) ; try { BufferedReader r = new BufferedReader ( new StringReader ( event . getMessage ( ) ) ) ; String line = r . readLine ( ) ; boolean first = true ; while ( line != null ) { if ( ! first ) { message . append ( StringUtils . LINE_SEP ) ; } first = false ; message . append ( label ) . append ( line ) ; line = r . readLine ( ) ; } } catch ( IOException e ) { message . append ( label ) . append ( event . getMessage ( ) ) ; } } else { message . append ( event . getMessage ( ) ) ; } String msg = message . toString ( ) ; if ( priority != Project . MSG_ERR ) { printMessage ( msg , out , priority ) ; } else { printMessage ( msg , err , priority ) ; } log ( msg ) ; } } protected static String formatTime ( final long millis ) { return DateUtils . formatElapsedTime ( millis ) ; } protected void printMessage ( final String message , final PrintStream stream , final int priority ) { stream . println ( message ) ; } protected void log ( String message ) { } } 	1
package org . apache . tools . tar ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class TarInputStream extends FilterInputStream { protected boolean debug ; protected boolean hasHitEOF ; protected int entrySize ; protected int entryOffset ; protected byte [ ] oneBuf ; protected byte [ ] readBuf ; protected TarBuffer buffer ; protected TarEntry currEntry ; private boolean v7Format ; public TarInputStream ( InputStream is ) { this ( is , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize ) { this ( is , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize , int recordSize ) { super ( is ) ; this . buffer = new TarBuffer ( is , blockSize , recordSize ) ; this . readBuf = null ; this . oneBuf = new byte [ 1 ] ; this . debug = false ; this . hasHitEOF = false ; this . v7Format = false ; } public void setDebug ( boolean debug ) { this . debug = debug ; this . buffer . setDebug ( debug ) ; } public void close ( ) throws IOException { this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public int available ( ) throws IOException { return this . entrySize - this . entryOffset ; } public long skip ( long numToSkip ) throws IOException { byte [ ] skipBuf = new byte [ 8 * 1024 ] ; long skip = numToSkip ; while ( skip > 0 ) { int realSkip = ( int ) ( skip > skipBuf . length ? skipBuf . length : skip ) ; int numRead = this . read ( skipBuf , 0 , realSkip ) ; if ( numRead == - 1 ) { break ; } skip -= numRead ; } return ( numToSkip - skip ) ; } public boolean markSupported ( ) { return false ; } public void mark ( int markLimit ) { } public void reset ( ) { } public TarEntry getNextEntry ( ) throws IOException { if ( this . hasHitEOF ) { return null ; } if ( this . currEntry != null ) { int numToSkip = this . entrySize - this . entryOffset ; if ( this . debug ) { System . err . println ( "TarInputStream: SKIP currENTRY '" + this . currEntry . getName ( ) + "' SZ " + this . entrySize + " OFF " + this . entryOffset + "  skipping " + numToSkip + " bytes" ) ; } if ( numToSkip > 0 ) { this . skip ( numToSkip ) ; } this . readBuf = null ; } byte [ ] headerBuf = this . buffer . readRecord ( ) ; if ( headerBuf == null ) { if ( this . debug ) { System . err . println ( "READ NULL RECORD" ) ; } this . hasHitEOF = true ; } else if ( this . buffer . isEOFRecord ( headerBuf ) ) { if ( this . debug ) { System . err . println ( "READ EOF RECORD" ) ; } this . hasHitEOF = true ; } if ( this . hasHitEOF ) { this . currEntry = null ; } else { this . currEntry = new TarEntry ( headerBuf ) ; if ( ! ( headerBuf [ 257 ] == 'u' && headerBuf [ 258 ] == 's' && headerBuf [ 259 ] == 't' && headerBuf [ 260 ] == 'a' && headerBuf [ 261 ] == 'r' ) ) { this . v7Format = true ; } if ( this . debug ) { System . err . println ( "TarInputStream: SET CURRENTRY '" + this . currEntry . getName ( ) + "' size = " + this . currEntry . getSize ( ) ) ; } this . entryOffset = 0 ; this . entrySize = ( int ) this . currEntry . getSize ( ) ; } if ( this . currEntry != null && this . currEntry . isGNULongNameEntry ( ) ) { StringBuffer longName = new StringBuffer ( ) ; byte [ ] buffer = new byte [ 256 ] ; int length = 0 ; while ( ( length = read ( buffer ) ) >= 0 ) { longName . append ( new String ( buffer , 0 , length ) ) ; } getNextEntry ( ) ; if ( longName . length ( ) > 0 && longName . charAt ( longName . length ( ) - 1 ) == 0 ) { longName . deleteCharAt ( longName . length ( ) - 1 ) ; } this . currEntry . setName ( longName . toString ( ) ) ; } return this . currEntry ; } public int read ( ) throws IOException { int num = this . read ( this . oneBuf , 0 , 1 ) ; if ( num == - 1 ) { return num ; } else { return ( int ) this . oneBuf [ 0 ] ; } } public int read ( byte [ ] buf ) throws IOException { return this . read ( buf , 0 , buf . length ) ; } public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { int totalRead = 0 ; if ( this . entryOffset >= this . entrySize ) { return - 1 ; } if ( ( numToRead + this . entryOffset ) > this . entrySize ) { numToRead = ( this . entrySize - this . entryOffset ) ; } if ( this . readBuf != null ) { int sz = ( numToRead > this . readBuf . length ) ? this . readBuf . length : numToRead ; System . arraycopy ( this . readBuf , 0 , buf , offset , sz ) ; if ( sz >= this . readBuf . length ) { this . readBuf = null ; } else { int newLen = this . readBuf . length - sz ; byte [ ] newBuf = new byte [ newLen ] ; System . arraycopy ( this . readBuf , sz , newBuf , 0 , newLen ) ; this . readBuf = newBuf ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } while ( numToRead > 0 ) { byte [ ] rec = this . buffer . readRecord ( ) ; if ( rec == null ) { throw new IOException ( "unexpected EOF with " + numToRead + " bytes unread" ) ; } int sz = numToRead ; int recLen = rec . length ; if ( recLen > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; this . readBuf = new byte [ recLen - sz ] ; System . arraycopy ( rec , sz , this . readBuf , 0 , recLen - sz ) ; } else { sz = recLen ; System . arraycopy ( rec , 0 , buf , offset , recLen ) ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } this . entryOffset += totalRead ; return totalRead ; } public void copyEntryContents ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 32 * 1024 ] ; while ( true ) { int numRead = this . read ( buf , 0 , buf . length ) ; if ( numRead == - 1 ) { break ; } out . write ( buf , 0 , numRead ) ; } } } 	1
package org . apache . tools . ant . helper ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TypeAdapter ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . AttributeList ; import org . xml . sax . DocumentHandler ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . XMLReaderAdapter ; public class ProjectHelperImpl extends ProjectHelper { private org . xml . sax . Parser parser ; private Project project ; private File buildFile ; private File buildFileParent ; private Locator locator ; private Target implicitTarget = new Target ( ) ; private static FileUtils fu = FileUtils . newFileUtils ( ) ; public ProjectHelperImpl ( ) { implicitTarget . setName ( "" ) ; } public void parse ( Project project , Object source ) throws BuildException { if ( ! ( source instanceof File ) ) { throw new BuildException ( "Only File source supported by " + "default plugin" ) ; } File buildFile = ( File ) source ; FileInputStream inputStream = null ; InputSource inputSource = null ; this . project = project ; this . buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; buildFileParent = new File ( this . buildFile . getParent ( ) ) ; try { try { parser = JAXPUtils . getParser ( ) ; } catch ( BuildException e ) { parser = new XMLReaderAdapter ( JAXPUtils . getXMLReader ( ) ) ; } String uri = fu . toURI ( buildFile . getAbsolutePath ( ) ) ; inputStream = new FileInputStream ( buildFile ) ; inputSource = new InputSource ( inputStream ) ; inputSource . setSystemId ( uri ) ; project . log ( "parsing buildfile " + buildFile + " with URI = " + uri , Project . MSG_VERBOSE ) ; HandlerBase hb = new RootHandler ( this ) ; parser . setDocumentHandler ( hb ) ; parser . setEntityResolver ( hb ) ; parser . setErrorHandler ( hb ) ; parser . setDTDHandler ( hb ) ; parser . parse ( inputSource ) ; } catch ( SAXParseException exc ) { Location location = new Location ( exc . getSystemId ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( "Encoding of project file is invalid." , exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file: " + exc . getMessage ( ) , exc ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ioe ) { } } } } static class AbstractHandler extends HandlerBase { protected DocumentHandler parentHandler ; ProjectHelperImpl helperImpl ; public AbstractHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { this . parentHandler = parentHandler ; this . helperImpl = helperImpl ; helperImpl . parser . setDocumentHandler ( this ) ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + tag + "\"" , helperImpl . locator ) ; } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { String s = new String ( buf , start , count ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , helperImpl . locator ) ; } } public void endElement ( String name ) throws SAXException { helperImpl . parser . setDocumentHandler ( parentHandler ) ; } } static class RootHandler extends HandlerBase { ProjectHelperImpl helperImpl ; public RootHandler ( ProjectHelperImpl helperImpl ) { this . helperImpl = helperImpl ; } public InputSource resolveEntity ( String publicId , String systemId ) { helperImpl . project . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = fu . fromURI ( systemId ) ; File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = fu . resolveFile ( helperImpl . buildFileParent , path ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( fu . toURI ( file . getAbsolutePath ( ) ) ) ; return inputSource ; } catch ( FileNotFoundException fne ) { helperImpl . project . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { if ( tag . equals ( "project" ) ) { new ProjectHandler ( helperImpl , this ) . init ( tag , attrs ) ; } else { throw new SAXParseException ( "Config file is not of expected " + "XML type" , helperImpl . locator ) ; } } public void setDocumentLocator ( Locator locator ) { helperImpl . locator = locator ; } } static class ProjectHandler extends AbstractHandler { public ProjectHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String def = null ; String name = null ; String id = null ; String baseDir = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { def = value ; } else if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "basedir" ) ) { baseDir = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getName ( i ) + "\"" , helperImpl . locator ) ; } } if ( def != null && ! def . equals ( "" ) ) { helperImpl . project . setDefaultTarget ( def ) ; } else { throw new BuildException ( "The default attribute is required" ) ; } if ( name != null ) { helperImpl . project . setName ( name ) ; helperImpl . project . addReference ( name , helperImpl . project ) ; } if ( id != null ) { helperImpl . project . addReference ( id , helperImpl . project ) ; } if ( helperImpl . project . getProperty ( "basedir" ) != null ) { helperImpl . project . setBasedir ( helperImpl . project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { helperImpl . project . setBasedir ( helperImpl . buildFileParent . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { helperImpl . project . setBasedir ( baseDir ) ; } else { File resolvedBaseDir = helperImpl . project . resolveFile ( baseDir , helperImpl . buildFileParent ) ; helperImpl . project . setBaseDir ( resolvedBaseDir ) ; } } } helperImpl . project . addTarget ( "" , helperImpl . implicitTarget ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( name . equals ( "target" ) ) { handleTarget ( name , attrs ) ; } else { handleElement ( helperImpl , this , helperImpl . implicitTarget , name , attrs ) ; } } private void handleTarget ( String tag , AttributeList attrs ) throws SAXParseException { new TargetHandler ( helperImpl , this ) . init ( tag , attrs ) ; } } static class TargetHandler extends AbstractHandler { private Target target ; public TargetHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String name = null ; String depends = "" ; String ifCond = null ; String unlessCond = null ; String id = null ; String description = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; if ( name . equals ( "" ) ) { throw new BuildException ( "name attribute must not" + " be empty" , new Location ( helperImpl . locator ) ) ; } } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , helperImpl . locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without a name attribute" , helperImpl . locator ) ; } target = new Target ( ) ; target . addDependency ( "" ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; helperImpl . project . addTarget ( name , target ) ; if ( id != null && ! id . equals ( "" ) ) { helperImpl . project . addReference ( id , target ) ; } if ( depends . length ( ) > 0 ) { target . setDepends ( depends ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { handleElement ( helperImpl , this , target , name , attrs ) ; } } private static void handleElement ( ProjectHelperImpl helperImpl , DocumentHandler parent , Target target , String elementName , AttributeList attrs ) throws SAXParseException { if ( elementName . equals ( "description" ) ) { new DescriptionHandler ( helperImpl , parent ) ; } else if ( helperImpl . project . getDataTypeDefinitions ( ) . get ( elementName ) != null ) { new DataTypeHandler ( helperImpl , parent , target ) . init ( elementName , attrs ) ; } else { new TaskHandler ( helperImpl , parent , target , null , target ) . init ( elementName , attrs ) ; } } static class DescriptionHandler extends AbstractHandler { public DescriptionHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void characters ( char [ ] buf , int start , int count ) { String text = new String ( buf , start , count ) ; String currentDescription = helperImpl . project . getDescription ( ) ; if ( currentDescription == null ) { helperImpl . project . setDescription ( text ) ; } else { helperImpl . project . setDescription ( currentDescription + text ) ; } } } static class TaskHandler extends AbstractHandler { private Target target ; private TaskContainer container ; private Task task ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , TaskContainer container , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; this . container = container ; this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = helperImpl . project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( task == null ) { task = new UnknownElement ( tag ) ; task . setProject ( helperImpl . project ) ; task . setTaskName ( tag ) ; } task . setLocation ( new Location ( helperImpl . locator ) ) ; helperImpl . configureId ( task , attrs ) ; task . setOwningTarget ( target ) ; container . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; if ( parentWrapper != null ) { parentWrapper . addChild ( wrapper ) ; } } public void characters ( char [ ] buf , int start , int count ) { wrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( task instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) task , wrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , task , wrapper , target ) . init ( name , attrs ) ; } } } static class NestedElementHandler extends AbstractHandler { private Object parent ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; private Target target ; public NestedElementHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Object parent , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; if ( parent instanceof TypeAdapter ) { this . parent = ( ( TypeAdapter ) parent ) . getProxy ( ) ; } else { this . parent = parent ; } this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; try { String elementName = propType . toLowerCase ( Locale . US ) ; if ( parent instanceof UnknownElement ) { UnknownElement uc = new UnknownElement ( elementName ) ; uc . setProject ( helperImpl . project ) ; ( ( UnknownElement ) parent ) . addChild ( uc ) ; child = uc ; } else { child = ih . createElement ( helperImpl . project , parent , elementName ) ; } helperImpl . configureId ( child , attrs ) ; childWrapper = new RuntimeConfigurable ( child , propType ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { childWrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( child instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) child , childWrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , child , childWrapper , target ) . init ( name , attrs ) ; } } } static class DataTypeHandler extends AbstractHandler { private Target target ; private Object element ; private RuntimeConfigurable wrapper = null ; public DataTypeHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Target target ) { super ( helperImpl , parentHandler ) ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = helperImpl . project . createDataType ( propType ) ; if ( element == null ) { throw new BuildException ( "Unknown data type " + propType ) ; } wrapper = new RuntimeConfigurable ( element , propType ) ; wrapper . setAttributes ( attrs ) ; target . addDataType ( wrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { wrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( helperImpl , this , element , wrapper , target ) . init ( name , attrs ) ; } } private void configureId ( Object target , AttributeList attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , target ) ; } } } 	1
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Iterator ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Properties ; import java . io . File ; import java . io . BufferedInputStream ; import java . io . FileInputStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; public class PropertiesfileCache implements Cache { private File cachefile = null ; private Properties cache = new Properties ( ) ; private boolean cacheLoaded = false ; private boolean cacheDirty = true ; public PropertiesfileCache ( ) { } public PropertiesfileCache ( File cachefile ) { this . cachefile = cachefile ; } public void setCachefile ( File file ) { cachefile = file ; } public File getCachefile ( ) { return cachefile ; } public boolean isValid ( ) { return ( cachefile != null ) ; } public void load ( ) { if ( ( cachefile != null ) && cachefile . isFile ( ) && cachefile . canRead ( ) ) { try { BufferedInputStream bis = new BufferedInputStream ( new FileInputStream ( cachefile ) ) ; cache . load ( bis ) ; bis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } cacheLoaded = true ; cacheDirty = false ; } public void save ( ) { if ( ! cacheDirty ) { return ; } if ( ( cachefile != null ) && cache . propertyNames ( ) . hasMoreElements ( ) ) { try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( cachefile ) ) ; cache . store ( bos , null ) ; bos . flush ( ) ; bos . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } cacheDirty = false ; } public void delete ( ) { cache = new Properties ( ) ; cachefile . delete ( ) ; cacheLoaded = true ; cacheDirty = false ; } public Object get ( Object key ) { if ( ! cacheLoaded ) { load ( ) ; } try { return cache . getProperty ( String . valueOf ( key ) ) ; } catch ( ClassCastException e ) { return null ; } } public void put ( Object key , Object value ) { cache . put ( String . valueOf ( key ) , String . valueOf ( value ) ) ; cacheDirty = true ; } public Iterator iterator ( ) { Vector v = new java . util . Vector ( ) ; Enumeration en = cache . propertyNames ( ) ; while ( en . hasMoreElements ( ) ) { v . add ( en . nextElement ( ) ) ; } return v . iterator ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "<PropertiesfileCache:" ) ; buf . append ( "cachefile=" ) . append ( cachefile ) ; buf . append ( ";noOfEntries=" ) . append ( cache . size ( ) ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 	1
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class RmicAdapterFactory { private RmicAdapterFactory ( ) { } public static RmicAdapter getRmic ( String rmicType , Task task ) throws BuildException { if ( rmicType . equalsIgnoreCase ( "sun" ) ) { return new SunRmic ( ) ; } else if ( rmicType . equalsIgnoreCase ( "kaffe" ) ) { return new KaffeRmic ( ) ; } else if ( rmicType . equalsIgnoreCase ( "weblogic" ) ) { return new WLRmic ( ) ; } return resolveClassName ( rmicType ) ; } private static RmicAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( RmicAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a rmic adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . DynamicConfigurator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . util . FileUtils ; public class XSLTProcess extends MatchingTask implements XSLTLogger { private File destDir = null ; private File baseDir = null ; private String xslFile = null ; private String targetExtension = ".html" ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private String processor ; private Path classpath = null ; private XSLTLiaison liaison ; private boolean stylesheetLoaded = false ; private boolean force = false ; private FileUtils fileUtils ; private Vector outputProperties = new Vector ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; private static final String TRAX_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ; private static final String XSLP_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.XslpLiaison" ; private static final String XALAN_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.XalanLiaison" ; private boolean performDirectoryScan = true ; private Factory factory = null ; private boolean reuseLoadedStylesheet = true ; public XSLTProcess ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void setScanIncludedDirectories ( boolean b ) { performDirectoryScan = b ; } public void setReloadStylesheet ( boolean b ) { reuseLoadedStylesheet = ! b ; } public void execute ( ) throws BuildException { File savedBaseDir = baseDir ; DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( xslFile == null ) { throw new BuildException ( "no stylesheet specified" , getLocation ( ) ) ; } if ( inFile != null && ! inFile . exists ( ) ) { throw new BuildException ( "input file " + inFile . toString ( ) + " does not exist" , getLocation ( ) ) ; } try { if ( baseDir == null ) { baseDir = getProject ( ) . resolveFile ( "." ) ; } liaison = getLiaison ( ) ; if ( liaison instanceof XSLTLoggerAware ) { ( ( XSLTLoggerAware ) liaison ) . setLogger ( this ) ; } log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; File stylesheet = getProject ( ) . resolveFile ( xslFile ) ; if ( ! stylesheet . exists ( ) ) { stylesheet = fileUtils . resolveFile ( baseDir , xslFile ) ; if ( stylesheet . exists ( ) ) { log ( "DEPRECATED - the style attribute should be relative " + "to the project\'s" ) ; log ( "             basedir, not the tasks\'s basedir." ) ; } } if ( inFile != null && outFile != null ) { process ( inFile , outFile , stylesheet ) ; return ; } if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } if ( performDirectoryScan ) { dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } } } } finally { liaison = null ; stylesheetLoaded = false ; baseDir = savedBaseDir ; } } public void setForce ( boolean force ) { this . force = force ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = xslFile ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProcessor ( String processor ) { this . processor = processor ; } public void addConfiguredXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog . addConfiguredXMLCatalog ( xmlCatalog ) ; } private void resolveProcessor ( String proc ) throws Exception { if ( proc . equals ( "trax" ) ) { final Class clazz = loadClass ( TRAX_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xslp" ) ) { log ( "DEPRECATED - xslp processor is deprecated. Use trax " + "instead." ) ; final Class clazz = loadClass ( XSLP_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xalan" ) ) { log ( "DEPRECATED - xalan processor is deprecated. Use trax " + "instead." ) ; final Class clazz = loadClass ( XALAN_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else { liaison = ( XSLTLiaison ) loadClass ( proc ) . newInstance ( ) ; } } private Class loadClass ( String classname ) throws Exception { if ( classpath == null ) { return Class . forName ( classname ) ; } else { AntClassLoader al = getProject ( ) . createClassLoader ( classpath ) ; Class c = Class . forName ( classname , true , al ) ; return c ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void process ( File baseDir , String xmlFile , File destDir , File stylesheet ) throws BuildException { String fileExt = targetExtension ; File outFile = null ; File inFile = null ; try { long styleSheetLastModified = stylesheet . lastModified ( ) ; inFile = new File ( baseDir , xmlFile ) ; if ( inFile . isDirectory ( ) ) { log ( "Skipping " + inFile + " it is a directory." , Project . MSG_VERBOSE ) ; return ; } int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + fileExt ) ; } else { outFile = new File ( destDir , xmlFile + fileExt ) ; } if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , File stylesheet ) throws BuildException { try { long styleSheetLastModified = stylesheet . lastModified ( ) ; log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( force || inFile . lastModified ( ) >= outFile . lastModified ( ) || styleSheetLastModified >= outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } else { log ( "Skipping input file " + inFile + " because it is older than output file " + outFile + " and so is the stylesheet " + stylesheet , Project . MSG_DEBUG ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = fileUtils . getParentFile ( targetFile ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } public Factory getFactory ( ) { return factory ; } public XMLCatalog getXMLCatalog ( ) { return xmlCatalog ; } public Enumeration getOutputProperties ( ) { return outputProperties . elements ( ) ; } protected XSLTLiaison getLiaison ( ) { if ( liaison == null ) { if ( processor != null ) { try { resolveProcessor ( processor ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } else { try { resolveProcessor ( "trax" ) ; } catch ( Throwable e1 ) { try { resolveProcessor ( "xalan" ) ; } catch ( Throwable e2 ) { try { resolveProcessor ( "xslp" ) ; } catch ( Throwable e3 ) { e3 . printStackTrace ( ) ; e2 . printStackTrace ( ) ; throw new BuildException ( e1 ) ; } } } } } return liaison ; } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public static class Param { private String name = null ; private String expression = null ; private String ifProperty ; private String unlessProperty ; private Project project ; public void setProject ( Project project ) { this . project = project ; } public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) { throw new BuildException ( "Name attribute is missing." ) ; } return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) { throw new BuildException ( "Expression attribute is missing." ) ; } return expression ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean shouldUse ( ) { if ( ifProperty != null && project . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && project . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } } public OutputProperty createOutputProperty ( ) { OutputProperty p = new OutputProperty ( ) ; outputProperties . addElement ( p ) ; return p ; } public static class OutputProperty { private String name ; private String value ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } public void init ( ) throws BuildException { super . init ( ) ; xmlCatalog . setProject ( getProject ( ) ) ; } protected void configureLiaison ( File stylesheet ) throws BuildException { if ( stylesheetLoaded && reuseLoadedStylesheet ) { return ; } stylesheetLoaded = true ; try { log ( "Loading stylesheet " + stylesheet , Project . MSG_INFO ) ; liaison . setStylesheet ( stylesheet ) ; for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; if ( p . shouldUse ( ) ) { liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } } if ( liaison instanceof XSLTLiaison2 ) { ( ( XSLTLiaison2 ) liaison ) . configure ( this ) ; } } catch ( Exception ex ) { log ( "Failed to transform using stylesheet " + stylesheet , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } public Factory createFactory ( ) throws BuildException { if ( factory != null ) { throw new BuildException ( "'factory' element must be unique" ) ; } factory = new Factory ( ) ; return factory ; } public static class Factory { private String name ; private Vector attributes = new Vector ( ) ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addAttribute ( Attribute attr ) { attributes . addElement ( attr ) ; } public Enumeration getAttributes ( ) { return attributes . elements ( ) ; } public static class Attribute implements DynamicConfigurator { private String name ; private Object value ; public String getName ( ) { return name ; } public Object getValue ( ) { return value ; } public Object createDynamicElement ( String name ) throws BuildException { return null ; } public void setDynamicAttribute ( String name , String value ) throws BuildException { if ( "name" . equalsIgnoreCase ( name ) ) { this . name = value ; } else if ( "value" . equalsIgnoreCase ( name ) ) { if ( "true" . equalsIgnoreCase ( value ) || "false" . equalsIgnoreCase ( value ) ) { this . value = new Boolean ( value ) ; } else { try { this . value = new Integer ( value ) ; } catch ( NumberFormatException e ) { this . value = value ; } } } else { throw new BuildException ( "Unsupported attribute: " + name ) ; } } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . CollectionUtils ; public class Manifest { public static final String ATTRIBUTE_MANIFEST_VERSION = "Manifest-Version" ; public static final String ATTRIBUTE_SIGNATURE_VERSION = "Signature-Version" ; public static final String ATTRIBUTE_NAME = "Name" ; public static final String ATTRIBUTE_FROM = "From" ; public static final String ATTRIBUTE_CLASSPATH = "Class-Path" ; public static final String DEFAULT_MANIFEST_VERSION = "1.0" ; public static final int MAX_LINE_LENGTH = 72 ; public static final int MAX_SECTION_LENGTH = MAX_LINE_LENGTH - 2 ; public static final String EOL = "\r\n" ; public static class Attribute { private String name = null ; private Vector values = new Vector ( ) ; private int currentIndex = 0 ; public Attribute ( ) { } public Attribute ( String line ) throws ManifestException { parse ( line ) ; } public Attribute ( String name , String value ) { this . name = name ; setValue ( value ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( name != null ) { hashCode += name . hashCode ( ) ; } hashCode += values . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Attribute rhsAttribute = ( Attribute ) rhs ; String lhsKey = getKey ( ) ; String rhsKey = rhsAttribute . getKey ( ) ; if ( ( lhsKey == null && rhsKey != null ) || ( lhsKey != null && rhsKey == null ) || ! lhsKey . equals ( rhsKey ) ) { return false ; } return CollectionUtils . equals ( values , rhsAttribute . values ) ; } public void parse ( String line ) throws ManifestException { int index = line . indexOf ( ": " ) ; if ( index == - 1 ) { throw new ManifestException ( "Manifest line \"" + line + "\" is not valid as it does not " + "contain a name and a value separated by ': ' " ) ; } name = line . substring ( 0 , index ) ; setValue ( line . substring ( index + 2 ) ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String getKey ( ) { if ( name == null ) { return null ; } return name . toLowerCase ( ) ; } public void setValue ( String value ) { if ( currentIndex >= values . size ( ) ) { values . addElement ( value ) ; currentIndex = values . size ( ) - 1 ; } else { values . setElementAt ( value , currentIndex ) ; } } public String getValue ( ) { if ( values . size ( ) == 0 ) { return null ; } String fullValue = "" ; for ( Enumeration e = getValues ( ) ; e . hasMoreElements ( ) ; ) { String value = ( String ) e . nextElement ( ) ; fullValue += value + " " ; } return fullValue . trim ( ) ; } public void addValue ( String value ) { currentIndex ++ ; setValue ( value ) ; } public Enumeration getValues ( ) { return values . elements ( ) ; } public void addContinuation ( String line ) { String currentValue = ( String ) values . elementAt ( currentIndex ) ; setValue ( currentValue + line . substring ( 1 ) ) ; } public void write ( PrintWriter writer ) throws IOException { for ( Enumeration e = getValues ( ) ; e . hasMoreElements ( ) ; ) { writeValue ( writer , ( String ) e . nextElement ( ) ) ; } } private void writeValue ( PrintWriter writer , String value ) throws IOException { String line = name + ": " + value ; while ( line . getBytes ( ) . length > MAX_LINE_LENGTH ) { int breakIndex = MAX_SECTION_LENGTH ; String section = line . substring ( 0 , breakIndex ) ; while ( section . getBytes ( ) . length > MAX_SECTION_LENGTH && breakIndex > 0 ) { breakIndex -- ; section = line . substring ( 0 , breakIndex ) ; } if ( breakIndex == 0 ) { throw new IOException ( "Unable to write manifest line " + name + ": " + value ) ; } writer . print ( section + EOL ) ; line = " " + line . substring ( breakIndex ) ; } writer . print ( line + EOL ) ; } } public static class Section { private Vector warnings = new Vector ( ) ; private String name = null ; private Hashtable attributes = new Hashtable ( ) ; private Vector attributeIndex = new Vector ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String read ( BufferedReader reader ) throws ManifestException , IOException { Attribute attribute = null ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null || line . length ( ) == 0 ) { return null ; } if ( line . charAt ( 0 ) == ' ' ) { if ( attribute == null ) { if ( name != null ) { name += line . substring ( 1 ) ; } else { throw new ManifestException ( "Can't start an " + "attribute with a continuation line " + line ) ; } } else { attribute . addContinuation ( line ) ; } } else { attribute = new Attribute ( line ) ; String nameReadAhead = addAttributeAndCheck ( attribute ) ; attribute = getAttribute ( attribute . getKey ( ) ) ; if ( nameReadAhead != null ) { return nameReadAhead ; } } } } public void merge ( Section section ) throws ManifestException { if ( name == null && section . getName ( ) != null || name != null && ! ( name . equalsIgnoreCase ( section . getName ( ) ) ) ) { throw new ManifestException ( "Unable to merge sections " + "with different names" ) ; } Enumeration e = section . getAttributeKeys ( ) ; Attribute classpathAttribute = null ; while ( e . hasMoreElements ( ) ) { String attributeName = ( String ) e . nextElement ( ) ; Attribute attribute = section . getAttribute ( attributeName ) ; if ( attributeName . equalsIgnoreCase ( ATTRIBUTE_CLASSPATH ) ) { if ( classpathAttribute == null ) { classpathAttribute = new Attribute ( ) ; classpathAttribute . setName ( ATTRIBUTE_CLASSPATH ) ; } Enumeration cpe = attribute . getValues ( ) ; while ( cpe . hasMoreElements ( ) ) { String value = ( String ) cpe . nextElement ( ) ; classpathAttribute . addValue ( value ) ; } } else { storeAttribute ( attribute ) ; } } if ( classpathAttribute != null ) { storeAttribute ( classpathAttribute ) ; } Enumeration warnEnum = section . warnings . elements ( ) ; while ( warnEnum . hasMoreElements ( ) ) { warnings . addElement ( warnEnum . nextElement ( ) ) ; } } public void write ( PrintWriter writer ) throws IOException { if ( name != null ) { Attribute nameAttr = new Attribute ( ATTRIBUTE_NAME , name ) ; nameAttr . write ( writer ) ; } Enumeration e = getAttributeKeys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; Attribute attribute = getAttribute ( key ) ; attribute . write ( writer ) ; } writer . print ( EOL ) ; } public Attribute getAttribute ( String attributeName ) { return ( Attribute ) attributes . get ( attributeName . toLowerCase ( ) ) ; } public Enumeration getAttributeKeys ( ) { return attributeIndex . elements ( ) ; } public String getAttributeValue ( String attributeName ) { Attribute attribute = getAttribute ( attributeName . toLowerCase ( ) ) ; if ( attribute == null ) { return null ; } return attribute . getValue ( ) ; } public void removeAttribute ( String attributeName ) { String key = attributeName . toLowerCase ( ) ; attributes . remove ( key ) ; attributeIndex . removeElement ( key ) ; } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { String check = addAttributeAndCheck ( attribute ) ; if ( check != null ) { throw new BuildException ( "Specify the section name using " + "the \"name\" attribute of the <section> element rather " + "than using a \"Name\" manifest attribute" ) ; } } public String addAttributeAndCheck ( Attribute attribute ) throws ManifestException { if ( attribute . getName ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getKey ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { warnings . addElement ( "\"" + ATTRIBUTE_NAME + "\" attributes " + "should not occur in the main section and must be the " + "first element in all other sections: \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; return attribute . getValue ( ) ; } if ( attribute . getKey ( ) . startsWith ( ATTRIBUTE_FROM . toLowerCase ( ) ) ) { warnings . addElement ( "Manifest attributes should not start " + "with \"" + ATTRIBUTE_FROM + "\" in \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; } else { String attributeKey = attribute . getKey ( ) ; if ( attributeKey . equalsIgnoreCase ( ATTRIBUTE_CLASSPATH ) ) { Attribute classpathAttribute = ( Attribute ) attributes . get ( attributeKey ) ; if ( classpathAttribute == null ) { storeAttribute ( attribute ) ; } else { warnings . addElement ( "Multiple Class-Path attributes " + "are supported but violate the Jar " + "specification and may not be correctly " + "processed in all environments" ) ; Enumeration e = attribute . getValues ( ) ; while ( e . hasMoreElements ( ) ) { String value = ( String ) e . nextElement ( ) ; classpathAttribute . addValue ( value ) ; } } } else if ( attributes . containsKey ( attributeKey ) ) { throw new ManifestException ( "The attribute \"" + attribute . getName ( ) + "\" may not occur more " + "than once in the same section" ) ; } else { storeAttribute ( attribute ) ; } } return null ; } public Object clone ( ) { Section cloned = new Section ( ) ; cloned . setName ( name ) ; Enumeration e = getAttributeKeys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; Attribute attribute = getAttribute ( key ) ; cloned . storeAttribute ( new Attribute ( attribute . getName ( ) , attribute . getValue ( ) ) ) ; } return cloned ; } private void storeAttribute ( Attribute attribute ) { if ( attribute == null ) { return ; } String attributeKey = attribute . getKey ( ) ; attributes . put ( attributeKey , attribute ) ; if ( ! attributeIndex . contains ( attributeKey ) ) { attributeIndex . addElement ( attributeKey ) ; } } public Enumeration getWarnings ( ) { return warnings . elements ( ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( name != null ) { hashCode += name . hashCode ( ) ; } hashCode += attributes . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Section rhsSection = ( Section ) rhs ; return CollectionUtils . equals ( attributes , rhsSection . attributes ) ; } } private String manifestVersion = DEFAULT_MANIFEST_VERSION ; private Section mainSection = new Section ( ) ; private Hashtable sections = new Hashtable ( ) ; private Vector sectionIndex = new Vector ( ) ; public static Manifest getDefaultManifest ( ) throws BuildException { try { String defManifest = "/org/apache/tools/ant/defaultManifest.mf" ; InputStream in = Manifest . class . getResourceAsStream ( defManifest ) ; if ( in == null ) { throw new BuildException ( "Could not find default manifest: " + defManifest ) ; } try { Manifest defaultManifest = new Manifest ( new InputStreamReader ( in , "UTF-8" ) ) ; Attribute createdBy = new Attribute ( "Created-By" , System . getProperty ( "java.vm.version" ) + " (" + System . getProperty ( "java.vm.vendor" ) + ")" ) ; defaultManifest . getMainSection ( ) . storeAttribute ( createdBy ) ; return defaultManifest ; } catch ( UnsupportedEncodingException e ) { return new Manifest ( new InputStreamReader ( in ) ) ; } } catch ( ManifestException e ) { throw new BuildException ( "Default manifest is invalid !!" , e ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read default manifest" , e ) ; } } public Manifest ( ) { manifestVersion = null ; } public Manifest ( Reader r ) throws ManifestException , IOException { BufferedReader reader = new BufferedReader ( r ) ; String nextSectionName = mainSection . read ( reader ) ; String readManifestVersion = mainSection . getAttributeValue ( ATTRIBUTE_MANIFEST_VERSION ) ; if ( readManifestVersion != null ) { manifestVersion = readManifestVersion ; mainSection . removeAttribute ( ATTRIBUTE_MANIFEST_VERSION ) ; } String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) == 0 ) { continue ; } Section section = new Section ( ) ; if ( nextSectionName == null ) { Attribute sectionName = new Attribute ( line ) ; if ( ! sectionName . getName ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { throw new ManifestException ( "Manifest sections should " + "start with a \"" + ATTRIBUTE_NAME + "\" attribute and not \"" + sectionName . getName ( ) + "\"" ) ; } nextSectionName = sectionName . getValue ( ) ; } else { Attribute firstAttribute = new Attribute ( line ) ; section . addAttributeAndCheck ( firstAttribute ) ; } section . setName ( nextSectionName ) ; nextSectionName = section . read ( reader ) ; addConfiguredSection ( section ) ; } } public void addConfiguredSection ( Section section ) throws ManifestException { String sectionName = section . getName ( ) ; if ( sectionName == null ) { throw new BuildException ( "Sections must have a name" ) ; } sections . put ( sectionName , section ) ; if ( ! sectionIndex . contains ( sectionName ) ) { sectionIndex . addElement ( sectionName ) ; } } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { if ( attribute . getKey ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getKey ( ) . equalsIgnoreCase ( ATTRIBUTE_MANIFEST_VERSION ) ) { manifestVersion = attribute . getValue ( ) ; } else { mainSection . addConfiguredAttribute ( attribute ) ; } } public void merge ( Manifest other ) throws ManifestException { merge ( other , false ) ; } public void merge ( Manifest other , boolean overwriteMain ) throws ManifestException { if ( other != null ) { if ( overwriteMain ) { mainSection = ( Section ) other . mainSection . clone ( ) ; } else { mainSection . merge ( other . mainSection ) ; } if ( other . manifestVersion != null ) { manifestVersion = other . manifestVersion ; } Enumeration e = other . getSectionNames ( ) ; while ( e . hasMoreElements ( ) ) { String sectionName = ( String ) e . nextElement ( ) ; Section ourSection = ( Section ) sections . get ( sectionName ) ; Section otherSection = ( Section ) other . sections . get ( sectionName ) ; if ( ourSection == null ) { if ( otherSection != null ) { addConfiguredSection ( ( Section ) otherSection . clone ( ) ) ; } } else { ourSection . merge ( otherSection ) ; } } } } public void write ( PrintWriter writer ) throws IOException { writer . print ( ATTRIBUTE_MANIFEST_VERSION + ": " + manifestVersion + EOL ) ; String signatureVersion = mainSection . getAttributeValue ( ATTRIBUTE_SIGNATURE_VERSION ) ; if ( signatureVersion != null ) { writer . print ( ATTRIBUTE_SIGNATURE_VERSION + ": " + signatureVersion + EOL ) ; mainSection . removeAttribute ( ATTRIBUTE_SIGNATURE_VERSION ) ; } mainSection . write ( writer ) ; if ( signatureVersion != null ) { try { Attribute svAttr = new Attribute ( ATTRIBUTE_SIGNATURE_VERSION , signatureVersion ) ; mainSection . addConfiguredAttribute ( svAttr ) ; } catch ( ManifestException e ) { } } Enumeration e = sectionIndex . elements ( ) ; while ( e . hasMoreElements ( ) ) { String sectionName = ( String ) e . nextElement ( ) ; Section section = getSection ( sectionName ) ; section . write ( writer ) ; } } public String toString ( ) { StringWriter sw = new StringWriter ( ) ; try { write ( new PrintWriter ( sw ) ) ; } catch ( IOException e ) { return null ; } return sw . toString ( ) ; } public Enumeration getWarnings ( ) { Vector warnings = new Vector ( ) ; Enumeration warnEnum = mainSection . getWarnings ( ) ; while ( warnEnum . hasMoreElements ( ) ) { warnings . addElement ( warnEnum . nextElement ( ) ) ; } Enumeration e = sections . elements ( ) ; while ( e . hasMoreElements ( ) ) { Section section = ( Section ) e . nextElement ( ) ; Enumeration e2 = section . getWarnings ( ) ; while ( e2 . hasMoreElements ( ) ) { warnings . addElement ( e2 . nextElement ( ) ) ; } } return warnings . elements ( ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( manifestVersion != null ) { hashCode += manifestVersion . hashCode ( ) ; } hashCode += mainSection . hashCode ( ) ; hashCode += sections . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Manifest rhsManifest = ( Manifest ) rhs ; if ( manifestVersion == null ) { if ( rhsManifest . manifestVersion != null ) { return false ; } } else if ( ! manifestVersion . equals ( rhsManifest . manifestVersion ) ) { return false ; } if ( ! mainSection . equals ( rhsManifest . mainSection ) ) { return false ; } return CollectionUtils . equals ( sections , rhsManifest . sections ) ; } public String getManifestVersion ( ) { return manifestVersion ; } public Section getMainSection ( ) { return mainSection ; } public Section getSection ( String name ) { return ( Section ) sections . get ( name ) ; } public Enumeration getSectionNames ( ) { return sectionIndex . elements ( ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Assertions ; import org . apache . tools . ant . types . Permissions ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private Environment env = new Environment ( ) ; private boolean fork = false ; private boolean newEnvironment = false ; private File dir = null ; private boolean failOnError = false ; private boolean append = false ; private Long timeout = null ; private Redirector redirector = new Redirector ( this ) ; private String resultProperty ; private Permissions perm = null ; private boolean spawn = false ; private boolean incompatibleWithSpawn = false ; public void execute ( ) throws BuildException { File savedDir = dir ; Permissions savedPermissions = perm ; int err = - 1 ; try { err = executeJava ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Java returned: " + err , getLocation ( ) ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } maybeSetResultPropertyValue ( err ) ; } finally { dir = savedDir ; perm = savedPermissions ; } } public int executeJava ( ) throws BuildException { String classname = cmdl . getClassname ( ) ; if ( classname == null && cmdl . getJar ( ) == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( ! fork && cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot execute a jar in non-forked mode." + " Please set fork='true'. " ) ; } if ( spawn && ! fork ) { throw new BuildException ( "Cannot spawn a java process in non-forked mode." + " Please set fork='true'. " ) ; } if ( spawn && incompatibleWithSpawn ) { getProject ( ) . log ( "spawn does not allow attributes related to input, " + "output, error, result" , Project . MSG_ERR ) ; getProject ( ) . log ( "spawn does not also not allow timeout" , Project . MSG_ERR ) ; throw new BuildException ( "You have used an attribute which is " + "not compatible with spawn" ) ; } if ( cmdl . getAssertions ( ) != null && ! fork ) { log ( "Assertion statements are currently ignored in non-forked mode" ) ; } if ( fork ) { if ( perm != null ) { log ( "Permissions can not be set this way in forked mode." , Project . MSG_WARN ) ; } log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; } else { if ( cmdl . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( newEnvironment || null != env . getVariables ( ) ) { log ( "Changes to environment variables are ignored when same " + "JVM is used." , Project . MSG_WARN ) ; } if ( cmdl . getBootclasspath ( ) != null ) { log ( "bootclasspath ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( perm == null && failOnError == true ) { perm = new Permissions ( true ) ; log ( "running " + this . cmdl . getClassname ( ) + " with default permissions (exit forbidden)" , Project . MSG_VERBOSE ) ; } log ( "Running in same VM " + cmdl . describeJavaCommand ( ) , Project . MSG_VERBOSE ) ; } try { if ( fork ) { if ( ! spawn ) { return fork ( cmdl . getCommandline ( ) ) ; } else { spawn ( cmdl . getCommandline ( ) ) ; return 0 ; } } else { try { run ( cmdl ) ; return 0 ; } catch ( ExitException ex ) { return ex . getStatus ( ) ; } } } catch ( BuildException e ) { if ( failOnError ) { throw e ; } else { log ( e . getMessage ( ) , Project . MSG_ERR ) ; return 0 ; } } catch ( Throwable t ) { if ( failOnError ) { throw new BuildException ( t ) ; } else { log ( t . getMessage ( ) , Project . MSG_ERR ) ; return 0 ; } } } public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return cmdl . createClasspath ( getProject ( ) ) . createPath ( ) ; } public Path createBootclasspath ( ) { return cmdl . createBootclasspath ( getProject ( ) ) . createPath ( ) ; } public Permissions createPermissions ( ) { if ( perm == null ) { perm = new Permissions ( ) ; } return perm ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setJar ( File jarfile ) throws BuildException { if ( cmdl . getClassname ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command." ) ; } cmdl . setJar ( jarfile . getAbsolutePath ( ) ) ; } public void setClassname ( String s ) throws BuildException { if ( cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command" ) ; } cmdl . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; cmdl . createArgument ( ) . setLine ( s ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; } protected void maybeSetResultPropertyValue ( int result ) { String res = Integer . toString ( result ) ; if ( resultProperty != null ) { getProject ( ) . setNewProperty ( resultProperty , res ) ; } } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; cmdl . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return cmdl . createVmArgument ( ) ; } public void setJvm ( String s ) { cmdl . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { cmdl . addSysproperty ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { cmdl . addSyspropertyset ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; incompatibleWithSpawn = true ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { redirector . setOutput ( out ) ; incompatibleWithSpawn = true ; } public void setInput ( File input ) { redirector . setInput ( input ) ; incompatibleWithSpawn = true ; } public void setInputString ( String inputString ) { redirector . setInputString ( inputString ) ; incompatibleWithSpawn = true ; } public void setLogError ( boolean logError ) { redirector . setLogError ( logError ) ; incompatibleWithSpawn = true ; } public void setError ( File error ) { redirector . setError ( error ) ; incompatibleWithSpawn = true ; } public void setOutputproperty ( String outputProp ) { redirector . setOutputProperty ( outputProp ) ; incompatibleWithSpawn = true ; } public void setErrorProperty ( String errorProperty ) { redirector . setErrorProperty ( errorProperty ) ; incompatibleWithSpawn = true ; } public void setMaxmemory ( String max ) { cmdl . setMaxmemory ( max ) ; } public void setJVMVersion ( String value ) { cmdl . setVmversion ( value ) ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setAppend ( boolean append ) { this . append = append ; incompatibleWithSpawn = true ; } public void setTimeout ( Long value ) { timeout = value ; incompatibleWithSpawn = true ; } public void addAssertions ( Assertions asserts ) { if ( cmdl . getAssertions ( ) != null ) { throw new BuildException ( "Only one assertion declaration is allowed" ) ; } cmdl . setAssertions ( asserts ) ; } protected void handleOutput ( String output ) { if ( redirector . getOutputStream ( ) != null ) { redirector . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( redirector . getInputStream ( ) != null ) { return redirector . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( redirector . getOutputStream ( ) != null ) { redirector . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } protected void handleErrorOutput ( String output ) { if ( redirector . getErrorStream ( ) != null ) { redirector . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void handleErrorFlush ( String output ) { if ( redirector . getErrorStream ( ) != null ) { redirector . handleErrorFlush ( output ) ; } else { super . handleErrorOutput ( output ) ; } } private void run ( CommandlineJava command ) throws BuildException { try { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; exe . setPermissions ( perm ) ; exe . setTimeout ( timeout ) ; redirector . createStreams ( ) ; exe . execute ( getProject ( ) ) ; redirector . complete ( ) ; if ( exe . killedProcess ( ) ) { throw new BuildException ( "Timeout: killed the sub-process" ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } } private int fork ( String [ ] command ) throws BuildException { Execute exe = new Execute ( redirector . createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( getProject ( ) ) ; if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , getLocation ( ) ) ; } exe . setWorkingDirectory ( dir ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; exe . setCommandline ( command ) ; try { int rc = exe . execute ( ) ; redirector . complete ( ) ; if ( exe . killedProcess ( ) ) { throw new BuildException ( "Timeout: killed the sub-process" ) ; } return rc ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private void spawn ( String [ ] command ) throws BuildException { Execute exe = new Execute ( ) ; exe . setAntRun ( getProject ( ) ) ; if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , getLocation ( ) ) ; } exe . setWorkingDirectory ( dir ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; exe . setCommandline ( command ) ; try { exe . spawn ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { cmdl . clearJavaArgs ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } } 	1
package org . apache . tools . tar ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; public class TarBuffer { public static final int DEFAULT_RCDSIZE = ( 512 ) ; public static final int DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 ) ; private InputStream inStream ; private OutputStream outStream ; private byte [ ] blockBuffer ; private int currBlkIdx ; private int currRecIdx ; private int blockSize ; private int recordSize ; private int recsPerBlock ; private boolean debug ; public TarBuffer ( InputStream inStream ) { this ( inStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize ) { this ( inStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize , int recordSize ) { this . inStream = inStream ; this . outStream = null ; this . initialize ( blockSize , recordSize ) ; } public TarBuffer ( OutputStream outStream ) { this ( outStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize ) { this ( outStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize , int recordSize ) { this . inStream = null ; this . outStream = outStream ; this . initialize ( blockSize , recordSize ) ; } private void initialize ( int blockSize , int recordSize ) { this . debug = false ; this . blockSize = blockSize ; this . recordSize = recordSize ; this . recsPerBlock = ( this . blockSize / this . recordSize ) ; this . blockBuffer = new byte [ this . blockSize ] ; if ( this . inStream != null ) { this . currBlkIdx = - 1 ; this . currRecIdx = this . recsPerBlock ; } else { this . currBlkIdx = 0 ; this . currRecIdx = 0 ; } } public int getBlockSize ( ) { return this . blockSize ; } public int getRecordSize ( ) { return this . recordSize ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean isEOFRecord ( byte [ ] record ) { for ( int i = 0 , sz = this . getRecordSize ( ) ; i < sz ; ++ i ) { if ( record [ i ] != 0 ) { return false ; } } return true ; } public void skipRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "SkipRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading (via skip) from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return ; } } this . currRecIdx ++ ; } public byte [ ] readRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ this . recordSize ] ; System . arraycopy ( this . blockBuffer , ( this . currRecIdx * this . recordSize ) , result , 0 , this . recordSize ) ; this . currRecIdx ++ ; return result ; } private boolean readBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } this . currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = this . blockSize ; while ( bytesNeeded > 0 ) { long numBytes = this . inStream . read ( this . blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != this . blockSize ) { if ( this . debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + this . blockSize + " bytes read." ) ; } } } this . currBlkIdx ++ ; return true ; } public int getCurrentBlockNum ( ) { return this . currBlkIdx ; } public int getCurrentRecordNum ( ) { return this . currRecIdx - 1 ; } public void writeRecord ( byte [ ] record ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( record . length != this . recordSize ) { throw new IOException ( "record to write has length '" + record . length + "' which is not the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( record , 0 , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( ( offset + this . recordSize ) > buf . length ) { throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( buf , offset , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } private void writeBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "WriteBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } this . outStream . write ( this . blockBuffer , 0 , this . blockSize ) ; this . outStream . flush ( ) ; this . currRecIdx = 0 ; this . currBlkIdx ++ ; } private void flushBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.flushBlock() called." ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( this . currRecIdx > 0 ) { this . writeBlock ( ) ; } } public void close ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.closeBuffer()." ) ; } if ( this . outStream != null ) { this . flushBlock ( ) ; if ( this . outStream != System . out && this . outStream != System . err ) { this . outStream . close ( ) ; this . outStream = null ; } } else if ( this . inStream != null ) { if ( this . inStream != System . in ) { this . inStream . close ( ) ; this . inStream = null ; } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . io . IOException ; import java . util . Date ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class Expand extends Task { private File dest ; private File source ; private boolean overwrite = true ; private Vector patternsets = new Vector ( ) ; private Vector filesets = new Vector ( ) ; private static final String NATIVE_ENCODING = "native-encoding" ; private String encoding = "UTF8" ; public void execute ( ) throws BuildException { if ( "expand" . equals ( getTaskType ( ) ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } if ( source == null && filesets . size ( ) == 0 ) { throw new BuildException ( "src attribute and/or filesets must be " + "specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( dest . exists ( ) && ! dest . isDirectory ( ) ) { throw new BuildException ( "Dest must be a directory." , getLocation ( ) ) ; } FileUtils fileUtils = FileUtils . newFileUtils ( ) ; if ( source != null ) { if ( source . isDirectory ( ) ) { throw new BuildException ( "Src must not be a directory." + " Use nested filesets instead." , getLocation ( ) ) ; } else { expandFile ( fileUtils , source , dest ) ; } } if ( filesets . size ( ) > 0 ) { for ( int j = 0 ; j < filesets . size ( ) ; j ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( j ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; File fromDir = fs . getDir ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { File file = new File ( fromDir , files [ i ] ) ; expandFile ( fileUtils , file , dest ) ; } } } } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; ZipFile zf = null ; try { zf = new ZipFile ( srcF , encoding ) ; Enumeration e = zf . getEntries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; extractFile ( fileUtils , srcF , dir , zf . getInputStream ( ze ) , ze . getName ( ) , new Date ( ze . getTime ( ) ) , ze . isDirectory ( ) ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { if ( zf != null ) { try { zf . close ( ) ; } catch ( IOException e ) { } } } } protected void extractFile ( FileUtils fileUtils , File srcF , File dir , InputStream compressedInputStream , String entryName , Date entryDate , boolean isDirectory ) throws IOException { if ( patternsets != null && patternsets . size ( ) > 0 ) { String name = entryName . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; boolean included = false ; for ( int v = 0 ; v < patternsets . size ( ) ; v ++ ) { PatternSet p = ( PatternSet ) patternsets . elementAt ( v ) ; String [ ] incls = p . getIncludePatterns ( getProject ( ) ) ; if ( incls == null || incls . length == 0 ) { incls = new String [ ] { "**" } ; } for ( int w = 0 ; w < incls . length ; w ++ ) { String pattern = incls [ w ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } included = SelectorUtils . matchPath ( pattern , name ) ; if ( included ) { break ; } } if ( ! included ) { break ; } String [ ] excls = p . getExcludePatterns ( getProject ( ) ) ; if ( excls != null ) { for ( int w = 0 ; w < excls . length ; w ++ ) { String pattern = excls [ w ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } included = ! ( SelectorUtils . matchPath ( pattern , name ) ) ; if ( ! included ) { break ; } } } } if ( ! included ) { return ; } } File f = fileUtils . resolveFile ( dir , entryName ) ; try { if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= entryDate . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; return ; } log ( "expanding " + entryName + " to " + f , Project . MSG_VERBOSE ) ; File dirF = fileUtils . getParentFile ( f ) ; if ( dirF != null ) { dirF . mkdirs ( ) ; } if ( isDirectory ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; while ( ( length = compressedInputStream . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; fos = null ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException e ) { } } } } fileUtils . setFileLastModified ( f , entryDate . getTime ( ) ) ; } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } public void addPatternset ( PatternSet set ) { patternsets . addElement ( set ) ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void setEncoding ( String encoding ) { if ( NATIVE_ENCODING . equals ( encoding ) ) { encoding = null ; } this . encoding = encoding ; } } 	1
package org . apache . tools . ant . util ; import java . io . BufferedInputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . lang . reflect . Method ; import java . net . MalformedURLException ; import java . net . URL ; import java . text . CharacterIterator ; import java . text . DecimalFormat ; import java . text . StringCharacterIterator ; import java . util . Random ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . launch . Locator ; public class FileUtils { private static Random rand = new Random ( System . currentTimeMillis ( ) ) ; private static Object lockReflection = new Object ( ) ; private static java . lang . reflect . Method setLastModified = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; private static boolean [ ] isSpecial = new boolean [ 256 ] ; private static char [ ] escapedChar1 = new char [ 256 ] ; private static char [ ] escapedChar2 = new char [ 256 ] ; public static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000 ; static { for ( int i = 0 ; i <= 0x20 ; i ++ ) { isSpecial [ i ] = true ; escapedChar1 [ i ] = Character . forDigit ( i > > 4 , 16 ) ; escapedChar2 [ i ] = Character . forDigit ( i & 0xf , 16 ) ; } isSpecial [ 0x7f ] = true ; escapedChar1 [ 0x7f ] = '7' ; escapedChar2 [ 0x7f ] = 'F' ; char [ ] escChs = { '<' , '>' , '#' , '%' , '"' , '{' , '}' , '|' , '\\' , '^' , '~' , '[' , ']' , '`' } ; int len = escChs . length ; char ch ; for ( int i = 0 ; i < len ; i ++ ) { ch = escChs [ i ] ; isSpecial [ ch ] = true ; escapedChar1 [ ch ] = Character . forDigit ( ch > > 4 , 16 ) ; escapedChar2 [ ch ] = Character . forDigit ( ch & 0xf , 16 ) ; } } public static FileUtils newFileUtils ( ) { return new FileUtils ( ) ; } protected FileUtils ( ) { } public URL getFileURL ( File file ) throws MalformedURLException { return new URL ( toURI ( file . getAbsolutePath ( ) ) ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , null , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified , encoding ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , encoding , project ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , inputEncoding , outputEncoding , project ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , null , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { copyFile ( sourceFile , destFile , filters , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , preserveLastModified , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( sourceFile , destFile , filters , null , overwrite , preserveLastModified , encoding , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( sourceFile , destFile , filters , filterChains , overwrite , preserveLastModified , encoding , encoding , project ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { if ( overwrite || ! destFile . exists ( ) || destFile . lastModified ( ) < sourceFile . lastModified ( ) ) { if ( destFile . exists ( ) && destFile . isFile ( ) ) { destFile . delete ( ) ; } File parent = getParentFile ( destFile ) ; if ( parent != null && ! parent . exists ( ) ) { parent . mkdirs ( ) ; } final boolean filterSetsAvailable = ( filters != null && filters . hasFilters ( ) ) ; final boolean filterChainsAvailable = ( filterChains != null && filterChains . size ( ) > 0 ) ; if ( filterSetsAvailable ) { BufferedReader in = null ; BufferedWriter out = null ; try { if ( inputEncoding == null ) { in = new BufferedReader ( new FileReader ( sourceFile ) ) ; } else { InputStreamReader isr = new InputStreamReader ( new FileInputStream ( sourceFile ) , inputEncoding ) ; in = new BufferedReader ( isr ) ; } if ( outputEncoding == null ) { out = new BufferedWriter ( new FileWriter ( destFile ) ) ; } else { OutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( destFile ) , outputEncoding ) ; out = new BufferedWriter ( osw ) ; } if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( 8192 ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } LineTokenizer lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; String newline = null ; String line = lineTokenizer . getToken ( in ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { newline = filters . replaceTokens ( line ) ; out . write ( newline ) ; } line = lineTokenizer . getToken ( in ) ; } } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } else if ( filterChainsAvailable || ( inputEncoding != null && ! inputEncoding . equals ( outputEncoding ) ) || ( inputEncoding == null && outputEncoding != null ) ) { BufferedReader in = null ; BufferedWriter out = null ; try { if ( inputEncoding == null ) { in = new BufferedReader ( new FileReader ( sourceFile ) ) ; } else { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sourceFile ) , inputEncoding ) ) ; } if ( outputEncoding == null ) { out = new BufferedWriter ( new FileWriter ( destFile ) ) ; } else { out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( destFile ) , outputEncoding ) ) ; } if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( 8192 ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } char [ ] buffer = new char [ 1024 * 8 ] ; while ( true ) { int nRead = in . read ( buffer , 0 , buffer . length ) ; if ( nRead == - 1 ) { break ; } out . write ( buffer , 0 , nRead ) ; } } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } else { FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( sourceFile ) ; out = new FileOutputStream ( destFile ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } if ( preserveLastModified ) { setFileLastModified ( destFile , sourceFile . lastModified ( ) ) ; } } } protected final Method getSetLastModified ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return null ; } synchronized ( lockReflection ) { if ( setLastModified == null ) { try { setLastModified = java . io . File . class . getMethod ( "setLastModified" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { throw new BuildException ( "File.setlastModified not in JDK > 1.1?" , nse ) ; } } } return setLastModified ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return ; } Long [ ] times = new Long [ 1 ] ; if ( time < 0 ) { times [ 0 ] = new Long ( System . currentTimeMillis ( ) ) ; } else { times [ 0 ] = new Long ( time ) ; } try { getSetLastModified ( ) . invoke ( file , times ) ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new BuildException ( "Exception setting the modification time " + "of " + file , nested ) ; } catch ( Throwable other ) { throw new BuildException ( "Exception setting the modification time " + "of " + file , other ) ; } } public File resolveFile ( File file , String filename ) { filename = filename . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( ! onNetWare ) { if ( filename . startsWith ( File . separator ) || ( filename . length ( ) >= 2 && Character . isLetter ( filename . charAt ( 0 ) ) && filename . charAt ( 1 ) == ':' ) ) { return normalize ( filename ) ; } } else { int colon = filename . indexOf ( ":" ) ; if ( filename . startsWith ( File . separator ) || ( colon > - 1 ) ) { return normalize ( filename ) ; } } if ( file == null ) { return new File ( filename ) ; } File helpFile = new File ( file . getAbsolutePath ( ) ) ; StringTokenizer tok = new StringTokenizer ( filename , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String part = tok . nextToken ( ) ; if ( part . equals ( ".." ) ) { helpFile = getParentFile ( helpFile ) ; if ( helpFile == null ) { String msg = "The file or path you specified (" + filename + ") is invalid relative to " + file . getPath ( ) ; throw new BuildException ( msg ) ; } } else if ( part . equals ( "." ) ) { } else { helpFile = new File ( helpFile , part ) ; } } return new File ( helpFile . getAbsolutePath ( ) ) ; } public File normalize ( String path ) { String orig = path ; path = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; int colon = path . indexOf ( ":" ) ; if ( ! onNetWare ) { if ( ! path . startsWith ( File . separator ) && ! ( path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && colon == 1 ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } } else { if ( ! path . startsWith ( File . separator ) && ( colon == - 1 ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } } boolean dosWithDrive = false ; String root = null ; if ( ( ! onNetWare && path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && path . charAt ( 1 ) == ':' ) || ( onNetWare && colon > - 1 ) ) { dosWithDrive = true ; char [ ] ca = path . replace ( '/' , '\\' ) . toCharArray ( ) ; StringBuffer sbRoot = new StringBuffer ( ) ; for ( int i = 0 ; i < colon ; i ++ ) { sbRoot . append ( Character . toUpperCase ( ca [ i ] ) ) ; } sbRoot . append ( ':' ) ; if ( colon + 1 < path . length ( ) ) { sbRoot . append ( File . separatorChar ) ; } root = sbRoot . toString ( ) ; StringBuffer sbPath = new StringBuffer ( ) ; for ( int i = colon + 1 ; i < ca . length ; i ++ ) { if ( ( ca [ i ] != '\\' ) || ( ca [ i ] == '\\' && ca [ i - 1 ] != '\\' ) ) { sbPath . append ( ca [ i ] ) ; } } path = sbPath . toString ( ) . replace ( '\\' , File . separatorChar ) ; } else { if ( path . length ( ) == 1 ) { root = File . separator ; path = "" ; } else if ( path . charAt ( 1 ) == File . separatorChar ) { root = File . separator + File . separator ; path = path . substring ( 2 ) ; } else { root = File . separator ; path = path . substring ( 1 ) ; } } Stack s = new Stack ( ) ; s . push ( root ) ; StringTokenizer tok = new StringTokenizer ( path , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String thisToken = tok . nextToken ( ) ; if ( "." . equals ( thisToken ) ) { continue ; } else if ( ".." . equals ( thisToken ) ) { if ( s . size ( ) < 2 ) { throw new BuildException ( "Cannot resolve path " + orig ) ; } else { s . pop ( ) ; } } else { s . push ( thisToken ) ; } } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i > 1 ) { sb . append ( File . separatorChar ) ; } sb . append ( s . elementAt ( i ) ) ; } path = sb . toString ( ) ; if ( dosWithDrive ) { path = path . replace ( '/' , '\\' ) ; } return new File ( path ) ; } public String toVMSPath ( File f ) { String osPath ; String path = normalize ( f . getAbsolutePath ( ) ) . getPath ( ) ; String name = f . getName ( ) ; boolean isAbsolute = path . charAt ( 0 ) == File . separatorChar ; boolean isDirectory = f . isDirectory ( ) && ! name . regionMatches ( true , name . length ( ) - 4 , ".DIR" , 0 , 4 ) ; String device = null ; StringBuffer directory = null ; String file = null ; int index = 0 ; if ( isAbsolute ) { index = path . indexOf ( File . separatorChar , 1 ) ; if ( index == - 1 ) { return path . substring ( 1 ) + ":[000000]" ; } else { device = path . substring ( 1 , index ++ ) ; } } if ( isDirectory ) { directory = new StringBuffer ( path . substring ( index ) . replace ( File . separatorChar , '.' ) ) ; } else { int dirEnd = path . lastIndexOf ( File . separatorChar , path . length ( ) ) ; if ( dirEnd == - 1 || dirEnd < index ) { file = path . substring ( index ) ; } else { directory = new StringBuffer ( path . substring ( index , dirEnd ) . replace ( File . separatorChar , '.' ) ) ; index = dirEnd + 1 ; if ( path . length ( ) > index ) { file = path . substring ( index ) ; } } } if ( ! isAbsolute && directory != null ) { directory . insert ( 0 , '.' ) ; } osPath = ( ( device != null ) ? device + ":" : "" ) + ( ( directory != null ) ? "[" + directory + "]" : "" ) + ( ( file != null ) ? file : "" ) ; return osPath ; } public File createTempFile ( String prefix , String suffix , File parentDir ) { File result = null ; String parent = System . getProperty ( "java.io.tmpdir" ) ; if ( parentDir != null ) { parent = parentDir . getPath ( ) ; } DecimalFormat fmt = new DecimalFormat ( "#####" ) ; synchronized ( rand ) { do { result = new File ( parent , prefix + fmt . format ( Math . abs ( rand . nextInt ( ) ) ) + suffix ) ; } while ( result . exists ( ) ) ; } return result ; } public boolean contentEquals ( File f1 , File f2 ) throws IOException { if ( f1 . exists ( ) != f2 . exists ( ) ) { return false ; } if ( ! f1 . exists ( ) ) { return true ; } if ( f1 . isDirectory ( ) || f2 . isDirectory ( ) ) { return false ; } if ( fileNameEquals ( f1 , f2 ) ) { return true ; } if ( f1 . length ( ) != f2 . length ( ) ) { return false ; } InputStream in1 = null ; InputStream in2 = null ; try { in1 = new BufferedInputStream ( new FileInputStream ( f1 ) ) ; in2 = new BufferedInputStream ( new FileInputStream ( f2 ) ) ; int expectedByte = in1 . read ( ) ; while ( expectedByte != - 1 ) { if ( expectedByte != in2 . read ( ) ) { return false ; } expectedByte = in1 . read ( ) ; } if ( in2 . read ( ) != - 1 ) { return false ; } return true ; } finally { if ( in1 != null ) { try { in1 . close ( ) ; } catch ( IOException e ) { } } if ( in2 != null ) { try { in2 . close ( ) ; } catch ( IOException e ) { } } } } public File getParentFile ( File f ) { if ( f != null ) { String p = f . getParent ( ) ; if ( p != null ) { return new File ( p ) ; } } return null ; } public static final String readFully ( Reader rdr ) throws IOException { return readFully ( rdr , 8192 ) ; } public static final String readFully ( Reader rdr , int bufferSize ) throws IOException { if ( bufferSize <= 0 ) { throw new IllegalArgumentException ( "Buffer size must be greater " + "than 0" ) ; } final char [ ] buffer = new char [ bufferSize ] ; int bufferLength = 0 ; String text = null ; StringBuffer textBuffer = null ; while ( bufferLength != - 1 ) { bufferLength = rdr . read ( buffer ) ; if ( bufferLength != - 1 ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( new String ( buffer , 0 , bufferLength ) ) ; } else { textBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; } } } if ( textBuffer != null ) { text = textBuffer . toString ( ) ; } return text ; } public boolean createNewFile ( File f ) throws IOException { if ( f != null ) { if ( f . exists ( ) ) { return false ; } FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; fos . write ( new byte [ 0 ] ) ; } finally { if ( fos != null ) { fos . close ( ) ; } } return true ; } return false ; } public boolean isSymbolicLink ( File parent , String name ) throws IOException { File resolvedParent = new File ( parent . getCanonicalPath ( ) ) ; File toTest = new File ( resolvedParent , name ) ; return ! toTest . getAbsolutePath ( ) . equals ( toTest . getCanonicalPath ( ) ) ; } public String removeLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( l . equals ( p ) ) { return "" ; } if ( ! l . endsWith ( File . separator ) ) { l += File . separator ; } if ( p . startsWith ( l ) ) { return p . substring ( l . length ( ) ) ; } else { return p ; } } public String toURI ( String path ) { boolean isDir = ( new File ( path ) ) . isDirectory ( ) ; StringBuffer sb = new StringBuffer ( "file:" ) ; try { path = normalize ( path ) . getAbsolutePath ( ) ; sb . append ( "//" ) ; if ( ! path . startsWith ( File . separator ) ) { sb . append ( "/" ) ; } } catch ( BuildException e ) { } path = path . replace ( '\\' , '/' ) ; CharacterIterator iter = new StringCharacterIterator ( path ) ; for ( char c = iter . first ( ) ; c != CharacterIterator . DONE ; c = iter . next ( ) ) { if ( isSpecial [ c ] ) { sb . append ( '%' ) ; sb . append ( escapedChar1 [ c ] ) ; sb . append ( escapedChar2 [ c ] ) ; } else { sb . append ( c ) ; } } if ( isDir && ! path . endsWith ( "/" ) ) { sb . append ( '/' ) ; } return sb . toString ( ) ; } public String fromURI ( String uri ) { String path = Locator . fromURI ( uri ) ; try { path = normalize ( path ) . getAbsolutePath ( ) ; } catch ( BuildException e ) { } return path ; } public boolean fileNameEquals ( File f1 , File f2 ) { return normalize ( f1 . getAbsolutePath ( ) ) . equals ( normalize ( f2 . getAbsolutePath ( ) ) ) ; } public void rename ( File from , File to ) throws IOException { if ( to . exists ( ) && ! to . delete ( ) ) { throw new IOException ( "Failed to delete " + to + " while trying to rename " + from ) ; } File parent = getParentFile ( to ) ; if ( parent != null && ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new IOException ( "Failed to create directory " + parent + " while trying to rename " + from ) ; } if ( ! from . renameTo ( to ) ) { copyFile ( from , to ) ; if ( ! from . delete ( ) ) { throw new IOException ( "Failed to delete " + from + " while trying to rename it." ) ; } } } public long getFileTimestampGranularity ( ) { if ( Os . isFamily ( "dos" ) ) { return FAT_FILE_TIMESTAMP_GRANULARITY ; } else { return 0 ; } } } 	1
package org . apache . tools . ant ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . io . IOException ; import org . apache . tools . ant . taskdefs . PreSetDef ; public class UnknownElement extends Task { private String elementName ; private String namespace ; private String qname ; private Object realThing ; private List children = null ; private boolean presetDefed = false ; public UnknownElement ( String elementName ) { this . elementName = elementName ; } public String getTag ( ) { return elementName ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { if ( namespace . equals ( ProjectHelper . ANT_CURRENT_URI ) ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; namespace = helper . getCurrentAntlibUri ( ) ; } this . namespace = namespace ; } public String getQName ( ) { return qname ; } public void setQName ( String qname ) { this . qname = qname ; } public RuntimeConfigurable getWrapper ( ) { return super . getWrapper ( ) ; } public void maybeConfigure ( ) throws BuildException { configure ( makeObject ( this , getWrapper ( ) ) ) ; } public void configure ( Object realObject ) { realThing = realObject ; getWrapper ( ) . setProxy ( realThing ) ; Task task = null ; if ( realThing instanceof Task ) { task = ( Task ) realThing ; task . setRuntimeConfigurableWrapper ( getWrapper ( ) ) ; this . getOwningTarget ( ) . replaceChild ( this , ( Task ) realThing ) ; } handleChildren ( realThing , getWrapper ( ) ) ; if ( task != null ) { task . maybeConfigure ( ) ; } else { getWrapper ( ) . maybeConfigure ( getProject ( ) ) ; } } protected void handleOutput ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( realThing instanceof Task ) { return ( ( Task ) realThing ) . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } protected void handleErrorOutput ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void handleErrorFlush ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void execute ( ) { if ( realThing == null ) { throw new BuildException ( "Could not create task of type: " + elementName , getLocation ( ) ) ; } if ( realThing instanceof Task ) { ( ( Task ) realThing ) . execute ( ) ; } realThing = null ; } public void addChild ( UnknownElement child ) { if ( children == null ) { children = new ArrayList ( ) ; } children . add ( child ) ; } protected void handleChildren ( Object parent , RuntimeConfigurable parentWrapper ) throws BuildException { if ( parent instanceof TypeAdapter ) { parent = ( ( TypeAdapter ) parent ) . getProxy ( ) ; } String parentUri = getNamespace ( ) ; Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; if ( children != null ) { Iterator it = children . iterator ( ) ; for ( int i = 0 ; it . hasNext ( ) ; i ++ ) { RuntimeConfigurable childWrapper = parentWrapper . getChild ( i ) ; UnknownElement child = ( UnknownElement ) it . next ( ) ; if ( ! handleChild ( parentUri , ih , parent , child , childWrapper ) ) { if ( ! ( parent instanceof TaskContainer ) ) { ih . throwNotSupported ( getProject ( ) , parent , child . getTag ( ) ) ; } else { TaskContainer container = ( TaskContainer ) parent ; container . addTask ( child ) ; } } } } } protected String getComponentName ( ) { return ProjectHelper . genComponentName ( getNamespace ( ) , getTag ( ) ) ; } public void applyPreSet ( UnknownElement u ) { if ( presetDefed ) { return ; } getWrapper ( ) . applyPreSet ( u . getWrapper ( ) ) ; if ( u . children != null ) { List newChildren = new ArrayList ( ) ; newChildren . addAll ( u . children ) ; if ( children != null ) { newChildren . addAll ( children ) ; } children = newChildren ; } presetDefed = true ; } protected Object makeObject ( UnknownElement ue , RuntimeConfigurable w ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String name = ue . getComponentName ( ) ; Object o = helper . createComponent ( ue , ue . getNamespace ( ) , name ) ; if ( o == null ) { throw getNotFoundException ( "task or type" , name ) ; } if ( o instanceof PreSetDef . PreSetDefinition ) { PreSetDef . PreSetDefinition def = ( PreSetDef . PreSetDefinition ) o ; o = def . createObject ( ue . getProject ( ) ) ; ue . applyPreSet ( def . getPreSets ( ) ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . setTaskType ( ue . getTaskType ( ) ) ; task . setTaskName ( ue . getTaskName ( ) ) ; } } if ( o instanceof Task ) { Task task = ( Task ) o ; task . setOwningTarget ( getOwningTarget ( ) ) ; task . init ( ) ; } return o ; } protected Task makeTask ( UnknownElement ue , RuntimeConfigurable w ) { Task task = getProject ( ) . createTask ( ue . getTag ( ) ) ; if ( task != null ) { task . setLocation ( getLocation ( ) ) ; task . setOwningTarget ( getOwningTarget ( ) ) ; task . init ( ) ; } return task ; } protected BuildException getNotFoundException ( String what , String elementName ) { String lSep = System . getProperty ( "line.separator" ) ; String msg = "Could not create " + what + " of type: " + elementName + "." + lSep + lSep + "Ant could not find the task or a class this " + "task relies upon." + lSep + lSep + "This is common and has a number of causes; the usual " + lSep + "solutions are to read the manual pages then download and" + lSep + "install needed JAR files, or fix the build file: " + lSep + " - You have misspelt '" + elementName + "'." + lSep + "   Fix: check your spelling." + lSep + " - The task needs an external JAR file to execute" + lSep + "   and this is not found at the right place in the classpath." + lSep + "   Fix: check the documentation for dependencies." + lSep + "   Fix: declare the task." + lSep + " - The task is an Ant optional task and optional.jar is absent" + lSep + "   Fix: look for optional.jar in ANT_HOME/lib, download if needed" + lSep + " - The task was not built into optional.jar as dependent" + lSep + "   libraries were not found at build time." + lSep + "   Fix: look in the JAR to verify, then rebuild with the needed" + lSep + "   libraries, or download a release version from apache.org" + lSep + " - The build file was written for a later version of Ant" + lSep + "   Fix: upgrade to at least the latest release version of Ant" + lSep + " - The task is not an Ant core or optional task " + lSep + "   and needs to be declared using <taskdef>." + lSep + lSep + "Remember that for JAR files to be visible to Ant tasks implemented" + lSep + "in ANT_HOME/lib, the files must be in the same directory or on the" + lSep + "classpath" + lSep + lSep + "Please neither file bug reports on this problem, nor email the" + lSep + "Ant mailing lists, until all of these causes have been explored," + lSep + "as this is not an Ant bug." ; return new BuildException ( msg , getLocation ( ) ) ; } public String getTaskName ( ) { return realThing == null || ! ( realThing instanceof Task ) ? super . getTaskName ( ) : ( ( Task ) realThing ) . getTaskName ( ) ; } public Task getTask ( ) { if ( realThing instanceof Task ) { return ( Task ) realThing ; } return null ; } public Object getRealThing ( ) { return realThing ; } private boolean handleChild ( String parentUri , IntrospectionHelper ih , Object parent , UnknownElement child , RuntimeConfigurable childWrapper ) { String childName = ProjectHelper . genComponentName ( child . getNamespace ( ) , child . getTag ( ) ) ; if ( ih . supportsNestedElement ( parentUri , childName ) ) { IntrospectionHelper . Creator creator = ih . getElementCreator ( getProject ( ) , parentUri , parent , childName , child ) ; creator . setPolyType ( childWrapper . getPolyType ( ) ) ; Object realChild = creator . create ( ) ; if ( realChild instanceof PreSetDef . PreSetDefinition ) { PreSetDef . PreSetDefinition def = ( PreSetDef . PreSetDefinition ) realChild ; realChild = creator . getRealObject ( ) ; child . applyPreSet ( def . getPreSets ( ) ) ; } childWrapper . setCreator ( creator ) ; childWrapper . setProxy ( realChild ) ; if ( realChild instanceof Task ) { Task childTask = ( Task ) realChild ; childTask . setRuntimeConfigurableWrapper ( childWrapper ) ; childTask . setTaskName ( childName ) ; childTask . setTaskType ( childName ) ; childTask . setLocation ( child . getLocation ( ) ) ; } child . handleChildren ( realChild , childWrapper ) ; return true ; } return false ; } public boolean similar ( Object obj ) { if ( obj == null ) { return false ; } if ( ! getClass ( ) . getName ( ) . equals ( obj . getClass ( ) . getName ( ) ) ) { return false ; } UnknownElement other = ( UnknownElement ) obj ; if ( ! equalsString ( elementName , other . elementName ) ) { return false ; } if ( ! namespace . equals ( other . namespace ) ) { return false ; } if ( ! qname . equals ( other . qname ) ) { return false ; } if ( ! getWrapper ( ) . getAttributeMap ( ) . equals ( other . getWrapper ( ) . getAttributeMap ( ) ) ) { return false ; } if ( ! getWrapper ( ) . getText ( ) . toString ( ) . equals ( other . getWrapper ( ) . getText ( ) . toString ( ) ) ) { return false ; } if ( children == null || children . size ( ) == 0 ) { return other . children == null || other . children . size ( ) == 0 ; } if ( other . children == null ) { return false ; } if ( children . size ( ) != other . children . size ( ) ) { return false ; } for ( int i = 0 ; i < children . size ( ) ; ++ i ) { UnknownElement child = ( UnknownElement ) children . get ( i ) ; if ( ! child . similar ( other . children . get ( i ) ) ) { return false ; } } return true ; } private boolean equalsString ( String a , String b ) { if ( a == null ) { return b == null ; } return a . equals ( b ) ; } } 	1
package org . apache . tools . ant . types ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class FilterSet extends DataType implements Cloneable { public static class Filter { String token ; String value ; public Filter ( String token , String value ) { this . token = token ; this . value = value ; } public Filter ( ) { } public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public String getToken ( ) { return token ; } public String getValue ( ) { return value ; } } public class FiltersFile { public FiltersFile ( ) { } public void setFile ( File file ) { readFiltersFromFile ( file ) ; } } public static final String DEFAULT_TOKEN_START = "@" ; public static final String DEFAULT_TOKEN_END = "@" ; private String startOfToken = DEFAULT_TOKEN_START ; private String endOfToken = DEFAULT_TOKEN_END ; private Vector filters = new Vector ( ) ; public FilterSet ( ) { } protected FilterSet ( FilterSet filterset ) { super ( ) ; this . filters = ( Vector ) filterset . getFilters ( ) . clone ( ) ; } protected Vector getFilters ( ) { if ( isReference ( ) ) { return getRef ( ) . getFilters ( ) ; } return filters ; } protected FilterSet getRef ( ) { return ( FilterSet ) getCheckedRef ( FilterSet . class , "filterset" ) ; } public Hashtable getFilterHash ( ) { int filterSize = getFilters ( ) . size ( ) ; Hashtable filterHash = new Hashtable ( filterSize + 1 ) ; for ( Enumeration e = getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; filterHash . put ( filter . getToken ( ) , filter . getValue ( ) ) ; } return filterHash ; } public void setFiltersfile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } readFiltersFromFile ( filtersFile ) ; } public void setBeginToken ( String startOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( startOfToken == null || "" . equals ( startOfToken ) ) { throw new BuildException ( "beginToken must not be empty" ) ; } this . startOfToken = startOfToken ; } public String getBeginToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getBeginToken ( ) ; } return startOfToken ; } public void setEndToken ( String endOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( endOfToken == null || "" . equals ( endOfToken ) ) { throw new BuildException ( "endToken must not be empty" ) ; } this . endOfToken = endOfToken ; } public String getEndToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getEndToken ( ) ; } return endOfToken ; } public void readFiltersFromFile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( ! filtersFile . exists ( ) ) { throw new BuildException ( "Could not read filters from file " + filtersFile + " as it doesn't exist." ) ; } if ( filtersFile . isFile ( ) ) { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; FileInputStream in = null ; try { Properties props = new Properties ( ) ; in = new FileInputStream ( filtersFile ) ; props . load ( in ) ; Enumeration e = props . propertyNames ( ) ; Vector filters = getFilters ( ) ; while ( e . hasMoreElements ( ) ) { String strPropName = ( String ) e . nextElement ( ) ; String strValue = props . getProperty ( strPropName ) ; filters . addElement ( new Filter ( strPropName , strValue ) ) ; } } catch ( Exception ex ) { throw new BuildException ( "Could not read filters from file: " + filtersFile ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ioex ) { } } } } else { throw new BuildException ( "Must specify a file not a directory in " + "the filtersfile attribute:" + filtersFile ) ; } } public String replaceTokens ( String line ) { String beginToken = getBeginToken ( ) ; String endToken = getEndToken ( ) ; int index = line . indexOf ( beginToken ) ; if ( index > - 1 ) { Hashtable tokens = getFilterHash ( ) ; try { StringBuffer b = new StringBuffer ( ) ; int i = 0 ; String token = null ; String value = null ; do { int endIndex = line . indexOf ( endToken , index + beginToken . length ( ) + 1 ) ; if ( endIndex == - 1 ) { break ; } token = line . substring ( index + beginToken . length ( ) , endIndex ) ; b . append ( line . substring ( i , index ) ) ; if ( tokens . containsKey ( token ) ) { value = ( String ) tokens . get ( token ) ; if ( ! value . equals ( token ) ) { value = replaceTokens ( value , token ) ; } log ( "Replacing: " + beginToken + token + endToken + " -> " + value , Project . MSG_VERBOSE ) ; b . append ( value ) ; i = index + beginToken . length ( ) + token . length ( ) + endToken . length ( ) ; } else { b . append ( beginToken ) ; i = index + beginToken . length ( ) ; } } while ( ( index = line . indexOf ( beginToken , i ) ) > - 1 ) ; b . append ( line . substring ( i ) ) ; return b . toString ( ) ; } catch ( StringIndexOutOfBoundsException e ) { return line ; } } else { return line ; } } private Vector passedTokens ; private boolean duplicateToken = false ; private String replaceTokens ( String line , String parent ) throws BuildException { if ( passedTokens == null ) { passedTokens = new Vector ( ) ; } if ( passedTokens . contains ( parent ) && ! duplicateToken ) { duplicateToken = true ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( "Inifinite loop in tokens. Currently known tokens : " ) ; sb . append ( passedTokens ) ; sb . append ( "\nProblem token : " + getBeginToken ( ) + parent + getEndToken ( ) ) ; sb . append ( " called from " + getBeginToken ( ) + passedTokens . lastElement ( ) ) ; sb . append ( getEndToken ( ) ) ; System . out . println ( sb . toString ( ) ) ; return parent ; } passedTokens . addElement ( parent ) ; String value = this . replaceTokens ( line ) ; if ( value . indexOf ( getBeginToken ( ) ) == - 1 && ! duplicateToken ) { duplicateToken = false ; passedTokens = null ; } else if ( duplicateToken ) { if ( passedTokens . size ( ) > 0 ) { value = ( String ) passedTokens . lastElement ( ) ; passedTokens . removeElementAt ( passedTokens . size ( ) - 1 ) ; if ( passedTokens . size ( ) == 0 ) { value = getBeginToken ( ) + value + getEndToken ( ) ; duplicateToken = false ; } } } return value ; } public void addFilter ( Filter filter ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( filter ) ; } public FiltersFile createFiltersfile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return new FiltersFile ( ) ; } public void addFilter ( String token , String value ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( new Filter ( token , value ) ) ; } public void addConfiguredFilterSet ( FilterSet filterSet ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } for ( Enumeration e = filterSet . getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { filters . addElement ( e . nextElement ( ) ) ; } } public boolean hasFilters ( ) { return getFilters ( ) . size ( ) > 0 ; } public Object clone ( ) throws BuildException { if ( isReference ( ) ) { return ( ( FilterSet ) getRef ( ) ) . clone ( ) ; } else { try { FilterSet fs = ( FilterSet ) super . clone ( ) ; fs . filters = ( Vector ) getFilters ( ) . clone ( ) ; fs . setProject ( getProject ( ) ) ; return fs ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import java . util . zip . CRC32 ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . types . ZipScanner ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . GlobPatternMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . ResourceUtils ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; import org . apache . tools . zip . ZipOutputStream ; public class Zip extends MatchingTask { protected File zipFile ; private ZipScanner zs ; private File baseDir ; protected Hashtable entries = new Hashtable ( ) ; private Vector groupfilesets = new Vector ( ) ; private Vector filesetsFromGroupfilesets = new Vector ( ) ; protected String duplicate = "add" ; private boolean doCompress = true ; private boolean doUpdate = false ; private boolean savedDoUpdate = false ; private boolean doFilesonly = false ; protected String archiveType = "zip" ; private static final long EMPTY_CRC = new CRC32 ( ) . getValue ( ) ; protected String emptyBehavior = "skip" ; private Vector filesets = new Vector ( ) ; protected Hashtable addedDirs = new Hashtable ( ) ; private Vector addedFiles = new Vector ( ) ; protected boolean doubleFilePass = false ; protected boolean skipWriting = false ; private static FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private boolean addingNewFiles = false ; private String encoding ; private boolean keepCompression = false ; public void setZipfile ( File zipFile ) { setDestFile ( zipFile ) ; } public void setFile ( File file ) { setDestFile ( file ) ; } public void setDestFile ( File destFile ) { this . zipFile = destFile ; } public File getDestFile ( ) { return zipFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setCompress ( boolean c ) { doCompress = c ; } public boolean isCompress ( ) { return doCompress ; } public void setFilesonly ( boolean f ) { doFilesonly = f ; } public void setUpdate ( boolean c ) { doUpdate = c ; savedDoUpdate = c ; } public boolean isInUpdateMode ( ) { return doUpdate ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addZipfileset ( ZipFileSet set ) { filesets . addElement ( set ) ; } public void addZipGroupFileset ( FileSet set ) { groupfilesets . addElement ( set ) ; } public void setDuplicate ( Duplicate df ) { duplicate = df . getValue ( ) ; } public static class WhenEmpty extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "fail" , "skip" , "create" } ; } } public void setWhenempty ( WhenEmpty we ) { emptyBehavior = we . getValue ( ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setKeepCompression ( boolean keep ) { keepCompression = keep ; } public void execute ( ) throws BuildException { if ( doubleFilePass ) { skipWriting = true ; executeMain ( ) ; skipWriting = false ; executeMain ( ) ; } else { executeMain ( ) ; } } public void executeMain ( ) throws BuildException { if ( baseDir == null && filesets . size ( ) == 0 && groupfilesets . size ( ) == 0 && "zip" . equals ( archiveType ) ) { throw new BuildException ( "basedir attribute must be set, " + "or at least " + "one fileset must be given!" ) ; } if ( zipFile == null ) { throw new BuildException ( "You must specify the " + archiveType + " file to create!" ) ; } File renamedFile = null ; addingNewFiles = true ; if ( doUpdate && ! zipFile . exists ( ) ) { doUpdate = false ; log ( "ignoring update attribute as " + archiveType + " doesn't exist." , Project . MSG_DEBUG ) ; } for ( int i = 0 ; i < groupfilesets . size ( ) ; i ++ ) { log ( "Processing groupfileset " , Project . MSG_VERBOSE ) ; FileSet fs = ( FileSet ) groupfilesets . elementAt ( i ) ; FileScanner scanner = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = scanner . getIncludedFiles ( ) ; File basedir = scanner . getBasedir ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { log ( "Adding file " + files [ j ] + " to fileset" , Project . MSG_VERBOSE ) ; ZipFileSet zf = new ZipFileSet ( ) ; zf . setProject ( getProject ( ) ) ; zf . setSrc ( new File ( basedir , files [ j ] ) ) ; filesets . addElement ( zf ) ; filesetsFromGroupfilesets . addElement ( zf ) ; } } Vector vfss = new Vector ( ) ; if ( baseDir != null ) { FileSet fs = ( FileSet ) getImplicitFileSet ( ) . clone ( ) ; fs . setDir ( baseDir ) ; vfss . addElement ( fs ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; vfss . addElement ( fs ) ; } FileSet [ ] fss = new FileSet [ vfss . size ( ) ] ; vfss . copyInto ( fss ) ; boolean success = false ; try { ArchiveState state = getResourcesToAdd ( fss , zipFile , false ) ; if ( ! state . isOutOfDate ( ) ) { return ; } Resource [ ] [ ] addThem = state . getResourcesToAdd ( ) ; if ( doUpdate ) { renamedFile = fileUtils . createTempFile ( "zip" , ".tmp" , fileUtils . getParentFile ( zipFile ) ) ; renamedFile . deleteOnExit ( ) ; try { fileUtils . rename ( zipFile , renamedFile ) ; } catch ( SecurityException e ) { throw new BuildException ( "Not allowed to rename old file (" + zipFile . getAbsolutePath ( ) + ") to temporary file" ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to rename old file (" + zipFile . getAbsolutePath ( ) + ") to temporary file" ) ; } } String action = doUpdate ? "Updating " : "Building " ; log ( action + archiveType + ": " + zipFile . getAbsolutePath ( ) ) ; ZipOutputStream zOut = null ; try { if ( ! skipWriting ) { zOut = new ZipOutputStream ( zipFile ) ; zOut . setEncoding ( encoding ) ; if ( doCompress ) { zOut . setMethod ( ZipOutputStream . DEFLATED ) ; } else { zOut . setMethod ( ZipOutputStream . STORED ) ; } } initZipOutputStream ( zOut ) ; for ( int i = 0 ; i < fss . length ; i ++ ) { if ( addThem [ i ] . length != 0 ) { addResources ( fss [ i ] , addThem [ i ] , zOut ) ; } } if ( doUpdate ) { addingNewFiles = false ; ZipFileSet oldFiles = new ZipFileSet ( ) ; oldFiles . setProject ( getProject ( ) ) ; oldFiles . setSrc ( renamedFile ) ; for ( int i = 0 ; i < addedFiles . size ( ) ; i ++ ) { PatternSet . NameEntry ne = oldFiles . createExclude ( ) ; ne . setName ( ( String ) addedFiles . elementAt ( i ) ) ; } DirectoryScanner ds = oldFiles . getDirectoryScanner ( getProject ( ) ) ; ( ( ZipScanner ) ds ) . setEncoding ( encoding ) ; String [ ] f = ds . getIncludedFiles ( ) ; Resource [ ] r = new Resource [ f . length ] ; for ( int i = 0 ; i < f . length ; i ++ ) { r [ i ] = ds . getResource ( f [ i ] ) ; } if ( ! doFilesonly ) { String [ ] d = ds . getIncludedDirectories ( ) ; Resource [ ] dr = new Resource [ d . length ] ; for ( int i = 0 ; i < d . length ; i ++ ) { dr [ i ] = ds . getResource ( d [ i ] ) ; } Resource [ ] tmp = r ; r = new Resource [ tmp . length + dr . length ] ; System . arraycopy ( dr , 0 , r , 0 , dr . length ) ; System . arraycopy ( tmp , 0 , r , dr . length , tmp . length ) ; } addResources ( oldFiles , r , zOut ) ; } finalizeZipOutputStream ( zOut ) ; if ( doUpdate ) { if ( ! renamedFile . delete ( ) ) { log ( "Warning: unable to delete temporary file " + renamedFile . getName ( ) , Project . MSG_WARN ) ; } } success = true ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { if ( success ) { throw ex ; } } } } catch ( IOException ioe ) { String msg = "Problem creating " + archiveType + ": " + ioe . getMessage ( ) ; if ( ( ! doUpdate || renamedFile != null ) && ! zipFile . delete ( ) ) { msg += " (and the archive is probably corrupt but I could not " + "delete it)" ; } if ( doUpdate && renamedFile != null ) { try { fileUtils . rename ( renamedFile , zipFile ) ; } catch ( IOException e ) { msg += " (and I couldn't rename the temporary file " + renamedFile . getName ( ) + " back)" ; } } throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { cleanUp ( ) ; } } protected final boolean isAddingNewFiles ( ) { return addingNewFiles ; } protected final void addResources ( FileSet fileset , Resource [ ] resources , ZipOutputStream zOut ) throws IOException { String prefix = "" ; String fullpath = "" ; int dirMode = ZipFileSet . DEFAULT_DIR_MODE ; int fileMode = ZipFileSet . DEFAULT_FILE_MODE ; ZipFileSet zfs = null ; if ( fileset instanceof ZipFileSet ) { zfs = ( ZipFileSet ) fileset ; prefix = zfs . getPrefix ( getProject ( ) ) ; fullpath = zfs . getFullpath ( getProject ( ) ) ; dirMode = zfs . getDirMode ( getProject ( ) ) ; fileMode = zfs . getFileMode ( getProject ( ) ) ; } if ( prefix . length ( ) > 0 && fullpath . length ( ) > 0 ) { throw new BuildException ( "Both prefix and fullpath attributes must" + " not be set on the same fileset." ) ; } if ( resources . length != 1 && fullpath . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only be specified" + " for filesets that specify a single" + " file." ) ; } if ( prefix . length ( ) > 0 ) { if ( ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } addParentDirs ( null , prefix , zOut , "" , dirMode ) ; } ZipFile zf = null ; try { boolean dealingWithFiles = false ; File base = null ; if ( zfs == null || zfs . getSrc ( getProject ( ) ) == null ) { dealingWithFiles = true ; base = fileset . getDir ( getProject ( ) ) ; } else { zf = new ZipFile ( zfs . getSrc ( getProject ( ) ) , encoding ) ; } for ( int i = 0 ; i < resources . length ; i ++ ) { String name = null ; if ( fullpath . length ( ) > 0 ) { name = fullpath ; } else { name = resources [ i ] . getName ( ) ; } name = name . replace ( File . separatorChar , '/' ) ; if ( "" . equals ( name ) ) { continue ; } if ( resources [ i ] . isDirectory ( ) && ! name . endsWith ( "/" ) ) { name = name + "/" ; } if ( ! doFilesonly && ! dealingWithFiles && resources [ i ] . isDirectory ( ) && ! zfs . hasDirModeBeenSet ( ) ) { int nextToLastSlash = name . lastIndexOf ( "/" , name . length ( ) - 2 ) ; if ( nextToLastSlash != - 1 ) { addParentDirs ( base , name . substring ( 0 , nextToLastSlash + 1 ) , zOut , prefix , dirMode ) ; } ZipEntry ze = zf . getEntry ( resources [ i ] . getName ( ) ) ; addParentDirs ( base , name , zOut , prefix , ze . getUnixMode ( ) ) ; } else { addParentDirs ( base , name , zOut , prefix , dirMode ) ; } if ( ! resources [ i ] . isDirectory ( ) && dealingWithFiles ) { File f = fileUtils . resolveFile ( base , resources [ i ] . getName ( ) ) ; zipFile ( f , zOut , prefix + name , fileMode ) ; } else if ( ! resources [ i ] . isDirectory ( ) ) { ZipEntry ze = zf . getEntry ( resources [ i ] . getName ( ) ) ; if ( ze != null ) { boolean oldCompress = doCompress ; if ( keepCompression ) { doCompress = ( ze . getMethod ( ) == ZipEntry . DEFLATED ) ; } try { zipFile ( zf . getInputStream ( ze ) , zOut , prefix + name , ze . getTime ( ) , zfs . getSrc ( getProject ( ) ) , zfs . hasFileModeBeenSet ( ) ? fileMode : ze . getUnixMode ( ) ) ; } finally { doCompress = oldCompress ; } } } } } finally { if ( zf != null ) { zf . close ( ) ; } } } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected boolean createEmptyZip ( File zipFile ) throws BuildException { log ( "Note: creating empty " + archiveType + " archive " + zipFile , Project . MSG_INFO ) ; OutputStream os = null ; try { os = new FileOutputStream ( zipFile ) ; byte [ ] empty = new byte [ 22 ] ; empty [ 0 ] = 80 ; empty [ 1 ] = 75 ; empty [ 2 ] = 5 ; empty [ 3 ] = 6 ; os . write ( empty ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create empty ZIP archive " + "(" + ioe . getMessage ( ) + ")" , ioe , getLocation ( ) ) ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException e ) { } } } return true ; } private synchronized ZipScanner getZipScanner ( ) { if ( zs == null ) { zs = new ZipScanner ( ) ; zs . setEncoding ( encoding ) ; zs . setSrc ( zipFile ) ; } return zs ; } protected ArchiveState getResourcesToAdd ( FileSet [ ] filesets , File zipFile , boolean needsUpdate ) throws BuildException { Resource [ ] [ ] initialResources = grabResources ( filesets ) ; if ( isEmpty ( initialResources ) ) { if ( needsUpdate && doUpdate ) { return new ArchiveState ( true , initialResources ) ; } if ( emptyBehavior . equals ( "skip" ) ) { if ( doUpdate ) { log ( archiveType + " archive " + zipFile + " not updated because no new files were included." , Project . MSG_VERBOSE ) ; } else { log ( "Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included." , Project . MSG_WARN ) ; } } else if ( emptyBehavior . equals ( "fail" ) ) { throw new BuildException ( "Cannot create " + archiveType + " archive " + zipFile + ": no files were included." , getLocation ( ) ) ; } else { createEmptyZip ( zipFile ) ; } return new ArchiveState ( needsUpdate , initialResources ) ; } if ( ! zipFile . exists ( ) ) { return new ArchiveState ( true , initialResources ) ; } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } Resource [ ] [ ] newerResources = new Resource [ filesets . length ] [ ] ; for ( int i = 0 ; i < filesets . length ; i ++ ) { if ( ! ( fileset instanceof ZipFileSet ) || ( ( ZipFileSet ) fileset ) . getSrc ( getProject ( ) ) == null ) { File base = filesets [ i ] . getDir ( getProject ( ) ) ; for ( int j = 0 ; j < initialResources [ i ] . length ; j ++ ) { File resourceAsFile = fileUtils . resolveFile ( base , initialResources [ i ] [ j ] . getName ( ) ) ; if ( resourceAsFile . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include " + "itself" , getLocation ( ) ) ; } } } } for ( int i = 0 ; i < filesets . length ; i ++ ) { if ( initialResources [ i ] . length == 0 ) { newerResources [ i ] = new Resource [ ] { } ; continue ; } FileNameMapper myMapper = new IdentityMapper ( ) ; if ( filesets [ i ] instanceof ZipFileSet ) { ZipFileSet zfs = ( ZipFileSet ) filesets [ i ] ; if ( zfs . getFullpath ( getProject ( ) ) != null && ! zfs . getFullpath ( getProject ( ) ) . equals ( "" ) ) { MergingMapper fm = new MergingMapper ( ) ; fm . setTo ( zfs . getFullpath ( getProject ( ) ) ) ; myMapper = fm ; } else if ( zfs . getPrefix ( getProject ( ) ) != null && ! zfs . getPrefix ( getProject ( ) ) . equals ( "" ) ) { GlobPatternMapper gm = new GlobPatternMapper ( ) ; gm . setFrom ( "*" ) ; String prefix = zfs . getPrefix ( getProject ( ) ) ; if ( ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } gm . setTo ( prefix + "*" ) ; myMapper = gm ; } } Resource [ ] resources = initialResources [ i ] ; if ( doFilesonly ) { resources = selectFileResources ( resources ) ; } newerResources [ i ] = ResourceUtils . selectOutOfDateSources ( this , resources , myMapper , getZipScanner ( ) ) ; needsUpdate = needsUpdate || ( newerResources [ i ] . length > 0 ) ; if ( needsUpdate && ! doUpdate ) { break ; } } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } return new ArchiveState ( needsUpdate , newerResources ) ; } protected Resource [ ] [ ] grabResources ( FileSet [ ] filesets ) { Resource [ ] [ ] result = new Resource [ filesets . length ] [ ] ; for ( int i = 0 ; i < filesets . length ; i ++ ) { DirectoryScanner rs = filesets [ i ] . getDirectoryScanner ( getProject ( ) ) ; if ( rs instanceof ZipScanner ) { ( ( ZipScanner ) rs ) . setEncoding ( encoding ) ; } Vector resources = new Vector ( ) ; String [ ] directories = rs . getIncludedDirectories ( ) ; for ( int j = 0 ; j < directories . length ; j ++ ) { resources . addElement ( rs . getResource ( directories [ j ] ) ) ; } String [ ] files = rs . getIncludedFiles ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { resources . addElement ( rs . getResource ( files [ j ] ) ) ; } result [ i ] = new Resource [ resources . size ( ) ] ; resources . copyInto ( result [ i ] ) ; } return result ; } protected void zipDir ( File dir , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( addedDirs . get ( vPath ) != null ) { return ; } log ( "adding directory " + vPath , Project . MSG_VERBOSE ) ; addedDirs . put ( vPath , vPath ) ; if ( ! skipWriting ) { ZipEntry ze = new ZipEntry ( vPath ) ; if ( dir != null && dir . exists ( ) ) { ze . setTime ( dir . lastModified ( ) + 1999 ) ; } else { ze . setTime ( System . currentTimeMillis ( ) + 1999 ) ; } ze . setSize ( 0 ) ; ze . setMethod ( ZipEntry . STORED ) ; ze . setCrc ( EMPTY_CRC ) ; ze . setUnixMode ( mode ) ; zOut . putNextEntry ( ze ) ; } } protected void zipFile ( InputStream in , ZipOutputStream zOut , String vPath , long lastModified , File fromArchive , int mode ) throws IOException { if ( entries . contains ( vPath ) ) { if ( duplicate . equals ( "preserve" ) ) { log ( vPath + " already added, skipping" , Project . MSG_INFO ) ; return ; } else if ( duplicate . equals ( "fail" ) ) { throw new BuildException ( "Duplicate file " + vPath + " was found and the duplicate " + "attribute is 'fail'." ) ; } else { log ( "duplicate file " + vPath + " found, adding." , Project . MSG_VERBOSE ) ; } } else { log ( "adding entry " + vPath , Project . MSG_VERBOSE ) ; } entries . put ( vPath , vPath ) ; if ( ! skipWriting ) { ZipEntry ze = new ZipEntry ( vPath ) ; ze . setTime ( lastModified ) ; ze . setMethod ( doCompress ? ZipEntry . DEFLATED : ZipEntry . STORED ) ; if ( ! zOut . isSeekable ( ) && ! doCompress ) { long size = 0 ; CRC32 cal = new CRC32 ( ) ; if ( ! in . markSupported ( ) ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; bos . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } else { in . mark ( Integer . MAX_VALUE ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . reset ( ) ; } ze . setSize ( size ) ; ze . setCrc ( cal . getValue ( ) ) ; } ze . setUnixMode ( mode ) ; zOut . putNextEntry ( ze ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { if ( count != 0 ) { zOut . write ( buffer , 0 , count ) ; } count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } addedFiles . addElement ( vPath ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( file . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , getLocation ( ) ) ; } FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut , vPath , file . lastModified ( ) + 1999 , null , mode ) ; } finally { fIn . close ( ) ; } } protected final void addParentDirs ( File baseDir , String entry , ZipOutputStream zOut , String prefix , int dirMode ) throws IOException { if ( ! doFilesonly ) { Stack directories = new Stack ( ) ; int slashPos = entry . length ( ) ; while ( ( slashPos = entry . lastIndexOf ( '/' , slashPos - 1 ) ) != - 1 ) { String dir = entry . substring ( 0 , slashPos + 1 ) ; if ( addedDirs . get ( prefix + dir ) != null ) { break ; } directories . push ( dir ) ; } while ( ! directories . isEmpty ( ) ) { String dir = ( String ) directories . pop ( ) ; File f = null ; if ( baseDir != null ) { f = new File ( baseDir , dir ) ; } else { f = new File ( dir ) ; } zipDir ( f , zOut , prefix + dir , dirMode ) ; } } } protected void cleanUp ( ) { addedDirs . clear ( ) ; addedFiles . removeAllElements ( ) ; entries . clear ( ) ; addingNewFiles = false ; doUpdate = savedDoUpdate ; Enumeration e = filesetsFromGroupfilesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { ZipFileSet zf = ( ZipFileSet ) e . nextElement ( ) ; filesets . removeElement ( zf ) ; } filesetsFromGroupfilesets . removeAllElements ( ) ; } public void reset ( ) { filesets . removeAllElements ( ) ; zipFile = null ; baseDir = null ; groupfilesets . removeAllElements ( ) ; duplicate = "add" ; archiveType = "zip" ; doCompress = true ; emptyBehavior = "skip" ; doUpdate = false ; doFilesonly = false ; encoding = null ; } protected static final boolean isEmpty ( Resource [ ] [ ] r ) { for ( int i = 0 ; i < r . length ; i ++ ) { if ( r [ i ] . length > 0 ) { return false ; } } return true ; } protected Resource [ ] selectFileResources ( Resource [ ] orig ) { if ( orig . length == 0 ) { return orig ; } Vector v = new Vector ( orig . length ) ; for ( int i = 0 ; i < orig . length ; i ++ ) { if ( ! orig [ i ] . isDirectory ( ) ) { v . addElement ( orig [ i ] ) ; } else { log ( "Ignoring directory " + orig [ i ] . getName ( ) + " as only files will be added." , Project . MSG_VERBOSE ) ; } } if ( v . size ( ) != orig . length ) { Resource [ ] r = new Resource [ v . size ( ) ] ; v . copyInto ( r ) ; return r ; } return orig ; } public static class Duplicate extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "preserve" , "fail" } ; } } public static class ArchiveState { private boolean outOfDate ; private Resource [ ] [ ] resourcesToAdd ; ArchiveState ( boolean state , Resource [ ] [ ] r ) { outOfDate = state ; resourcesToAdd = r ; } public boolean isOutOfDate ( ) { return outOfDate ; } public Resource [ ] [ ] getResourcesToAdd ( ) { return resourcesToAdd ; } } } 	1
package org . apache . tools . ant . util ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import org . apache . bsf . BSFException ; import org . apache . bsf . BSFManager ; import org . apache . tools . ant . BuildException ; import java . util . Map ; import java . util . HashMap ; import java . util . Iterator ; public class ScriptRunner { private String language ; private String script = "" ; private Map beans = new HashMap ( ) ; public void addBeans ( Map dictionary ) { for ( Iterator i = dictionary . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; try { Object val = dictionary . get ( key ) ; addBean ( key , val ) ; } catch ( BuildException ex ) { } } } public void addBean ( String key , Object bean ) { boolean isValid = key . length ( ) > 0 && Character . isJavaIdentifierStart ( key . charAt ( 0 ) ) ; for ( int i = 1 ; isValid && i < key . length ( ) ; i ++ ) { isValid = Character . isJavaIdentifierPart ( key . charAt ( i ) ) ; } if ( isValid ) { beans . put ( key , bean ) ; } } public void executeScript ( String execName ) throws BuildException { if ( language == null ) { throw new BuildException ( "script language must be specified" ) ; } try { BSFManager manager = new BSFManager ( ) ; for ( Iterator i = beans . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; Object value = beans . get ( key ) ; if ( value != null ) { manager . declareBean ( key , value , value . getClass ( ) ) ; } else { manager . undeclareBean ( key ) ; } } manager . exec ( language , execName , 0 , 0 , script ) ; } catch ( BSFException be ) { Throwable t = be ; Throwable te = be . getTargetException ( ) ; if ( te != null ) { if ( te instanceof BuildException ) { throw ( BuildException ) te ; } else { t = te ; } } throw new BuildException ( t ) ; } } public void setLanguage ( String language ) { this . language = language ; } public String getLanguage ( ) { return language ; } public void setSrc ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "file " + file . getPath ( ) + " not found." ) ; } int count = ( int ) file . length ( ) ; byte [ ] data = new byte [ count ] ; try { FileInputStream inStream = new FileInputStream ( file ) ; inStream . read ( data ) ; inStream . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } script += new String ( data ) ; } public void addText ( String text ) { this . script += text ; } } 	1
package org . apache . tools . tar ; public interface TarConstants { int NAMELEN = 100 ; int MODELEN = 8 ; int UIDLEN = 8 ; int GIDLEN = 8 ; int CHKSUMLEN = 8 ; int SIZELEN = 12 ; int MAGICLEN = 8 ; int MODTIMELEN = 12 ; int UNAMELEN = 32 ; int GNAMELEN = 32 ; int DEVLEN = 8 ; byte LF_OLDNORM = 0 ; byte LF_NORMAL = ( byte ) '0' ; byte LF_LINK = ( byte ) '1' ; byte LF_SYMLINK = ( byte ) '2' ; byte LF_CHR = ( byte ) '3' ; byte LF_BLK = ( byte ) '4' ; byte LF_DIR = ( byte ) '5' ; byte LF_FIFO = ( byte ) '6' ; byte LF_CONTIG = ( byte ) '7' ; String TMAGIC = "ustar" ; String GNU_TMAGIC = "ustar  " ; String GNU_LONGLINK = "././@LongLink" ; byte LF_GNUTYPE_LONGNAME = ( byte ) 'L' ; } 	1
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; public final class ClassConstants extends BaseFilterReader implements ChainableReader { private String queuedData = null ; private static final String JAVA_CLASS_HELPER = "org.apache.tools.ant.filters.util.JavaClassHelper" ; public ClassConstants ( ) { super ( ) ; } public ClassConstants ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { final String clazz = readFully ( ) ; if ( clazz == null ) { ch = - 1 ; } else { final byte [ ] bytes = clazz . getBytes ( ) ; try { final Class javaClassHelper = Class . forName ( JAVA_CLASS_HELPER ) ; if ( javaClassHelper != null ) { final Class [ ] params = { byte [ ] . class } ; final Method getConstants = javaClassHelper . getMethod ( "getConstants" , params ) ; final Object [ ] args = { bytes } ; final StringBuffer sb = ( StringBuffer ) getConstants . invoke ( null , args ) ; if ( sb . length ( ) > 0 ) { queuedData = sb . toString ( ) ; return read ( ) ; } } } catch ( ClassNotFoundException cnfe ) { throw new IOException ( cnfe . getMessage ( ) ) ; } catch ( NoSuchMethodException nsme ) { throw new IOException ( nsme . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new IOException ( iae . getMessage ( ) ) ; } catch ( IllegalArgumentException iarge ) { throw new IOException ( iarge . getMessage ( ) ) ; } catch ( InvocationTargetException ite ) { throw new IOException ( ite . getMessage ( ) ) ; } } } return ch ; } public final Reader chain ( final Reader rdr ) { ClassConstants newFilter = new ClassConstants ( rdr ) ; return newFilter ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Locale ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Touch extends Task { private File file ; private long millis = - 1 ; private String dateTime ; private Vector filesets = new Vector ( ) ; private FileUtils fileUtils ; public Touch ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void setFile ( File file ) { this . file = file ; } public void setMillis ( long millis ) { this . millis = millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { long savedMillis = millis ; if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or " + "a fileset." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to touch directories." ) ; } try { if ( dateTime != null ) { DateFormat df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; } catch ( ParseException pe ) { df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . MEDIUM , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; } catch ( ParseException pe2 ) { throw new BuildException ( pe2 . getMessage ( ) , pe , getLocation ( ) ) ; } } if ( millis < 0 ) { throw new BuildException ( "Date of " + dateTime + " results in negative " + "milliseconds value " + "relative to epoch " + "(January 1, 1970, " + "00:00:00 GMT)." ) ; } } touch ( ) ; } finally { millis = savedMillis ; } } protected void touch ( ) throws BuildException { if ( file != null ) { if ( ! file . exists ( ) ) { log ( "Creating " + file , Project . MSG_INFO ) ; try { fileUtils . createNewFile ( file ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create " + file , ioe , getLocation ( ) ) ; } } } if ( millis >= 0 && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { log ( "modification time of files cannot be set in JDK 1.1" , Project . MSG_WARN ) ; return ; } boolean resetMillis = false ; if ( millis < 0 ) { resetMillis = true ; millis = System . currentTimeMillis ( ) ; } if ( file != null ) { touch ( file ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; File fromDir = fs . getDir ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { touch ( new File ( fromDir , srcFiles [ j ] ) ) ; } for ( int j = 0 ; j < srcDirs . length ; j ++ ) { touch ( new File ( fromDir , srcDirs [ j ] ) ) ; } } if ( resetMillis ) { millis = - 1 ; } } protected void touch ( File file ) throws BuildException { if ( ! file . canWrite ( ) ) { throw new BuildException ( "Can not change modification date of " + "read-only file " + file ) ; } if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return ; } fileUtils . setFileLastModified ( file , millis ) ; } } 	1
package org . apache . tools . zip ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; import java . util . zip . ZipException ; public class ZipEntry extends java . util . zip . ZipEntry implements Cloneable { private static final int PLATFORM_UNIX = 3 ; private static final int PLATFORM_FAT = 0 ; private int internalAttributes = 0 ; private int platform = PLATFORM_FAT ; private long externalAttributes = 0 ; private Vector extraFields = new Vector ( ) ; private String name = null ; public ZipEntry ( String name ) { super ( name ) ; } public ZipEntry ( java . util . zip . ZipEntry entry ) throws ZipException { super ( entry . getName ( ) ) ; setComment ( entry . getComment ( ) ) ; setMethod ( entry . getMethod ( ) ) ; setTime ( entry . getTime ( ) ) ; long size = entry . getSize ( ) ; if ( size > 0 ) { setSize ( size ) ; } long cSize = entry . getCompressedSize ( ) ; if ( cSize > 0 ) { setComprSize ( cSize ) ; } long crc = entry . getCrc ( ) ; if ( crc > 0 ) { setCrc ( crc ) ; } byte [ ] extra = entry . getExtra ( ) ; if ( extra != null ) { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } else { setExtra ( ) ; } } public ZipEntry ( ZipEntry entry ) throws ZipException { this ( ( java . util . zip . ZipEntry ) entry ) ; setInternalAttributes ( entry . getInternalAttributes ( ) ) ; setExternalAttributes ( entry . getExternalAttributes ( ) ) ; setExtraFields ( entry . getExtraFields ( ) ) ; } protected ZipEntry ( ) { super ( "" ) ; } public Object clone ( ) { try { ZipEntry e = ( ZipEntry ) super . clone ( ) ; e . setName ( getName ( ) ) ; e . setComment ( getComment ( ) ) ; e . setMethod ( getMethod ( ) ) ; e . setTime ( getTime ( ) ) ; long size = getSize ( ) ; if ( size > 0 ) { e . setSize ( size ) ; } long cSize = getCompressedSize ( ) ; if ( cSize > 0 ) { e . setComprSize ( cSize ) ; } long crc = getCrc ( ) ; if ( crc > 0 ) { e . setCrc ( crc ) ; } e . extraFields = ( Vector ) extraFields . clone ( ) ; e . setInternalAttributes ( getInternalAttributes ( ) ) ; e . setExternalAttributes ( getExternalAttributes ( ) ) ; e . setExtraFields ( getExtraFields ( ) ) ; return e ; } catch ( Throwable t ) { return null ; } } public int getInternalAttributes ( ) { return internalAttributes ; } public void setInternalAttributes ( int value ) { internalAttributes = value ; } public long getExternalAttributes ( ) { return externalAttributes ; } public void setExternalAttributes ( long value ) { externalAttributes = value ; } public void setUnixMode ( int mode ) { setExternalAttributes ( ( mode << 16 ) | ( ( mode & 0200 ) == 0 ? 1 : 0 ) | ( isDirectory ( ) ? 0x10 : 0 ) ) ; platform = PLATFORM_UNIX ; } public int getUnixMode ( ) { return ( int ) ( ( getExternalAttributes ( ) > > 16 ) & 0xFFFF ) ; } public int getPlatform ( ) { return platform ; } protected void setPlatform ( int platform ) { this . platform = platform ; } public void setExtraFields ( ZipExtraField [ ] fields ) { extraFields . removeAllElements ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { extraFields . addElement ( fields [ i ] ) ; } setExtra ( ) ; } public ZipExtraField [ ] getExtraFields ( ) { ZipExtraField [ ] result = new ZipExtraField [ extraFields . size ( ) ] ; extraFields . copyInto ( result ) ; return result ; } public void addExtraField ( ZipExtraField ze ) { ZipShort type = ze . getHeaderId ( ) ; boolean done = false ; for ( int i = 0 ; ! done && i < extraFields . size ( ) ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . setElementAt ( ze , i ) ; done = true ; } } if ( ! done ) { extraFields . addElement ( ze ) ; } setExtra ( ) ; } public void removeExtraField ( ZipShort type ) { boolean done = false ; for ( int i = 0 ; ! done && i < extraFields . size ( ) ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . removeElementAt ( i ) ; done = true ; } } if ( ! done ) { throw new java . util . NoSuchElementException ( ) ; } setExtra ( ) ; } public void setExtra ( byte [ ] extra ) throws RuntimeException { try { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } protected void setExtra ( ) { super . setExtra ( ExtraFieldUtils . mergeLocalFileDataData ( getExtraFields ( ) ) ) ; } public byte [ ] getLocalFileDataExtra ( ) { byte [ ] extra = getExtra ( ) ; return extra != null ? extra : new byte [ 0 ] ; } public byte [ ] getCentralDirectoryExtra ( ) { return ExtraFieldUtils . mergeCentralDirectoryData ( getExtraFields ( ) ) ; } private Long compressedSize = null ; public void setComprSize ( long size ) { if ( haveSetCompressedSize ( ) ) { performSetCompressedSize ( this , size ) ; } else { compressedSize = new Long ( size ) ; } } public long getCompressedSize ( ) { if ( compressedSize != null ) { return compressedSize . longValue ( ) ; } return super . getCompressedSize ( ) ; } public String getName ( ) { return name == null ? super . getName ( ) : name ; } public boolean isDirectory ( ) { return getName ( ) . endsWith ( "/" ) ; } protected void setName ( String name ) { this . name = name ; } private static Method setCompressedSizeMethod = null ; private static Object lockReflection = new Object ( ) ; private static boolean triedToGetMethod = false ; private static boolean haveSetCompressedSize ( ) { checkSCS ( ) ; return setCompressedSizeMethod != null ; } private static void performSetCompressedSize ( ZipEntry ze , long size ) { Long [ ] s = { new Long ( size ) } ; try { setCompressedSizeMethod . invoke ( ze , s ) ; } catch ( InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new RuntimeException ( "Exception setting the compressed size " + "of " + ze + ": " + nested . getMessage ( ) ) ; } catch ( Throwable other ) { throw new RuntimeException ( "Exception setting the compressed size " + "of " + ze + ": " + other . getMessage ( ) ) ; } } private static void checkSCS ( ) { if ( ! triedToGetMethod ) { synchronized ( lockReflection ) { triedToGetMethod = true ; try { setCompressedSizeMethod = java . util . zip . ZipEntry . class . getMethod ( "setCompressedSize" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { } } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; import java . util . Date ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Get extends Task { private URL source ; private File dest ; private boolean verbose = false ; private boolean useTimestamp = false ; private boolean ignoreErrors = false ; private String uname = null ; private String pword = null ; public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( dest == null ) { throw new BuildException ( "dest attribute is required" , getLocation ( ) ) ; } if ( dest . exists ( ) && dest . isDirectory ( ) ) { throw new BuildException ( "The specified destination is a directory" , getLocation ( ) ) ; } if ( dest . exists ( ) && ! dest . canWrite ( ) ) { throw new BuildException ( "Can't write to " + dest . getAbsolutePath ( ) , getLocation ( ) ) ; } try { log ( "Getting: " + source ) ; long timestamp = 0 ; boolean hasTimestamp = false ; if ( useTimestamp && dest . exists ( ) ) { timestamp = dest . lastModified ( ) ; if ( verbose ) { Date t = new Date ( timestamp ) ; log ( "local file date : " + t . toString ( ) ) ; } hasTimestamp = true ; } URLConnection connection = source . openConnection ( ) ; if ( useTimestamp && hasTimestamp ) { connection . setIfModifiedSince ( timestamp ) ; } if ( uname != null || pword != null ) { String up = uname + ":" + pword ; String encoding ; try { Object encoder = Class . forName ( "sun.misc.BASE64Encoder" ) . newInstance ( ) ; encoding = ( String ) encoder . getClass ( ) . getMethod ( "encode" , new Class [ ] { byte [ ] . class } ) . invoke ( encoder , new Object [ ] { up . getBytes ( ) } ) ; } catch ( Exception ex ) { Base64Converter encoder = new Base64Converter ( ) ; encoding = encoder . encode ( up . getBytes ( ) ) ; } connection . setRequestProperty ( "Authorization" , "Basic " + encoding ) ; } connection . connect ( ) ; if ( connection instanceof HttpURLConnection ) { HttpURLConnection httpConnection = ( HttpURLConnection ) connection ; if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_NOT_MODIFIED ) { log ( "Not modified - so not downloaded" ) ; return ; } if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_UNAUTHORIZED ) { String message = "HTTP Authorization failure" ; if ( ignoreErrors ) { log ( message , Project . MSG_WARN ) ; return ; } else { throw new BuildException ( message ) ; } } } InputStream is = null ; for ( int i = 0 ; i < 3 ; i ++ ) { try { is = connection . getInputStream ( ) ; break ; } catch ( IOException ex ) { log ( "Error opening connection " + ex ) ; } } if ( is == null ) { log ( "Can't get " + source + " to " + dest ) ; if ( ignoreErrors ) { return ; } throw new BuildException ( "Can't get " + source + " to " + dest , getLocation ( ) ) ; } FileOutputStream fos = new FileOutputStream ( dest ) ; boolean finished = false ; try { byte [ ] buffer = new byte [ 100 * 1024 ] ; int length ; int dots = 0 ; while ( ( length = is . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; if ( verbose ) { System . out . print ( "." ) ; if ( dots ++ > 50 ) { System . out . flush ( ) ; dots = 0 ; } } } if ( verbose ) { System . out . println ( ) ; } finished = true ; } finally { if ( fos != null ) { fos . close ( ) ; } is . close ( ) ; if ( ! finished ) { dest . delete ( ) ; } } if ( useTimestamp ) { long remoteTimestamp = connection . getLastModified ( ) ; if ( verbose ) { Date t = new Date ( remoteTimestamp ) ; log ( "last modified = " + t . toString ( ) + ( ( remoteTimestamp == 0 ) ? " - using current time instead" : "" ) ) ; } if ( remoteTimestamp != 0 ) { FileUtils . newFileUtils ( ) . setFileLastModified ( dest , remoteTimestamp ) ; } } } catch ( IOException ioe ) { log ( "Error getting " + source + " to " + dest ) ; if ( ignoreErrors ) { return ; } throw new BuildException ( ioe , getLocation ( ) ) ; } } public void setSrc ( URL u ) { this . source = u ; } public void setDest ( File dest ) { this . dest = dest ; } public void setVerbose ( boolean v ) { verbose = v ; } public void setIgnoreErrors ( boolean v ) { ignoreErrors = v ; } public void setUseTimestamp ( boolean v ) { if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { useTimestamp = v ; } } public void setUsername ( String u ) { this . uname = u ; } public void setPassword ( String p ) { this . pword = p ; } private static class Base64Converter { public final char [ ] alphabet = { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' , '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '/' } ; public String encode ( String s ) { return encode ( s . getBytes ( ) ) ; } public String encode ( byte [ ] octetString ) { int bits24 ; int bits6 ; char [ ] out = new char [ ( ( octetString . length - 1 ) / 3 + 1 ) * 4 ] ; int outIndex = 0 ; int i = 0 ; while ( ( i + 3 ) <= octetString . length ) { bits24 = ( octetString [ i ++ ] & 0xFF ) << 16 ; bits24 |= ( octetString [ i ++ ] & 0xFF ) << 8 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x00000FC0 ) > > 6 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x0000003F ) ; out [ outIndex ++ ] = alphabet [ bits6 ] ; } if ( octetString . length - i == 2 ) { bits24 = ( octetString [ i ] & 0xFF ) << 16 ; bits24 |= ( octetString [ i + 1 ] & 0xFF ) << 8 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x00000FC0 ) > > 6 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; out [ outIndex ++ ] = '=' ; } else if ( octetString . length - i == 1 ) { bits24 = ( octetString [ i ] & 0xFF ) << 16 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = alphabet [ bits6 ] ; out [ outIndex ++ ] = '=' ; out [ outIndex ++ ] = '=' ; } return new String ( out ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . GZIPInputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . bzip2 . CBZip2InputStream ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarInputStream ; public class Untar extends Expand { private UntarCompressionMethod compression = new UntarCompressionMethod ( ) ; public void setCompression ( UntarCompressionMethod method ) { compression = method ; } public void setEncoding ( String encoding ) { throw new BuildException ( "The " + getTaskName ( ) + " task doesn't support the encoding" + " attribute" , getLocation ( ) ) ; } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { TarInputStream tis = null ; try { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; tis = new TarInputStream ( compression . decompress ( srcF , new BufferedInputStream ( new FileInputStream ( srcF ) ) ) ) ; TarEntry te = null ; while ( ( te = tis . getNextEntry ( ) ) != null ) { extractFile ( fileUtils , srcF , dir , tis , te . getName ( ) , te . getModTime ( ) , te . isDirectory ( ) ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe , getLocation ( ) ) ; } finally { if ( tis != null ) { try { tis . close ( ) ; } catch ( IOException e ) { } } } } public static final class UntarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public UntarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } private InputStream decompress ( final File file , final InputStream istream ) throws IOException , BuildException { final String value = getValue ( ) ; if ( GZIP . equals ( value ) ) { return new GZIPInputStream ( istream ) ; } else { if ( BZIP2 . equals ( value ) ) { final char [ ] magic = new char [ ] { 'B' , 'Z' } ; for ( int i = 0 ; i < magic . length ; i ++ ) { if ( istream . read ( ) != magic [ i ] ) { throw new BuildException ( "Invalid bz2 file." + file . toString ( ) ) ; } } return new CBZip2InputStream ( istream ) ; } } return istream ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . IOException ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class ManifestTask extends Task { private Manifest nestedManifest = new Manifest ( ) ; private File manifestFile ; private Mode mode ; private String encoding ; public static class Mode extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "update" , "replace" } ; } } public ManifestTask ( ) { mode = new Mode ( ) ; mode . setValue ( "replace" ) ; } public void addConfiguredSection ( Manifest . Section section ) throws ManifestException { nestedManifest . addConfiguredSection ( section ) ; } public void addConfiguredAttribute ( Manifest . Attribute attribute ) throws ManifestException { nestedManifest . addConfiguredAttribute ( attribute ) ; } public void setFile ( File f ) { manifestFile = f ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setMode ( Mode m ) { mode = m ; } public void execute ( ) throws BuildException { if ( manifestFile == null ) { throw new BuildException ( "the file attribute is required" ) ; } Manifest toWrite = Manifest . getDefaultManifest ( ) ; Manifest current = null ; BuildException error = null ; if ( manifestFile . exists ( ) ) { FileInputStream fis = null ; InputStreamReader isr = null ; try { fis = new FileInputStream ( manifestFile ) ; if ( encoding == null ) { isr = new InputStreamReader ( fis , "UTF-8" ) ; } else { isr = new InputStreamReader ( fis , encoding ) ; } current = new Manifest ( isr ) ; } catch ( ManifestException m ) { error = new BuildException ( "Existing manifest " + manifestFile + " is invalid" , m , getLocation ( ) ) ; } catch ( IOException e ) { error = new BuildException ( "Failed to read " + manifestFile , e , getLocation ( ) ) ; } finally { if ( isr != null ) { try { isr . close ( ) ; } catch ( IOException e ) { } } } } try { if ( mode . getValue ( ) . equals ( "update" ) && manifestFile . exists ( ) ) { if ( current != null ) { toWrite . merge ( current ) ; } else if ( error != null ) { throw error ; } } toWrite . merge ( nestedManifest ) ; } catch ( ManifestException m ) { throw new BuildException ( "Manifest is invalid" , m , getLocation ( ) ) ; } if ( toWrite . equals ( current ) ) { log ( "Manifest has not changed, do not recreate" , Project . MSG_VERBOSE ) ; return ; } PrintWriter w = null ; try { FileOutputStream fos = new FileOutputStream ( manifestFile ) ; OutputStreamWriter osw = new OutputStreamWriter ( fos , "UTF-8" ) ; w = new PrintWriter ( osw ) ; toWrite . write ( w ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to write " + manifestFile , e , getLocation ( ) ) ; } finally { if ( w != null ) { w . close ( ) ; } } } } 	1
package org . apache . tools . tar ; import java . io . FilterOutputStream ; import java . io . OutputStream ; import java . io . IOException ; public class TarOutputStream extends FilterOutputStream { public static final int LONGFILE_ERROR = 0 ; public static final int LONGFILE_TRUNCATE = 1 ; public static final int LONGFILE_GNU = 2 ; protected boolean debug ; protected int currSize ; protected int currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { this . finish ( ) ; this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = ( int ) entry . getSize ( ) ; } } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	1
package org . apache . tools . zip ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . io . UnsupportedEncodingException ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . zip . Inflater ; import java . util . zip . InflaterInputStream ; import java . util . zip . ZipException ; public class ZipFile { private Hashtable entries = new Hashtable ( ) ; private Hashtable nameMap = new Hashtable ( ) ; private Hashtable dataOffsets = new Hashtable ( ) ; private String encoding = null ; private RandomAccessFile archive ; public ZipFile ( File f ) throws IOException { this ( f , null ) ; } public ZipFile ( String name ) throws IOException { this ( new File ( name ) , null ) ; } public ZipFile ( String name , String encoding ) throws IOException { this ( new File ( name ) , encoding ) ; } public ZipFile ( File f , String encoding ) throws IOException { this . encoding = encoding ; archive = new RandomAccessFile ( f , "r" ) ; populateFromCentralDirectory ( ) ; resolveLocalFileHeaderData ( ) ; } public String getEncoding ( ) { return encoding ; } public void close ( ) throws IOException { archive . close ( ) ; } public Enumeration getEntries ( ) { return entries . keys ( ) ; } public ZipEntry getEntry ( String name ) { return ( ZipEntry ) nameMap . get ( name ) ; } public InputStream getInputStream ( ZipEntry ze ) throws IOException , ZipException { Long start = ( Long ) dataOffsets . get ( ze ) ; if ( start == null ) { return null ; } BoundedInputStream bis = new BoundedInputStream ( start . longValue ( ) , ze . getCompressedSize ( ) ) ; switch ( ze . getMethod ( ) ) { case ZipEntry . STORED : return bis ; case ZipEntry . DEFLATED : bis . addDummy ( ) ; return new InflaterInputStream ( bis , new Inflater ( true ) ) ; default : throw new ZipException ( "Found unsupported compression method " + ze . getMethod ( ) ) ; } } private static final int CFH_LEN = 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 4 + 4 ; private void populateFromCentralDirectory ( ) throws IOException { positionAtCentralDirectory ( ) ; byte [ ] cfh = new byte [ CFH_LEN ] ; byte [ ] signatureBytes = new byte [ 4 ] ; archive . readFully ( signatureBytes ) ; ZipLong sig = new ZipLong ( signatureBytes ) ; while ( sig . equals ( ZipOutputStream . CFH_SIG ) ) { archive . readFully ( cfh ) ; int off = 0 ; ZipEntry ze = new ZipEntry ( ) ; ZipShort versionMadeBy = new ZipShort ( cfh , off ) ; off += 2 ; ze . setPlatform ( ( versionMadeBy . getValue ( ) > > 8 ) & 0x0F ) ; off += 4 ; ze . setMethod ( ( new ZipShort ( cfh , off ) ) . getValue ( ) ) ; off += 2 ; ze . setTime ( fromDosTime ( new ZipLong ( cfh , off ) ) . getTime ( ) ) ; off += 4 ; ze . setCrc ( ( new ZipLong ( cfh , off ) ) . getValue ( ) ) ; off += 4 ; ze . setCompressedSize ( ( new ZipLong ( cfh , off ) ) . getValue ( ) ) ; off += 4 ; ze . setSize ( ( new ZipLong ( cfh , off ) ) . getValue ( ) ) ; off += 4 ; int fileNameLen = ( new ZipShort ( cfh , off ) ) . getValue ( ) ; off += 2 ; int extraLen = ( new ZipShort ( cfh , off ) ) . getValue ( ) ; off += 2 ; int commentLen = ( new ZipShort ( cfh , off ) ) . getValue ( ) ; off += 2 ; off += 2 ; ze . setInternalAttributes ( ( new ZipShort ( cfh , off ) ) . getValue ( ) ) ; off += 2 ; ze . setExternalAttributes ( ( new ZipLong ( cfh , off ) ) . getValue ( ) ) ; off += 4 ; entries . put ( ze , new Long ( ( new ZipLong ( cfh , off ) ) . getValue ( ) ) ) ; byte [ ] fileName = new byte [ fileNameLen ] ; archive . readFully ( fileName ) ; ze . setName ( getString ( fileName ) ) ; nameMap . put ( ze . getName ( ) , ze ) ; archive . skipBytes ( extraLen ) ; byte [ ] comment = new byte [ commentLen ] ; archive . readFully ( comment ) ; ze . setComment ( getString ( comment ) ) ; archive . readFully ( signatureBytes ) ; sig = new ZipLong ( signatureBytes ) ; } } private static final int MIN_EOCD_SIZE = 4 + 2 + + 2 + + 2 + + 2 + 4 + + + 4 + 2 ; private static final int CFD_LOCATOR_OFFSET = 4 + 2 + + 2 + + 2 + + 2 + 4 ; private void positionAtCentralDirectory ( ) throws IOException { long off = archive . length ( ) - MIN_EOCD_SIZE ; archive . seek ( off ) ; byte [ ] sig = ZipOutputStream . EOCD_SIG . getBytes ( ) ; int curr = archive . read ( ) ; boolean found = false ; while ( curr != - 1 ) { if ( curr == sig [ 0 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 1 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 2 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 3 ] ) { found = true ; break ; } } } } archive . seek ( -- off ) ; curr = archive . read ( ) ; } if ( ! found ) { throw new ZipException ( "archive is not a ZIP archive" ) ; } archive . seek ( off + CFD_LOCATOR_OFFSET ) ; byte [ ] cfdOffset = new byte [ 4 ] ; archive . readFully ( cfdOffset ) ; archive . seek ( ( new ZipLong ( cfdOffset ) ) . getValue ( ) ) ; } private static final long LFH_OFFSET_FOR_FILENAME_LENGTH = 4 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 ; private void resolveLocalFileHeaderData ( ) throws IOException { Enumeration e = getEntries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; long offset = ( ( Long ) entries . get ( ze ) ) . longValue ( ) ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ 2 ] ; archive . readFully ( b ) ; int fileNameLen = ( new ZipShort ( b ) ) . getValue ( ) ; archive . readFully ( b ) ; int extraFieldLen = ( new ZipShort ( b ) ) . getValue ( ) ; archive . skipBytes ( fileNameLen ) ; byte [ ] localExtraData = new byte [ extraFieldLen ] ; archive . readFully ( localExtraData ) ; ze . setExtra ( localExtraData ) ; dataOffsets . put ( ze , new Long ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH + 2 + 2 + fileNameLen + extraFieldLen ) ) ; } } protected static Date fromDosTime ( ZipLong l ) { long dosTime = l . getValue ( ) ; Calendar cal = Calendar . getInstance ( ) ; cal . set ( Calendar . YEAR , ( int ) ( ( dosTime > > 25 ) & 0x7f ) + 1980 ) ; cal . set ( Calendar . MONTH , ( int ) ( ( dosTime > > 21 ) & 0x0f ) - 1 ) ; cal . set ( Calendar . DATE , ( int ) ( dosTime > > 16 ) & 0x1f ) ; cal . set ( Calendar . HOUR_OF_DAY , ( int ) ( dosTime > > 11 ) & 0x1f ) ; cal . set ( Calendar . MINUTE , ( int ) ( dosTime > > 5 ) & 0x3f ) ; cal . set ( Calendar . SECOND , ( int ) ( dosTime << 1 ) & 0x3e ) ; return cal . getTime ( ) ; } protected String getString ( byte [ ] bytes ) throws ZipException { if ( encoding == null ) { return new String ( bytes ) ; } else { try { return new String ( bytes , encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } private class BoundedInputStream extends InputStream { private long remaining ; private long loc ; private boolean addDummyByte = false ; BoundedInputStream ( long start , long remaining ) { this . remaining = remaining ; loc = start ; } public int read ( ) throws IOException { if ( remaining -- <= 0 ) { if ( addDummyByte ) { addDummyByte = false ; return 0 ; } return - 1 ; } synchronized ( archive ) { archive . seek ( loc ++ ) ; return archive . read ( ) ; } } public int read ( byte [ ] b , int off , int len ) throws IOException { if ( remaining <= 0 ) { if ( addDummyByte ) { addDummyByte = false ; b [ off ] = 0 ; return 1 ; } return - 1 ; } if ( len <= 0 ) { return 0 ; } if ( len > remaining ) { len = ( int ) remaining ; } int ret = - 1 ; synchronized ( archive ) { archive . seek ( loc ) ; ret = archive . read ( b , off , len ) ; } if ( ret > 0 ) { loc += ret ; remaining -= ret ; } return ret ; } void addDummy ( ) { addDummyByte = true ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Recorder extends Task { private String filename = null ; private Boolean append = null ; private Boolean start = null ; private int loglevel = - 1 ; private boolean emacsMode = false ; private static Hashtable recorderEntries = new Hashtable ( ) ; public void setName ( String fname ) { filename = fname ; } public void setAction ( ActionChoices action ) { if ( action . getValue ( ) . equalsIgnoreCase ( "start" ) ) { start = Boolean . TRUE ; } else { start = Boolean . FALSE ; } } public void setAppend ( boolean append ) { this . append = new Boolean ( append ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void setLoglevel ( VerbosityLevelChoices level ) { String lev = level . getValue ( ) ; if ( lev . equalsIgnoreCase ( "error" ) ) { loglevel = Project . MSG_ERR ; } else if ( lev . equalsIgnoreCase ( "warn" ) ) { loglevel = Project . MSG_WARN ; } else if ( lev . equalsIgnoreCase ( "info" ) ) { loglevel = Project . MSG_INFO ; } else if ( lev . equalsIgnoreCase ( "verbose" ) ) { loglevel = Project . MSG_VERBOSE ; } else if ( lev . equalsIgnoreCase ( "debug" ) ) { loglevel = Project . MSG_DEBUG ; } } public void execute ( ) throws BuildException { if ( filename == null ) { throw new BuildException ( "No filename specified" ) ; } getProject ( ) . log ( "setting a recorder for name " + filename , Project . MSG_DEBUG ) ; RecorderEntry recorder = getRecorder ( filename , getProject ( ) ) ; recorder . setMessageOutputLevel ( loglevel ) ; recorder . setRecordState ( start ) ; recorder . setEmacsMode ( emacsMode ) ; } public static class ActionChoices extends EnumeratedAttribute { private static final String [ ] values = { "start" , "stop" } ; public String [ ] getValues ( ) { return values ; } } public static class VerbosityLevelChoices extends EnumeratedAttribute { private static final String [ ] values = { "error" , "warn" , "info" , "verbose" , "debug" } ; public String [ ] getValues ( ) { return values ; } } protected RecorderEntry getRecorder ( String name , Project proj ) throws BuildException { Object o = recorderEntries . get ( name ) ; RecorderEntry entry ; if ( o == null ) { try { entry = new RecorderEntry ( name ) ; PrintStream out = null ; if ( append == null ) { out = new PrintStream ( new FileOutputStream ( name ) ) ; } else { out = new PrintStream ( new FileOutputStream ( name , append . booleanValue ( ) ) ) ; } entry . setErrorPrintStream ( out ) ; entry . setOutputPrintStream ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Problems creating a recorder entry" , ioe ) ; } proj . addBuildListener ( entry ) ; recorderEntries . put ( name , entry ) ; } else { entry = ( RecorderEntry ) o ; } return entry ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; import java . util . List ; import java . util . ArrayList ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . util . StringUtils ; public class Parallel extends Task implements TaskContainer { public static class TaskList implements TaskContainer { private List tasks = new ArrayList ( ) ; public void addTask ( Task nestedTask ) throws BuildException { tasks . add ( nestedTask ) ; } } private Vector nestedTasks = new Vector ( ) ; private final Object semaphore = new Object ( ) ; private int numThreads = 0 ; private int numThreadsPerProcessor = 0 ; private long timeout ; private volatile boolean stillRunning ; private boolean timedOut ; private boolean failOnAny ; private TaskList daemonTasks ; private StringBuffer exceptionMessage ; private int numExceptions = 0 ; private Throwable firstException ; private Location firstLocation ; public void addDaemons ( TaskList daemonTasks ) { if ( this . daemonTasks != null ) { throw new BuildException ( "Only one daemon group is supported" ) ; } this . daemonTasks = daemonTasks ; } public void setPollInterval ( int pollInterval ) { } public void setFailOnAny ( boolean failOnAny ) { this . failOnAny = failOnAny ; } public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void setThreadsPerProcessor ( int numThreadsPerProcessor ) { this . numThreadsPerProcessor = numThreadsPerProcessor ; } public void setThreadCount ( int numThreads ) { this . numThreads = numThreads ; } public void setTimeout ( long timeout ) { this . timeout = timeout ; } public void execute ( ) throws BuildException { updateThreadCounts ( ) ; if ( numThreads == 0 ) { numThreads = nestedTasks . size ( ) ; } spinThreads ( ) ; } private void updateThreadCounts ( ) { if ( numThreadsPerProcessor != 0 ) { int numProcessors = getNumProcessors ( ) ; if ( numProcessors != 0 ) { numThreads = numProcessors * numThreadsPerProcessor ; } } } private void processExceptions ( TaskRunnable [ ] runnables ) { if ( runnables == null ) { return ; } for ( int i = 0 ; i < runnables . length ; ++ i ) { Throwable t = runnables [ i ] . getException ( ) ; if ( t != null ) { numExceptions ++ ; if ( firstException == null ) { firstException = t ; } if ( t instanceof BuildException && firstLocation == Location . UNKNOWN_LOCATION ) { firstLocation = ( ( BuildException ) t ) . getLocation ( ) ; } exceptionMessage . append ( StringUtils . LINE_SEP ) ; exceptionMessage . append ( t . getMessage ( ) ) ; } } } private void spinThreads ( ) throws BuildException { final int numTasks = nestedTasks . size ( ) ; TaskRunnable [ ] runnables = new TaskRunnable [ numTasks ] ; stillRunning = true ; timedOut = false ; int threadNumber = 0 ; for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; threadNumber ++ ) { Task nestedTask = ( Task ) e . nextElement ( ) ; runnables [ threadNumber ] = new TaskRunnable ( nestedTask ) ; } final int maxRunning = numTasks < numThreads ? numTasks : numThreads ; TaskRunnable [ ] running = new TaskRunnable [ maxRunning ] ; threadNumber = 0 ; ThreadGroup group = new ThreadGroup ( "parallel" ) ; TaskRunnable [ ] daemons = null ; if ( daemonTasks != null && daemonTasks . tasks . size ( ) != 0 ) { daemons = new TaskRunnable [ daemonTasks . tasks . size ( ) ] ; } synchronized ( semaphore ) { if ( daemons != null ) { for ( int i = 0 ; i < daemons . length ; ++ i ) { daemons [ i ] = new TaskRunnable ( ( Task ) daemonTasks . tasks . get ( i ) ) ; Thread daemonThread = new Thread ( group , daemons [ i ] ) ; daemonThread . setDaemon ( true ) ; daemonThread . start ( ) ; } } for ( int i = 0 ; i < maxRunning ; ++ i ) { running [ i ] = runnables [ threadNumber ++ ] ; Thread thread = new Thread ( group , running [ i ] ) ; thread . start ( ) ; } if ( timeout != 0 ) { Thread timeoutThread = new Thread ( ) { public synchronized void run ( ) { try { wait ( timeout ) ; synchronized ( semaphore ) { stillRunning = false ; timedOut = true ; semaphore . notifyAll ( ) ; } } catch ( InterruptedException e ) { } } } ; timeoutThread . start ( ) ; } outer : while ( threadNumber < numTasks && stillRunning ) { for ( int i = 0 ; i < maxRunning ; i ++ ) { if ( running [ i ] == null || running [ i ] . finished ) { running [ i ] = runnables [ threadNumber ++ ] ; Thread thread = new Thread ( group , running [ i ] ) ; thread . start ( ) ; continue outer ; } } try { semaphore . wait ( ) ; } catch ( InterruptedException ie ) { } } outer2 : while ( stillRunning ) { for ( int i = 0 ; i < maxRunning ; ++ i ) { if ( running [ i ] != null && ! running [ i ] . finished ) { try { semaphore . wait ( ) ; } catch ( InterruptedException ie ) { } continue outer2 ; } } stillRunning = false ; } } if ( timedOut ) { throw new BuildException ( "Parallel execution timed out" ) ; } exceptionMessage = new StringBuffer ( ) ; numExceptions = 0 ; firstException = null ; firstLocation = Location . UNKNOWN_LOCATION ; processExceptions ( daemons ) ; processExceptions ( runnables ) ; if ( numExceptions == 1 ) { if ( firstException instanceof BuildException ) { throw ( BuildException ) firstException ; } else { throw new BuildException ( firstException ) ; } } else if ( numExceptions > 1 ) { throw new BuildException ( exceptionMessage . toString ( ) , firstLocation ) ; } } private int getNumProcessors ( ) { try { Class [ ] paramTypes = { } ; Method availableProcessors = Runtime . class . getMethod ( "availableProcessors" , paramTypes ) ; Object [ ] args = { } ; Integer ret = ( Integer ) availableProcessors . invoke ( Runtime . getRuntime ( ) , args ) ; return ret . intValue ( ) ; } catch ( Exception e ) { return 0 ; } } private class TaskRunnable implements Runnable { private Throwable exception ; private Task task ; boolean finished ; TaskRunnable ( Task task ) { this . task = task ; } public void run ( ) { try { task . perform ( ) ; } catch ( Throwable t ) { exception = t ; } finally { synchronized ( semaphore ) { finished = true ; if ( failOnAny ) { stillRunning = false ; } semaphore . notifyAll ( ) ; } } } public Throwable getException ( ) { return exception ; } } } 	1
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public class Environment { protected Vector variables ; public static class Variable { private String key , value ; public Variable ( ) { super ( ) ; } public void setKey ( String key ) { this . key = key ; } public void setValue ( String value ) { this . value = value ; } public String getKey ( ) { return this . key ; } public String getValue ( ) { return this . value ; } public void setPath ( Path path ) { this . value = path . toString ( ) ; } public void setFile ( java . io . File file ) { this . value = file . getAbsolutePath ( ) ; } public String getContent ( ) throws BuildException { if ( key == null || value == null ) { throw new BuildException ( "key and value must be specified " + "for environment variables." ) ; } StringBuffer sb = new StringBuffer ( key . trim ( ) ) ; sb . append ( "=" ) . append ( value . trim ( ) ) ; return sb . toString ( ) ; } } public Environment ( ) { variables = new Vector ( ) ; } public void addVariable ( Variable var ) { variables . addElement ( var ) ; } public String [ ] getVariables ( ) throws BuildException { if ( variables . size ( ) == 0 ) { return null ; } String [ ] result = new String [ variables . size ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( ( Variable ) variables . elementAt ( i ) ) . getContent ( ) ; } return result ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Date ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; public class DependSet extends MatchingTask { private Vector sourceFileSets = new Vector ( ) ; private Vector sourceFileLists = new Vector ( ) ; private Vector targetFileSets = new Vector ( ) ; private Vector targetFileLists = new Vector ( ) ; public DependSet ( ) { } public void addSrcfileset ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public void addSrcfilelist ( FileList fl ) { sourceFileLists . addElement ( fl ) ; } public void addTargetfileset ( FileSet fs ) { targetFileSets . addElement ( fs ) ; } public void addTargetfilelist ( FileList fl ) { targetFileLists . addElement ( fl ) ; } public void execute ( ) throws BuildException { if ( ( sourceFileSets . size ( ) == 0 ) && ( sourceFileLists . size ( ) == 0 ) ) { throw new BuildException ( "At least one <srcfileset> or <srcfilelist>" + " element must be set" ) ; } if ( ( targetFileSets . size ( ) == 0 ) && ( targetFileLists . size ( ) == 0 ) ) { throw new BuildException ( "At least one <targetfileset> or" + " <targetfilelist> element must be set" ) ; } long now = ( new Date ( ) ) . getTime ( ) ; if ( Os . isFamily ( "windows" ) ) { now += 2000 ; } Vector allTargets = new Vector ( ) ; long oldestTargetTime = 0 ; File oldestTarget = null ; Enumeration enumTargetSets = targetFileSets . elements ( ) ; while ( enumTargetSets . hasMoreElements ( ) ) { FileSet targetFS = ( FileSet ) enumTargetSets . nextElement ( ) ; if ( ! targetFS . getDir ( getProject ( ) ) . exists ( ) ) { continue ; } DirectoryScanner targetDS = targetFS . getDirectoryScanner ( getProject ( ) ) ; String [ ] targetFiles = targetDS . getIncludedFiles ( ) ; for ( int i = 0 ; i < targetFiles . length ; i ++ ) { File dest = new File ( targetFS . getDir ( getProject ( ) ) , targetFiles [ i ] ) ; allTargets . addElement ( dest ) ; if ( dest . lastModified ( ) > now ) { log ( "Warning: " + targetFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( oldestTarget == null || dest . lastModified ( ) < oldestTargetTime ) { oldestTargetTime = dest . lastModified ( ) ; oldestTarget = dest ; } } } boolean upToDate = true ; Enumeration enumTargetLists = targetFileLists . elements ( ) ; while ( enumTargetLists . hasMoreElements ( ) ) { FileList targetFL = ( FileList ) enumTargetLists . nextElement ( ) ; String [ ] targetFiles = targetFL . getFiles ( getProject ( ) ) ; for ( int i = 0 ; i < targetFiles . length ; i ++ ) { File dest = new File ( targetFL . getDir ( getProject ( ) ) , targetFiles [ i ] ) ; if ( ! dest . exists ( ) ) { log ( targetFiles [ i ] + " does not exist." , Project . MSG_VERBOSE ) ; upToDate = false ; continue ; } else { allTargets . addElement ( dest ) ; } if ( dest . lastModified ( ) > now ) { log ( "Warning: " + targetFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( oldestTarget == null || dest . lastModified ( ) < oldestTargetTime ) { oldestTargetTime = dest . lastModified ( ) ; oldestTarget = dest ; } } } if ( oldestTarget != null ) { log ( oldestTarget + " is oldest target file" , Project . MSG_VERBOSE ) ; } else { upToDate = false ; } if ( upToDate ) { Enumeration enumSourceLists = sourceFileLists . elements ( ) ; while ( upToDate && enumSourceLists . hasMoreElements ( ) ) { FileList sourceFL = ( FileList ) enumSourceLists . nextElement ( ) ; String [ ] sourceFiles = sourceFL . getFiles ( getProject ( ) ) ; for ( int i = 0 ; upToDate && i < sourceFiles . length ; i ++ ) { File src = new File ( sourceFL . getDir ( getProject ( ) ) , sourceFiles [ i ] ) ; if ( src . lastModified ( ) > now ) { log ( "Warning: " + sourceFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( ! src . exists ( ) ) { log ( sourceFiles [ i ] + " does not exist." , Project . MSG_VERBOSE ) ; upToDate = false ; break ; } if ( src . lastModified ( ) > oldestTargetTime ) { upToDate = false ; log ( oldestTarget + " is out of date with respect to " + sourceFiles [ i ] , Project . MSG_VERBOSE ) ; } } } } if ( upToDate ) { Enumeration enumSourceSets = sourceFileSets . elements ( ) ; while ( upToDate && enumSourceSets . hasMoreElements ( ) ) { FileSet sourceFS = ( FileSet ) enumSourceSets . nextElement ( ) ; DirectoryScanner sourceDS = sourceFS . getDirectoryScanner ( getProject ( ) ) ; String [ ] sourceFiles = sourceDS . getIncludedFiles ( ) ; for ( int i = 0 ; upToDate && i < sourceFiles . length ; i ++ ) { File src = new File ( sourceFS . getDir ( getProject ( ) ) , sourceFiles [ i ] ) ; if ( src . lastModified ( ) > now ) { log ( "Warning: " + sourceFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( src . lastModified ( ) > oldestTargetTime ) { upToDate = false ; log ( oldestTarget + " is out of date with respect to " + sourceFiles [ i ] , Project . MSG_VERBOSE ) ; } } } } if ( ! upToDate ) { log ( "Deleting all target files. " , Project . MSG_VERBOSE ) ; for ( Enumeration e = allTargets . elements ( ) ; e . hasMoreElements ( ) ; ) { File fileToRemove = ( File ) e . nextElement ( ) ; log ( "Deleting file " + fileToRemove . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; fileToRemove . delete ( ) ; } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Available extends Task implements Condition { private String property ; private String classname ; private String file ; private Path filepath ; private String resource ; private FileDir type ; private Path classpath ; private AntClassLoader loader ; private String value = "true" ; private boolean isTask = false ; private boolean ignoreSystemclasses = false ; public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setFilepath ( Path filepath ) { createFilepath ( ) . append ( filepath ) ; } public Path createFilepath ( ) { if ( this . filepath == null ) { this . filepath = new Path ( getProject ( ) ) ; } return this . filepath . createPath ( ) ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public void setClassname ( String classname ) { if ( ! "" . equals ( classname ) ) { this . classname = classname ; } } public void setFile ( File file ) { this . file = FileUtils . newFileUtils ( ) . removeLeadingPath ( getProject ( ) . getBaseDir ( ) , file ) ; } public void setResource ( String resource ) { this . resource = resource ; } public void setType ( String type ) { log ( "DEPRECATED - The setType(String) method has been deprecated." + " Use setType(Available.FileDir) instead." ) ; this . type = new FileDir ( ) ; this . type . setValue ( type ) ; } public void setType ( FileDir type ) { this . type = type ; } public void setIgnoresystemclasses ( boolean ignore ) { this . ignoreSystemclasses = ignore ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required" , getLocation ( ) ) ; } isTask = true ; try { if ( eval ( ) ) { String oldvalue = getProject ( ) . getProperty ( property ) ; if ( null != oldvalue && ! oldvalue . equals ( value ) ) { log ( "DEPRECATED - <available> used to override an existing" + " property." + StringUtils . LINE_SEP + "  Build file should not reuse the same property" + " name for different values." ) ; } getProject ( ) . setProperty ( property , value ) ; } } finally { isTask = false ; } } public boolean eval ( ) throws BuildException { if ( classname == null && file == null && resource == null ) { throw new BuildException ( "At least one of (classname|file|" + "resource) is required" , getLocation ( ) ) ; } if ( type != null ) { if ( file == null ) { throw new BuildException ( "The type attribute is only valid " + "when specifying the file " + "attribute." , getLocation ( ) ) ; } } if ( classpath != null ) { classpath . setProject ( getProject ( ) ) ; this . loader = getProject ( ) . createClassLoader ( classpath ) ; } String appendix = "" ; if ( isTask ) { appendix = " to set property " + property ; } else { setTaskName ( "available" ) ; } if ( ( classname != null ) && ! checkClass ( classname ) ) { log ( "Unable to load class " + classname + appendix , Project . MSG_VERBOSE ) ; return false ; } if ( ( file != null ) && ! checkFile ( ) ) { if ( type != null ) { log ( "Unable to find " + type + " " + file + appendix , Project . MSG_VERBOSE ) ; } else { log ( "Unable to find " + file + appendix , Project . MSG_VERBOSE ) ; } return false ; } if ( ( resource != null ) && ! checkResource ( resource ) ) { log ( "Unable to load resource " + resource + appendix , Project . MSG_VERBOSE ) ; return false ; } if ( loader != null ) { loader . cleanup ( ) ; loader = null ; } if ( ! isTask ) { setTaskName ( null ) ; } return true ; } private boolean checkFile ( ) { if ( filepath == null ) { return checkFile ( getProject ( ) . resolveFile ( file ) , file ) ; } else { String [ ] paths = filepath . list ( ) ; for ( int i = 0 ; i < paths . length ; ++ i ) { log ( "Searching " + paths [ i ] , Project . MSG_DEBUG ) ; File path = new File ( paths [ i ] ) ; if ( path . exists ( ) && file . equals ( paths [ i ] ) ) { if ( type == null ) { log ( "Found: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) && path . isDirectory ( ) ) { log ( "Found directory: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isFile ( ) && path . isFile ( ) ) { log ( "Found file: " + path , Project . MSG_VERBOSE ) ; return true ; } return false ; } FileUtils fileUtils = FileUtils . newFileUtils ( ) ; File parent = fileUtils . getParentFile ( path ) ; if ( parent != null && parent . exists ( ) && file . equals ( parent . getAbsolutePath ( ) ) ) { if ( type == null ) { log ( "Found: " + parent , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) ) { log ( "Found directory: " + parent , Project . MSG_VERBOSE ) ; return true ; } return false ; } if ( path . exists ( ) && path . isDirectory ( ) ) { if ( checkFile ( new File ( path , file ) , file + " in " + path ) ) { return true ; } } if ( parent != null && parent . exists ( ) ) { if ( checkFile ( new File ( parent , file ) , file + " in " + parent ) ) { return true ; } } if ( parent != null ) { File grandParent = fileUtils . getParentFile ( parent ) ; if ( grandParent != null && grandParent . exists ( ) ) { if ( checkFile ( new File ( grandParent , file ) , file + " in " + grandParent ) ) { return true ; } } } } } return false ; } private boolean checkFile ( File f , String text ) { if ( type != null ) { if ( type . isDir ( ) ) { if ( f . isDirectory ( ) ) { log ( "Found directory: " + text , Project . MSG_VERBOSE ) ; } return f . isDirectory ( ) ; } else if ( type . isFile ( ) ) { if ( f . isFile ( ) ) { log ( "Found file: " + text , Project . MSG_VERBOSE ) ; } return f . isFile ( ) ; } } if ( f . exists ( ) ) { log ( "Found: " + text , Project . MSG_VERBOSE ) ; } return f . exists ( ) ; } private boolean checkResource ( String resource ) { if ( loader != null ) { return ( loader . getResourceAsStream ( resource ) != null ) ; } else { ClassLoader cL = this . getClass ( ) . getClassLoader ( ) ; if ( cL != null ) { return ( cL . getResourceAsStream ( resource ) != null ) ; } else { return ( ClassLoader . getSystemResourceAsStream ( resource ) != null ) ; } } } private boolean checkClass ( String classname ) { try { Class requiredClass = null ; if ( ignoreSystemclasses ) { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; if ( loader != null ) { try { requiredClass = loader . findClass ( classname ) ; } catch ( SecurityException se ) { return true ; } } else { return false ; } } else if ( loader != null ) { requiredClass = loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { requiredClass = Class . forName ( classname , true , l ) ; } else { requiredClass = Class . forName ( classname ) ; } } return true ; } catch ( ClassNotFoundException e ) { log ( "class \"" + classname + "\" was not found" , Project . MSG_DEBUG ) ; return false ; } catch ( NoClassDefFoundError e ) { log ( "Could not load dependent class \"" + e . getMessage ( ) + "\" for class \"" + classname + "\"" , Project . MSG_DEBUG ) ; return false ; } } public static class FileDir extends EnumeratedAttribute { private static final String [ ] VALUES = { "file" , "dir" } ; public String [ ] getValues ( ) { return VALUES ; } public boolean isDir ( ) { return "dir" . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFile ( ) { return "file" . equalsIgnoreCase ( getValue ( ) ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . NoSuchElementException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileUtils ; public class FixCRLF extends MatchingTask { private static final int UNDEF = - 1 ; private static final int NOTJAVA = 0 ; private static final int LOOKING = 1 ; private static final int IN_CHAR_CONST = 2 ; private static final int IN_STR_CONST = 3 ; private static final int IN_SINGLE_COMMENT = 4 ; private static final int IN_MULTI_COMMENT = 5 ; private static final int ASIS = 0 ; private static final int CR = 1 ; private static final int LF = 2 ; private static final int CRLF = 3 ; private static final int ADD = 1 ; private static final int REMOVE = - 1 ; private static final int SPACES = - 1 ; private static final int TABS = 1 ; private static final int INBUFLEN = 8192 ; private static final int LINEBUFLEN = 200 ; private static final char CTRLZ = '' ; private int tablength = 8 ; private String spaces = "        " ; private StringBuffer linebuf = new StringBuffer ( 1024 ) ; private StringBuffer linebuf2 = new StringBuffer ( 1024 ) ; private int eol ; private String eolstr ; private int ctrlz ; private int tabs ; private boolean javafiles = false ; private File srcDir ; private File destDir = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private String encoding = null ; public FixCRLF ( ) { tabs = ASIS ; if ( Os . isFamily ( "mac" ) ) { ctrlz = REMOVE ; eol = CR ; eolstr = "\r" ; } else if ( Os . isFamily ( "dos" ) ) { ctrlz = ASIS ; eol = CRLF ; eolstr = "\r\n" ; } else { ctrlz = REMOVE ; eol = LF ; eolstr = "\n" ; } } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setJavafiles ( boolean javafiles ) { this . javafiles = javafiles ; } public void setEol ( CrLf attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "asis" ) ) { eol = ASIS ; } else if ( option . equals ( "cr" ) || option . equals ( "mac" ) ) { eol = CR ; eolstr = "\r" ; } else if ( option . equals ( "lf" ) || option . equals ( "unix" ) ) { eol = LF ; eolstr = "\n" ; } else { eol = CRLF ; eolstr = "\r\n" ; } } public void setCr ( AddAsisRemove attr ) { log ( "DEPRECATED: The cr attribute has been deprecated," , Project . MSG_WARN ) ; log ( "Please use the eol attribute instead" , Project . MSG_WARN ) ; String option = attr . getValue ( ) ; CrLf c = new CrLf ( ) ; if ( option . equals ( "remove" ) ) { c . setValue ( "lf" ) ; } else if ( option . equals ( "asis" ) ) { c . setValue ( "asis" ) ; } else { c . setValue ( "crlf" ) ; } setEol ( c ) ; } public void setTab ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { tabs = SPACES ; } else if ( option . equals ( "asis" ) ) { tabs = ASIS ; } else { tabs = TABS ; } } public void setTablength ( int tlength ) throws BuildException { if ( tlength < 2 || tlength > 80 ) { throw new BuildException ( "tablength must be between 2 and 80" , getLocation ( ) ) ; } tablength = tlength ; StringBuffer sp = new StringBuffer ( ) ; for ( int i = 0 ; i < tablength ; i ++ ) { sp . append ( ' ' ) ; } spaces = sp . toString ( ) ; } public void setEof ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { ctrlz = REMOVE ; } else if ( option . equals ( "asis" ) ) { ctrlz = ASIS ; } else { ctrlz = ADD ; } } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void execute ( ) throws BuildException { if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } log ( "options:" + " eol=" + ( eol == ASIS ? "asis" : eol == CR ? "cr" : eol == LF ? "lf" : "crlf" ) + " tab=" + ( tabs == TABS ? "add" : tabs == ASIS ? "asis" : "remove" ) + " eof=" + ( ctrlz == ADD ? "add" : ctrlz == ASIS ? "asis" : "remove" ) + " tablength=" + tablength + " encoding=" + ( encoding == null ? "default" : encoding ) , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { processFile ( files [ i ] ) ; } } private Reader getReader ( File f ) throws IOException { return ( encoding == null ) ? new FileReader ( f ) : new InputStreamReader ( new FileInputStream ( f ) , encoding ) ; } private void processFile ( String file ) throws BuildException { File srcFile = new File ( srcDir , file ) ; File destD = destDir == null ? srcDir : destDir ; File tmpFile = null ; BufferedWriter outWriter ; OneLiner . BufferLine line ; OneLiner lines = new OneLiner ( srcFile ) ; try { try { tmpFile = fileUtils . createTempFile ( "fixcrlf" , "" , null ) ; tmpFile . deleteOnExit ( ) ; Writer writer = ( encoding == null ) ? new FileWriter ( tmpFile ) : new OutputStreamWriter ( new FileOutputStream ( tmpFile ) , encoding ) ; outWriter = new BufferedWriter ( writer ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } while ( lines . hasMoreElements ( ) ) { int endComment ; try { line = ( OneLiner . BufferLine ) lines . nextElement ( ) ; } catch ( NoSuchElementException e ) { throw new BuildException ( e ) ; } String lineString = line . getLineString ( ) ; int linelen = line . length ( ) ; if ( tabs == ASIS ) { try { outWriter . write ( lineString ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { while ( line . getNext ( ) < linelen ) { switch ( lines . getState ( ) ) { case NOTJAVA : notInConstant ( line , line . length ( ) , outWriter ) ; break ; case IN_MULTI_COMMENT : endComment = lineString . indexOf ( "*/" , line . getNext ( ) ) ; if ( endComment >= 0 ) { endComment += 2 ; lines . setState ( LOOKING ) ; } else { endComment = linelen ; } notInConstant ( line , endComment , outWriter ) ; break ; case IN_SINGLE_COMMENT : notInConstant ( line , line . length ( ) , outWriter ) ; lines . setState ( LOOKING ) ; break ; case IN_CHAR_CONST : case IN_STR_CONST : int begin = line . getNext ( ) ; char terminator = ( lines . getState ( ) == IN_STR_CONST ? '\"' : '\'' ) ; endOfCharConst ( line , terminator ) ; while ( line . getNext ( ) < line . getLookahead ( ) ) { if ( line . getNextCharInc ( ) == '\t' ) { line . setColumn ( line . getColumn ( ) + tablength - ( line . getColumn ( ) % tablength ) ) ; } else { line . incColumn ( ) ; } } try { outWriter . write ( line . substring ( begin , line . getNext ( ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } lines . setState ( LOOKING ) ; break ; case LOOKING : nextStateChange ( line ) ; notInConstant ( line , line . getLookahead ( ) , outWriter ) ; break ; } } } try { outWriter . write ( eolstr ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { if ( ctrlz == ASIS ) { outWriter . write ( lines . getEofStr ( ) ) ; } else if ( ctrlz == ADD ) { outWriter . write ( CTRLZ ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { outWriter . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { lines . close ( ) ; lines = null ; } catch ( IOException e ) { throw new BuildException ( "Unable to close source file " + srcFile ) ; } File destFile = new File ( destD , file ) ; boolean destIsWrong = true ; if ( destFile . exists ( ) ) { log ( "destFile exists" , Project . MSG_DEBUG ) ; if ( ! fileUtils . contentEquals ( destFile , tmpFile ) ) { log ( destFile + " is being written" , Project . MSG_DEBUG ) ; } else { log ( destFile + " is not written, as the contents " + "are identical" , Project . MSG_DEBUG ) ; destIsWrong = false ; } } if ( destIsWrong ) { fileUtils . rename ( tmpFile , destFile ) ; tmpFile = null ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { if ( lines != null ) { lines . close ( ) ; } } catch ( IOException io ) { log ( "Error closing " + srcFile , Project . MSG_ERR ) ; } if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private void nextStateChange ( OneLiner . BufferLine bufline ) throws BuildException { int eol = bufline . length ( ) ; int ptr = bufline . getNext ( ) ; while ( ptr < eol ) { switch ( bufline . getChar ( ptr ++ ) ) { case '\'' : bufline . setState ( IN_CHAR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '\"' : bufline . setState ( IN_STR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '/' : if ( ptr < eol ) { if ( bufline . getChar ( ptr ) == '*' ) { bufline . setState ( IN_MULTI_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } else if ( bufline . getChar ( ptr ) == '/' ) { bufline . setState ( IN_SINGLE_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } } break ; } } bufline . setLookahead ( ptr ) ; } private void endOfCharConst ( OneLiner . BufferLine bufline , char terminator ) throws BuildException { int ptr = bufline . getNext ( ) ; int eol = bufline . length ( ) ; char c ; ptr ++ ; while ( ptr < eol ) { if ( ( c = bufline . getChar ( ptr ++ ) ) == '\\' ) { ptr ++ ; } else { if ( c == terminator ) { bufline . setLookahead ( ptr ) ; return ; } } } throw new BuildException ( "endOfCharConst: unterminated char constant" ) ; } private void notInConstant ( OneLiner . BufferLine bufline , int end , BufferedWriter outWriter ) { int nextTab ; int nextStop ; int tabspaces ; String line = bufline . substring ( bufline . getNext ( ) , end ) ; int place = 0 ; int col = bufline . getColumn ( ) ; linebuf = new StringBuffer ( ) ; while ( ( nextTab = line . indexOf ( ( int ) '\t' , place ) ) >= 0 ) { linebuf . append ( line . substring ( place , nextTab ) ) ; col += nextTab - place ; tabspaces = tablength - ( col % tablength ) ; linebuf . append ( spaces . substring ( 0 , tabspaces ) ) ; col += tabspaces ; place = nextTab + 1 ; } linebuf . append ( line . substring ( place , line . length ( ) ) ) ; String linestring = new String ( linebuf . substring ( 0 ) ) ; if ( tabs == REMOVE ) { try { outWriter . write ( linestring ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int tabCol ; linebuf2 = new StringBuffer ( ) ; place = 0 ; col = bufline . getColumn ( ) ; int placediff = col - 0 ; nextStop = col + ( tablength - col % tablength ) ; if ( nextStop - col < 2 ) { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; place = nextStop - placediff ; nextStop += tablength ; } for ( ; nextStop - placediff <= linestring . length ( ) ; nextStop += tablength ) { for ( tabCol = nextStop ; -- tabCol - placediff >= place && linestring . charAt ( tabCol - placediff ) == ' ' ; ) { ; } if ( nextStop - tabCol > 2 ) { linebuf2 . append ( linestring . substring ( place , ++ tabCol - placediff ) ) ; linebuf2 . append ( '\t' ) ; } else { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; } place = nextStop - placediff ; } linebuf2 . append ( linestring . substring ( place , linestring . length ( ) ) ) ; try { outWriter . write ( linebuf2 . substring ( 0 ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } bufline . setColumn ( bufline . getColumn ( ) + linestring . length ( ) ) ; bufline . setNext ( end ) ; } class OneLiner implements Enumeration { private int state = javafiles ? LOOKING : NOTJAVA ; private StringBuffer eolStr = new StringBuffer ( LINEBUFLEN ) ; private StringBuffer eofStr = new StringBuffer ( ) ; private BufferedReader reader ; private StringBuffer line = new StringBuffer ( ) ; private boolean reachedEof = false ; private File srcFile ; public OneLiner ( File srcFile ) throws BuildException { this . srcFile = srcFile ; try { reader = new BufferedReader ( getReader ( srcFile ) , INBUFLEN ) ; nextLine ( ) ; } catch ( IOException e ) { throw new BuildException ( srcFile + ": " + e . getMessage ( ) , e , getLocation ( ) ) ; } } protected void nextLine ( ) throws BuildException { int ch = - 1 ; int eolcount = 0 ; eolStr = new StringBuffer ( ) ; line = new StringBuffer ( ) ; try { ch = reader . read ( ) ; while ( ch != - 1 && ch != '\r' && ch != '\n' ) { line . append ( ( char ) ch ) ; ch = reader . read ( ) ; } if ( ch == - 1 && line . length ( ) == 0 ) { reachedEof = true ; return ; } switch ( ( char ) ch ) { case '\r' : ++ eolcount ; eolStr . append ( '\r' ) ; reader . mark ( 2 ) ; switch ( ( ch = reader . read ( ) ) ) { case '\r' : if ( ( char ) ( ch = reader . read ( ) ) == '\n' ) { eolcount += 2 ; eolStr . append ( "\r\n" ) ; } else { reader . reset ( ) ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; case - 1 : break ; default : reader . reset ( ) ; break ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; } if ( eolcount == 0 ) { int i = line . length ( ) ; while ( -- i >= 0 && line . charAt ( i ) == CTRLZ ) { } if ( i < line . length ( ) - 1 ) { eofStr . append ( line . toString ( ) . substring ( i + 1 ) ) ; if ( i < 0 ) { line . setLength ( 0 ) ; reachedEof = true ; } else { line . setLength ( i + 1 ) ; } } } } catch ( IOException e ) { throw new BuildException ( srcFile + ": " + e . getMessage ( ) , e , getLocation ( ) ) ; } } public String getEofStr ( ) { return eofStr . substring ( 0 ) ; } public int getState ( ) { return state ; } public void setState ( int state ) { this . state = state ; } public boolean hasMoreElements ( ) { return ! reachedEof ; } public Object nextElement ( ) throws NoSuchElementException { if ( ! hasMoreElements ( ) ) { throw new NoSuchElementException ( "OneLiner" ) ; } BufferLine tmpLine = new BufferLine ( line . toString ( ) , eolStr . substring ( 0 ) ) ; nextLine ( ) ; return tmpLine ; } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } class BufferLine { private int next = 0 ; private int column = 0 ; private int lookahead = UNDEF ; private String line ; private String eolStr ; public BufferLine ( String line , String eolStr ) throws BuildException { next = 0 ; column = 0 ; this . line = line ; this . eolStr = eolStr ; } public int getNext ( ) { return next ; } public void setNext ( int next ) { this . next = next ; } public int getLookahead ( ) { return lookahead ; } public void setLookahead ( int lookahead ) { this . lookahead = lookahead ; } public char getChar ( int i ) { return line . charAt ( i ) ; } public char getNextChar ( ) { return getChar ( next ) ; } public char getNextCharInc ( ) { return getChar ( next ++ ) ; } public int getColumn ( ) { return column ; } public void setColumn ( int col ) { column = col ; } public int incColumn ( ) { return column ++ ; } public int length ( ) { return line . length ( ) ; } public int getEolLength ( ) { return eolStr . length ( ) ; } public String getLineString ( ) { return line ; } public String getEol ( ) { return eolStr ; } public String substring ( int begin ) { return line . substring ( begin ) ; } public String substring ( int begin , int end ) { return line . substring ( begin , end ) ; } public void setState ( int state ) { OneLiner . this . setState ( state ) ; } public int getState ( ) { return OneLiner . this . getState ( ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } public static class CrLf extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" , "mac" , "unix" , "dos" } ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamPumper implements Runnable { private static final int SIZE = 128 ; private InputStream is ; private OutputStream os ; private boolean finished ; private boolean closeWhenExhausted ; public StreamPumper ( InputStream is , OutputStream os , boolean closeWhenExhausted ) { this . is = is ; this . os = os ; this . closeWhenExhausted = closeWhenExhausted ; } public StreamPumper ( InputStream is , OutputStream os ) { this ( is , os , false ) ; } public void run ( ) { synchronized ( this ) { finished = false ; } final byte [ ] buf = new byte [ SIZE ] ; int length ; try { while ( ( length = is . read ( buf ) ) > 0 ) { os . write ( buf , 0 , length ) ; } } catch ( Exception e ) { } finally { if ( closeWhenExhausted ) { try { os . close ( ) ; } catch ( IOException e ) { } } synchronized ( this ) { finished = true ; notifyAll ( ) ; } } } public synchronized boolean isFinished ( ) { return finished ; } public synchronized void waitFor ( ) throws InterruptedException { while ( ! isFinished ( ) ) { wait ( ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . BufferedReader ; import java . io . FileReader ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Locale ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Javadoc extends Task { public class DocletParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class ExtensionInfo extends ProjectComponent { private String name ; private Path path ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setPath ( Path path ) { if ( this . path == null ) { this . path = path ; } else { this . path . append ( path ) ; } } public Path getPath ( ) { return path ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } } public class DocletInfo extends ExtensionInfo { private Vector params = new Vector ( ) ; public DocletParam createParam ( ) { DocletParam param = new DocletParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } } public static class PackageName { private String name ; public void setName ( String name ) { this . name = name . trim ( ) ; } public String getName ( ) { return name ; } public String toString ( ) { return getName ( ) ; } } public static class SourceFile { private File file ; public SourceFile ( ) { } public SourceFile ( File file ) { this . file = file ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } } public static class Html { private StringBuffer text = new StringBuffer ( ) ; public void addText ( String t ) { text . append ( t ) ; } public String getText ( ) { return text . substring ( 0 ) ; } } public static class AccessType extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "protected" , "public" , "package" , "private" } ; } } private Commandline cmd = new Commandline ( ) ; private static boolean javadoc1 = JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ; private static boolean javadoc4 = ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ; private void addArgIf ( boolean b , String arg ) { if ( b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIfNotEmpty ( String key , String value ) { if ( ! javadoc1 ) { if ( value != null && value . length ( ) != 0 ) { cmd . createArgument ( ) . setValue ( key ) ; cmd . createArgument ( ) . setValue ( value ) ; } else { log ( "Warning: Leaving out empty argument '" + key + "'" , Project . MSG_WARN ) ; } } } private void add12ArgIf ( boolean b , String arg ) { if ( ! javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private boolean failOnError = false ; private Path sourcePath = null ; private File destDir = null ; private Vector sourceFiles = new Vector ( ) ; private Vector packageNames = new Vector ( ) ; private Vector excludePackageNames = new Vector ( 1 ) ; private boolean author = true ; private boolean version = true ; private DocletInfo doclet = null ; private Path classpath = null ; private Path bootclasspath = null ; private String group = null ; private String packageList = null ; private Vector links = new Vector ( ) ; private Vector groups = new Vector ( ) ; private Vector tags = new Vector ( ) ; private boolean useDefaultExcludes = true ; private Html doctitle = null ; private Html header = null ; private Html footer = null ; private Html bottom = null ; private boolean useExternalFile = false ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private String source = null ; private boolean linksource = false ; private boolean breakiterator = false ; private String noqualifier ; private Vector fileSets = new Vector ( ) ; private Vector packageSets = new Vector ( ) ; public void setUseExternalFile ( boolean b ) { if ( ! javadoc1 ) { useExternalFile = b ; } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } public void setMaxmemory ( String max ) { if ( javadoc1 ) { cmd . createArgument ( ) . setValue ( "-J-mx" + max ) ; } else { cmd . createArgument ( ) . setValue ( "-J-Xmx" + max ) ; } } public void setAdditionalparam ( String add ) { cmd . createArgument ( ) . setLine ( add ) ; } public Commandline . Argument createArg ( ) { return cmd . createArgument ( ) ; } public void setSourcepath ( Path src ) { if ( sourcePath == null ) { sourcePath = src ; } else { sourcePath . append ( src ) ; } } public Path createSourcepath ( ) { if ( sourcePath == null ) { sourcePath = new Path ( getProject ( ) ) ; } return sourcePath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setDestdir ( File dir ) { destDir = dir ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } public void setSourcefiles ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String f = tok . nextToken ( ) ; SourceFile sf = new SourceFile ( ) ; sf . setFile ( getProject ( ) . resolveFile ( f . trim ( ) ) ) ; addSource ( sf ) ; } } public void addSource ( SourceFile sf ) { sourceFiles . addElement ( sf ) ; } public void setPackagenames ( String packages ) { StringTokenizer tok = new StringTokenizer ( packages , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packageNames . addElement ( pn ) ; } public void setExcludePackageNames ( String packages ) { StringTokenizer tok = new StringTokenizer ( packages , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addExcludePackage ( pn ) ; } } public void addExcludePackage ( PackageName pn ) { excludePackageNames . addElement ( pn ) ; } public void setOverview ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-overview" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setPublic ( boolean b ) { addArgIf ( b , "-public" ) ; } public void setProtected ( boolean b ) { addArgIf ( b , "-protected" ) ; } public void setPackage ( boolean b ) { addArgIf ( b , "-package" ) ; } public void setPrivate ( boolean b ) { addArgIf ( b , "-private" ) ; } public void setAccess ( AccessType at ) { cmd . createArgument ( ) . setValue ( "-" + at . getValue ( ) ) ; } public void setDoclet ( String docletName ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . setName ( docletName ) ; } public void setDocletPath ( Path docletPath ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . setPath ( docletPath ) ; } public void setDocletPathRef ( Reference r ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; doclet . setProject ( getProject ( ) ) ; } doclet . createPath ( ) . setRefid ( r ) ; } public DocletInfo createDoclet ( ) { doclet = new DocletInfo ( ) ; return doclet ; } public void addTaglet ( ExtensionInfo tagletInfo ) { tags . addElement ( tagletInfo ) ; } public void setOld ( boolean b ) { if ( b ) { if ( javadoc1 ) { log ( "Javadoc 1.1 doesn't support the -1.1 switch" , Project . MSG_WARN ) ; } else if ( javadoc4 ) { log ( "Javadoc 1.4 doesn't support the -1.1 switch anymore" , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( "-1.1" ) ; } } } public void setClasspath ( Path path ) { if ( classpath == null ) { classpath = path ; } else { classpath . append ( path ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path path ) { if ( bootclasspath == null ) { bootclasspath = path ; } else { bootclasspath . append ( path ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( String path ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setValue ( path ) ; } } public void setExtdirs ( Path path ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( path ) ; } } public void setVerbose ( boolean b ) { add12ArgIf ( b , "-verbose" ) ; } public void setLocale ( String locale ) { if ( ! javadoc1 ) { cmd . createArgument ( true ) . setValue ( locale ) ; cmd . createArgument ( true ) . setValue ( "-locale" ) ; } } public void setEncoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setVersion ( boolean b ) { this . version = b ; } public void setUse ( boolean b ) { add12ArgIf ( b , "-use" ) ; } public void setAuthor ( boolean b ) { author = b ; } public void setSplitindex ( boolean b ) { add12ArgIf ( b , "-splitindex" ) ; } public void setWindowtitle ( String title ) { add12ArgIfNotEmpty ( "-windowtitle" , title ) ; } public void setDoctitle ( String doctitle ) { Html h = new Html ( ) ; h . addText ( doctitle ) ; addDoctitle ( h ) ; } public void addDoctitle ( Html text ) { if ( ! javadoc1 ) { doctitle = text ; } } public void setHeader ( String header ) { Html h = new Html ( ) ; h . addText ( header ) ; addHeader ( h ) ; } public void addHeader ( Html text ) { if ( ! javadoc1 ) { header = text ; } } public void setFooter ( String footer ) { Html h = new Html ( ) ; h . addText ( footer ) ; addFooter ( h ) ; } public void addFooter ( Html text ) { if ( ! javadoc1 ) { footer = text ; } } public void setBottom ( String bottom ) { Html h = new Html ( ) ; h . addText ( bottom ) ; addBottom ( h ) ; } public void addBottom ( Html text ) { if ( ! javadoc1 ) { bottom = text ; } } public void setLinkoffline ( String src ) { if ( ! javadoc1 ) { LinkArgument le = createLink ( ) ; le . setOffline ( true ) ; String linkOfflineError = "The linkoffline attribute must include" + " a URL and a package-list file location separated by a" + " space" ; if ( src . trim ( ) . length ( ) == 0 ) { throw new BuildException ( linkOfflineError ) ; } StringTokenizer tok = new StringTokenizer ( src , " " , false ) ; le . setHref ( tok . nextToken ( ) ) ; if ( ! tok . hasMoreTokens ( ) ) { throw new BuildException ( linkOfflineError ) ; } le . setPackagelistLoc ( getProject ( ) . resolveFile ( tok . nextToken ( ) ) ) ; } } public void setGroup ( String src ) { group = src ; } public void setLink ( String src ) { if ( ! javadoc1 ) { createLink ( ) . setHref ( src ) ; } } public void setNodeprecated ( boolean b ) { addArgIf ( b , "-nodeprecated" ) ; } public void setNodeprecatedlist ( boolean b ) { add12ArgIf ( b , "-nodeprecatedlist" ) ; } public void setNotree ( boolean b ) { addArgIf ( b , "-notree" ) ; } public void setNoindex ( boolean b ) { addArgIf ( b , "-noindex" ) ; } public void setNohelp ( boolean b ) { add12ArgIf ( b , "-nohelp" ) ; } public void setNonavbar ( boolean b ) { add12ArgIf ( b , "-nonavbar" ) ; } public void setSerialwarn ( boolean b ) { add12ArgIf ( b , "-serialwarn" ) ; } public void setStylesheetfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-stylesheetfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setHelpfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-helpfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setDocencoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-docencoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setPackageList ( String src ) { if ( ! javadoc1 ) { packageList = src ; } } public LinkArgument createLink ( ) { LinkArgument la = new LinkArgument ( ) ; links . addElement ( la ) ; return la ; } public class LinkArgument { private String href ; private boolean offline = false ; private File packagelistLoc ; public LinkArgument ( ) { } public void setHref ( String hr ) { href = hr ; } public String getHref ( ) { return href ; } public void setPackagelistLoc ( File src ) { packagelistLoc = src ; } public File getPackagelistLoc ( ) { return packagelistLoc ; } public void setOffline ( boolean offline ) { this . offline = offline ; } public boolean isLinkOffline ( ) { return offline ; } } public TagArgument createTag ( ) { if ( ! javadoc4 ) { log ( "-tag option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } TagArgument ta = new TagArgument ( ) ; tags . addElement ( ta ) ; return ta ; } static final String [ ] SCOPE_ELEMENTS = { "overview" , "packages" , "types" , "constructors" , "methods" , "fields" } ; public class TagArgument extends FileSet { private String name = null ; private String description = null ; private boolean enabled = true ; private String scope = "a" ; public TagArgument ( ) { } public void setName ( String name ) { this . name = name ; } public void setDescription ( String description ) { this . description = description ; } public void setScope ( String verboseScope ) throws BuildException { verboseScope = verboseScope . toLowerCase ( Locale . US ) ; boolean [ ] elements = new boolean [ SCOPE_ELEMENTS . length ] ; boolean gotAll = false ; boolean gotNotAll = false ; StringTokenizer tok = new StringTokenizer ( verboseScope , "," ) ; while ( tok . hasMoreTokens ( ) ) { String next = tok . nextToken ( ) . trim ( ) ; if ( next . equals ( "all" ) ) { if ( gotAll ) { getProject ( ) . log ( "Repeated tag scope element: all" , Project . MSG_VERBOSE ) ; } gotAll = true ; } else { int i ; for ( i = 0 ; i < SCOPE_ELEMENTS . length ; i ++ ) { if ( next . equals ( SCOPE_ELEMENTS [ i ] ) ) { break ; } } if ( i == SCOPE_ELEMENTS . length ) { throw new BuildException ( "Unrecognised scope element: " + next ) ; } else { if ( elements [ i ] ) { getProject ( ) . log ( "Repeated tag scope element: " + next , Project . MSG_VERBOSE ) ; } elements [ i ] = true ; gotNotAll = true ; } } } if ( gotNotAll && gotAll ) { throw new BuildException ( "Mixture of \"all\" and other scope " + "elements in tag parameter." ) ; } if ( ! gotNotAll && ! gotAll ) { throw new BuildException ( "No scope elements specified in tag " + "parameter." ) ; } if ( gotAll ) { this . scope = "a" ; } else { StringBuffer buff = new StringBuffer ( elements . length ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { if ( elements [ i ] ) { buff . append ( SCOPE_ELEMENTS [ i ] . charAt ( 0 ) ) ; } } this . scope = buff . toString ( ) ; } } public void setEnabled ( boolean enabled ) { this . enabled = enabled ; } public String getParameter ( ) throws BuildException { if ( name == null || name . equals ( "" ) ) { throw new BuildException ( "No name specified for custom tag." ) ; } if ( description != null ) { return name + ":" + ( enabled ? "" : "X" ) + scope + ":" + description ; } else { return name ; } } } public GroupArgument createGroup ( ) { GroupArgument ga = new GroupArgument ( ) ; groups . addElement ( ga ) ; return ga ; } public class GroupArgument { private Html title ; private Vector packages = new Vector ( ) ; public GroupArgument ( ) { } public void setTitle ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addTitle ( h ) ; } public void addTitle ( Html text ) { title = text ; } public String getTitle ( ) { return title != null ? title . getText ( ) : null ; } public void setPackages ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packages . addElement ( pn ) ; } public String getPackages ( ) { StringBuffer p = new StringBuffer ( ) ; for ( int i = 0 ; i < packages . size ( ) ; i ++ ) { if ( i > 0 ) { p . append ( ":" ) ; } p . append ( packages . elementAt ( i ) . toString ( ) ) ; } return p . toString ( ) ; } } public void setCharset ( String src ) { this . add12ArgIfNotEmpty ( "-charset" , src ) ; } public void setFailonerror ( boolean b ) { failOnError = b ; } public void setSource ( String source ) { if ( ! javadoc4 ) { log ( "-source option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } this . source = source ; } public void addPackageset ( DirSet packageSet ) { packageSets . addElement ( packageSet ) ; } public void addFileset ( FileSet fs ) { fileSets . addElement ( fs ) ; } public void setLinksource ( boolean b ) { if ( ! javadoc4 ) { log ( "-linksource option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } this . linksource = b ; } public void setBreakiterator ( boolean b ) { if ( ! javadoc4 ) { log ( "-breakiterator option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } this . breakiterator = b ; } public void setNoqualifier ( String noqualifier ) { if ( ! javadoc4 ) { log ( "-noqualifier option not supported on JavaDoc < 1.4" , Project . MSG_VERBOSE ) ; } this . noqualifier = noqualifier ; } public void execute ( ) throws BuildException { if ( "javadoc2" . equals ( getTaskType ( ) ) ) { log ( "!! javadoc2 is deprecated. Use javadoc instead. !!" ) ; } Vector packagesToDoc = new Vector ( ) ; Path sourceDirs = new Path ( getProject ( ) ) ; if ( packageList != null && sourcePath == null ) { String msg = "sourcePath attribute must be set when " + "specifying packagelist." ; throw new BuildException ( msg ) ; } if ( sourcePath != null ) { sourceDirs . addExisting ( sourcePath ) ; } parsePackages ( packagesToDoc , sourceDirs ) ; if ( packagesToDoc . size ( ) != 0 && sourceDirs . size ( ) == 0 ) { String msg = "sourcePath attribute must be set when " + "specifying package names." ; throw new BuildException ( msg ) ; } Vector sourceFilesToDoc = ( Vector ) sourceFiles . clone ( ) ; addFileSets ( sourceFilesToDoc ) ; if ( packageList == null && packagesToDoc . size ( ) == 0 && sourceFilesToDoc . size ( ) == 0 ) { throw new BuildException ( "No source files and no packages have " + "been specified." ) ; } log ( "Generating Javadoc" , Project . MSG_INFO ) ; Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( JavaEnvUtils . getJdkExecutable ( "javadoc" ) ) ; if ( doctitle != null ) { toExecute . createArgument ( ) . setValue ( "-doctitle" ) ; toExecute . createArgument ( ) . setValue ( expand ( doctitle . getText ( ) ) ) ; } if ( header != null ) { toExecute . createArgument ( ) . setValue ( "-header" ) ; toExecute . createArgument ( ) . setValue ( expand ( header . getText ( ) ) ) ; } if ( footer != null ) { toExecute . createArgument ( ) . setValue ( "-footer" ) ; toExecute . createArgument ( ) . setValue ( expand ( footer . getText ( ) ) ) ; } if ( bottom != null ) { toExecute . createArgument ( ) . setValue ( "-bottom" ) ; toExecute . createArgument ( ) . setValue ( expand ( bottom . getText ( ) ) ) ; } if ( classpath == null ) { classpath = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } else { classpath = classpath . concatSystemClasspath ( "ignore" ) ; } if ( ! javadoc1 ) { if ( classpath . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( classpath ) ; } if ( sourceDirs . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-sourcepath" ) ; toExecute . createArgument ( ) . setPath ( sourceDirs ) ; } } else { sourceDirs . append ( classpath ) ; if ( sourceDirs . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( sourceDirs ) ; } } if ( version && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-version" ) ; } if ( author && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-author" ) ; } if ( javadoc1 || doclet == null ) { if ( destDir == null ) { String msg = "destDir attribute must be set!" ; throw new BuildException ( msg ) ; } } if ( ! javadoc1 ) { if ( doclet != null ) { if ( doclet . getName ( ) == null ) { throw new BuildException ( "The doclet name must be " + "specified." , getLocation ( ) ) ; } else { toExecute . createArgument ( ) . setValue ( "-doclet" ) ; toExecute . createArgument ( ) . setValue ( doclet . getName ( ) ) ; if ( doclet . getPath ( ) != null ) { Path docletPath = doclet . getPath ( ) . concatSystemClasspath ( "ignore" ) ; if ( docletPath . size ( ) != 0 ) { toExecute . createArgument ( ) . setValue ( "-docletpath" ) ; toExecute . createArgument ( ) . setPath ( docletPath ) ; } } for ( Enumeration e = doclet . getParams ( ) ; e . hasMoreElements ( ) ; ) { DocletParam param = ( DocletParam ) e . nextElement ( ) ; if ( param . getName ( ) == null ) { throw new BuildException ( "Doclet parameters must " + "have a name" ) ; } toExecute . createArgument ( ) . setValue ( param . getName ( ) ) ; if ( param . getValue ( ) != null ) { toExecute . createArgument ( ) . setValue ( param . getValue ( ) ) ; } } } } if ( bootclasspath != null && bootclasspath . size ( ) > 0 ) { toExecute . createArgument ( ) . setValue ( "-bootclasspath" ) ; toExecute . createArgument ( ) . setPath ( bootclasspath ) ; } if ( links . size ( ) != 0 ) { for ( Enumeration e = links . elements ( ) ; e . hasMoreElements ( ) ; ) { LinkArgument la = ( LinkArgument ) e . nextElement ( ) ; if ( la . getHref ( ) == null || la . getHref ( ) . length ( ) == 0 ) { log ( "No href was given for the link - skipping" , Project . MSG_VERBOSE ) ; continue ; } else { try { URL base = new URL ( "file://." ) ; new URL ( base , la . getHref ( ) ) ; } catch ( MalformedURLException mue ) { log ( "Link href \"" + la . getHref ( ) + "\" is not a valid url - skipping link" , Project . MSG_WARN ) ; continue ; } } if ( la . isLinkOffline ( ) ) { File packageListLocation = la . getPackagelistLoc ( ) ; if ( packageListLocation == null ) { throw new BuildException ( "The package list " + " location for link " + la . getHref ( ) + " must be provided because the link is " + "offline" ) ; } File packageListFile = new File ( packageListLocation , "package-list" ) ; if ( packageListFile . exists ( ) ) { try { String packageListURL = fileUtils . getFileURL ( packageListLocation ) . toExternalForm ( ) ; toExecute . createArgument ( ) . setValue ( "-linkoffline" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; toExecute . createArgument ( ) . setValue ( packageListURL ) ; } catch ( MalformedURLException ex ) { log ( "Warning: Package list location was " + "invalid " + packageListLocation , Project . MSG_WARN ) ; } } else { log ( "Warning: No package list was found at " + packageListLocation , Project . MSG_VERBOSE ) ; } } else { toExecute . createArgument ( ) . setValue ( "-link" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; } } } if ( group != null ) { StringTokenizer tok = new StringTokenizer ( group , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String grp = tok . nextToken ( ) . trim ( ) ; int space = grp . indexOf ( " " ) ; if ( space > 0 ) { String name = grp . substring ( 0 , space ) ; String pkgList = grp . substring ( space + 1 ) ; toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( name ) ; toExecute . createArgument ( ) . setValue ( pkgList ) ; } } } if ( groups . size ( ) != 0 ) { for ( Enumeration e = groups . elements ( ) ; e . hasMoreElements ( ) ; ) { GroupArgument ga = ( GroupArgument ) e . nextElement ( ) ; String title = ga . getTitle ( ) ; String packages = ga . getPackages ( ) ; if ( title == null || packages == null ) { throw new BuildException ( "The title and packages must " + "be specified for group " + "elements." ) ; } toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( expand ( title ) ) ; toExecute . createArgument ( ) . setValue ( packages ) ; } } if ( javadoc4 ) { for ( Enumeration e = tags . elements ( ) ; e . hasMoreElements ( ) ; ) { Object element = e . nextElement ( ) ; if ( element instanceof TagArgument ) { TagArgument ta = ( TagArgument ) element ; File tagDir = ta . getDir ( getProject ( ) ) ; if ( tagDir == null ) { toExecute . createArgument ( ) . setValue ( "-tag" ) ; toExecute . createArgument ( ) . setValue ( ta . getParameter ( ) ) ; } else { DirectoryScanner tagDefScanner = ta . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = tagDefScanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File tagDefFile = new File ( tagDir , files [ i ] ) ; try { BufferedReader in = new BufferedReader ( new FileReader ( tagDefFile ) ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { toExecute . createArgument ( ) . setValue ( "-tag" ) ; toExecute . createArgument ( ) . setValue ( line ) ; } in . close ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Couldn't read " + " tag file from " + tagDefFile . getAbsolutePath ( ) , ioe ) ; } } } } else { ExtensionInfo tagletInfo = ( ExtensionInfo ) element ; toExecute . createArgument ( ) . setValue ( "-taglet" ) ; toExecute . createArgument ( ) . setValue ( tagletInfo . getName ( ) ) ; if ( tagletInfo . getPath ( ) != null ) { Path tagletPath = tagletInfo . getPath ( ) . concatSystemClasspath ( "ignore" ) ; if ( tagletPath . size ( ) != 0 ) { toExecute . createArgument ( ) . setValue ( "-tagletpath" ) ; toExecute . createArgument ( ) . setPath ( tagletPath ) ; } } } } if ( source != null ) { toExecute . createArgument ( ) . setValue ( "-source" ) ; toExecute . createArgument ( ) . setValue ( source ) ; } if ( linksource && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-linksource" ) ; } if ( breakiterator && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-breakiterator" ) ; } if ( noqualifier != null && doclet == null ) { toExecute . createArgument ( ) . setValue ( "-noqualifier" ) ; toExecute . createArgument ( ) . setValue ( noqualifier ) ; } } } File tmpList = null ; PrintWriter srcListWriter = null ; try { if ( useExternalFile ) { if ( tmpList == null ) { tmpList = fileUtils . createTempFile ( "javadoc" , "" , null ) ; tmpList . deleteOnExit ( ) ; toExecute . createArgument ( ) . setValue ( "@" + tmpList . getAbsolutePath ( ) ) ; } srcListWriter = new PrintWriter ( new FileWriter ( tmpList . getAbsolutePath ( ) , true ) ) ; } Enumeration e = packagesToDoc . elements ( ) ; while ( e . hasMoreElements ( ) ) { String packageName = ( String ) e . nextElement ( ) ; if ( useExternalFile ) { srcListWriter . println ( packageName ) ; } else { toExecute . createArgument ( ) . setValue ( packageName ) ; } } e = sourceFilesToDoc . elements ( ) ; while ( e . hasMoreElements ( ) ) { SourceFile sf = ( SourceFile ) e . nextElement ( ) ; String sourceFileName = sf . getFile ( ) . getAbsolutePath ( ) ; if ( useExternalFile ) { if ( javadoc4 && sourceFileName . indexOf ( " " ) > - 1 ) { srcListWriter . println ( "\"" + sourceFileName + "\"" ) ; } else { srcListWriter . println ( sourceFileName ) ; } } else { toExecute . createArgument ( ) . setValue ( sourceFileName ) ; } } } catch ( IOException e ) { tmpList . delete ( ) ; throw new BuildException ( "Error creating temporary file" , e , getLocation ( ) ) ; } finally { if ( srcListWriter != null ) { srcListWriter . close ( ) ; } } if ( packageList != null ) { toExecute . createArgument ( ) . setValue ( "@" + packageList ) ; } log ( toExecute . describeCommand ( ) , Project . MSG_VERBOSE ) ; log ( "Javadoc execution" , Project . MSG_INFO ) ; JavadocOutputStream out = new JavadocOutputStream ( Project . MSG_INFO ) ; JavadocOutputStream err = new JavadocOutputStream ( Project . MSG_WARN ) ; Execute exe = new Execute ( new PumpStreamHandler ( out , err ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( null ) ; try { exe . setCommandline ( toExecute . getCommandline ( ) ) ; int ret = exe . execute ( ) ; if ( ret != 0 && failOnError ) { throw new BuildException ( "Javadoc returned " + ret , getLocation ( ) ) ; } } catch ( IOException e ) { throw new BuildException ( "Javadoc failed: " + e , e , getLocation ( ) ) ; } finally { if ( tmpList != null ) { tmpList . delete ( ) ; tmpList = null ; } out . logFlush ( ) ; err . logFlush ( ) ; try { out . close ( ) ; err . close ( ) ; } catch ( IOException e ) { } } } private void addFileSets ( Vector sf ) { Enumeration e = fileSets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; if ( ! fs . hasPatterns ( ) && ! fs . hasSelectors ( ) ) { fs = ( FileSet ) fs . clone ( ) ; fs . createInclude ( ) . setName ( "**/*.java" ) ; } File baseDir = fs . getDir ( getProject ( ) ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { sf . addElement ( new SourceFile ( new File ( baseDir , files [ i ] ) ) ) ; } } } private void parsePackages ( Vector pn , Path sp ) { Vector addedPackages = new Vector ( ) ; Vector dirSets = ( Vector ) packageSets . clone ( ) ; if ( sourcePath != null && packageNames . size ( ) > 0 ) { PatternSet ps = new PatternSet ( ) ; Enumeration e = packageNames . elements ( ) ; while ( e . hasMoreElements ( ) ) { PackageName p = ( PackageName ) e . nextElement ( ) ; String pkg = p . getName ( ) . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } ps . createInclude ( ) . setName ( pkg ) ; } e = excludePackageNames . elements ( ) ; while ( e . hasMoreElements ( ) ) { PackageName p = ( PackageName ) e . nextElement ( ) ; String pkg = p . getName ( ) . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } ps . createExclude ( ) . setName ( pkg ) ; } String [ ] pathElements = sourcePath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; i ++ ) { DirSet ds = new DirSet ( ) ; ds . setDefaultexcludes ( useDefaultExcludes ) ; ds . setDir ( new File ( pathElements [ i ] ) ) ; ds . createPatternSet ( ) . addConfiguredPatternset ( ps ) ; dirSets . addElement ( ds ) ; } } Enumeration e = dirSets . elements ( ) ; while ( e . hasMoreElements ( ) ) { DirSet ds = ( DirSet ) e . nextElement ( ) ; File baseDir = ds . getDir ( getProject ( ) ) ; log ( "scanning " + baseDir + " for packages." , Project . MSG_DEBUG ) ; DirectoryScanner dsc = ds . getDirectoryScanner ( getProject ( ) ) ; String [ ] dirs = dsc . getIncludedDirectories ( ) ; boolean containsPackages = false ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File pd = new File ( baseDir , dirs [ i ] ) ; String [ ] files = pd . list ( new FilenameFilter ( ) { public boolean accept ( File dir1 , String name ) { if ( name . endsWith ( ".java" ) ) { return true ; } return false ; } } ) ; if ( files . length > 0 ) { containsPackages = true ; String packageName = dirs [ i ] . replace ( File . separatorChar , '.' ) ; if ( ! addedPackages . contains ( packageName ) ) { addedPackages . addElement ( packageName ) ; pn . addElement ( packageName ) ; } } } if ( containsPackages ) { sp . createPathElement ( ) . setLocation ( baseDir ) ; } else { log ( baseDir + " doesn\'t contain any packages, dropping it." , Project . MSG_VERBOSE ) ; } } } private class JavadocOutputStream extends LogOutputStream { JavadocOutputStream ( int level ) { super ( Javadoc . this , level ) ; } private String queuedLine = null ; protected void processLine ( String line , int messageLevel ) { if ( messageLevel == Project . MSG_INFO && line . startsWith ( "Generating " ) ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } queuedLine = line ; } else { if ( queuedLine != null ) { if ( line . startsWith ( "Building " ) ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } else { super . processLine ( queuedLine , Project . MSG_INFO ) ; } queuedLine = null ; } super . processLine ( line , messageLevel ) ; } } protected void logFlush ( ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; queuedLine = null ; } } } protected String expand ( String content ) { return getProject ( ) . replaceProperties ( content ) ; } } 	1
package org . apache . tools . ant . loader ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . Project ; import java . util . jar . Manifest ; import java . util . jar . JarFile ; import java . util . zip . ZipFile ; import java . util . jar . Attributes ; import java . util . jar . Attributes . Name ; import java . net . URL ; import java . net . MalformedURLException ; import java . util . zip . ZipEntry ; import java . util . StringTokenizer ; import org . apache . tools . ant . util . FileUtils ; public class AntClassLoader2 extends AntClassLoader { private FileUtils fileUtils ; public AntClassLoader2 ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } protected Class defineClassFromData ( File container , byte [ ] classData , String className ) throws IOException { definePackage ( container , className ) ; return defineClass ( className , classData , 0 , classData . length , Project . class . getProtectionDomain ( ) ) ; } private Manifest getJarManifest ( File container ) throws IOException { if ( container . isDirectory ( ) ) { return null ; } JarFile jarFile = null ; try { jarFile = new JarFile ( container ) ; return jarFile . getManifest ( ) ; } finally { if ( jarFile != null ) { jarFile . close ( ) ; } } } protected void definePackage ( File container , String className ) throws IOException { int classIndex = className . lastIndexOf ( '.' ) ; if ( classIndex == - 1 ) { return ; } String packageName = className . substring ( 0 , classIndex ) ; if ( getPackage ( packageName ) != null ) { return ; } Manifest manifest = getJarManifest ( container ) ; if ( manifest == null ) { definePackage ( packageName , null , null , null , null , null , null , null ) ; } else { definePackage ( container , packageName , manifest ) ; } } protected void definePackage ( File container , String packageName , Manifest manifest ) { String sectionName = packageName . replace ( '.' , '/' ) + "/" ; String specificationTitle = null ; String specificationVendor = null ; String specificationVersion = null ; String implementationTitle = null ; String implementationVendor = null ; String implementationVersion = null ; String sealedString = null ; URL sealBase = null ; Attributes sectionAttributes = manifest . getAttributes ( sectionName ) ; if ( sectionAttributes != null ) { specificationTitle = sectionAttributes . getValue ( Name . SPECIFICATION_TITLE ) ; specificationVendor = sectionAttributes . getValue ( Name . SPECIFICATION_VENDOR ) ; specificationVersion = sectionAttributes . getValue ( Name . SPECIFICATION_VERSION ) ; implementationTitle = sectionAttributes . getValue ( Name . IMPLEMENTATION_TITLE ) ; implementationVendor = sectionAttributes . getValue ( Name . IMPLEMENTATION_VENDOR ) ; implementationVersion = sectionAttributes . getValue ( Name . IMPLEMENTATION_VERSION ) ; sealedString = sectionAttributes . getValue ( Name . SEALED ) ; } Attributes mainAttributes = manifest . getMainAttributes ( ) ; if ( mainAttributes != null ) { if ( specificationTitle == null ) { specificationTitle = mainAttributes . getValue ( Name . SPECIFICATION_TITLE ) ; } if ( specificationVendor == null ) { specificationVendor = mainAttributes . getValue ( Name . SPECIFICATION_VENDOR ) ; } if ( specificationVersion == null ) { specificationVersion = mainAttributes . getValue ( Name . SPECIFICATION_VERSION ) ; } if ( implementationTitle == null ) { implementationTitle = mainAttributes . getValue ( Name . IMPLEMENTATION_TITLE ) ; } if ( implementationVendor == null ) { implementationVendor = mainAttributes . getValue ( Name . IMPLEMENTATION_VENDOR ) ; } if ( implementationVersion == null ) { implementationVersion = mainAttributes . getValue ( Name . IMPLEMENTATION_VERSION ) ; } if ( sealedString == null ) { sealedString = mainAttributes . getValue ( Name . SEALED ) ; } } if ( sealedString != null && sealedString . equalsIgnoreCase ( "true" ) ) { try { sealBase = new URL ( "file:" + container . getPath ( ) ) ; } catch ( MalformedURLException e ) { } } definePackage ( packageName , specificationTitle , specificationVersion , specificationVendor , implementationTitle , implementationVersion , implementationVendor , sealBase ) ; } protected void addPathFile ( File pathComponent ) throws IOException { super . addPathFile ( pathComponent ) ; if ( pathComponent . isDirectory ( ) ) { return ; } String classpath = null ; ZipFile jarFile = null ; InputStream manifestStream = null ; try { jarFile = new ZipFile ( pathComponent ) ; manifestStream = jarFile . getInputStream ( new ZipEntry ( "META-INF/MANIFEST.MF" ) ) ; if ( manifestStream == null ) { return ; } Reader manifestReader = new InputStreamReader ( manifestStream , "UTF-8" ) ; org . apache . tools . ant . taskdefs . Manifest manifest = new org . apache . tools . ant . taskdefs . Manifest ( manifestReader ) ; classpath = manifest . getMainSection ( ) . getAttributeValue ( "Class-Path" ) ; } catch ( org . apache . tools . ant . taskdefs . ManifestException e ) { } finally { if ( manifestStream != null ) { manifestStream . close ( ) ; } if ( jarFile != null ) { jarFile . close ( ) ; } } if ( classpath != null ) { URL baseURL = fileUtils . getFileURL ( pathComponent ) ; StringTokenizer st = new StringTokenizer ( classpath ) ; while ( st . hasMoreTokens ( ) ) { String classpathElement = st . nextToken ( ) ; URL libraryURL = new URL ( baseURL , classpathElement ) ; if ( ! libraryURL . getProtocol ( ) . equals ( "file" ) ) { log ( "Skipping jar library " + classpathElement + " since only relative URLs are supported by this" + " loader" , Project . MSG_VERBOSE ) ; continue ; } File libraryFile = new File ( libraryURL . getFile ( ) ) ; if ( libraryFile . exists ( ) && ! isInPath ( libraryFile ) ) { addPathFile ( libraryFile ) ; } } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . security . DigestInputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . NoSuchProviderException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileInputStream ; import java . io . FileReader ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . HashMap ; import java . util . Map ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; import java . util . Set ; import java . util . Arrays ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . FileSet ; public class Checksum extends MatchingTask implements Condition { private File file = null ; private File todir ; private String algorithm = "MD5" ; private String provider = null ; private String fileext ; private String property ; private Map allDigests = new HashMap ( ) ; private Map relativeFilePaths = new HashMap ( ) ; private String totalproperty ; private boolean forceOverwrite ; private String verifyProperty ; private Vector filesets = new Vector ( ) ; private Hashtable includeFileMap = new Hashtable ( ) ; private MessageDigest messageDigest ; private boolean isCondition ; private int readBufferSize = 8 * 1024 ; public void setFile ( File file ) { this . file = file ; } public void setTodir ( File todir ) { this . todir = todir ; } public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void setProvider ( String provider ) { this . provider = provider ; } public void setFileext ( String fileext ) { this . fileext = fileext ; } public void setProperty ( String property ) { this . property = property ; } public void setTotalproperty ( String totalproperty ) { this . totalproperty = totalproperty ; } public void setVerifyproperty ( String verifyProperty ) { this . verifyProperty = verifyProperty ; } public void setForceOverwrite ( boolean forceOverwrite ) { this . forceOverwrite = forceOverwrite ; } public void setReadBufferSize ( int size ) { this . readBufferSize = size ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { isCondition = false ; boolean value = validateAndExecute ( ) ; if ( verifyProperty != null ) { getProject ( ) . setNewProperty ( verifyProperty , new Boolean ( value ) . toString ( ) ) ; } } public boolean eval ( ) throws BuildException { isCondition = true ; return validateAndExecute ( ) ; } private boolean validateAndExecute ( ) throws BuildException { String savedFileExt = fileext ; if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Checksum cannot be generated for directories" ) ; } if ( file != null && totalproperty != null ) { throw new BuildException ( "File and Totalproperty cannot co-exist." ) ; } if ( property != null && fileext != null ) { throw new BuildException ( "Property and FileExt cannot co-exist." ) ; } if ( property != null ) { if ( forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when Property is specified" ) ; } if ( file != null ) { if ( filesets . size ( ) > 0 ) { throw new BuildException ( "Multiple files cannot be used " + "when Property is specified" ) ; } } else { if ( filesets . size ( ) > 1 ) { throw new BuildException ( "Multiple files cannot be used " + "when Property is specified" ) ; } } } if ( verifyProperty != null ) { isCondition = true ; } if ( verifyProperty != null && forceOverwrite ) { throw new BuildException ( "VerifyProperty and ForceOverwrite cannot co-exist." ) ; } if ( isCondition && forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when " + "conditions are being used." ) ; } messageDigest = null ; if ( provider != null ) { try { messageDigest = MessageDigest . getInstance ( algorithm , provider ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , getLocation ( ) ) ; } catch ( NoSuchProviderException noprovider ) { throw new BuildException ( noprovider , getLocation ( ) ) ; } } else { try { messageDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , getLocation ( ) ) ; } } if ( messageDigest == null ) { throw new BuildException ( "Unable to create Message Digest" , getLocation ( ) ) ; } if ( fileext == null ) { fileext = "." + algorithm ; } else if ( fileext . trim ( ) . length ( ) == 0 ) { throw new BuildException ( "File extension when specified must not be an empty string" ) ; } try { int sizeofFileSet = filesets . size ( ) ; for ( int i = 0 ; i < sizeofFileSet ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { File src = new File ( fs . getDir ( getProject ( ) ) , srcFiles [ j ] ) ; if ( totalproperty != null || todir != null ) { String relativePath = srcFiles [ j ] . replace ( File . separatorChar , '/' ) ; relativeFilePaths . put ( src , relativePath ) ; } addToIncludeFileMap ( src ) ; } } addToIncludeFileMap ( file ) ; return generateChecksums ( ) ; } finally { fileext = savedFileExt ; includeFileMap . clear ( ) ; } } private void addToIncludeFileMap ( File file ) throws BuildException { if ( file != null ) { if ( file . exists ( ) ) { if ( property == null ) { File checksumFile = getChecksumFile ( file ) ; if ( forceOverwrite || isCondition || ( file . lastModified ( ) > checksumFile . lastModified ( ) ) ) { includeFileMap . put ( file , checksumFile ) ; } else { log ( file + " omitted as " + checksumFile + " is up to date." , Project . MSG_VERBOSE ) ; if ( totalproperty != null ) { String checksum = null ; try { BufferedReader diskChecksumReader = new BufferedReader ( new FileReader ( checksumFile ) ) ; checksum = diskChecksumReader . readLine ( ) ; } catch ( IOException e ) { throw new BuildException ( "Couldn't read checksum file " + checksumFile , e ) ; } byte [ ] digest = decodeHex ( checksum . toCharArray ( ) ) ; allDigests . put ( file , digest ) ; } } } else { includeFileMap . put ( file , property ) ; } } else { String message = "Could not find file " + file . getAbsolutePath ( ) + " to generate checksum for." ; log ( message ) ; throw new BuildException ( message , getLocation ( ) ) ; } } } private File getChecksumFile ( File file ) { File directory ; if ( todir != null ) { String path = ( String ) relativeFilePaths . get ( file ) ; directory = new File ( todir , path ) . getParentFile ( ) ; directory . mkdirs ( ) ; } else { directory = file . getParentFile ( ) ; } File checksumFile = new File ( directory , file . getName ( ) + fileext ) ; return checksumFile ; } private boolean generateChecksums ( ) throws BuildException { boolean checksumMatches = true ; FileInputStream fis = null ; FileOutputStream fos = null ; byte [ ] buf = new byte [ readBufferSize ] ; try { for ( Enumeration e = includeFileMap . keys ( ) ; e . hasMoreElements ( ) ; ) { messageDigest . reset ( ) ; File src = ( File ) e . nextElement ( ) ; if ( ! isCondition ) { log ( "Calculating " + algorithm + " checksum for " + src , Project . MSG_VERBOSE ) ; } fis = new FileInputStream ( src ) ; DigestInputStream dis = new DigestInputStream ( fis , messageDigest ) ; while ( dis . read ( buf , 0 , readBufferSize ) != - 1 ) { ; } dis . close ( ) ; fis . close ( ) ; fis = null ; byte [ ] fileDigest = messageDigest . digest ( ) ; if ( totalproperty != null ) { allDigests . put ( src , fileDigest ) ; } String checksum = createDigestString ( fileDigest ) ; Object destination = includeFileMap . get ( src ) ; if ( destination instanceof java . lang . String ) { String prop = ( String ) destination ; if ( isCondition ) { checksumMatches = checksumMatches && checksum . equals ( property ) ; } else { getProject ( ) . setNewProperty ( prop , checksum ) ; } } else if ( destination instanceof java . io . File ) { if ( isCondition ) { File existingFile = ( File ) destination ; if ( existingFile . exists ( ) ) { fis = new FileInputStream ( existingFile ) ; InputStreamReader isr = new InputStreamReader ( fis ) ; BufferedReader br = new BufferedReader ( isr ) ; String suppliedChecksum = br . readLine ( ) ; fis . close ( ) ; fis = null ; br . close ( ) ; isr . close ( ) ; checksumMatches = checksumMatches && checksum . equals ( suppliedChecksum ) ; } else { checksumMatches = false ; } } else { File dest = ( File ) destination ; fos = new FileOutputStream ( dest ) ; fos . write ( checksum . getBytes ( ) ) ; fos . close ( ) ; fos = null ; } } } if ( totalproperty != null ) { Set keys = allDigests . keySet ( ) ; Object [ ] keyArray = keys . toArray ( ) ; Arrays . sort ( keyArray ) ; messageDigest . reset ( ) ; for ( int i = 0 ; i < keyArray . length ; i ++ ) { File src = ( File ) keyArray [ i ] ; byte [ ] digest = ( byte [ ] ) allDigests . get ( src ) ; messageDigest . update ( digest ) ; String fileName = ( String ) relativeFilePaths . get ( src ) ; messageDigest . update ( fileName . getBytes ( ) ) ; } String totalChecksum = createDigestString ( messageDigest . digest ( ) ) ; getProject ( ) . setNewProperty ( totalproperty , totalChecksum ) ; } } catch ( Exception e ) { throw new BuildException ( e , getLocation ( ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException e ) { } } } return checksumMatches ; } private String createDigestString ( byte [ ] fileDigest ) { StringBuffer checksumSb = new StringBuffer ( ) ; for ( int i = 0 ; i < fileDigest . length ; i ++ ) { String hexStr = Integer . toHexString ( 0x00ff & fileDigest [ i ] ) ; if ( hexStr . length ( ) < 2 ) { checksumSb . append ( "0" ) ; } checksumSb . append ( hexStr ) ; } return checksumSb . toString ( ) ; } public static byte [ ] decodeHex ( char [ ] data ) throws BuildException { int l = data . length ; if ( ( l & 0x01 ) != 0 ) { throw new BuildException ( "odd number of characters." ) ; } byte [ ] out = new byte [ l > > 1 ] ; for ( int i = 0 , j = 0 ; j < l ; i ++ ) { int f = Character . digit ( data [ j ++ ] , 16 ) << 4 ; f = f | Character . digit ( data [ j ++ ] , 16 ) ; out [ i ] = ( byte ) ( f & 0xFF ) ; } return out ; } } 	1
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . security . DigestInputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . NoSuchProviderException ; import org . apache . tools . ant . BuildException ; public class DigestAlgorithm implements Algorithm { private String algorithm = "MD5" ; private String provider = null ; private MessageDigest messageDigest = null ; private int readBufferSize = 8 * 1024 ; public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void setProvider ( String provider ) { this . provider = provider ; } public void initMessageDigest ( ) { if ( messageDigest != null ) { return ; } if ( ( provider != null ) && ! "" . equals ( provider ) && ! "null" . equals ( provider ) ) { try { messageDigest = MessageDigest . getInstance ( algorithm , provider ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo ) ; } catch ( NoSuchProviderException noprovider ) { throw new BuildException ( noprovider ) ; } } else { try { messageDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo ) ; } } } public boolean isValid ( ) { return true ; } public String getValue ( File file ) { initMessageDigest ( ) ; String checksum = null ; try { if ( ! file . canRead ( ) ) { return null ; } FileInputStream fis = null ; FileOutputStream fos = null ; byte [ ] buf = new byte [ readBufferSize ] ; try { messageDigest . reset ( ) ; fis = new FileInputStream ( file ) ; DigestInputStream dis = new DigestInputStream ( fis , messageDigest ) ; while ( dis . read ( buf , 0 , readBufferSize ) != - 1 ) { } dis . close ( ) ; fis . close ( ) ; fis = null ; byte [ ] fileDigest = messageDigest . digest ( ) ; StringBuffer checksumSb = new StringBuffer ( ) ; for ( int i = 0 ; i < fileDigest . length ; i ++ ) { String hexStr = Integer . toHexString ( 0x00ff & fileDigest [ i ] ) ; if ( hexStr . length ( ) < 2 ) { checksumSb . append ( "0" ) ; } checksumSb . append ( hexStr ) ; } checksum = checksumSb . toString ( ) ; } catch ( Exception e ) { return null ; } } catch ( Exception e ) { return null ; } return checksum ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "<DigestAlgorithm:" ) ; buf . append ( "algorithm=" ) . append ( algorithm ) ; buf . append ( ";provider=" ) . append ( provider ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 	1
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; public class ChangeLogTask extends Task { private File m_usersFile ; private Vector m_cvsUsers = new Vector ( ) ; private File m_dir ; private File m_destfile ; private Date m_start ; private Date m_stop ; private final Vector m_filesets = new Vector ( ) ; public void setDir ( final File dir ) { m_dir = dir ; } public void setDestfile ( final File destfile ) { m_destfile = destfile ; } public void setUsersfile ( final File usersFile ) { m_usersFile = usersFile ; } public void addUser ( final CvsUser user ) { m_cvsUsers . addElement ( user ) ; } public void setStart ( final Date start ) { m_start = start ; } public void setEnd ( final Date stop ) { m_stop = stop ; } public void setDaysinpast ( final int days ) { final long time = System . currentTimeMillis ( ) - ( long ) days * 24 * 60 * 60 * 1000 ; setStart ( new Date ( time ) ) ; } public void addFileset ( final FileSet fileSet ) { m_filesets . addElement ( fileSet ) ; } public void execute ( ) throws BuildException { File savedDir = m_dir ; try { validate ( ) ; final Properties userList = new Properties ( ) ; loadUserlist ( userList ) ; for ( Enumeration e = m_cvsUsers . elements ( ) ; e . hasMoreElements ( ) ; ) { final CvsUser user = ( CvsUser ) e . nextElement ( ) ; user . validate ( ) ; userList . put ( user . getUserID ( ) , user . getDisplayname ( ) ) ; } final Commandline command = new Commandline ( ) ; command . setExecutable ( "cvs" ) ; command . createArgument ( ) . setValue ( "log" ) ; if ( null != m_start ) { final SimpleDateFormat outputDate = new SimpleDateFormat ( "yyyy-MM-dd" ) ; final String dateRange = ">=" + outputDate . format ( m_start ) ; command . createArgument ( ) . setValue ( "-d" ) ; command . createArgument ( ) . setValue ( dateRange ) ; } if ( ! m_filesets . isEmpty ( ) ) { final Enumeration e = m_filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { final FileSet fileSet = ( FileSet ) e . nextElement ( ) ; final DirectoryScanner scanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; final String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { command . createArgument ( ) . setValue ( files [ i ] ) ; } } } final ChangeLogParser parser = new ChangeLogParser ( ) ; final RedirectingStreamHandler handler = new RedirectingStreamHandler ( parser ) ; log ( command . describeCommand ( ) , Project . MSG_VERBOSE ) ; final Execute exe = new Execute ( handler ) ; exe . setWorkingDirectory ( m_dir ) ; exe . setCommandline ( command . getCommandline ( ) ) ; exe . setAntRun ( getProject ( ) ) ; try { final int resultCode = exe . execute ( ) ; if ( Execute . isFailure ( resultCode ) ) { throw new BuildException ( "Error running cvs log" ) ; } } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) ) ; } final String errors = handler . getErrors ( ) ; if ( null != errors ) { log ( errors , Project . MSG_ERR ) ; } final CVSEntry [ ] entrySet = parser . getEntrySetAsArray ( ) ; final CVSEntry [ ] filteredEntrySet = filterEntrySet ( entrySet ) ; replaceAuthorIdWithName ( userList , filteredEntrySet ) ; writeChangeLog ( filteredEntrySet ) ; } finally { m_dir = savedDir ; } } private void validate ( ) throws BuildException { if ( null == m_dir ) { m_dir = getProject ( ) . getBaseDir ( ) ; } if ( null == m_destfile ) { final String message = "Destfile must be set." ; throw new BuildException ( message ) ; } if ( ! m_dir . exists ( ) ) { final String message = "Cannot find base dir " + m_dir . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } if ( null != m_usersFile && ! m_usersFile . exists ( ) ) { final String message = "Cannot find user lookup list " + m_usersFile . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } } private void loadUserlist ( final Properties userList ) throws BuildException { if ( null != m_usersFile ) { try { userList . load ( new FileInputStream ( m_usersFile ) ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } } } private CVSEntry [ ] filterEntrySet ( final CVSEntry [ ] entrySet ) { final Vector results = new Vector ( ) ; for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry cvsEntry = entrySet [ i ] ; final Date date = cvsEntry . getDate ( ) ; if ( null != m_start && m_start . after ( date ) ) { continue ; } if ( null != m_stop && m_stop . before ( date ) ) { continue ; } results . addElement ( cvsEntry ) ; } final CVSEntry [ ] resultArray = new CVSEntry [ results . size ( ) ] ; results . copyInto ( resultArray ) ; return resultArray ; } private void replaceAuthorIdWithName ( final Properties userList , final CVSEntry [ ] entrySet ) { for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry entry = entrySet [ i ] ; if ( userList . containsKey ( entry . getAuthor ( ) ) ) { entry . setAuthor ( userList . getProperty ( entry . getAuthor ( ) ) ) ; } } } private void writeChangeLog ( final CVSEntry [ ] entrySet ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( m_destfile ) ; final PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; final ChangeLogWriter serializer = new ChangeLogWriter ( ) ; serializer . printChangeLog ( writer , entrySet ) ; } catch ( final UnsupportedEncodingException uee ) { getProject ( ) . log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( final IOException ioe ) { } } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringReader ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; public class Execute { public static final int INVALID = Integer . MAX_VALUE ; private String [ ] cmdl = null ; private String [ ] env = null ; private int exitValue = INVALID ; private ExecuteStreamHandler streamHandler ; private ExecuteWatchdog watchdog ; private File workingDirectory = null ; private Project project = null ; private boolean newEnvironment = false ; private boolean useVMLauncher = true ; private static String antWorkingDirectory = System . getProperty ( "user.dir" ) ; private static CommandLauncher vmLauncher = null ; private static CommandLauncher shellLauncher = null ; private static Vector procEnvironment = null ; private boolean spawn = false ; private static ProcessDestroyer processDestroyer = new ProcessDestroyer ( ) ; static { try { if ( Os . isFamily ( "openvms" ) ) { vmLauncher = new VmsCommandLauncher ( ) ; } else if ( ! Os . isFamily ( "os/2" ) ) { vmLauncher = new Java13CommandLauncher ( ) ; } } catch ( NoSuchMethodException exc ) { } if ( Os . isFamily ( "mac" ) && ! Os . isFamily ( "unix" ) ) { shellLauncher = new MacCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "os/2" ) ) { shellLauncher = new OS2CommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "windows" ) ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } if ( ! Os . isFamily ( "win9x" ) ) { shellLauncher = new WinNTCommandLauncher ( baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun.bat" , baseLauncher ) ; } } else if ( Os . isFamily ( "netware" ) ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } shellLauncher = new PerlScriptCommandLauncher ( "bin/antRun.pl" , baseLauncher ) ; } else if ( Os . isFamily ( "openvms" ) ) { shellLauncher = vmLauncher ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun" , new CommandLauncher ( ) ) ; } } public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public static synchronized Vector getProcEnvironment ( ) { if ( procEnvironment != null ) { return procEnvironment ; } procEnvironment = new Vector ( ) ; try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Execute exe = new Execute ( new PumpStreamHandler ( out ) ) ; exe . setCommandline ( getProcEnvCommand ( ) ) ; exe . setNewenvironment ( true ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { } BufferedReader in = new BufferedReader ( new StringReader ( toString ( out ) ) ) ; if ( Os . isFamily ( "openvms" ) ) { procEnvironment = addVMSLogicals ( procEnvironment , in ) ; return procEnvironment ; } String var = null ; String line , lineSep = System . getProperty ( "line.separator" ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . indexOf ( '=' ) == - 1 ) { if ( var == null ) { var = lineSep + line ; } else { var += lineSep + line ; } } else { if ( var != null ) { procEnvironment . addElement ( var ) ; } var = line ; } } if ( var != null ) { procEnvironment . addElement ( var ) ; } } catch ( java . io . IOException exc ) { exc . printStackTrace ( ) ; } return procEnvironment ; } private static String [ ] getProcEnvCommand ( ) { if ( Os . isFamily ( "os/2" ) ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else if ( Os . isFamily ( "windows" ) ) { if ( ! Os . isFamily ( "win9x" ) ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else { String [ ] cmd = { "command.com" , "/c" , "set" } ; return cmd ; } } else if ( Os . isFamily ( "z/os" ) || Os . isFamily ( "unix" ) ) { String [ ] cmd = new String [ 1 ] ; if ( new File ( "/bin/env" ) . canRead ( ) ) { cmd [ 0 ] = "/bin/env" ; } else if ( new File ( "/usr/bin/env" ) . canRead ( ) ) { cmd [ 0 ] = "/usr/bin/env" ; } else { cmd [ 0 ] = "env" ; } return cmd ; } else if ( Os . isFamily ( "netware" ) || Os . isFamily ( "os/400" ) ) { String [ ] cmd = { "env" } ; return cmd ; } else if ( Os . isFamily ( "openvms" ) ) { String [ ] cmd = { "show" , "logical" } ; return cmd ; } else { String [ ] cmd = null ; return cmd ; } } public static String toString ( ByteArrayOutputStream bos ) { if ( Os . isFamily ( "z/os" ) ) { try { return bos . toString ( "Cp1047" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } else if ( Os . isFamily ( "os/400" ) ) { try { return bos . toString ( "Cp500" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } return bos . toString ( ) ; } public Execute ( ) { this ( new PumpStreamHandler ( ) , null ) ; } public Execute ( ExecuteStreamHandler streamHandler ) { this ( streamHandler , null ) ; } public Execute ( ExecuteStreamHandler streamHandler , ExecuteWatchdog watchdog ) { setStreamHandler ( streamHandler ) ; this . watchdog = watchdog ; } public void setStreamHandler ( ExecuteStreamHandler streamHandler ) { this . streamHandler = streamHandler ; } public String [ ] getCommandline ( ) { return cmdl ; } public void setCommandline ( String [ ] commandline ) { cmdl = commandline ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public String [ ] getEnvironment ( ) { if ( env == null || newEnvironment ) { return env ; } return patchEnvironment ( ) ; } public void setEnvironment ( String [ ] env ) { this . env = env ; } public void setWorkingDirectory ( File wd ) { if ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) { workingDirectory = null ; } else { workingDirectory = wd ; } } public void setAntRun ( Project project ) throws BuildException { this . project = project ; } public void setVMLauncher ( boolean useVMLauncher ) { this . useVMLauncher = useVMLauncher ; } public static Process launch ( Project project , String [ ] command , String [ ] env , File dir , boolean useVM ) throws IOException { CommandLauncher launcher = vmLauncher != null ? vmLauncher : shellLauncher ; if ( ! useVM ) { launcher = shellLauncher ; } return launcher . exec ( project , command , env , dir ) ; } public int execute ( ) throws IOException { final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; try { streamHandler . setProcessInputStream ( process . getOutputStream ( ) ) ; streamHandler . setProcessOutputStream ( process . getInputStream ( ) ) ; streamHandler . setProcessErrorStream ( process . getErrorStream ( ) ) ; } catch ( IOException e ) { process . destroy ( ) ; throw e ; } streamHandler . start ( ) ; try { processDestroyer . add ( process ) ; if ( watchdog != null ) { watchdog . start ( process ) ; } waitFor ( process ) ; if ( watchdog != null ) { watchdog . stop ( ) ; } streamHandler . stop ( ) ; if ( watchdog != null ) { watchdog . checkException ( ) ; } return getExitValue ( ) ; } finally { processDestroyer . remove ( process ) ; } } public void spawn ( ) throws IOException { final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; if ( Os . isFamily ( "windows" ) ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { project . log ( "interruption in the sleep after having spawned a process" , Project . MSG_VERBOSE ) ; } } project . log ( "spawned process " + process . toString ( ) , Project . MSG_VERBOSE ) ; } protected void waitFor ( Process process ) { try { process . waitFor ( ) ; setExitValue ( process . exitValue ( ) ) ; } catch ( InterruptedException e ) { process . destroy ( ) ; } } protected void setExitValue ( int value ) { exitValue = value ; } public int getExitValue ( ) { return exitValue ; } public static boolean isFailure ( int exitValue ) { if ( Os . isFamily ( "openvms" ) ) { return ( exitValue % 2 ) == 0 ; } else { return exitValue != 0 ; } } public boolean killedProcess ( ) { return watchdog != null && watchdog . killedProcess ( ) ; } private String [ ] patchEnvironment ( ) { if ( Os . isFamily ( "openvms" ) ) { return env ; } Vector osEnv = ( Vector ) getProcEnvironment ( ) . clone ( ) ; for ( int i = 0 ; i < env . length ; i ++ ) { int pos = env [ i ] . indexOf ( '=' ) ; String key = env [ i ] . substring ( 0 , pos + 1 ) ; int size = osEnv . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { if ( ( ( String ) osEnv . elementAt ( j ) ) . startsWith ( key ) ) { osEnv . removeElementAt ( j ) ; break ; } } osEnv . addElement ( env [ i ] ) ; } String [ ] result = new String [ osEnv . size ( ) ] ; osEnv . copyInto ( result ) ; return result ; } public static void runCommand ( Task task , String [ ] cmdline ) throws BuildException { try { task . log ( Commandline . describeCommand ( cmdline ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( new LogStreamHandler ( task , Project . MSG_INFO , Project . MSG_ERR ) ) ; exe . setAntRun ( task . getProject ( ) ) ; exe . setCommandline ( cmdline ) ; int retval = exe . execute ( ) ; if ( isFailure ( retval ) ) { throw new BuildException ( cmdline [ 0 ] + " failed with return code " + retval , task . getLocation ( ) ) ; } } catch ( java . io . IOException exc ) { throw new BuildException ( "Could not launch " + cmdline [ 0 ] + ": " + exc , task . getLocation ( ) ) ; } } private static Vector addVMSLogicals ( Vector environment , BufferedReader in ) throws IOException { HashMap logicals = new HashMap ( ) ; String logName = null , logValue = null , newLogName ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( "\t=" ) ) { if ( logName != null ) { logValue += "," + line . substring ( 4 , line . length ( ) - 1 ) ; } } else if ( line . startsWith ( "  \"" ) ) { if ( logName != null ) { logicals . put ( logName , logValue ) ; } int eqIndex = line . indexOf ( '=' ) ; newLogName = line . substring ( 3 , eqIndex - 2 ) ; if ( logicals . containsKey ( newLogName ) ) { logName = null ; } else { logName = newLogName ; logValue = line . substring ( eqIndex + 3 , line . length ( ) - 1 ) ; } } } if ( logName != null ) { logicals . put ( logName , logValue ) ; } for ( Iterator i = logicals . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String logical = ( String ) i . next ( ) ; environment . add ( logical + "=" + logicals . get ( logical ) ) ; } return environment ; } private static class CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { if ( project != null ) { project . log ( "Execute:CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( cmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot execute a process in different " + "directory under this JVM" ) ; } } private static class Java11CommandLauncher extends CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { String [ ] newcmd = new String [ cmd . length ] ; for ( int i = 0 ; i < cmd . length ; i ++ ) { newcmd [ i ] = Commandline . quoteArgument ( cmd [ i ] ) ; } if ( project != null ) { project . log ( "Execute:Java11CommandLauncher: " + Commandline . describeCommand ( newcmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( newcmd , env ) ; } } private static class Java13CommandLauncher extends CommandLauncher { public Java13CommandLauncher ( ) throws NoSuchMethodException { myExecWithCWD = Runtime . class . getMethod ( "exec" , new Class [ ] { String [ ] . class , String [ ] . class , File . class } ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { try { if ( project != null ) { project . log ( "Execute:Java13CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } Object [ ] arguments = { cmd , env , workingDir } ; return ( Process ) myExecWithCWD . invoke ( Runtime . getRuntime ( ) , arguments ) ; } catch ( InvocationTargetException exc ) { Throwable realexc = exc . getTargetException ( ) ; if ( realexc instanceof ThreadDeath ) { throw ( ThreadDeath ) realexc ; } else if ( realexc instanceof IOException ) { throw ( IOException ) realexc ; } else { throw new BuildException ( "Unable to execute command" , realexc ) ; } } catch ( Exception exc ) { throw new BuildException ( "Unable to execute command" , exc ) ; } } private Method myExecWithCWD ; } private static class CommandLauncherProxy extends CommandLauncher { CommandLauncherProxy ( CommandLauncher launcher ) { myLauncher = launcher ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { return myLauncher . exec ( project , cmd , env ) ; } private CommandLauncher myLauncher ; } private static class OS2CommandLauncher extends CommandLauncherProxy { OS2CommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 7 ; final String cmdDir = commandDir . getAbsolutePath ( ) ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = cmdDir . substring ( 0 , 2 ) ; newcmd [ 3 ] = "&&" ; newcmd [ 4 ] = "cd" ; newcmd [ 5 ] = cmdDir . substring ( 2 ) ; newcmd [ 6 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class WinNTCommandLauncher extends CommandLauncherProxy { WinNTCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 6 ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = "cd" ; newcmd [ 3 ] = "/d" ; newcmd [ 4 ] = commandDir . getAbsolutePath ( ) ; newcmd [ 5 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class MacCommandLauncher extends CommandLauncherProxy { MacCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } System . getProperties ( ) . put ( "user.dir" , workingDir . getAbsolutePath ( ) ) ; try { return exec ( project , cmd , env ) ; } finally { System . getProperties ( ) . put ( "user.dir" , antWorkingDirectory ) ; } } } private static class ScriptCommandLauncher extends CommandLauncherProxy { ScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; myScript = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + myScript ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 2 ] ; newcmd [ 0 ] = antRun ; newcmd [ 1 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 2 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String myScript ; } private static class PerlScriptCommandLauncher extends CommandLauncherProxy { PerlScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; myScript = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + myScript ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 3 ] ; newcmd [ 0 ] = "perl" ; newcmd [ 1 ] = antRun ; newcmd [ 2 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 3 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String myScript ; } private static class VmsCommandLauncher extends Java13CommandLauncher { public VmsCommandLauncher ( ) throws NoSuchMethodException { super ( ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { String [ ] vmsCmd = { createCommandFile ( cmd , env ) . getPath ( ) } ; return super . exec ( project , vmsCmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { String [ ] vmsCmd = { createCommandFile ( cmd , env ) . getPath ( ) } ; return super . exec ( project , vmsCmd , env , workingDir ) ; } private File createCommandFile ( String [ ] cmd , String [ ] env ) throws IOException { File script = File . createTempFile ( "ANT" , ".COM" ) ; script . deleteOnExit ( ) ; PrintWriter out = null ; try { out = new PrintWriter ( new FileWriter ( script ) ) ; if ( env != null ) { int eqIndex ; for ( int i = 1 ; i < env . length ; i ++ ) { eqIndex = env [ i ] . indexOf ( '=' ) ; if ( eqIndex != - 1 ) { out . print ( "$ DEFINE/NOLOG " ) ; out . print ( env [ i ] . substring ( 0 , eqIndex ) ) ; out . print ( " \"" ) ; out . print ( env [ i ] . substring ( eqIndex + 1 ) ) ; out . println ( '\"' ) ; } } } out . print ( "$ " + cmd [ 0 ] ) ; for ( int i = 1 ; i < cmd . length ; i ++ ) { out . println ( " -" ) ; out . print ( cmd [ i ] ) ; } } finally { if ( out != null ) { out . close ( ) ; } } return script ; } } } 	1
package org . apache . tools . ant ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . List ; import java . util . StringTokenizer ; import org . apache . tools . ant . util . CollectionUtils ; public class Target implements TaskContainer { private String name ; private String ifCondition = "" ; private String unlessCondition = "" ; private List dependencies = null ; private List children = new ArrayList ( ) ; private Project project ; private String description = null ; public Target ( ) { } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setDepends ( String depS ) { if ( depS . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depS , "," , true ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; if ( token . equals ( "" ) || token . equals ( "," ) ) { throw new BuildException ( "Syntax Error: Depend " + "attribute for target \"" + getName ( ) + "\" has an empty string for dependency." ) ; } addDependency ( token ) ; if ( tok . hasMoreTokens ( ) ) { token = tok . nextToken ( ) ; if ( ! tok . hasMoreTokens ( ) || ! token . equals ( "," ) ) { throw new BuildException ( "Syntax Error: Depend " + "attribute for target \"" + getName ( ) + "\" ends with a , character" ) ; } } } } } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void addTask ( Task task ) { children . add ( task ) ; } public void addDataType ( RuntimeConfigurable r ) { children . add ( r ) ; } public Task [ ] getTasks ( ) { List tasks = new ArrayList ( children . size ( ) ) ; Iterator it = children . iterator ( ) ; while ( it . hasNext ( ) ) { Object o = it . next ( ) ; if ( o instanceof Task ) { tasks . add ( o ) ; } } return ( Task [ ] ) tasks . toArray ( new Task [ tasks . size ( ) ] ) ; } public void addDependency ( String dependency ) { if ( dependencies == null ) { dependencies = new ArrayList ( 2 ) ; } dependencies . add ( dependency ) ; } public Enumeration getDependencies ( ) { if ( dependencies != null ) { return Collections . enumeration ( dependencies ) ; } else { return new CollectionUtils . EmptyEnumeration ( ) ; } } public boolean dependsOn ( String other ) { if ( getProject ( ) != null ) { List l = getProject ( ) . topoSort ( getName ( ) , getProject ( ) . getTargets ( ) ) ; int myIdx = l . indexOf ( this ) ; int otherIdx = l . indexOf ( getProject ( ) . getTargets ( ) . get ( other ) ) ; return myIdx >= otherIdx ; } return false ; } public void setIf ( String property ) { this . ifCondition = ( property == null ) ? "" : property ; } public void setUnless ( String property ) { this . unlessCondition = ( property == null ) ? "" : property ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public String toString ( ) { return name ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { for ( int taskPosition = 0 ; taskPosition < children . size ( ) ; ++ taskPosition ) { Object o = children . get ( taskPosition ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . perform ( ) ; } else { RuntimeConfigurable r = ( RuntimeConfigurable ) o ; r . maybeConfigure ( project ) ; } } } else if ( ! testIfCondition ( ) ) { project . log ( this , "Skipped because property '" + project . replaceProperties ( this . ifCondition ) + "' not set." , Project . MSG_VERBOSE ) ; } else { project . log ( this , "Skipped because property '" + project . replaceProperties ( this . unlessCondition ) + "' set." , Project . MSG_VERBOSE ) ; } } public final void performTasks ( ) { try { project . fireTargetStarted ( this ) ; execute ( ) ; project . fireTargetFinished ( this , null ) ; } catch ( RuntimeException exc ) { project . fireTargetFinished ( this , exc ) ; throw exc ; } } void replaceChild ( Task el , RuntimeConfigurable o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . set ( index , o ) ; } } void replaceChild ( Task el , Task o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . set ( index , o ) ; } } private boolean testIfCondition ( ) { if ( "" . equals ( ifCondition ) ) { return true ; } String test = project . replaceProperties ( ifCondition ) ; return project . getProperty ( test ) != null ; } private boolean testUnlessCondition ( ) { if ( "" . equals ( unlessCondition ) ) { return true ; } String test = project . replaceProperties ( unlessCondition ) ; return project . getProperty ( test ) == null ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . PrintStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Permissions ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; public class ExecuteJava implements Runnable , TimeoutObserver { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; private Permissions perm = null ; private Method main = null ; private Long timeout = null ; private Throwable caught = null ; private boolean timedOut = false ; private Thread thread = null ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setPermissions ( Permissions permissions ) { perm = permissions ; } public void setOutput ( PrintStream out ) { } public void setTimeout ( Long timeout ) { this . timeout = timeout ; } public void execute ( Project project ) throws BuildException { final String classname = javaCommand . getExecutable ( ) ; AntClassLoader loader = null ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) } ; Class target = null ; if ( classpath == null ) { target = Class . forName ( classname ) ; } else { loader = project . createClassLoader ( classpath ) ; loader . setParent ( project . getCoreLoader ( ) ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; loader . setIsolated ( true ) ; loader . setThreadContextLoader ( ) ; loader . forceLoadClass ( classname ) ; target = Class . forName ( classname , true , loader ) ; } main = target . getMethod ( "main" , param ) ; if ( main == null ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } if ( ( main . getModifiers ( ) & Modifier . STATIC ) == 0 ) { throw new BuildException ( "main() method in " + classname + " is not declared static" ) ; } if ( timeout == null ) { run ( ) ; } else { thread = new Thread ( this , "ExecuteJava" ) ; Task currentThreadTask = project . getThreadTask ( Thread . currentThread ( ) ) ; project . registerThreadTask ( thread , currentThreadTask ) ; thread . setDaemon ( true ) ; Watchdog w = new Watchdog ( timeout . longValue ( ) ) ; w . addTimeoutObserver ( this ) ; synchronized ( this ) { thread . start ( ) ; w . start ( ) ; try { wait ( ) ; } catch ( InterruptedException e ) { } if ( timedOut ) { project . log ( "Timeout: sub-process interrupted" , Project . MSG_WARN ) ; } else { thread = null ; w . stop ( ) ; } } } if ( caught != null ) { throw caught ; } } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + "." + " Make sure you have it in your" + " classpath" ) ; } catch ( SecurityException e ) { throw e ; } catch ( Throwable e ) { throw new BuildException ( e ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; } if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } } } public void run ( ) { final Object [ ] argument = { javaCommand . getArguments ( ) } ; try { if ( perm != null ) { perm . setSecurityManager ( ) ; } main . invoke ( null , argument ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof InterruptedException ) ) { caught = t ; } } catch ( Throwable t ) { caught = t ; } finally { if ( perm != null ) { perm . restoreSecurityManager ( ) ; } synchronized ( this ) { notifyAll ( ) ; } } } public synchronized void timeoutOccured ( Watchdog w ) { if ( thread != null ) { timedOut = true ; thread . interrupt ( ) ; } notifyAll ( ) ; } public synchronized boolean killedProcess ( ) { return timedOut ; } } 	1
package org . apache . tools . ant ; import java . util . Enumeration ; import java . io . IOException ; public abstract class Task extends ProjectComponent { protected Target target ; protected String description ; protected Location location = Location . UNKNOWN_LOCATION ; protected String taskName ; protected String taskType ; protected RuntimeConfigurable wrapper ; private boolean invalid ; public Task ( ) { } public void setOwningTarget ( Target target ) { this . target = target ; } public Target getOwningTarget ( ) { return target ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } public void setTaskType ( String type ) { this . taskType = type ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void init ( ) throws BuildException { } public void execute ( ) throws BuildException { } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public RuntimeConfigurable getRuntimeConfigurableWrapper ( ) { if ( wrapper == null ) { wrapper = new RuntimeConfigurable ( this , getTaskName ( ) ) ; } return wrapper ; } public void setRuntimeConfigurableWrapper ( RuntimeConfigurable wrapper ) { this . wrapper = wrapper ; } public void maybeConfigure ( ) throws BuildException { if ( ! invalid ) { if ( wrapper != null ) { wrapper . maybeConfigure ( getProject ( ) ) ; } } else { getReplacement ( ) ; } } public void reconfigure ( ) { if ( wrapper != null ) { wrapper . reconfigure ( getProject ( ) ) ; } } protected void handleOutput ( String output ) { log ( output , Project . MSG_INFO ) ; } protected void handleFlush ( String output ) { handleOutput ( output ) ; } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { return getProject ( ) . defaultInput ( buffer , offset , length ) ; } protected void handleErrorOutput ( String output ) { log ( output , Project . MSG_WARN ) ; } protected void handleErrorFlush ( String output ) { handleErrorOutput ( output ) ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { getProject ( ) . log ( this , msg , msgLevel ) ; } public final void perform ( ) { if ( ! invalid ) { try { getProject ( ) . fireTaskStarted ( this ) ; maybeConfigure ( ) ; execute ( ) ; getProject ( ) . fireTaskFinished ( this , null ) ; } catch ( RuntimeException exc ) { if ( exc instanceof BuildException ) { BuildException be = ( BuildException ) exc ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( getLocation ( ) ) ; } } getProject ( ) . fireTaskFinished ( this , exc ) ; throw exc ; } } else { UnknownElement ue = getReplacement ( ) ; Task task = ue . getTask ( ) ; task . perform ( ) ; } } final void markInvalid ( ) { invalid = true ; } protected final boolean isInvalid ( ) { return invalid ; } private UnknownElement replacement ; private UnknownElement getReplacement ( ) { if ( replacement == null ) { replacement = new UnknownElement ( taskType ) ; replacement . setProject ( getProject ( ) ) ; replacement . setTaskType ( taskType ) ; replacement . setTaskName ( taskName ) ; replacement . setLocation ( location ) ; replacement . setOwningTarget ( target ) ; replacement . setRuntimeConfigurableWrapper ( wrapper ) ; wrapper . setProxy ( replacement ) ; replaceChildren ( wrapper , replacement ) ; target . replaceChild ( this , replacement ) ; replacement . maybeConfigure ( ) ; } return replacement ; } private void replaceChildren ( RuntimeConfigurable wrapper , UnknownElement parentElement ) { Enumeration e = wrapper . getChildren ( ) ; while ( e . hasMoreElements ( ) ) { RuntimeConfigurable childWrapper = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement childElement = new UnknownElement ( childWrapper . getElementTag ( ) ) ; parentElement . addChild ( childElement ) ; childElement . setProject ( getProject ( ) ) ; childElement . setRuntimeConfigurableWrapper ( childWrapper ) ; childWrapper . setProxy ( childElement ) ; replaceChildren ( childWrapper , childElement ) ; } } public String getTaskType ( ) { return taskType ; } protected RuntimeConfigurable getWrapper ( ) { return wrapper ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; public class XmlProperty extends org . apache . tools . ant . Task { private File src ; private String prefix = "" ; private boolean keepRoot = true ; private boolean validate = false ; private boolean collapseAttributes = false ; private boolean semanticAttributes = false ; private boolean includeSemanticAttribute = false ; private File rootDirectory = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private Hashtable addedAttributes = new Hashtable ( ) ; private static final String ID = "id" ; private static final String REF_ID = "refid" ; private static final String LOCATION = "location" ; private static final String VALUE = "value" ; private static final String PATH = "path" ; private static final String PATHID = "pathid" ; private static final String [ ] ATTRIBUTES = new String [ ] { ID , REF_ID , LOCATION , VALUE , PATH , PATHID } ; public XmlProperty ( ) { super ( ) ; } public void init ( ) { super . init ( ) ; } public void execute ( ) throws BuildException { if ( getFile ( ) == null ) { String msg = "XmlProperty task requires a file attribute" ; throw new BuildException ( msg ) ; } try { log ( "Loading " + src . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; if ( src . exists ( ) ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setValidating ( validate ) ; factory . setNamespaceAware ( false ) ; Document document = factory . newDocumentBuilder ( ) . parse ( src ) ; Element topElement = document . getDocumentElement ( ) ; addedAttributes = new Hashtable ( ) ; if ( keepRoot ) { addNodeRecursively ( topElement , prefix , null ) ; } else { NodeList topChildren = topElement . getChildNodes ( ) ; int numChildren = topChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( topChildren . item ( i ) , prefix , null ) ; } } } else { log ( "Unable to find property file: " + src . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; } } catch ( SAXException sxe ) { Exception x = sxe ; if ( sxe . getException ( ) != null ) { x = sxe . getException ( ) ; } throw new BuildException ( x ) ; } catch ( ParserConfigurationException pce ) { throw new BuildException ( pce ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe ) ; } } private void addNodeRecursively ( Node node , String prefix , Object container ) { String nodePrefix = prefix ; if ( node . getNodeType ( ) != Node . TEXT_NODE ) { if ( prefix . trim ( ) . length ( ) > 0 ) { nodePrefix += "." ; } nodePrefix += node . getNodeName ( ) ; } Object nodeObject = processNode ( node , nodePrefix , container ) ; if ( node . hasChildNodes ( ) ) { NodeList nodeChildren = node . getChildNodes ( ) ; int numChildren = nodeChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( nodeChildren . item ( i ) , nodePrefix , nodeObject ) ; } } } void addNodeRecursively ( org . w3c . dom . Node node , String prefix ) { addNodeRecursively ( node , prefix , null ) ; } public Object processNode ( Node node , String prefix , Object container ) { Object addedPath = null ; String id = null ; if ( node . hasAttributes ( ) ) { NamedNodeMap nodeAttributes = node . getAttributes ( ) ; Node idNode = nodeAttributes . getNamedItem ( ID ) ; id = ( semanticAttributes && idNode != null ? idNode . getNodeValue ( ) : null ) ; for ( int i = 0 ; i < nodeAttributes . getLength ( ) ; i ++ ) { Node attributeNode = nodeAttributes . item ( i ) ; if ( ! semanticAttributes ) { String attributeName = getAttributeName ( attributeNode ) ; String attributeValue = getAttributeValue ( attributeNode ) ; addProperty ( prefix + attributeName , attributeValue , null ) ; } else { String nodeName = attributeNode . getNodeName ( ) ; String attributeValue = getAttributeValue ( attributeNode ) ; Path containingPath = ( container != null && container instanceof Path ? ( Path ) container : null ) ; if ( nodeName . equals ( ID ) ) { continue ; } else if ( containingPath != null && nodeName . equals ( PATH ) ) { containingPath . setPath ( attributeValue ) ; } else if ( container instanceof Path && nodeName . equals ( REF_ID ) ) { containingPath . setPath ( attributeValue ) ; } else if ( container instanceof Path && nodeName . equals ( LOCATION ) ) { containingPath . setLocation ( resolveFile ( attributeValue ) ) ; } else if ( nodeName . equals ( PATHID ) ) { if ( container != null ) { throw new BuildException ( "XmlProperty does not " + "support nested paths" ) ; } addedPath = new Path ( getProject ( ) ) ; getProject ( ) . addReference ( attributeValue , addedPath ) ; } else { String attributeName = getAttributeName ( attributeNode ) ; addProperty ( prefix + attributeName , attributeValue , id ) ; } } } } String nodeText = null ; if ( node . getNodeType ( ) == Node . TEXT_NODE ) { nodeText = getAttributeValue ( node ) ; } else if ( ( node . getNodeType ( ) == Node . ELEMENT_NODE ) && ( node . getChildNodes ( ) . getLength ( ) == 1 ) && ( node . getFirstChild ( ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) ) { nodeText = node . getFirstChild ( ) . getNodeValue ( ) ; } if ( nodeText != null ) { if ( semanticAttributes && id == null && container instanceof String ) { id = ( String ) container ; System . out . println ( "Setting id = " + id ) ; } if ( nodeText . trim ( ) . length ( ) != 0 ) { addProperty ( prefix , nodeText , id ) ; } } return ( addedPath != null ? addedPath : id ) ; } private void addProperty ( String name , String value , String id ) { String msg = name + ":" + value ; if ( id != null ) { msg += ( "(id=" + id + ")" ) ; } log ( msg , Project . MSG_DEBUG ) ; if ( addedAttributes . containsKey ( name ) ) { value = ( String ) addedAttributes . get ( name ) + "," + value ; getProject ( ) . setProperty ( name , value ) ; } else { getProject ( ) . setNewProperty ( name , value ) ; } addedAttributes . put ( name , value ) ; if ( id != null ) { getProject ( ) . addReference ( id , value ) ; } } private String getAttributeName ( Node attributeNode ) { String attributeName = attributeNode . getNodeName ( ) ; if ( semanticAttributes ) { if ( attributeName . equals ( REF_ID ) ) { return "" ; } else if ( ! isSemanticAttribute ( attributeName ) || includeSemanticAttribute ) { return "." + attributeName ; } else { return "" ; } } else if ( collapseAttributes ) { return "." + attributeName ; } else { return "(" + attributeName + ")" ; } } private static boolean isSemanticAttribute ( String attributeName ) { for ( int i = 0 ; i < ATTRIBUTES . length ; i ++ ) { if ( attributeName . equals ( ATTRIBUTES [ i ] ) ) { return true ; } } return false ; } private String getAttributeValue ( Node attributeNode ) { String nodeValue = attributeNode . getNodeValue ( ) . trim ( ) ; if ( semanticAttributes ) { String attributeName = attributeNode . getNodeName ( ) ; nodeValue = getProject ( ) . replaceProperties ( nodeValue ) ; if ( attributeName . equals ( LOCATION ) ) { File f = resolveFile ( nodeValue ) ; return f . getPath ( ) ; } else if ( attributeName . equals ( REF_ID ) ) { Object ref = getProject ( ) . getReference ( nodeValue ) ; if ( ref != null ) { return ref . toString ( ) ; } } } return nodeValue ; } public void setFile ( File src ) { this . src = src ; } public void setPrefix ( String prefix ) { this . prefix = prefix . trim ( ) ; } public void setKeeproot ( boolean keepRoot ) { this . keepRoot = keepRoot ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public void setCollapseAttributes ( boolean collapseAttributes ) { this . collapseAttributes = collapseAttributes ; } public void setSemanticAttributes ( boolean semanticAttributes ) { this . semanticAttributes = semanticAttributes ; } public void setRootDirectory ( File rootDirectory ) { this . rootDirectory = rootDirectory ; } public void setIncludeSemanticAttribute ( boolean includeSemanticAttribute ) { this . includeSemanticAttribute = includeSemanticAttribute ; } protected File getFile ( ) { return this . src ; } protected String getPrefix ( ) { return this . prefix ; } protected boolean getKeeproot ( ) { return this . keepRoot ; } protected boolean getValidate ( ) { return this . validate ; } protected boolean getCollapseAttributes ( ) { return this . collapseAttributes ; } protected boolean getSemanticAttributes ( ) { return this . semanticAttributes ; } protected File getRootDirectory ( ) { return this . rootDirectory ; } protected boolean getIncludeSementicAttribute ( ) { return this . includeSemanticAttribute ; } private File resolveFile ( String fileName ) { if ( rootDirectory == null ) { return getProject ( ) . resolveFile ( fileName ) ; } return fileUtils . resolveFile ( rootDirectory , fileName ) ; } } 	1
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import java . io . File ; import java . util . Vector ; public class ResourceUtils { public static Resource [ ] selectOutOfDateSources ( ProjectComponent logTo , Resource [ ] source , FileNameMapper mapper , ResourceFactory targets ) { long now = ( new java . util . Date ( ) ) . getTime ( ) ; if ( Os . isFamily ( "windows" ) ) { now += 2000 ; } Vector vresult = new Vector ( ) ; for ( int counter = 0 ; counter < source . length ; counter ++ ) { if ( source [ counter ] . getLastModified ( ) > now ) { logTo . log ( "Warning: " + source [ counter ] . getName ( ) + " modified in the future." , Project . MSG_WARN ) ; } String [ ] targetnames = mapper . mapFileName ( source [ counter ] . getName ( ) . replace ( '/' , File . separatorChar ) ) ; if ( targetnames != null ) { boolean added = false ; StringBuffer targetList = new StringBuffer ( ) ; for ( int ctarget = 0 ; ! added && ctarget < targetnames . length ; ctarget ++ ) { Resource atarget = targets . getResource ( targetnames [ ctarget ] . replace ( File . separatorChar , '/' ) ) ; if ( ! atarget . isExists ( ) ) { logTo . log ( source [ counter ] . getName ( ) + " added as " + atarget . getName ( ) + " doesn\'t exist." , Project . MSG_VERBOSE ) ; vresult . addElement ( source [ counter ] ) ; added = true ; } else if ( ! atarget . isDirectory ( ) && atarget . getLastModified ( ) < source [ counter ] . getLastModified ( ) ) { logTo . log ( source [ counter ] . getName ( ) + " added as " + atarget . getName ( ) + " is outdated." , Project . MSG_VERBOSE ) ; vresult . addElement ( source [ counter ] ) ; added = true ; } else { if ( targetList . length ( ) > 0 ) { targetList . append ( ", " ) ; } targetList . append ( atarget . getName ( ) ) ; } } if ( ! added ) { logTo . log ( source [ counter ] . getName ( ) + " omitted as " + targetList . toString ( ) + ( targetnames . length == 1 ? " is" : " are " ) + " up to date." , Project . MSG_VERBOSE ) ; } } else { logTo . log ( source [ counter ] . getName ( ) + " skipped - don\'t know how to handle it" , Project . MSG_VERBOSE ) ; } } Resource [ ] result = new Resource [ vresult . size ( ) ] ; vresult . copyInto ( result ) ; return result ; } } 	1
package org . apache . tools . ant . taskdefs . compilers ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . Javac ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public abstract class DefaultCompilerAdapter implements CompilerAdapter { protected Path src ; protected File destDir ; protected String encoding ; protected boolean debug = false ; protected boolean optimize = false ; protected boolean deprecation = false ; protected boolean depend = false ; protected boolean verbose = false ; protected String target ; protected Path bootclasspath ; protected Path extdirs ; protected Path compileClasspath ; protected Path compileSourcepath ; protected Project project ; protected Location location ; protected boolean includeAntRuntime ; protected boolean includeJavaRuntime ; protected String memoryInitialSize ; protected String memoryMaximumSize ; protected File [ ] compileList ; protected static final String lSep = System . getProperty ( "line.separator" ) ; protected Javac attributes ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; public void setJavac ( Javac attributes ) { this . attributes = attributes ; src = attributes . getSrcdir ( ) ; destDir = attributes . getDestdir ( ) ; encoding = attributes . getEncoding ( ) ; debug = attributes . getDebug ( ) ; optimize = attributes . getOptimize ( ) ; deprecation = attributes . getDeprecation ( ) ; depend = attributes . getDepend ( ) ; verbose = attributes . getVerbose ( ) ; target = attributes . getTarget ( ) ; bootclasspath = attributes . getBootclasspath ( ) ; extdirs = attributes . getExtdirs ( ) ; compileList = attributes . getFileList ( ) ; compileClasspath = attributes . getClasspath ( ) ; compileSourcepath = attributes . getSourcepath ( ) ; project = attributes . getProject ( ) ; location = attributes . getLocation ( ) ; includeAntRuntime = attributes . getIncludeantruntime ( ) ; includeJavaRuntime = attributes . getIncludejavaruntime ( ) ; memoryInitialSize = attributes . getMemoryInitialSize ( ) ; memoryMaximumSize = attributes . getMemoryMaximumSize ( ) ; } public Javac getJavac ( ) { return attributes ; } protected Project getProject ( ) { return project ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( project ) ; if ( destDir != null ) { classpath . setLocation ( destDir ) ; } Path cp = compileClasspath ; if ( cp == null ) { cp = new Path ( project ) ; } if ( includeAntRuntime ) { classpath . addExisting ( cp . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( cp . concatSystemClasspath ( "ignore" ) ) ; } if ( includeJavaRuntime ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd ) { return setupJavacCommandlineSwitches ( cmd , false ) ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd , boolean useDebugLevel ) { Path classpath = getCompileClasspath ( ) ; Path sourcepath = null ; if ( compileSourcepath != null ) { sourcepath = compileSourcepath ; } else { sourcepath = src ; } String memoryParameterPrefix = assumeJava11 ( ) ? "-J-" : "-J-X" ; if ( memoryInitialSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryInitialSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "ms" + memoryInitialSize ) ; } } if ( memoryMaximumSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryMaximumSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "mx" + memoryMaximumSize ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; if ( assumeJava11 ( ) ) { Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; cp . append ( sourcepath ) ; cmd . createArgument ( ) . setPath ( cp ) ; } else { cmd . createArgument ( ) . setPath ( classpath ) ; if ( sourcepath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( sourcepath ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } if ( bootclasspath != null && bootclasspath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bootclasspath ) ; } if ( extdirs != null && extdirs . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } } if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { if ( useDebugLevel && ! assumeJava11 ( ) ) { String debugLevel = attributes . getDebugLevel ( ) ; if ( debugLevel != null ) { cmd . createArgument ( ) . setValue ( "-g:" + debugLevel ) ; } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else if ( ! assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-g:none" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( depend ) { if ( assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } else if ( assumeJava12 ( ) ) { cmd . createArgument ( ) . setValue ( "-Xdepend" ) ; } else { attributes . log ( "depend attribute is not supported by the " + "modern compiler" , Project . MSG_WARN ) ; } } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; return cmd ; } protected Commandline setupModernJavacCommandlineSwitches ( Commandline cmd ) { setupJavacCommandlineSwitches ( cmd , true ) ; if ( attributes . getSource ( ) != null && ! assumeJava13 ( ) ) { cmd . createArgument ( ) . setValue ( "-source" ) ; cmd . createArgument ( ) . setValue ( attributes . getSource ( ) ) ; } return cmd ; } protected Commandline setupModernJavacCommand ( ) { Commandline cmd = new Commandline ( ) ; setupModernJavacCommandlineSwitches ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected Commandline setupJavacCommand ( ) { return setupJavacCommand ( false ) ; } protected Commandline setupJavacCommand ( boolean debugLevelCheck ) { Commandline cmd = new Commandline ( ) ; setupJavacCommandlineSwitches ( cmd , debugLevelCheck ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . length != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( lSep ) ; for ( int i = 0 ; i < compileList . length ; i ++ ) { String arg = compileList [ i ] . getAbsolutePath ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg + lSep ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName ) { return executeExternalCompile ( args , firstFileName , true ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName , boolean quoteFiles ) { String [ ] commandArray = null ; File tmpFile = null ; try { if ( Commandline . toString ( args ) . length ( ) > 4096 && firstFileName >= 0 ) { PrintWriter out = null ; try { File userDir = getJavac ( ) . getTempdir ( ) ; if ( userDir == null ) { String userDirName = System . getProperty ( "user.dir" ) ; userDir = new File ( userDirName ) ; } tmpFile = fileUtils . createTempFile ( "files" , "" , userDir ) ; tmpFile . deleteOnExit ( ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < args . length ; i ++ ) { if ( quoteFiles && args [ i ] . indexOf ( " " ) > - 1 ) { args [ i ] = args [ i ] . replace ( '\\' , '/' ) ; out . println ( "\"" + args [ i ] + "\"" ) ; } else { out . println ( args [ i ] ) ; } } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + tmpFile ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = args ; } try { Execute exe = new Execute ( new LogStreamHandler ( attributes , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; return exe . getExitValue ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running " + args [ 0 ] + " compiler" , e , location ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void addExtdirsToClasspath ( Path classpath ) { classpath . addExtdirs ( extdirs ) ; } protected void addCurrentCompilerArgs ( Commandline cmd ) { cmd . addArguments ( getJavac ( ) . getCurrentCompilerArgs ( ) ) ; } protected boolean assumeJava11 ( ) { return "javac1.1" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) ; } protected boolean assumeJava12 ( ) { return "javac1.2" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) ; } protected boolean assumeJava13 ( ) { return "javac1.3" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "modern" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; public class Sync extends Task { private MyCopy _copy ; public void init ( ) throws BuildException { _copy = new MyCopy ( ) ; configureTask ( _copy ) ; _copy . setFiltering ( false ) ; _copy . setIncludeEmptyDirs ( false ) ; _copy . setPreserveLastModified ( true ) ; } private void configureTask ( Task helper ) { helper . setProject ( getProject ( ) ) ; helper . setTaskName ( getTaskName ( ) ) ; helper . setOwningTarget ( getOwningTarget ( ) ) ; helper . init ( ) ; } public void execute ( ) throws BuildException { File toDir = _copy . getToDir ( ) ; Hashtable allFiles = _copy . _dest2src ; boolean noRemovalNecessary = ! toDir . exists ( ) || toDir . list ( ) . length < 1 ; log ( "PASS#1: Copying files to " + toDir , Project . MSG_DEBUG ) ; _copy . execute ( ) ; if ( noRemovalNecessary ) { log ( "NO removing necessary in " + toDir , Project . MSG_DEBUG ) ; return ; } log ( "PASS#2: Removing orphan files from " + toDir , Project . MSG_DEBUG ) ; int [ ] removedFileCount = removeOrphanFiles ( allFiles , toDir ) ; logRemovedCount ( removedFileCount [ 0 ] , "dangling director" , "y" , "ies" ) ; logRemovedCount ( removedFileCount [ 1 ] , "dangling file" , "" , "s" ) ; if ( ! _copy . getIncludeEmptyDirs ( ) ) { log ( "PASS#3: Removing empty directories from " + toDir , Project . MSG_DEBUG ) ; int removedDirCount = removeEmptyDirectories ( toDir , false ) ; logRemovedCount ( removedDirCount , "empty director" , "y" , "ies" ) ; } } private void logRemovedCount ( int count , String prefix , String singularSuffix , String pluralSuffix ) { File toDir = _copy . getToDir ( ) ; String what = ( prefix == null ) ? "" : prefix ; what += ( count < 2 ) ? singularSuffix : pluralSuffix ; if ( count > 0 ) { log ( "Removed " + count + " " + what + " from " + toDir , Project . MSG_INFO ) ; } else { log ( "NO " + what + " to remove from " + toDir , Project . MSG_VERBOSE ) ; } } private int [ ] removeOrphanFiles ( Hashtable nonOrphans , File file ) { int [ ] removedCount = new int [ ] { 0 , 0 , 0 } ; if ( file . isDirectory ( ) ) { File [ ] children = file . listFiles ( ) ; for ( int i = 0 ; i < children . length ; ++ i ) { int [ ] temp = removeOrphanFiles ( nonOrphans , children [ i ] ) ; removedCount [ 0 ] += temp [ 0 ] ; removedCount [ 1 ] += temp [ 1 ] ; removedCount [ 2 ] += temp [ 2 ] ; } if ( nonOrphans . get ( file ) == null && removedCount [ 2 ] == 0 ) { log ( "Removing orphan directory: " + file , Project . MSG_DEBUG ) ; file . delete ( ) ; ++ removedCount [ 0 ] ; } else { removedCount [ 2 ] = 1 ; } } else { if ( nonOrphans . get ( file ) == null ) { log ( "Removing orphan file: " + file , Project . MSG_DEBUG ) ; file . delete ( ) ; ++ removedCount [ 1 ] ; } else { removedCount [ 2 ] = 1 ; } } return removedCount ; } private int removeEmptyDirectories ( File dir , boolean removeIfEmpty ) { int removedCount = 0 ; if ( dir . isDirectory ( ) ) { File [ ] children = dir . listFiles ( ) ; for ( int i = 0 ; i < children . length ; ++ i ) { File file = children [ i ] ; if ( file . isDirectory ( ) ) { removedCount += removeEmptyDirectories ( file , true ) ; } } if ( children . length > 0 ) { children = dir . listFiles ( ) ; } if ( children . length < 1 && removeIfEmpty ) { log ( "Removing empty directory: " + dir , Project . MSG_DEBUG ) ; dir . delete ( ) ; ++ removedCount ; } } return removedCount ; } public void setTodir ( File destDir ) { _copy . setTodir ( destDir ) ; } public void setVerbose ( boolean verbose ) { _copy . setVerbose ( verbose ) ; } public void setOverwrite ( boolean overwrite ) { _copy . setOverwrite ( overwrite ) ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { _copy . setIncludeEmptyDirs ( includeEmpty ) ; } public void setFailOnError ( boolean failonerror ) { _copy . setFailOnError ( failonerror ) ; } public void addFileset ( FileSet set ) { _copy . addFileset ( set ) ; } public static class MyCopy extends Copy { private Hashtable _dest2src = new Hashtable ( ) ; public MyCopy ( ) { } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { assertTrue ( "No mapper" , mapper instanceof IdentityMapper ) ; super . buildMap ( fromDir , toDir , names , mapper , map ) ; for ( int i = 0 ; i < names . length ; ++ i ) { String name = names [ i ] ; File dest = new File ( toDir , name ) ; _dest2src . put ( dest , fromDir ) ; } } public File getToDir ( ) { return destDir ; } public boolean getIncludeEmptyDirs ( ) { return includeEmpty ; } } private static void assertTrue ( String message , boolean condition ) { if ( ! condition ) { throw new BuildException ( "Assertion Error: " + message ) ; } } } 	1
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Comparator ; import java . util . Vector ; import java . util . Iterator ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . selectors . BaseExtendSelector ; public class ModifiedSelector extends BaseExtendSelector { private Cache cache = null ; private Algorithm algorithm = null ; private Comparator comparator = null ; private boolean update = true ; private boolean selectDirectories = true ; private boolean isConfigured = false ; private AlgorithmName algoName = null ; private CacheName cacheName = null ; private ComparatorName compName = null ; private Vector configParameter = new Vector ( ) ; private Vector specialParameter = new Vector ( ) ; public ModifiedSelector ( ) { } public void verifySettings ( ) { configure ( ) ; if ( cache == null ) { setError ( "Cache must be set." ) ; } else if ( algorithm == null ) { setError ( "Algorithm must be set." ) ; } else if ( ! cache . isValid ( ) ) { setError ( "Cache must be proper configured." ) ; } else if ( ! algorithm . isValid ( ) ) { setError ( "Algorithm must be proper configured." ) ; } } public void configure ( ) { if ( isConfigured ) { return ; } isConfigured = true ; org . apache . tools . ant . Project project = getProject ( ) ; String filename = "cache.properties" ; File cachefile = null ; if ( project != null ) { cachefile = new File ( project . getBaseDir ( ) , filename ) ; } else { cachefile = new File ( filename ) ; } cache = new PropertiesfileCache ( cachefile ) ; algorithm = new DigestAlgorithm ( ) ; comparator = new EqualComparator ( ) ; update = true ; selectDirectories = true ; for ( Iterator itConfig = configParameter . iterator ( ) ; itConfig . hasNext ( ) ; ) { Parameter par = ( Parameter ) itConfig . next ( ) ; if ( par . getName ( ) . indexOf ( "." ) > 0 ) { specialParameter . add ( par ) ; } else { useParameter ( par ) ; } } configParameter = new Vector ( ) ; String className = null ; String pkg = "org.apache.tools.ant.types.selectors.cacheselector" ; if ( algorithm == null ) { if ( "hashvalue" . equals ( algoName . getValue ( ) ) ) { className = pkg + ".HashvalueAlgorithm" ; } else if ( "digest" . equals ( algoName . getValue ( ) ) ) { className = pkg + ".DigestAlgorithm" ; } if ( className != null ) { try { algorithm = ( Algorithm ) Class . forName ( className ) . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } if ( cache == null ) { if ( "propertyfile" . equals ( cacheName . getValue ( ) ) ) { className = pkg + ".PropertiesfileCache" ; } if ( className != null ) { try { cache = ( Cache ) Class . forName ( className ) . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } if ( comparator == null ) { if ( "equal" . equals ( compName . getValue ( ) ) ) { className = pkg + ".EqualComparator" ; } else if ( "role" . equals ( compName . getValue ( ) ) ) { className = "java.text.RuleBasedCollator" ; } if ( className != null ) { try { comparator = ( Comparator ) Class . forName ( className ) . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } for ( Iterator itSpecial = specialParameter . iterator ( ) ; itSpecial . hasNext ( ) ; ) { Parameter par = ( Parameter ) itSpecial . next ( ) ; useParameter ( par ) ; } specialParameter = new Vector ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; File f = new File ( basedir , filename ) ; if ( f . isDirectory ( ) ) { return selectDirectories ; } String cachedValue = String . valueOf ( cache . get ( f . getAbsolutePath ( ) ) ) ; String newValue = algorithm . getValue ( f ) ; boolean rv = ( comparator . compare ( cachedValue , newValue ) != 0 ) ; if ( update && ! cachedValue . equals ( newValue ) ) { cache . put ( f . getAbsolutePath ( ) , newValue ) ; cache . save ( ) ; } return rv ; } public void setUpdate ( boolean update ) { this . update = update ; } public void setSeldirs ( boolean seldirs ) { selectDirectories = seldirs ; } public void addParam ( String key , Object value ) { Parameter par = new Parameter ( ) ; par . setName ( key ) ; par . setValue ( String . valueOf ( value ) ) ; configParameter . add ( par ) ; } public void addParam ( Parameter parameter ) { configParameter . add ( parameter ) ; } public void setParameters ( Parameter [ ] parameters ) { if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { configParameter . add ( parameters [ i ] ) ; } } } public void useParameter ( Parameter parameter ) { String key = parameter . getName ( ) ; String value = parameter . getValue ( ) ; if ( "cache" . equals ( key ) ) { CacheName cn = new CacheName ( ) ; cn . setValue ( value ) ; setCache ( cn ) ; } else if ( "algorithm" . equals ( key ) ) { AlgorithmName an = new AlgorithmName ( ) ; an . setValue ( value ) ; setAlgorithm ( an ) ; } else if ( "comparator" . equals ( key ) ) { ComparatorName cn = new ComparatorName ( ) ; cn . setValue ( value ) ; setComparator ( cn ) ; } else if ( "update" . equals ( key ) ) { boolean updateValue = ( "true" . equalsIgnoreCase ( value ) ) ? true : false ; setUpdate ( updateValue ) ; } else if ( "seldirs" . equals ( key ) ) { boolean sdValue = ( "true" . equalsIgnoreCase ( value ) ) ? true : false ; setSeldirs ( sdValue ) ; } else if ( key . startsWith ( "cache." ) ) { String name = key . substring ( 6 ) ; tryToSetAParameter ( cache , name , value ) ; } else if ( key . startsWith ( "algorithm." ) ) { String name = key . substring ( 10 ) ; tryToSetAParameter ( algorithm , name , value ) ; } else if ( key . startsWith ( "comparator." ) ) { String name = key . substring ( 11 ) ; tryToSetAParameter ( comparator , name , value ) ; } else { setError ( "Invalid parameter " + key ) ; } } protected void tryToSetAParameter ( Object obj , String name , String value ) { Project prj = ( getProject ( ) != null ) ? getProject ( ) : new Project ( ) ; IntrospectionHelper iHelper = IntrospectionHelper . getHelper ( prj , obj . getClass ( ) ) ; try { iHelper . setAttribute ( prj , obj , name , value ) ; } catch ( org . apache . tools . ant . BuildException e ) { } } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{modifiedselector" ) ; buf . append ( " update=" ) . append ( update ) ; buf . append ( " seldirs=" ) . append ( selectDirectories ) ; buf . append ( " cache=" ) . append ( cache ) ; buf . append ( " algorithm=" ) . append ( algorithm ) ; buf . append ( " comparator=" ) . append ( comparator ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public Cache getCache ( ) { return cache ; } public void setCache ( CacheName name ) { cacheName = name ; } public static class CacheName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "propertyfile" } ; } } public Algorithm getAlgorithm ( ) { return algorithm ; } public void setAlgorithm ( AlgorithmName name ) { algoName = name ; } public static class AlgorithmName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "hashvalue" , "digest" } ; } } public Comparator getComparator ( ) { return comparator ; } public void setComparator ( ComparatorName name ) { compName = name ; } public static class ComparatorName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "equal" , "rule" } ; } } } 	1
package org . apache . tools . ant . types ; import java . util . Properties ; import java . util . Stack ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileNameMapper ; public class Mapper extends DataType implements Cloneable { protected MapperType type = null ; public Mapper ( Project p ) { setProject ( p ) ; } public void setType ( MapperType type ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . type = type ; } protected String classname = null ; public void setClassname ( String classname ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . classname = classname ; } protected Path classpath = null ; public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } protected String from = null ; public void setFrom ( String from ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . from = from ; } protected String to = null ; public void setTo ( String to ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . to = to ; } public void setRefid ( Reference r ) throws BuildException { if ( type != null || from != null || to != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public FileNameMapper getImplementation ( ) throws BuildException { if ( isReference ( ) ) { return getRef ( ) . getImplementation ( ) ; } if ( type == null && classname == null ) { throw new BuildException ( "one of the attributes type or classname is required" ) ; } if ( type != null && classname != null ) { throw new BuildException ( "must not specify both type and classname attribute" ) ; } try { if ( type != null ) { classname = type . getImplementation ( ) ; } Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = getProject ( ) . createClassLoader ( classpath ) ; c = Class . forName ( classname , true , al ) ; } FileNameMapper m = ( FileNameMapper ) c . newInstance ( ) ; final Project project = getProject ( ) ; if ( project != null ) { project . setProjectReference ( m ) ; } m . setFrom ( from ) ; m . setTo ( to ) ; return m ; } catch ( BuildException be ) { throw be ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } finally { if ( type != null ) { classname = null ; } } } protected Mapper getRef ( ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Object o = getRefid ( ) . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Mapper ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a mapper" ; throw new BuildException ( msg ) ; } else { return ( Mapper ) o ; } } public static class MapperType extends EnumeratedAttribute { private Properties implementations ; public MapperType ( ) { implementations = new Properties ( ) ; implementations . put ( "identity" , "org.apache.tools.ant.util.IdentityMapper" ) ; implementations . put ( "flatten" , "org.apache.tools.ant.util.FlatFileNameMapper" ) ; implementations . put ( "glob" , "org.apache.tools.ant.util.GlobPatternMapper" ) ; implementations . put ( "merge" , "org.apache.tools.ant.util.MergingMapper" ) ; implementations . put ( "regexp" , "org.apache.tools.ant.util.RegexpPatternMapper" ) ; implementations . put ( "package" , "org.apache.tools.ant.util.PackageNameMapper" ) ; implementations . put ( "unpackage" , "org.apache.tools.ant.util.UnPackageNameMapper" ) ; } public String [ ] getValues ( ) { return new String [ ] { "identity" , "flatten" , "glob" , "merge" , "regexp" , "package" , "unpackage" } ; } public String getImplementation ( ) { return implementations . getProperty ( getValue ( ) ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Reader ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . ZipOutputStream ; public class Jar extends Zip { private static final String INDEX_NAME = "META-INF/INDEX.LIST" ; private static final String MANIFEST_NAME = "META-INF/MANIFEST.MF" ; private Manifest configuredManifest ; private Manifest savedConfiguredManifest ; private Manifest filesetManifest ; private Manifest originalManifest ; private FilesetManifestConfig filesetManifestConfig ; private boolean mergeManifestsMain = true ; private Manifest manifest ; private String manifestEncoding ; private File manifestFile ; private boolean index = false ; private boolean createEmpty = false ; private Vector rootEntries ; public Jar ( ) { super ( ) ; archiveType = "jar" ; emptyBehavior = "create" ; setEncoding ( "UTF8" ) ; rootEntries = new Vector ( ) ; } public void setWhenempty ( WhenEmpty we ) { log ( "JARs are never empty, they contain at least a manifest file" , Project . MSG_WARN ) ; } public void setJarfile ( File jarFile ) { setDestFile ( jarFile ) ; } public void setIndex ( boolean flag ) { index = flag ; } public void setManifestEncoding ( String manifestEncoding ) { this . manifestEncoding = manifestEncoding ; } public void addConfiguredManifest ( Manifest newManifest ) throws ManifestException { if ( configuredManifest == null ) { configuredManifest = newManifest ; } else { configuredManifest . merge ( newManifest ) ; } savedConfiguredManifest = configuredManifest ; } public void setManifest ( File manifestFile ) { if ( ! manifestFile . exists ( ) ) { throw new BuildException ( "Manifest file: " + manifestFile + " does not exist." , getLocation ( ) ) ; } this . manifestFile = manifestFile ; } private Manifest getManifest ( File manifestFile ) { Manifest newManifest = null ; FileInputStream fis = null ; InputStreamReader isr = null ; try { fis = new FileInputStream ( manifestFile ) ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( fis ) ; } else { isr = new InputStreamReader ( fis , manifestEncoding ) ; } newManifest = getManifest ( isr ) ; } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading manifest: " + e . getMessage ( ) , e ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " + manifestFile + " (" + e . getMessage ( ) + ")" , e ) ; } finally { if ( isr != null ) { try { isr . close ( ) ; } catch ( IOException e ) { } } } return newManifest ; } private Manifest getManifestFromJar ( File jarFile ) throws IOException { ZipFile zf = null ; try { zf = new ZipFile ( jarFile ) ; Enumeration e = zf . entries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; if ( ze . getName ( ) . equalsIgnoreCase ( MANIFEST_NAME ) ) { InputStreamReader isr = new InputStreamReader ( zf . getInputStream ( ze ) , "UTF-8" ) ; return getManifest ( isr ) ; } } return null ; } finally { if ( zf != null ) { try { zf . close ( ) ; } catch ( IOException e ) { } } } } private Manifest getManifest ( Reader r ) { Manifest newManifest = null ; try { newManifest = new Manifest ( r ) ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest: " + manifestFile , e , getLocation ( ) ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file" + " (" + e . getMessage ( ) + ")" , e ) ; } return newManifest ; } public void setFilesetmanifest ( FilesetManifestConfig config ) { filesetManifestConfig = config ; mergeManifestsMain = "merge" . equals ( config . getValue ( ) ) ; if ( filesetManifestConfig != null && ! filesetManifestConfig . getValue ( ) . equals ( "skip" ) ) { doubleFilePass = true ; } } public void addMetainf ( ZipFileSet fs ) { fs . setPrefix ( "META-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( ! skipWriting ) { Manifest jarManifest = createManifest ( ) ; writeManifest ( zOut , jarManifest ) ; } } private Manifest createManifest ( ) throws BuildException { try { Manifest finalManifest = Manifest . getDefaultManifest ( ) ; if ( manifest == null ) { if ( manifestFile != null ) { manifest = getManifest ( manifestFile ) ; } } if ( isInUpdateMode ( ) ) { finalManifest . merge ( originalManifest ) ; } finalManifest . merge ( filesetManifest ) ; finalManifest . merge ( configuredManifest ) ; finalManifest . merge ( manifest , ! mergeManifestsMain ) ; return finalManifest ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } private void writeManifest ( ZipOutputStream zOut , Manifest manifest ) throws IOException { for ( Enumeration e = manifest . getWarnings ( ) ; e . hasMoreElements ( ) ; ) { log ( "Manifest warning: " + ( String ) e . nextElement ( ) , Project . MSG_WARN ) ; } zipDir ( null , zOut , "META-INF/" , ZipFileSet . DEFAULT_DIR_MODE ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; OutputStreamWriter osw = new OutputStreamWriter ( baos , "UTF-8" ) ; PrintWriter writer = new PrintWriter ( osw ) ; manifest . write ( writer ) ; writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , MANIFEST_NAME , System . currentTimeMillis ( ) , null , ZipFileSet . DEFAULT_FILE_MODE ) ; super . initZipOutputStream ( zOut ) ; } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( index ) { createIndexList ( zOut ) ; } } private void createIndexList ( ZipOutputStream zOut ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( baos , "UTF8" ) ) ; writer . println ( "JarIndex-Version: 1.0" ) ; writer . println ( ) ; writer . println ( zipFile . getName ( ) ) ; Enumeration e = addedDirs . keys ( ) ; while ( e . hasMoreElements ( ) ) { String dir = ( String ) e . nextElement ( ) ; dir = dir . replace ( '\\' , '/' ) ; int pos = dir . lastIndexOf ( '/' ) ; if ( pos != - 1 ) { dir = dir . substring ( 0 , pos ) ; } if ( dir . startsWith ( "META-INF" ) ) { continue ; } writer . println ( dir ) ; } e = rootEntries . elements ( ) ; while ( e . hasMoreElements ( ) ) { writer . println ( e . nextElement ( ) ) ; } writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , INDEX_NAME , System . currentTimeMillis ( ) , null , ZipFileSet . DEFAULT_FILE_MODE ) ; } protected void zipFile ( InputStream is , ZipOutputStream zOut , String vPath , long lastModified , File fromArchive , int mode ) throws IOException { if ( MANIFEST_NAME . equalsIgnoreCase ( vPath ) ) { if ( ! doubleFilePass || ( doubleFilePass && skipWriting ) ) { filesetManifest ( fromArchive , is ) ; } } else if ( INDEX_NAME . equalsIgnoreCase ( vPath ) && index ) { log ( "Warning: selected " + archiveType + " files include a META-INF/INDEX.LIST which will" + " be replaced by a newly generated one." , Project . MSG_WARN ) ; } else { if ( index && vPath . indexOf ( "/" ) == - 1 ) { rootEntries . addElement ( vPath ) ; } super . zipFile ( is , zOut , vPath , lastModified , fromArchive , mode ) ; } } private void filesetManifest ( File file , InputStream is ) throws IOException { if ( manifestFile != null && manifestFile . equals ( file ) ) { log ( "Found manifest " + file , Project . MSG_VERBOSE ) ; try { if ( is != null ) { InputStreamReader isr ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( is ) ; } else { isr = new InputStreamReader ( is , manifestEncoding ) ; } manifest = getManifest ( isr ) ; } else { manifest = getManifest ( file ) ; } } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading " + "manifest: " + e . getMessage ( ) , e ) ; } } else if ( filesetManifestConfig != null && ! filesetManifestConfig . getValue ( ) . equals ( "skip" ) ) { log ( "Found manifest to merge in file " + file , Project . MSG_VERBOSE ) ; try { Manifest newManifest = null ; if ( is != null ) { InputStreamReader isr ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( is ) ; } else { isr = new InputStreamReader ( is , manifestEncoding ) ; } newManifest = getManifest ( isr ) ; } else { newManifest = getManifest ( file ) ; } if ( filesetManifest == null ) { filesetManifest = newManifest ; } else { filesetManifest . merge ( newManifest ) ; } } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading " + "manifest: " + e . getMessage ( ) , e ) ; } catch ( ManifestException e ) { log ( "Manifest in file " + file + " is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } else { } } protected ArchiveState getResourcesToAdd ( FileSet [ ] filesets , File zipFile , boolean needsUpdate ) throws BuildException { if ( zipFile . exists ( ) ) { try { originalManifest = getManifestFromJar ( zipFile ) ; if ( originalManifest == null ) { log ( "Updating jar since the current jar has no manifest" , Project . MSG_VERBOSE ) ; needsUpdate = true ; } else { Manifest mf = createManifest ( ) ; if ( ! mf . equals ( originalManifest ) ) { log ( "Updating jar since jar manifest has changed" , Project . MSG_VERBOSE ) ; needsUpdate = true ; } } } catch ( Throwable t ) { log ( "error while reading original manifest: " + t . getMessage ( ) , Project . MSG_WARN ) ; needsUpdate = true ; } } else { needsUpdate = true ; } createEmpty = needsUpdate ; return super . getResourcesToAdd ( filesets , zipFile , needsUpdate ) ; } protected boolean createEmptyZip ( File zipFile ) throws BuildException { if ( ! createEmpty ) { return true ; } ZipOutputStream zOut = null ; try { log ( "Building MANIFEST-only jar: " + getDestFile ( ) . getAbsolutePath ( ) ) ; zOut = new ZipOutputStream ( new FileOutputStream ( getDestFile ( ) ) ) ; zOut . setEncoding ( getEncoding ( ) ) ; if ( isCompress ( ) ) { zOut . setMethod ( ZipOutputStream . DEFLATED ) ; } else { zOut . setMethod ( ZipOutputStream . STORED ) ; } initZipOutputStream ( zOut ) ; finalizeZipOutputStream ( zOut ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create almost empty JAR archive" + " (" + ioe . getMessage ( ) + ")" , ioe , getLocation ( ) ) ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { } createEmpty = false ; } return true ; } protected void cleanUp ( ) { super . cleanUp ( ) ; if ( ! doubleFilePass || ( doubleFilePass && ! skipWriting ) ) { manifest = null ; configuredManifest = savedConfiguredManifest ; filesetManifest = null ; originalManifest = null ; } rootEntries . removeAllElements ( ) ; } public void reset ( ) { super . reset ( ) ; configuredManifest = null ; filesetManifestConfig = null ; mergeManifestsMain = false ; manifestFile = null ; index = false ; } public static class FilesetManifestConfig extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "skip" , "merge" , "mergewithoutmain" } ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public class Delete extends MatchingTask { private static final int DELETE_RETRY_SLEEP_MILLIS = 10 ; protected File file = null ; protected File dir = null ; protected Vector filesets = new Vector ( ) ; protected boolean usedMatchingTask = false ; protected boolean includeEmpty = false ; private int verbosity = Project . MSG_VERBOSE ; private boolean quiet = false ; private boolean failonerror = true ; public void setFile ( File file ) { this . file = file ; } public void setDir ( File dir ) { this . dir = dir ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . failonerror = false ; } } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public PatternSet . NameEntry createInclude ( ) { usedMatchingTask = true ; return super . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { usedMatchingTask = true ; return super . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { usedMatchingTask = true ; return super . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { usedMatchingTask = true ; return super . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { usedMatchingTask = true ; return super . createPatternSet ( ) ; } public void setIncludes ( String includes ) { usedMatchingTask = true ; super . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { usedMatchingTask = true ; super . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { usedMatchingTask = true ; super . setDefaultexcludes ( useDefaultExcludes ) ; } public void setIncludesfile ( File includesfile ) { usedMatchingTask = true ; super . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { usedMatchingTask = true ; super . setExcludesfile ( excludesfile ) ; } public void setCaseSensitive ( boolean isCaseSensitive ) { usedMatchingTask = true ; super . setCaseSensitive ( isCaseSensitive ) ; } public void setFollowSymlinks ( boolean followSymlinks ) { usedMatchingTask = true ; super . setFollowSymlinks ( followSymlinks ) ; } public void addSelector ( SelectSelector selector ) { usedMatchingTask = true ; super . addSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { usedMatchingTask = true ; super . addAnd ( selector ) ; } public void addOr ( OrSelector selector ) { usedMatchingTask = true ; super . addOr ( selector ) ; } public void addNot ( NotSelector selector ) { usedMatchingTask = true ; super . addNot ( selector ) ; } public void addNone ( NoneSelector selector ) { usedMatchingTask = true ; super . addNone ( selector ) ; } public void addMajority ( MajoritySelector selector ) { usedMatchingTask = true ; super . addMajority ( selector ) ; } public void addDate ( DateSelector selector ) { usedMatchingTask = true ; super . addDate ( selector ) ; } public void addSize ( SizeSelector selector ) { usedMatchingTask = true ; super . addSize ( selector ) ; } public void addFilename ( FilenameSelector selector ) { usedMatchingTask = true ; super . addFilename ( selector ) ; } public void addCustom ( ExtendSelector selector ) { usedMatchingTask = true ; super . addCustom ( selector ) ; } public void addContains ( ContainsSelector selector ) { usedMatchingTask = true ; super . addContains ( selector ) ; } public void addPresent ( PresentSelector selector ) { usedMatchingTask = true ; super . addPresent ( selector ) ; } public void addDepth ( DepthSelector selector ) { usedMatchingTask = true ; super . addDepth ( selector ) ; } public void addDepend ( DependSelector selector ) { usedMatchingTask = true ; super . addDepend ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { usedMatchingTask = true ; super . addContainsRegexp ( selector ) ; } public void addModified ( ModifiedSelector selector ) { usedMatchingTask = true ; super . addModified ( selector ) ; } public void add ( FileSelector selector ) { usedMatchingTask = true ; super . add ( selector ) ; } public void execute ( ) throws BuildException { if ( usedMatchingTask ) { log ( "DEPRECATED - Use of the implicit FileSet is deprecated.  " + "Use a nested fileset element instead." ) ; } if ( file == null && dir == null && filesets . size ( ) == 0 ) { throw new BuildException ( "At least one of the file or dir " + "attributes, or a fileset element, " + "must be set." ) ; } if ( quiet && failonerror ) { throw new BuildException ( "quiet and failonerror cannot both be " + "set to true" , getLocation ( ) ) ; } if ( file != null ) { if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { log ( "Directory " + file . getAbsolutePath ( ) + " cannot be removed using the file attribute.  " + "Use dir instead." ) ; } else { log ( "Deleting: " + file . getAbsolutePath ( ) ) ; if ( ! delete ( file ) ) { String message = "Unable to delete file " + file . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to delete." , Project . MSG_VERBOSE ) ; } } if ( dir != null && dir . exists ( ) && dir . isDirectory ( ) && ! usedMatchingTask ) { if ( verbosity == Project . MSG_VERBOSE ) { log ( "Deleting directory " + dir . getAbsolutePath ( ) ) ; } removeDir ( dir ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; try { DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( fs . getDir ( getProject ( ) ) , files , dirs ) ; } catch ( BuildException be ) { if ( failonerror ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } if ( usedMatchingTask && dir != null ) { try { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( dir , files , dirs ) ; } catch ( BuildException be ) { if ( failonerror ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } private boolean delete ( File f ) { if ( ! f . delete ( ) ) { try { Thread . sleep ( DELETE_RETRY_SLEEP_MILLIS ) ; return f . delete ( ) ; } catch ( InterruptedException ex ) { return f . delete ( ) ; } } return true ; } protected void removeDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { list = new String [ 0 ] ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! delete ( f ) ) { String message = "Unable to delete file " + f . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! delete ( d ) ) { String message = "Unable to delete directory " + dir . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } protected void removeFiles ( File d , String [ ] files , String [ ] dirs ) { if ( files . length > 0 ) { log ( "Deleting " + files . length + " files from " + d . getAbsolutePath ( ) ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( d , files [ j ] ) ; log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! delete ( f ) ) { String message = "Unable to delete file " + f . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } if ( dirs . length > 0 && includeEmpty ) { int dirCount = 0 ; for ( int j = dirs . length - 1 ; j >= 0 ; j -- ) { File dir = new File ( d , dirs [ j ] ) ; String [ ] dirFiles = dir . list ( ) ; if ( dirFiles == null || dirFiles . length == 0 ) { log ( "Deleting " + dir . getAbsolutePath ( ) , verbosity ) ; if ( ! delete ( dir ) ) { String message = "Unable to delete directory " + dir . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } else { dirCount ++ ; } } } if ( dirCount > 0 ) { log ( "Deleted " + dirCount + " director" + ( dirCount == 1 ? "y" : "ies" ) + " from " + d . getAbsolutePath ( ) ) ; } } } } 	1
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class JavacExternal extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using external javac compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( getJavac ( ) . getJavacExecutable ( ) ) ; setupModernJavacCommandlineSwitches ( cmd ) ; int firstFileName = assumeJava11 ( ) ? - 1 : cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName , true ) == 0 ; } } 	1
package org . apache . tools . ant ; public abstract class ProjectComponent { protected Project project ; public ProjectComponent ( ) { } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { if ( project != null ) { project . log ( msg , msgLevel ) ; } else { if ( msgLevel >= Project . MSG_INFO ) { System . err . println ( msg ) ; } } } } 	1
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Hashtable ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . BuildException ; public final class ReplaceTokens extends BaseParamFilterReader implements ChainableReader { private static final char DEFAULT_BEGIN_TOKEN = '@' ; private static final char DEFAULT_END_TOKEN = '@' ; private String queuedData = null ; private String replaceData = null ; private int replaceIndex = - 1 ; private int queueIndex = - 1 ; private Hashtable hash = new Hashtable ( ) ; private char beginToken = DEFAULT_BEGIN_TOKEN ; private char endToken = DEFAULT_END_TOKEN ; public ReplaceTokens ( ) { super ( ) ; } public ReplaceTokens ( final Reader in ) { super ( in ) ; } private int getNextChar ( ) throws IOException { if ( queueIndex != - 1 ) { final int ch = queuedData . charAt ( queueIndex ++ ) ; if ( queueIndex >= queuedData . length ( ) ) { queueIndex = - 1 ; } return ch ; } return in . read ( ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } if ( replaceIndex != - 1 ) { final int ch = replaceData . charAt ( replaceIndex ++ ) ; if ( replaceIndex >= replaceData . length ( ) ) { replaceIndex = - 1 ; } return ch ; } int ch = getNextChar ( ) ; if ( ch == beginToken ) { final StringBuffer key = new StringBuffer ( "" ) ; do { ch = getNextChar ( ) ; if ( ch != - 1 ) { key . append ( ( char ) ch ) ; } else { break ; } } while ( ch != endToken ) ; if ( ch == - 1 ) { if ( queuedData == null || queueIndex == - 1 ) { queuedData = key . toString ( ) ; } else { queuedData = key . toString ( ) + queuedData . substring ( queueIndex ) ; } queueIndex = 0 ; return beginToken ; } else { key . setLength ( key . length ( ) - 1 ) ; final String replaceWith = ( String ) hash . get ( key . toString ( ) ) ; if ( replaceWith != null ) { if ( replaceWith . length ( ) > 0 ) { replaceData = replaceWith ; replaceIndex = 0 ; } return read ( ) ; } else { String newData = key . toString ( ) + endToken ; if ( queuedData == null || queueIndex == - 1 ) { queuedData = newData ; } else { queuedData = newData + queuedData . substring ( queueIndex ) ; } queueIndex = 0 ; return beginToken ; } } } return ch ; } public final void setBeginToken ( final char beginToken ) { this . beginToken = beginToken ; } private final char getBeginToken ( ) { return beginToken ; } public final void setEndToken ( final char endToken ) { this . endToken = endToken ; } private final char getEndToken ( ) { return endToken ; } public final void addConfiguredToken ( final Token token ) { hash . put ( token . getKey ( ) , token . getValue ( ) ) ; } private void setTokens ( final Hashtable hash ) { this . hash = hash ; } private final Hashtable getTokens ( ) { return hash ; } public final Reader chain ( final Reader rdr ) { ReplaceTokens newFilter = new ReplaceTokens ( rdr ) ; newFilter . setBeginToken ( getBeginToken ( ) ) ; newFilter . setEndToken ( getEndToken ( ) ) ; newFilter . setTokens ( getTokens ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { final String type = params [ i ] . getType ( ) ; if ( "tokenchar" . equals ( type ) ) { final String name = params [ i ] . getName ( ) ; String value = params [ i ] . getValue ( ) ; if ( "begintoken" . equals ( name ) ) { if ( value . length ( ) == 0 ) { throw new BuildException ( "Begin token cannot " + "be empty" ) ; } beginToken = params [ i ] . getValue ( ) . charAt ( 0 ) ; } else if ( "endtoken" . equals ( name ) ) { if ( value . length ( ) == 0 ) { throw new BuildException ( "End token cannot " + "be empty" ) ; } endToken = params [ i ] . getValue ( ) . charAt ( 0 ) ; } } else if ( "token" . equals ( type ) ) { final String name = params [ i ] . getName ( ) ; final String value = params [ i ] . getValue ( ) ; hash . put ( name , value ) ; } } } } } public static class Token { private String key ; private String value ; public final void setKey ( String key ) { this . key = key ; } public final void setValue ( String value ) { this . value = value ; } public final String getKey ( ) { return key ; } public final String getValue ( ) { return value ; } } } 	1
package org . apache . tools . ant . util ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . condition . Os ; public class JavaEnvUtils { private static final boolean isDos = Os . isFamily ( "dos" ) ; private static final boolean isNetware = Os . isName ( "netware" ) ; private static final boolean isAix = Os . isName ( "aix" ) ; private static final String javaHome = System . getProperty ( "java.home" ) ; private static final FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private static String javaVersion ; private static int javaVersionNumber ; public static final String JAVA_1_0 = "1.0" ; public static final String JAVA_1_1 = "1.1" ; public static final String JAVA_1_2 = "1.2" ; public static final String JAVA_1_3 = "1.3" ; public static final String JAVA_1_4 = "1.4" ; private static Vector jrePackages ; static { try { javaVersion = JAVA_1_0 ; javaVersionNumber = 10 ; Class . forName ( "java.lang.Void" ) ; javaVersion = JAVA_1_1 ; javaVersionNumber ++ ; Class . forName ( "java.lang.ThreadLocal" ) ; javaVersion = JAVA_1_2 ; javaVersionNumber ++ ; Class . forName ( "java.lang.StrictMath" ) ; javaVersion = JAVA_1_3 ; javaVersionNumber ++ ; Class . forName ( "java.lang.CharSequence" ) ; javaVersion = JAVA_1_4 ; javaVersionNumber ++ ; } catch ( Throwable t ) { } } public static String getJavaVersion ( ) { return javaVersion ; } public static boolean isJavaVersion ( String version ) { return javaVersion == version ; } public static String getJreExecutable ( String command ) { if ( isNetware ) { return command ; } File jExecutable = null ; if ( isAix ) { jExecutable = findInDir ( javaHome + "/sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( javaHome + "/bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return addExtension ( command ) ; } } public static String getJdkExecutable ( String command ) { if ( isNetware ) { return command ; } File jExecutable = null ; if ( isAix ) { jExecutable = findInDir ( javaHome + "/../sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( javaHome + "/../bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return getJreExecutable ( command ) ; } } private static String addExtension ( String command ) { return command + ( isDos ? ".exe" : "" ) ; } private static File findInDir ( String dirName , String commandName ) { File dir = fileUtils . normalize ( dirName ) ; File executable = null ; if ( dir . exists ( ) ) { executable = new File ( dir , addExtension ( commandName ) ) ; if ( ! executable . exists ( ) ) { executable = null ; } } return executable ; } private static void buildJrePackages ( ) { jrePackages = new Vector ( ) ; switch ( javaVersionNumber ) { case 14 : jrePackages . addElement ( "org.apache.crimson" ) ; jrePackages . addElement ( "org.apache.xalan" ) ; jrePackages . addElement ( "org.apache.xml" ) ; jrePackages . addElement ( "org.apache.xpath" ) ; jrePackages . addElement ( "org.ietf.jgss" ) ; jrePackages . addElement ( "org.w3c.dom" ) ; jrePackages . addElement ( "org.xml.sax" ) ; case 13 : jrePackages . addElement ( "org.omg" ) ; jrePackages . addElement ( "com.sun.corba" ) ; jrePackages . addElement ( "com.sun.jndi" ) ; jrePackages . addElement ( "com.sun.media" ) ; jrePackages . addElement ( "com.sun.naming" ) ; jrePackages . addElement ( "com.sun.org.omg" ) ; jrePackages . addElement ( "com.sun.rmi" ) ; jrePackages . addElement ( "sunw.io" ) ; jrePackages . addElement ( "sunw.util" ) ; case 12 : jrePackages . addElement ( "com.sun.java" ) ; jrePackages . addElement ( "com.sun.image" ) ; case 11 : default : jrePackages . addElement ( "sun" ) ; jrePackages . addElement ( "java" ) ; jrePackages . addElement ( "javax" ) ; break ; } } public static Vector getJrePackageTestCases ( ) { Vector tests = new Vector ( ) ; tests . addElement ( "java.lang.Object" ) ; switch ( javaVersionNumber ) { case 14 : tests . addElement ( "sun.audio.AudioPlayer" ) ; tests . addElement ( "org.apache.crimson.parser.ContentModel" ) ; tests . addElement ( "org.apache.xalan.processor.ProcessorImport" ) ; tests . addElement ( "org.apache.xml.utils.URI" ) ; tests . addElement ( "org.apache.xpath.XPathFactory" ) ; tests . addElement ( "org.ietf.jgss.Oid" ) ; tests . addElement ( "org.w3c.dom.Attr" ) ; tests . addElement ( "org.xml.sax.XMLReader" ) ; case 13 : tests . addElement ( "org.omg.CORBA.Any" ) ; tests . addElement ( "com.sun.corba.se.internal.corba.AnyImpl" ) ; tests . addElement ( "com.sun.jndi.ldap.LdapURL" ) ; tests . addElement ( "com.sun.media.sound.Printer" ) ; tests . addElement ( "com.sun.naming.internal.VersionHelper" ) ; tests . addElement ( "com.sun.org.omg.CORBA.Initializer" ) ; tests . addElement ( "sunw.io.Serializable" ) ; tests . addElement ( "sunw.util.EventListener" ) ; case 12 : tests . addElement ( "javax.accessibility.Accessible" ) ; tests . addElement ( "sun.misc.BASE64Encoder" ) ; tests . addElement ( "com.sun.image.codec.jpeg.JPEGCodec" ) ; case 11 : default : tests . addElement ( "sun.reflect.SerializationConstructorAccessorImpl" ) ; tests . addElement ( "sun.net.www.http.HttpClient" ) ; tests . addElement ( "sun.audio.AudioPlayer" ) ; break ; } return tests ; } public static Vector getJrePackages ( ) { if ( jrePackages == null ) { buildJrePackages ( ) ; } return jrePackages ; } } 	1
package org . apache . tools . ant ; import java . io . File ; import java . io . IOException ; import java . io . EOFException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import java . util . Set ; import java . util . HashSet ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Description ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . StringUtils ; public class Project { public static final int MSG_ERR = 0 ; public static final int MSG_WARN = 1 ; public static final int MSG_INFO = 2 ; public static final int MSG_VERBOSE = 3 ; public static final int MSG_DEBUG = 4 ; private static final String VISITING = "VISITING" ; private static final String VISITED = "VISITED" ; private static final String ANTCLASSLOADER_JDK12 = "org.apache.tools.ant.loader.AntClassLoader2" ; public static final String JAVA_1_0 = JavaEnvUtils . JAVA_1_0 ; public static final String JAVA_1_1 = JavaEnvUtils . JAVA_1_1 ; public static final String JAVA_1_2 = JavaEnvUtils . JAVA_1_2 ; public static final String JAVA_1_3 = JavaEnvUtils . JAVA_1_3 ; public static final String JAVA_1_4 = JavaEnvUtils . JAVA_1_4 ; public static final String TOKEN_START = FilterSet . DEFAULT_TOKEN_START ; public static final String TOKEN_END = FilterSet . DEFAULT_TOKEN_END ; private String name ; private String description ; private Hashtable references = new AntRefTable ( this ) ; private String defaultTarget ; private Hashtable targets = new Hashtable ( ) ; private FilterSet globalFilterSet = new FilterSet ( ) ; private FilterSetCollection globalFilters = new FilterSetCollection ( globalFilterSet ) ; private File baseDir ; private Vector listeners = new Vector ( ) ; private ClassLoader coreLoader = null ; private Hashtable threadTasks = new Hashtable ( ) ; private Hashtable threadGroupTasks = new Hashtable ( ) ; private InputHandler inputHandler = null ; private InputStream defaultInputStream = null ; private boolean keepGoingMode = false ; public void setInputHandler ( InputHandler handler ) { inputHandler = handler ; } public void setDefaultInputStream ( InputStream defaultInputStream ) { this . defaultInputStream = defaultInputStream ; } public InputStream getDefaultInputStream ( ) { return defaultInputStream ; } public InputHandler getInputHandler ( ) { return inputHandler ; } private FileUtils fileUtils ; private boolean loggingMessage = false ; public Project ( ) { fileUtils = FileUtils . newFileUtils ( ) ; inputHandler = new DefaultInputHandler ( ) ; } public void initSubProject ( Project subProject ) { ComponentHelper . getComponentHelper ( subProject ) . initSubProject ( ComponentHelper . getComponentHelper ( this ) ) ; subProject . setKeepGoingMode ( this . isKeepGoingMode ( ) ) ; } public void init ( ) throws BuildException { setJavaVersionProperty ( ) ; ComponentHelper . getComponentHelper ( this ) . initDefaultDefinitions ( ) ; setSystemProperties ( ) ; } private AntClassLoader createClassLoader ( ) { AntClassLoader loader = null ; if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { try { Class loaderClass = Class . forName ( ANTCLASSLOADER_JDK12 ) ; loader = ( AntClassLoader ) loaderClass . newInstance ( ) ; } catch ( Exception e ) { log ( "Unable to create Class Loader: " + e . getMessage ( ) , Project . MSG_DEBUG ) ; } } if ( loader == null ) { loader = new AntClassLoader ( ) ; } loader . setProject ( this ) ; return loader ; } public AntClassLoader createClassLoader ( Path path ) { AntClassLoader loader = createClassLoader ( ) ; loader . setClassPath ( path ) ; return loader ; } public void setCoreLoader ( ClassLoader coreLoader ) { this . coreLoader = coreLoader ; } public ClassLoader getCoreLoader ( ) { return coreLoader ; } public synchronized void addBuildListener ( BuildListener listener ) { Vector newListeners = getBuildListeners ( ) ; newListeners . addElement ( listener ) ; listeners = newListeners ; } public synchronized void removeBuildListener ( BuildListener listener ) { Vector newListeners = getBuildListeners ( ) ; newListeners . removeElement ( listener ) ; listeners = newListeners ; } public Vector getBuildListeners ( ) { return ( Vector ) listeners . clone ( ) ; } public void log ( String message ) { log ( message , MSG_INFO ) ; } public void log ( String message , int msgLevel ) { fireMessageLogged ( this , message , msgLevel ) ; } public void log ( Task task , String message , int msgLevel ) { fireMessageLogged ( task , message , msgLevel ) ; } public void log ( Target target , String message , int msgLevel ) { fireMessageLogged ( target , message , msgLevel ) ; } public FilterSet getGlobalFilterSet ( ) { return globalFilterSet ; } public void setProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setProperty ( null , name , value , true ) ; } public void setNewProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setNewProperty ( null , name , value ) ; } public void setUserProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setUserProperty ( null , name , value ) ; } public void setInheritedProperty ( String name , String value ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . setInheritedProperty ( null , name , value ) ; } private void setPropertyInternal ( String name , String value ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . setProperty ( null , name , value , false ) ; } public String getProperty ( String name ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ( String ) ph . getProperty ( null , name ) ; } public String replaceProperties ( String value ) throws BuildException { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . replaceProperties ( null , value , null ) ; } public String getUserProperty ( String name ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ( String ) ph . getUserProperty ( null , name ) ; } public Hashtable getProperties ( ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . getProperties ( ) ; } public Hashtable getUserProperties ( ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . getUserProperties ( ) ; } public void copyUserProperties ( Project other ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . copyUserProperties ( other ) ; } public void copyInheritedProperties ( Project other ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . copyInheritedProperties ( other ) ; } public void setDefaultTarget ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public String getDefaultTarget ( ) { return defaultTarget ; } public void setDefault ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public void setName ( String name ) { setUserProperty ( "ant.project.name" , name ) ; this . name = name ; } public String getName ( ) { return name ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { if ( description == null ) { description = Description . getDescription ( this ) ; } return description ; } public void addFilter ( String token , String value ) { if ( token == null ) { return ; } globalFilterSet . addFilter ( new FilterSet . Filter ( token , value ) ) ; } public Hashtable getFilters ( ) { return globalFilterSet . getFilterHash ( ) ; } public void setBasedir ( String baseD ) throws BuildException { setBaseDir ( new File ( baseD ) ) ; } public void setBaseDir ( File baseDir ) throws BuildException { baseDir = fileUtils . normalize ( baseDir . getAbsolutePath ( ) ) ; if ( ! baseDir . exists ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " does not exist" ) ; } if ( ! baseDir . isDirectory ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " is not a directory" ) ; } this . baseDir = baseDir ; setPropertyInternal ( "basedir" , this . baseDir . getPath ( ) ) ; String msg = "Project base dir set to: " + this . baseDir ; log ( msg , MSG_VERBOSE ) ; } public File getBaseDir ( ) { if ( baseDir == null ) { try { setBasedir ( "." ) ; } catch ( BuildException ex ) { ex . printStackTrace ( ) ; } } return baseDir ; } public void setKeepGoingMode ( boolean keepGoingMode ) { this . keepGoingMode = keepGoingMode ; } public boolean isKeepGoingMode ( ) { return this . keepGoingMode ; } public static String getJavaVersion ( ) { return JavaEnvUtils . getJavaVersion ( ) ; } public void setJavaVersionProperty ( ) throws BuildException { String javaVersion = JavaEnvUtils . getJavaVersion ( ) ; setPropertyInternal ( "ant.java.version" , javaVersion ) ; if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) ) { throw new BuildException ( "Ant cannot work on Java 1.0" ) ; } log ( "Detected Java version: " + javaVersion + " in: " + System . getProperty ( "java.home" ) , MSG_VERBOSE ) ; log ( "Detected OS: " + System . getProperty ( "os.name" ) , MSG_VERBOSE ) ; } public void setSystemProperties ( ) { Properties systemP = System . getProperties ( ) ; Enumeration e = systemP . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; String value = systemP . get ( name ) . toString ( ) ; this . setPropertyInternal ( name . toString ( ) , value ) ; } } public void addTaskDefinition ( String taskName , Class taskClass ) throws BuildException { ComponentHelper . getComponentHelper ( this ) . addTaskDefinition ( taskName , taskClass ) ; } public void checkTaskClass ( final Class taskClass ) throws BuildException { ComponentHelper . getComponentHelper ( this ) . checkTaskClass ( taskClass ) ; if ( ! Modifier . isPublic ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is not public" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( Modifier . isAbstract ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is abstract" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } try { taskClass . getConstructor ( null ) ; } catch ( NoSuchMethodException e ) { final String message = "No public no-arg constructor in " + taskClass ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( ! Task . class . isAssignableFrom ( taskClass ) ) { TaskAdapter . checkTaskClass ( taskClass , this ) ; } } public Hashtable getTaskDefinitions ( ) { return ComponentHelper . getComponentHelper ( this ) . getTaskDefinitions ( ) ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { ComponentHelper . getComponentHelper ( this ) . addDataTypeDefinition ( typeName , typeClass ) ; } public Hashtable getDataTypeDefinitions ( ) { return ComponentHelper . getComponentHelper ( this ) . getDataTypeDefinitions ( ) ; } public void addTarget ( Target target ) throws BuildException { String name = target . getName ( ) ; if ( targets . get ( name ) != null ) { throw new BuildException ( "Duplicate target: `" + name + "'" ) ; } addOrReplaceTarget ( name , target ) ; } public void addTarget ( String targetName , Target target ) throws BuildException { if ( targets . get ( targetName ) != null ) { throw new BuildException ( "Duplicate target: `" + targetName + "'" ) ; } addOrReplaceTarget ( targetName , target ) ; } public void addOrReplaceTarget ( Target target ) { addOrReplaceTarget ( target . getName ( ) , target ) ; } public void addOrReplaceTarget ( String targetName , Target target ) { String msg = " +Target: " + targetName ; log ( msg , MSG_DEBUG ) ; target . setProject ( this ) ; targets . put ( targetName , target ) ; } public Hashtable getTargets ( ) { return targets ; } public Task createTask ( String taskType ) throws BuildException { return ComponentHelper . getComponentHelper ( this ) . createTask ( taskType ) ; } public Object createDataType ( String typeName ) throws BuildException { return ComponentHelper . getComponentHelper ( this ) . createDataType ( typeName ) ; } public void executeTargets ( Vector targetNames ) throws BuildException { for ( int i = 0 ; i < targetNames . size ( ) ; i ++ ) { executeTarget ( ( String ) targetNames . elementAt ( i ) ) ; } } public void demuxOutput ( String output , boolean isWarning ) { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { log ( output , isWarning ? MSG_WARN : MSG_INFO ) ; } else { if ( isWarning ) { task . handleErrorOutput ( output ) ; } else { task . handleOutput ( output ) ; } } } public int defaultInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( defaultInputStream != null ) { System . out . flush ( ) ; return defaultInputStream . read ( buffer , offset , length ) ; } else { throw new EOFException ( "No input provided for project" ) ; } } public int demuxInput ( byte [ ] buffer , int offset , int length ) throws IOException { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { return defaultInput ( buffer , offset , length ) ; } else { return task . handleInput ( buffer , offset , length ) ; } } public void demuxFlush ( String output , boolean isError ) { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { fireMessageLogged ( this , output , isError ? MSG_ERR : MSG_INFO ) ; } else { if ( isError ) { task . handleErrorFlush ( output ) ; } else { task . handleFlush ( output ) ; } } } public void executeTarget ( String targetName ) throws BuildException { if ( targetName == null ) { String msg = "No target specified" ; throw new BuildException ( msg ) ; } Vector sortedTargets = topoSort ( targetName , targets ) ; Set succeededTargets = new HashSet ( ) ; BuildException buildException = null ; for ( Enumeration iter = sortedTargets . elements ( ) ; iter . hasMoreElements ( ) ; ) { Target curtarget = ( Target ) iter . nextElement ( ) ; boolean canExecute = true ; for ( Enumeration depIter = curtarget . getDependencies ( ) ; depIter . hasMoreElements ( ) ; ) { String dependencyName = ( ( String ) depIter . nextElement ( ) ) ; if ( ! succeededTargets . contains ( dependencyName ) ) { canExecute = false ; log ( curtarget , "Cannot execute '" + curtarget . getName ( ) + "' - '" + dependencyName + "' failed or was not executed." , MSG_ERR ) ; break ; } } if ( canExecute ) { Throwable thrownException = null ; try { curtarget . performTasks ( ) ; succeededTargets . add ( curtarget . getName ( ) ) ; } catch ( RuntimeException ex ) { if ( ! ( keepGoingMode ) ) { throw ex ; } thrownException = ex ; } catch ( Throwable ex ) { if ( ! ( keepGoingMode ) ) { throw new BuildException ( ex ) ; } thrownException = ex ; } if ( thrownException != null ) { if ( thrownException instanceof BuildException ) { log ( curtarget , "Target '" + curtarget . getName ( ) + "' failed with message '" + thrownException . getMessage ( ) + "'." , MSG_ERR ) ; if ( buildException == null ) { buildException = ( BuildException ) thrownException ; } } else { log ( curtarget , "Target '" + curtarget . getName ( ) + "' failed with message '" + thrownException . getMessage ( ) + "'." , MSG_ERR ) ; thrownException . printStackTrace ( System . err ) ; if ( buildException == null ) { buildException = new BuildException ( thrownException ) ; } } } } if ( curtarget . getName ( ) . equals ( targetName ) ) { break ; } } if ( buildException != null ) { throw buildException ; } } public File resolveFile ( String fileName , File rootDir ) { return fileUtils . resolveFile ( rootDir , fileName ) ; } public File resolveFile ( String fileName ) { return fileUtils . resolveFile ( baseDir , fileName ) ; } public static String translatePath ( String toProcess ) { if ( toProcess == null || toProcess . length ( ) == 0 ) { return "" ; } StringBuffer path = new StringBuffer ( toProcess . length ( ) + 50 ) ; PathTokenizer tokenizer = new PathTokenizer ( toProcess ) ; while ( tokenizer . hasMoreTokens ( ) ) { String pathComponent = tokenizer . nextToken ( ) ; pathComponent = pathComponent . replace ( '/' , File . separatorChar ) ; pathComponent = pathComponent . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) != 0 ) { path . append ( File . pathSeparatorChar ) ; } path . append ( pathComponent ) ; } return path . toString ( ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { fileUtils . copyFile ( sourceFile , destFile ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { fileUtils . copyFile ( sourceFile , destFile ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { log ( "Cannot change the modification time of " + file + " in JDK 1.1" , Project . MSG_WARN ) ; return ; } fileUtils . setFileLastModified ( file , time ) ; log ( "Setting modification time for " + file , MSG_VERBOSE ) ; } public static boolean toBoolean ( String s ) { return ( "on" . equalsIgnoreCase ( s ) || "true" . equalsIgnoreCase ( s ) || "yes" . equalsIgnoreCase ( s ) ) ; } public final Vector topoSort ( String root , Hashtable targets ) throws BuildException { Vector ret = new Vector ( ) ; Hashtable state = new Hashtable ( ) ; Stack visiting = new Stack ( ) ; tsort ( root , targets , state , visiting , ret ) ; log ( "Build sequence for target `" + root + "' is " + ret , MSG_VERBOSE ) ; for ( Enumeration en = targets . keys ( ) ; en . hasMoreElements ( ) ; ) { String curTarget = ( String ) en . nextElement ( ) ; String st = ( String ) state . get ( curTarget ) ; if ( st == null ) { tsort ( curTarget , targets , state , visiting , ret ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + curTarget ) ; } } log ( "Complete build sequence is " + ret , MSG_VERBOSE ) ; return ret ; } private final void tsort ( String root , Hashtable targets , Hashtable state , Stack visiting , Vector ret ) throws BuildException { state . put ( root , VISITING ) ; visiting . push ( root ) ; Target target = ( Target ) targets . get ( root ) ; if ( target == null ) { StringBuffer sb = new StringBuffer ( "Target `" ) ; sb . append ( root ) ; sb . append ( "' does not exist in this project. " ) ; visiting . pop ( ) ; if ( ! visiting . empty ( ) ) { String parent = ( String ) visiting . peek ( ) ; sb . append ( "It is used from target `" ) ; sb . append ( parent ) ; sb . append ( "'." ) ; } throw new BuildException ( new String ( sb ) ) ; } for ( Enumeration en = target . getDependencies ( ) ; en . hasMoreElements ( ) ; ) { String cur = ( String ) en . nextElement ( ) ; String m = ( String ) state . get ( cur ) ; if ( m == null ) { tsort ( cur , targets , state , visiting , ret ) ; } else if ( m == VISITING ) { throw makeCircularException ( cur , visiting ) ; } } String p = ( String ) visiting . pop ( ) ; if ( root != p ) { throw new RuntimeException ( "Unexpected internal error: expected to " + "pop " + root + " but got " + p ) ; } state . put ( root , VISITED ) ; ret . addElement ( target ) ; } private static BuildException makeCircularException ( String end , Stack stk ) { StringBuffer sb = new StringBuffer ( "Circular dependency: " ) ; sb . append ( end ) ; String c ; do { c = ( String ) stk . pop ( ) ; sb . append ( " <- " ) ; sb . append ( c ) ; } while ( ! c . equals ( end ) ) ; return new BuildException ( new String ( sb ) ) ; } public void addReference ( String name , Object value ) { synchronized ( references ) { Object old = ( ( AntRefTable ) references ) . getReal ( name ) ; if ( old == value ) { return ; } if ( old != null && ! ( old instanceof UnknownElement ) ) { log ( "Overriding previous definition of reference to " + name , MSG_WARN ) ; } log ( "Adding reference: " + name , MSG_DEBUG ) ; references . put ( name , value ) ; } } public Hashtable getReferences ( ) { return references ; } public Object getReference ( String key ) { return references . get ( key ) ; } public String getElementName ( Object element ) { return ComponentHelper . getComponentHelper ( this ) . getElementName ( element ) ; } public void fireBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . buildStarted ( event ) ; } } public void fireBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . buildFinished ( event ) ; } } protected void fireTargetStarted ( Target target ) { BuildEvent event = new BuildEvent ( target ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . targetStarted ( event ) ; } } protected void fireTargetFinished ( Target target , Throwable exception ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . targetFinished ( event ) ; } } protected void fireTaskStarted ( Task task ) { registerThreadTask ( Thread . currentThread ( ) , task ) ; BuildEvent event = new BuildEvent ( task ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . taskStarted ( event ) ; } } protected void fireTaskFinished ( Task task , Throwable exception ) { registerThreadTask ( Thread . currentThread ( ) , null ) ; System . out . flush ( ) ; System . err . flush ( ) ; BuildEvent event = new BuildEvent ( task ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . taskFinished ( event ) ; } } private void fireMessageLoggedEvent ( BuildEvent event , String message , int priority ) { if ( message . endsWith ( StringUtils . LINE_SEP ) ) { int endIndex = message . length ( ) - StringUtils . LINE_SEP . length ( ) ; event . setMessage ( message . substring ( 0 , endIndex ) , priority ) ; } else { event . setMessage ( message , priority ) ; } synchronized ( this ) { if ( loggingMessage ) { throw new BuildException ( "Listener attempted to access " + ( priority == MSG_ERR ? "System.err" : "System.out" ) + " - infinite loop terminated" ) ; } try { loggingMessage = true ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . messageLogged ( event ) ; } } finally { loggingMessage = false ; } } } protected void fireMessageLogged ( Project project , String message , int priority ) { BuildEvent event = new BuildEvent ( project ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Target target , String message , int priority ) { BuildEvent event = new BuildEvent ( target ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Task task , String message , int priority ) { BuildEvent event = new BuildEvent ( task ) ; fireMessageLoggedEvent ( event , message , priority ) ; } public synchronized void registerThreadTask ( Thread thread , Task task ) { if ( task != null ) { threadTasks . put ( thread , task ) ; threadGroupTasks . put ( thread . getThreadGroup ( ) , task ) ; } else { threadTasks . remove ( thread ) ; threadGroupTasks . remove ( thread . getThreadGroup ( ) ) ; } } public Task getThreadTask ( Thread thread ) { Task task = ( Task ) threadTasks . get ( thread ) ; if ( task == null ) { ThreadGroup group = thread . getThreadGroup ( ) ; while ( task == null && group != null ) { task = ( Task ) threadGroupTasks . get ( group ) ; group = group . getParent ( ) ; } } return task ; } private static class AntRefTable extends Hashtable { private Project project ; public AntRefTable ( Project project ) { super ( ) ; this . project = project ; } public Object getReal ( Object key ) { return super . get ( key ) ; } public Object get ( Object key ) { Object o = super . get ( key ) ; if ( o instanceof UnknownElement ) { UnknownElement ue = ( UnknownElement ) o ; ue . maybeConfigure ( ) ; o = ue . getRealThing ( ) ; } return o ; } } public final void setProjectReference ( final Object obj ) { if ( obj instanceof ProjectComponent ) { ( ( ProjectComponent ) obj ) . setProject ( this ) ; return ; } try { Method method = obj . getClass ( ) . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( method != null ) { method . invoke ( obj , new Object [ ] { this } ) ; } } catch ( Throwable e ) { } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . PrintStream ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildLogger ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; public class RecorderEntry implements BuildLogger { private String filename = null ; private boolean record = true ; private int loglevel = Project . MSG_INFO ; private PrintStream out = null ; private long targetStartTime = 0L ; private boolean emacsMode = false ; protected RecorderEntry ( String name ) { targetStartTime = System . currentTimeMillis ( ) ; filename = name ; } public String getFilename ( ) { return filename ; } public void setRecordState ( Boolean state ) { if ( state != null ) { record = state . booleanValue ( ) ; } } public void buildStarted ( BuildEvent event ) { log ( "> BUILD STARTED" , Project . MSG_DEBUG ) ; } public void buildFinished ( BuildEvent event ) { log ( "< BUILD FINISHED" , Project . MSG_DEBUG ) ; Throwable error = event . getException ( ) ; if ( error == null ) { out . println ( StringUtils . LINE_SEP + "BUILD SUCCESSFUL" ) ; } else { out . println ( StringUtils . LINE_SEP + "BUILD FAILED" + StringUtils . LINE_SEP ) ; error . printStackTrace ( out ) ; } out . flush ( ) ; out . close ( ) ; } public void targetStarted ( BuildEvent event ) { log ( ">> TARGET STARTED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; log ( StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" , Project . MSG_INFO ) ; targetStartTime = System . currentTimeMillis ( ) ; } public void targetFinished ( BuildEvent event ) { log ( "<< TARGET FINISHED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; String time = formatTime ( System . currentTimeMillis ( ) - targetStartTime ) ; log ( event . getTarget ( ) + ":  duration " + time , Project . MSG_VERBOSE ) ; out . flush ( ) ; } public void taskStarted ( BuildEvent event ) { log ( ">>> TASK STARTED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; } public void taskFinished ( BuildEvent event ) { log ( "<<< TASK FINISHED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; out . flush ( ) ; } public void messageLogged ( BuildEvent event ) { log ( "--- MESSAGE LOGGED" , Project . MSG_DEBUG ) ; StringBuffer buf = new StringBuffer ( ) ; if ( event . getTask ( ) != null ) { String name = event . getTask ( ) . getTaskName ( ) ; if ( ! emacsMode ) { String label = "[" + name + "] " ; int size = DefaultLogger . LEFT_COLUMN_SIZE - label . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { buf . append ( " " ) ; } buf . append ( label ) ; } } buf . append ( event . getMessage ( ) ) ; log ( buf . toString ( ) , event . getPriority ( ) ) ; } private void log ( String mesg , int level ) { if ( record && ( level <= loglevel ) ) { out . println ( mesg ) ; } } public void setMessageOutputLevel ( int level ) { if ( level >= Project . MSG_ERR && level <= Project . MSG_DEBUG ) { loglevel = level ; } } public void setOutputPrintStream ( PrintStream output ) { out = output ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void setErrorPrintStream ( PrintStream err ) { out = err ; } private static String formatTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; if ( minutes > 0 ) { return Long . toString ( minutes ) + " minute" + ( minutes == 1 ? " " : "s " ) + Long . toString ( seconds % 60 ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } else { return Long . toString ( seconds ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapter ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapterFactory ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . GlobPatternMapper ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; public class Javac extends MatchingTask { private static final String FAIL_MSG = "Compile failed; see the compiler error output for details." ; private Path src ; private File destDir ; private Path compileClasspath ; private Path compileSourcepath ; private String encoding ; private boolean debug = false ; private boolean optimize = false ; private boolean deprecation = false ; private boolean depend = false ; private boolean verbose = false ; private String target ; private Path bootclasspath ; private Path extdirs ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private boolean fork = false ; private String forkedExecutable = null ; private boolean nowarn = false ; private String memoryInitialSize ; private String memoryMaximumSize ; private FacadeTaskHelper facade = null ; protected boolean failOnError = true ; protected boolean listFiles = false ; protected File [ ] compileList = new File [ 0 ] ; private String source ; private String debugLevel ; private File tmpDir ; public Javac ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { facade = new FacadeTaskHelper ( "javac1.1" ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) { facade = new FacadeTaskHelper ( "javac1.2" ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) { facade = new FacadeTaskHelper ( "javac1.3" ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) { facade = new FacadeTaskHelper ( "javac1.4" ) ; } else { facade = new FacadeTaskHelper ( "classic" ) ; } } public String getDebugLevel ( ) { return debugLevel ; } public void setDebugLevel ( String v ) { this . debugLevel = v ; } public String getSource ( ) { return source ; } public void setSource ( String v ) { this . source = v ; } public Path createSrc ( ) { if ( src == null ) { src = new Path ( getProject ( ) ) ; } return src . createPath ( ) ; } protected Path recreateSrc ( ) { src = null ; return createSrc ( ) ; } public void setSrcdir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcdir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setSourcepath ( Path sourcepath ) { if ( compileSourcepath == null ) { compileSourcepath = sourcepath ; } else { compileSourcepath . append ( sourcepath ) ; } } public Path getSourcepath ( ) { return compileSourcepath ; } public Path createSourcepath ( ) { if ( compileSourcepath == null ) { compileSourcepath = new Path ( getProject ( ) ) ; } return compileSourcepath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } } public Path getBootclasspath ( ) { return bootclasspath ; } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path getExtdirs ( ) { return extdirs ; } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( getProject ( ) ) ; } return extdirs . createPath ( ) ; } public void setListfiles ( boolean list ) { listFiles = list ; } public boolean getListfiles ( ) { return listFiles ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setProceed ( boolean proceed ) { failOnError = ! proceed ; } public boolean getFailonerror ( ) { return failOnError ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean getDeprecation ( ) { return deprecation ; } public void setMemoryInitialSize ( String memoryInitialSize ) { this . memoryInitialSize = memoryInitialSize ; } public String getMemoryInitialSize ( ) { return memoryInitialSize ; } public void setMemoryMaximumSize ( String memoryMaximumSize ) { this . memoryMaximumSize = memoryMaximumSize ; } public String getMemoryMaximumSize ( ) { return memoryMaximumSize ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setOptimize ( boolean optimize ) { this . optimize = optimize ; } public boolean getOptimize ( ) { return optimize ; } public void setDepend ( boolean depend ) { this . depend = depend ; } public boolean getDepend ( ) { return depend ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setTarget ( String target ) { this . target = target ; } public String getTarget ( ) { return target ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setFork ( boolean f ) { fork = f ; } public void setExecutable ( String forkExec ) { forkedExecutable = forkExec ; } public String getExecutable ( ) { return forkedExecutable ; } public boolean isForkedJavac ( ) { return fork || "extJavac" . equals ( getCompiler ( ) ) ; } public String getJavacExecutable ( ) { if ( forkedExecutable == null && isForkedJavac ( ) ) { forkedExecutable = getSystemJavac ( ) ; } else if ( forkedExecutable != null && ! isForkedJavac ( ) ) { forkedExecutable = null ; } return forkedExecutable ; } public void setNowarn ( boolean flag ) { this . nowarn = flag ; } public boolean getNowarn ( ) { return nowarn ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { String chosen = facade . getExplicitChoice ( ) ; facade . setImplementation ( getCompiler ( ) ) ; try { return facade . getArgs ( ) ; } finally { facade . setImplementation ( chosen ) ; } } public void setTempdir ( File tmpDir ) { this . tmpDir = tmpDir ; } public File getTempdir ( ) { return tmpDir ; } public void execute ( ) throws BuildException { checkParameters ( ) ; resetFileLists ( ) ; String [ ] list = src . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = getProject ( ) . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , getLocation ( ) ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir != null ? destDir : srcDir , files ) ; } compile ( ) ; } protected void resetFileLists ( ) { compileList = new File [ 0 ] ; } protected void scanDir ( File srcDir , File destDir , String [ ] files ) { GlobPatternMapper m = new GlobPatternMapper ( ) ; m . setFrom ( "*.java" ) ; m . setTo ( "*.class" ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; File [ ] newFiles = sfs . restrictAsFiles ( files , srcDir , destDir , m ) ; if ( newFiles . length > 0 ) { File [ ] newCompileList = new File [ compileList . length + newFiles . length ] ; System . arraycopy ( compileList , 0 , newCompileList , 0 , compileList . length ) ; System . arraycopy ( newFiles , 0 , newCompileList , compileList . length , newFiles . length ) ; compileList = newCompileList ; } } public File [ ] getFileList ( ) { return compileList ; } protected boolean isJdkCompiler ( String compilerImpl ) { return "modern" . equals ( compilerImpl ) || "classic" . equals ( compilerImpl ) || "javac1.1" . equals ( compilerImpl ) || "javac1.2" . equals ( compilerImpl ) || "javac1.3" . equals ( compilerImpl ) || "javac1.4" . equals ( compilerImpl ) ; } protected String getSystemJavac ( ) { return JavaEnvUtils . getJdkExecutable ( "javac" ) ; } public void setCompiler ( String compiler ) { facade . setImplementation ( compiler ) ; } public String getCompiler ( ) { String compilerImpl = getCompilerVersion ( ) ; if ( fork ) { if ( isJdkCompiler ( compilerImpl ) ) { if ( facade . hasBeenSet ( ) ) { log ( "Since fork is true, ignoring compiler setting." , Project . MSG_WARN ) ; } compilerImpl = "extJavac" ; } else { log ( "Since compiler setting isn't classic or modern," + "ignoring fork setting." , Project . MSG_WARN ) ; } } return compilerImpl ; } public String getCompilerVersion ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.compiler" ) ) ; return facade . getImplementation ( ) ; } protected void checkParameters ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( src . size ( ) == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( destDir != null && ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist " + "or is not a directory" , getLocation ( ) ) ; } } protected void compile ( ) { String compilerImpl = getCompiler ( ) ; if ( compileList . length > 0 ) { log ( "Compiling " + compileList . length + " source file" + ( compileList . length == 1 ? "" : "s" ) + ( destDir != null ? " to " + destDir : "" ) ) ; if ( listFiles ) { for ( int i = 0 ; i < compileList . length ; i ++ ) { String filename = compileList [ i ] . getAbsolutePath ( ) ; log ( filename ) ; } } CompilerAdapter adapter = CompilerAdapterFactory . getCompiler ( compilerImpl , this ) ; adapter . setJavac ( this ) ; if ( ! adapter . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , getLocation ( ) ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; public class ImportTask extends Task { private String file ; private boolean optional ; private static final FileUtils FILE_UTILS = FileUtils . newFileUtils ( ) ; public void setOptional ( boolean optional ) { this . optional = true ; } public void setFile ( String file ) { this . file = file ; } public void execute ( ) { if ( file == null ) { throw new BuildException ( "import requires file attribute" ) ; } if ( getOwningTarget ( ) == null || ! "" . equals ( getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "import only allowed as a top-level task" ) ; } ProjectHelper helper = ( ProjectHelper ) getProject ( ) . getReference ( "ant.projectHelper" ) ; Vector importStack = helper . getImportStack ( ) ; if ( importStack . size ( ) == 0 ) { throw new BuildException ( "import requires support in ProjectHelper" ) ; } if ( getLocation ( ) == null || getLocation ( ) . getFileName ( ) == null ) { throw new BuildException ( "Unable to get location of import task" ) ; } File buildFile = new File ( getLocation ( ) . getFileName ( ) ) ; buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; getProject ( ) . log ( "Importing file " + file + " from " + buildFile . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; File buildFileParent = new File ( buildFile . getParent ( ) ) ; File importedFile = FILE_UTILS . resolveFile ( buildFileParent , file ) ; if ( ! importedFile . exists ( ) ) { String message = "Cannot find " + file + " imported from " + buildFile . getAbsolutePath ( ) ; if ( optional ) { getProject ( ) . log ( message , Project . MSG_VERBOSE ) ; return ; } else { throw new BuildException ( message ) ; } } importedFile = new File ( getPath ( importedFile ) ) ; if ( importStack . contains ( importedFile ) ) { getProject ( ) . log ( "Skipped already imported file:\n   " + importedFile + "\n" , Project . MSG_WARN ) ; return ; } try { helper . parse ( getProject ( ) , importedFile ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } } private static String getPath ( File file ) { try { return file . getCanonicalPath ( ) ; } catch ( IOException e ) { return file . getAbsolutePath ( ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . bzip2 . CBZip2OutputStream ; import org . apache . tools . tar . TarConstants ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarOutputStream ; import org . apache . tools . zip . UnixStat ; public class Tar extends MatchingTask { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; File tarFile ; File baseDir ; private TarLongFileMode longFileMode = new TarLongFileMode ( ) ; Vector filesets = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; private TarCompressionMethod compression = new TarCompressionMethod ( ) ; public TarFileSet createTarFileSet ( ) { TarFileSet fileset = new TarFileSet ( ) ; filesets . addElement ( fileset ) ; return fileset ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setDestFile ( File destFile ) { this . tarFile = destFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { log ( "DEPRECATED - The setLongfile(String) method has been deprecated." + " Use setLongfile(Tar.TarLongFileMode) instead." ) ; this . longFileMode = new TarLongFileMode ( ) ; longFileMode . setValue ( mode ) ; } public void setLongfile ( TarLongFileMode mode ) { this . longFileMode = mode ; } public void setCompression ( TarCompressionMethod mode ) { this . compression = mode ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , getLocation ( ) ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , getLocation ( ) ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , getLocation ( ) ) ; } Vector savedFileSets = ( Vector ) filesets . clone ( ) ; try { if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , getLocation ( ) ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basedir " + "attribute or some nested filesets." , getLocation ( ) ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( getProject ( ) ) ; if ( ! archiveIsUpToDate ( files , fs . getDir ( getProject ( ) ) ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( fs . getDir ( getProject ( ) ) , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include " + "itself" , getLocation ( ) ) ; } } } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( compression . compress ( new BufferedOutputStream ( new FileOutputStream ( tarFile ) ) ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . isTruncateMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . isFailMode ( ) || longFileMode . isOmitMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( getProject ( ) ) ; if ( files . length > 1 && fs . getFullpath ( ) . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only " + "be specified for " + "filesets that specify a " + "single file." ) ; } for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( fs . getDir ( getProject ( ) ) , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , fs ) ; } } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( tOut != null ) { try { tOut . close ( ) ; } catch ( IOException e ) { } } } } finally { filesets = savedFileSets ; } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { FileInputStream fIn = null ; String fullpath = tarFileSet . getFullpath ( ) ; if ( fullpath . length ( ) > 0 ) { vPath = fullpath ; } else { if ( vPath . length ( ) <= 0 ) { return ; } if ( file . isDirectory ( ) && ! vPath . endsWith ( "/" ) ) { vPath += "/" ; } String prefix = tarFileSet . getPrefix ( ) ; if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) ) { prefix = prefix + "/" ; } vPath = prefix + vPath ; } if ( vPath . startsWith ( "/" ) && ! tarFileSet . getPreserveLeadingSlashes ( ) ) { int l = vPath . length ( ) ; if ( l <= 1 ) { return ; } vPath = vPath . substring ( 1 , l ) ; } try { if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . isOmitMode ( ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . isWarnMode ( ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed " + "successfully by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . isFailMode ( ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , getLocation ( ) ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setModTime ( file . lastModified ( ) ) ; if ( ! file . isDirectory ( ) ) { te . setSize ( file . length ( ) ) ; te . setMode ( tarFileSet . getMode ( ) ) ; } else { te . setMode ( tarFileSet . getDirMode ( ) ) ; } te . setUserName ( tarFileSet . getUserName ( ) ) ; te . setGroupName ( tarFileSet . getGroup ( ) ) ; tOut . putNextEntry ( te ) ; if ( ! file . isDirectory ( ) ) { fIn = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = fIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } tOut . closeEntry ( ) ; } finally { if ( fIn != null ) { fIn . close ( ) ; } } } protected boolean archiveIsUpToDate ( String [ ] files ) { return archiveIsUpToDate ( files , baseDir ) ; } protected boolean archiveIsUpToDate ( String [ ] files , File dir ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , dir , null , mm ) . length == 0 ; } public static class TarFileSet extends FileSet { private String [ ] files = null ; private int fileMode = UnixStat . FILE_FLAG | UnixStat . DEFAULT_FILE_PERM ; private int dirMode = UnixStat . DIR_FLAG | UnixStat . DEFAULT_DIR_PERM ; private String userName = "" ; private String groupName = "" ; private String prefix = "" ; private String fullpath = "" ; private boolean preserveLeadingSlashes = false ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { DirectoryScanner ds = getDirectoryScanner ( p ) ; String [ ] directories = ds . getIncludedDirectories ( ) ; String [ ] filesPerSe = ds . getIncludedFiles ( ) ; files = new String [ directories . length + filesPerSe . length ] ; System . arraycopy ( directories , 0 , files , 0 , directories . length ) ; System . arraycopy ( filesPerSe , 0 , files , directories . length , filesPerSe . length ) ; } return files ; } public void setMode ( String octalString ) { this . fileMode = UnixStat . FILE_FLAG | Integer . parseInt ( octalString , 8 ) ; } public int getMode ( ) { return fileMode ; } public void setDirMode ( String octalString ) { this . dirMode = UnixStat . DIR_FLAG | Integer . parseInt ( octalString , 8 ) ; } public int getDirMode ( ) { return dirMode ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getUserName ( ) { return userName ; } public void setGroup ( String groupName ) { this . groupName = groupName ; } public String getGroup ( ) { return groupName ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public void setPreserveLeadingSlashes ( boolean b ) { this . preserveLeadingSlashes = b ; } public boolean getPreserveLeadingSlashes ( ) { return preserveLeadingSlashes ; } } public static class TarLongFileMode extends EnumeratedAttribute { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; private final String [ ] validModes = { WARN , FAIL , TRUNCATE , GNU , OMIT } ; public TarLongFileMode ( ) { super ( ) ; setValue ( WARN ) ; } public String [ ] getValues ( ) { return validModes ; } public boolean isTruncateMode ( ) { return TRUNCATE . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isWarnMode ( ) { return WARN . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isGnuMode ( ) { return GNU . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFailMode ( ) { return FAIL . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isOmitMode ( ) { return OMIT . equalsIgnoreCase ( getValue ( ) ) ; } } public static final class TarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public TarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } private OutputStream compress ( final OutputStream ostream ) throws IOException { final String value = getValue ( ) ; if ( GZIP . equals ( value ) ) { return new GZIPOutputStream ( ostream ) ; } else { if ( BZIP2 . equals ( value ) ) { ostream . write ( 'B' ) ; ostream . write ( 'Z' ) ; return new CBZip2OutputStream ( ostream ) ; } } return ostream ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . StringReader ; import java . io . OutputStream ; import java . io . InputStream ; import java . io . PrintStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . LazyFileOutputStream ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . TeeOutputStream ; public class Redirector { private File out ; private File error ; private File input ; private boolean logError = false ; private ByteArrayOutputStream baos = null ; private ByteArrayOutputStream errorBaos = null ; private String outputProperty ; private String errorProperty ; private String inputString ; private boolean append = false ; private Task managingTask ; private OutputStream outputStream = null ; private OutputStream errorStream = null ; private InputStream inputStream = null ; private PrintStream outPrintStream = null ; private PrintStream errorPrintStream = null ; public Redirector ( Task managingTask ) { this . managingTask = managingTask ; } public void setInput ( File input ) { this . input = input ; } public void setInputString ( String inputString ) { this . inputString = inputString ; } public void setOutput ( File out ) { this . out = out ; } public void setLogError ( boolean logError ) { this . logError = logError ; } public void setError ( File error ) { this . error = error ; } public void setOutputProperty ( String outputProperty ) { this . outputProperty = outputProperty ; } public void setAppend ( boolean append ) { this . append = append ; } public void setErrorProperty ( String errorProperty ) { this . errorProperty = errorProperty ; } private void setPropertyFromBAOS ( ByteArrayOutputStream baos , String propertyName ) throws IOException { BufferedReader in = new BufferedReader ( new StringReader ( Execute . toString ( baos ) ) ) ; String line = null ; StringBuffer val = new StringBuffer ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( val . length ( ) != 0 ) { val . append ( StringUtils . LINE_SEP ) ; } val . append ( line ) ; } managingTask . getProject ( ) . setNewProperty ( propertyName , val . toString ( ) ) ; } public void createStreams ( ) { if ( out == null && outputProperty == null ) { outputStream = new LogOutputStream ( managingTask , Project . MSG_INFO ) ; errorStream = new LogOutputStream ( managingTask , Project . MSG_WARN ) ; } else { if ( out != null ) { outputStream = new LazyFileOutputStream ( out , append ) ; managingTask . log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } if ( outputProperty != null ) { baos = new ByteArrayOutputStream ( ) ; managingTask . log ( "Output redirected to property: " + outputProperty , Project . MSG_VERBOSE ) ; if ( out == null ) { outputStream = baos ; } else { outputStream = new TeeOutputStream ( outputStream , baos ) ; } } else { baos = null ; } errorStream = outputStream ; } if ( logError ) { errorStream = new LogOutputStream ( managingTask , Project . MSG_WARN ) ; } if ( error != null ) { errorStream = new LazyFileOutputStream ( error , append ) ; managingTask . log ( "Error redirected to " + error , Project . MSG_VERBOSE ) ; } if ( errorProperty != null ) { errorBaos = new ByteArrayOutputStream ( ) ; managingTask . log ( "Error redirected to property: " + errorProperty , Project . MSG_VERBOSE ) ; if ( error == null ) { errorStream = errorBaos ; } else { errorStream = new TeeOutputStream ( errorStream , errorBaos ) ; } } else { errorBaos = null ; } if ( input != null && inputString != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } if ( input != null ) { try { inputStream = new FileInputStream ( input ) ; } catch ( FileNotFoundException fne ) { throw new BuildException ( "Cannot read from " + input , fne ) ; } } else if ( inputString != null ) { inputStream = new ByteArrayInputStream ( inputString . getBytes ( ) ) ; } } public ExecuteStreamHandler createHandler ( ) throws BuildException { createStreams ( ) ; return new PumpStreamHandler ( outputStream , errorStream , inputStream ) ; } protected void handleOutput ( String output ) { if ( outPrintStream == null ) { outPrintStream = new PrintStream ( outputStream ) ; } outPrintStream . print ( output ) ; } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( inputStream == null ) { return managingTask . getProject ( ) . defaultInput ( buffer , offset , length ) ; } else { return inputStream . read ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( outPrintStream == null ) { outPrintStream = new PrintStream ( outputStream ) ; } outPrintStream . print ( output ) ; outPrintStream . flush ( ) ; } protected void handleErrorOutput ( String output ) { if ( errorPrintStream == null ) { errorPrintStream = new PrintStream ( errorStream ) ; } errorPrintStream . print ( output ) ; } protected void handleErrorFlush ( String output ) { if ( errorPrintStream == null ) { errorPrintStream = new PrintStream ( errorStream ) ; } errorPrintStream . print ( output ) ; } public OutputStream getOutputStream ( ) { return outputStream ; } public OutputStream getErrorStream ( ) { return errorStream ; } public InputStream getInputStream ( ) { return inputStream ; } public void complete ( ) throws IOException { System . out . flush ( ) ; System . err . flush ( ) ; if ( inputStream != null ) { inputStream . close ( ) ; } if ( outputStream instanceof LazyFileOutputStream ) { ( ( LazyFileOutputStream ) outputStream ) . open ( ) ; } outputStream . close ( ) ; if ( errorStream != outputStream ) { if ( errorStream instanceof LazyFileOutputStream ) { ( ( LazyFileOutputStream ) errorStream ) . open ( ) ; } errorStream . close ( ) ; } if ( baos != null ) { setPropertyFromBAOS ( baos , outputProperty ) ; } if ( errorBaos != null ) { setPropertyFromBAOS ( errorBaos , errorProperty ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; public class TempFile extends Task { private String property ; private File destDir = null ; private String prefix ; private String suffix = "" ; public void setProperty ( String property ) { this . property = property ; } public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void execute ( ) throws BuildException { if ( property == null || property . length ( ) == 0 ) { throw new BuildException ( "no property specified" ) ; } if ( destDir == null ) { destDir = getProject ( ) . resolveFile ( "." ) ; } FileUtils utils = FileUtils . newFileUtils ( ) ; File tfile = utils . createTempFile ( prefix , suffix , destDir ) ; getProject ( ) . setNewProperty ( property , tfile . toString ( ) ) ; } } 	1
package org . apache . tools . ant . types ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class PatternSet extends DataType implements Cloneable { private Vector includeList = new Vector ( ) ; private Vector excludeList = new Vector ( ) ; private Vector includesFileList = new Vector ( ) ; private Vector excludesFileList = new Vector ( ) ; public class NameEntry { private String name ; private String ifCond ; private String unlessCond ; public void setName ( String name ) { this . name = name ; } public void setIf ( String cond ) { ifCond = cond ; } public void setUnless ( String cond ) { unlessCond = cond ; } public String getName ( ) { return name ; } public String evalName ( Project p ) { return valid ( p ) ? name : null ; } private boolean valid ( Project p ) { if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( name ) ; if ( ( ifCond != null ) || ( unlessCond != null ) ) { buf . append ( ":" ) ; String connector = "" ; if ( ifCond != null ) { buf . append ( "if->" ) ; buf . append ( ifCond ) ; connector = ";" ; } if ( unlessCond != null ) { buf . append ( connector ) ; buf . append ( "unless->" ) ; buf . append ( unlessCond ) ; } } return buf . toString ( ) ; } } public PatternSet ( ) { super ( ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! includeList . isEmpty ( ) || ! excludeList . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void addConfiguredPatternset ( PatternSet p ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } String [ ] nestedIncludes = p . getIncludePatterns ( getProject ( ) ) ; String [ ] nestedExcludes = p . getExcludePatterns ( getProject ( ) ) ; if ( nestedIncludes != null ) { for ( int i = 0 ; i < nestedIncludes . length ; i ++ ) { createInclude ( ) . setName ( nestedIncludes [ i ] ) ; } } if ( nestedExcludes != null ) { for ( int i = 0 ; i < nestedExcludes . length ; i ++ ) { createExclude ( ) . setName ( nestedExcludes [ i ] ) ; } } } public NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includeList ) ; } public NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includesFileList ) ; } public NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludeList ) ; } public NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludesFileList ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( includes != null && includes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( includes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createInclude ( ) . setName ( tok . nextToken ( ) ) ; } } } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( excludes != null && excludes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( excludes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( tok . nextToken ( ) ) ; } } } private NameEntry addPatternToList ( Vector list ) { NameEntry result = new NameEntry ( ) ; list . addElement ( result ) ; return result ; } public void setIncludesfile ( File includesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createIncludesFile ( ) . setName ( includesFile . getAbsolutePath ( ) ) ; } public void setExcludesfile ( File excludesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createExcludesFile ( ) . setName ( excludesFile . getAbsolutePath ( ) ) ; } private void readPatterns ( File patternfile , Vector patternlist , Project p ) throws BuildException { BufferedReader patternReader = null ; try { patternReader = new BufferedReader ( new FileReader ( patternfile ) ) ; String line = patternReader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) > 0 ) { line = p . replaceProperties ( line ) ; addPatternToList ( patternlist ) . setName ( line ) ; } line = patternReader . readLine ( ) ; } } catch ( IOException ioe ) { String msg = "An error occured while reading from pattern file: " + patternfile ; throw new BuildException ( msg , ioe ) ; } finally { if ( null != patternReader ) { try { patternReader . close ( ) ; } catch ( IOException ioe ) { } } } } public void append ( PatternSet other , Project p ) { if ( isReference ( ) ) { throw new BuildException ( "Cannot append to a reference" ) ; } String [ ] incl = other . getIncludePatterns ( p ) ; if ( incl != null ) { for ( int i = 0 ; i < incl . length ; i ++ ) { createInclude ( ) . setName ( incl [ i ] ) ; } } String [ ] excl = other . getExcludePatterns ( p ) ; if ( excl != null ) { for ( int i = 0 ; i < excl . length ; i ++ ) { createExclude ( ) . setName ( excl [ i ] ) ; } } } public String [ ] getIncludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getIncludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( includeList , p ) ; } } public String [ ] getExcludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExcludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( excludeList , p ) ; } } boolean hasPatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . hasPatterns ( p ) ; } else { return includesFileList . size ( ) > 0 || excludesFileList . size ( ) > 0 || includeList . size ( ) > 0 || excludeList . size ( ) > 0 ; } } private PatternSet getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( ! ( o instanceof PatternSet ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a patternset" ; throw new BuildException ( msg ) ; } else { return ( PatternSet ) o ; } } private String [ ] makeArray ( Vector list , Project p ) { if ( list . size ( ) == 0 ) { return null ; } Vector tmpNames = new Vector ( ) ; for ( Enumeration e = list . elements ( ) ; e . hasMoreElements ( ) ; ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String pattern = ne . evalName ( p ) ; if ( pattern != null && pattern . length ( ) > 0 ) { tmpNames . addElement ( pattern ) ; } } String [ ] result = new String [ tmpNames . size ( ) ] ; tmpNames . copyInto ( result ) ; return result ; } private void readFiles ( Project p ) { if ( includesFileList . size ( ) > 0 ) { Enumeration e = includesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File inclFile = p . resolveFile ( fileName ) ; if ( ! inclFile . exists ( ) ) { throw new BuildException ( "Includesfile " + inclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( inclFile , includeList , p ) ; } } includesFileList . removeAllElements ( ) ; } if ( excludesFileList . size ( ) > 0 ) { Enumeration e = excludesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File exclFile = p . resolveFile ( fileName ) ; if ( ! exclFile . exists ( ) ) { throw new BuildException ( "Excludesfile " + exclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( exclFile , excludeList , p ) ; } } excludesFileList . removeAllElements ( ) ; } } public String toString ( ) { return "patternSet{ includes: " + includeList + " excludes: " + excludeList + " }" ; } public Object clone ( ) { if ( isReference ( ) ) { return getRef ( getProject ( ) ) . clone ( ) ; } else { try { PatternSet ps = ( PatternSet ) super . clone ( ) ; ps . includeList = ( Vector ) includeList . clone ( ) ; ps . excludeList = ( Vector ) excludeList . clone ( ) ; ps . includesFileList = ( Vector ) includesFileList . clone ( ) ; ps . excludesFileList = ( Vector ) excludesFileList . clone ( ) ; return ps ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } } } 	1
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . JavaEnvUtils ; public class CompilerAdapterFactory { private static final String MODERN_COMPILER = "com.sun.tools.javac.Main" ; private CompilerAdapterFactory ( ) { } public static CompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { boolean isClassicCompilerSupported = true ; if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) { isClassicCompilerSupported = false ; } if ( compilerType . equalsIgnoreCase ( "jikes" ) ) { return new Jikes ( ) ; } if ( compilerType . equalsIgnoreCase ( "extJavac" ) ) { return new JavacExternal ( ) ; } if ( compilerType . equalsIgnoreCase ( "classic" ) || compilerType . equalsIgnoreCase ( "javac1.1" ) || compilerType . equalsIgnoreCase ( "javac1.2" ) ) { if ( isClassicCompilerSupported ) { return new Javac12 ( ) ; } else { task . log ( "This version of java does " + "not support the classic " + "compiler; upgrading to modern" , Project . MSG_WARN ) ; compilerType = "modern" ; } } if ( compilerType . equalsIgnoreCase ( "modern" ) || compilerType . equalsIgnoreCase ( "javac1.3" ) || compilerType . equalsIgnoreCase ( "javac1.4" ) ) { if ( doesModernCompilerExist ( ) ) { return new Javac13 ( ) ; } else { if ( isClassicCompilerSupported ) { task . log ( "Modern compiler not found - looking for " + "classic compiler" , Project . MSG_WARN ) ; return new Javac12 ( ) ; } else { throw new BuildException ( "Unable to find a javac " + "compiler;\n" + MODERN_COMPILER + " is not on the " + "classpath.\n" + "Perhaps JAVA_HOME does not" + " point to the JDK" ) ; } } } if ( compilerType . equalsIgnoreCase ( "jvc" ) || compilerType . equalsIgnoreCase ( "microsoft" ) ) { return new Jvc ( ) ; } if ( compilerType . equalsIgnoreCase ( "kjc" ) ) { return new Kjc ( ) ; } if ( compilerType . equalsIgnoreCase ( "gcj" ) ) { return new Gcj ( ) ; } if ( compilerType . equalsIgnoreCase ( "sj" ) || compilerType . equalsIgnoreCase ( "symantec" ) ) { return new Sj ( ) ; } return resolveClassName ( compilerType ) ; } private static boolean doesModernCompilerExist ( ) { try { Class . forName ( MODERN_COMPILER ) ; return true ; } catch ( ClassNotFoundException cnfe ) { try { CompilerAdapterFactory . class . getClassLoader ( ) . loadClass ( MODERN_COMPILER ) ; return true ; } catch ( ClassNotFoundException cnfe2 ) { } } return false ; } private static CompilerAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( CompilerAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( "Compiler Adapter '" + className + "' can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a compiler adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( "Compiler Adapter " + className + " caused an interesting exception." , t ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . Driver ; import java . sql . SQLException ; import java . util . Hashtable ; import java . util . Properties ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public abstract class JDBCTask extends Task { private static Hashtable loaderMap = new Hashtable ( 3 ) ; private boolean caching = true ; private Path classpath ; private AntClassLoader loader ; private boolean autocommit = false ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private String rdbms = null ; private String version = null ; public void setClasspath ( Path classpath ) { this . classpath = classpath ; } public void setCaching ( boolean enable ) { caching = enable ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setDriver ( String driver ) { this . driver = driver ; } public void setUrl ( String url ) { this . url = url ; } public void setPassword ( String password ) { this . password = password ; } public void setAutocommit ( boolean autocommit ) { this . autocommit = autocommit ; } public void setRdbms ( String rdbms ) { this . rdbms = rdbms ; } public void setVersion ( String version ) { this . version = version ; } protected boolean isValidRdbms ( Connection conn ) { if ( rdbms == null && version == null ) { return true ; } try { DatabaseMetaData dmd = conn . getMetaData ( ) ; if ( rdbms != null ) { String theVendor = dmd . getDatabaseProductName ( ) . toLowerCase ( ) ; log ( "RDBMS = " + theVendor , Project . MSG_VERBOSE ) ; if ( theVendor == null || theVendor . indexOf ( rdbms ) < 0 ) { log ( "Not the required RDBMS: " + rdbms , Project . MSG_VERBOSE ) ; return false ; } } if ( version != null ) { String theVersion = dmd . getDatabaseProductVersion ( ) . toLowerCase ( ) ; log ( "Version = " + theVersion , Project . MSG_VERBOSE ) ; if ( theVersion == null || ! ( theVersion . startsWith ( version ) || theVersion . indexOf ( " " + version ) >= 0 ) ) { log ( "Not the required version: \"" + version + "\"" , Project . MSG_VERBOSE ) ; return false ; } } } catch ( SQLException e ) { log ( "Failed to obtain required RDBMS information" , Project . MSG_ERR ) ; return false ; } return true ; } protected static Hashtable getLoaderMap ( ) { return loaderMap ; } protected AntClassLoader getLoader ( ) { return loader ; } protected Connection getConnection ( ) throws BuildException { if ( userId == null ) { throw new BuildException ( "User Id attribute must be set!" , getLocation ( ) ) ; } if ( password == null ) { throw new BuildException ( "Password attribute must be set!" , getLocation ( ) ) ; } if ( url == null ) { throw new BuildException ( "Url attribute must be set!" , getLocation ( ) ) ; } try { log ( "connecting to " + getUrl ( ) , Project . MSG_VERBOSE ) ; Properties info = new Properties ( ) ; info . put ( "user" , getUserId ( ) ) ; info . put ( "password" , getPassword ( ) ) ; Connection conn = getDriver ( ) . connect ( getUrl ( ) , info ) ; if ( conn == null ) { throw new SQLException ( "No suitable Driver for " + url ) ; } conn . setAutoCommit ( autocommit ) ; return conn ; } catch ( SQLException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private Driver getDriver ( ) throws BuildException { if ( driver == null ) { throw new BuildException ( "Driver attribute must be set!" , getLocation ( ) ) ; } Driver driverInstance = null ; try { Class dc ; if ( classpath != null ) { synchronized ( loaderMap ) { if ( caching ) { loader = ( AntClassLoader ) loaderMap . get ( driver ) ; } if ( loader == null ) { log ( "Loading " + driver + " using AntClassLoader with classpath " + classpath , Project . MSG_VERBOSE ) ; loader = getProject ( ) . createClassLoader ( classpath ) ; if ( caching ) { loaderMap . put ( driver , loader ) ; } } else { log ( "Loading " + driver + " using a cached AntClassLoader." , Project . MSG_VERBOSE ) ; } } dc = loader . loadClass ( driver ) ; } else { log ( "Loading " + driver + " using system loader." , Project . MSG_VERBOSE ) ; dc = Class . forName ( driver ) ; } driverInstance = ( Driver ) dc . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class Not Found: JDBC driver " + driver + " could not be loaded" , getLocation ( ) ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Illegal Access: JDBC driver " + driver + " could not be loaded" , getLocation ( ) ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Instantiation Exception: JDBC driver " + driver + " could not be loaded" , getLocation ( ) ) ; } return driverInstance ; } public void isCaching ( boolean value ) { caching = value ; } public Path getClasspath ( ) { return classpath ; } public boolean isAutocommit ( ) { return autocommit ; } public String getUrl ( ) { return url ; } public String getUserId ( ) { return userId ; } public void setUserid ( String userId ) { this . userId = userId ; } public String getPassword ( ) { return password ; } public String getRdbms ( ) { return rdbms ; } public String getVersion ( ) { return version ; } } 	1
package org . apache . tools . ant . util ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . Resource ; public class SourceFileScanner implements ResourceFactory { protected Task task ; private FileUtils fileUtils ; private File destDir ; public SourceFileScanner ( Task task ) { this . task = task ; fileUtils = FileUtils . newFileUtils ( ) ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { this . destDir = destDir ; Vector v = new Vector ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File src = fileUtils . resolveFile ( srcDir , files [ i ] ) ; v . addElement ( new Resource ( files [ i ] , src . exists ( ) , src . lastModified ( ) , src . isDirectory ( ) ) ) ; } Resource [ ] sourceresources = new Resource [ v . size ( ) ] ; v . copyInto ( sourceresources ) ; Resource [ ] outofdate = ResourceUtils . selectOutOfDateSources ( task , sourceresources , mapper , this ) ; String [ ] result = new String [ outofdate . length ] ; for ( int counter = 0 ; counter < outofdate . length ; counter ++ ) { result [ counter ] = outofdate [ counter ] . getName ( ) ; } return result ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { String [ ] res = restrict ( files , srcDir , destDir , mapper ) ; File [ ] result = new File [ res . length ] ; for ( int i = 0 ; i < res . length ; i ++ ) { result [ i ] = new File ( srcDir , res [ i ] ) ; } return result ; } public Resource getResource ( String name ) { File src = fileUtils . resolveFile ( destDir , name ) ; return new Resource ( name , src . exists ( ) , src . lastModified ( ) , src . isDirectory ( ) ) ; } } 	1
package org . apache . tools . ant . util ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class ClasspathUtils { private static final String LOADER_ID_PREFIX = "ant.loader." ; public static final String REUSE_LOADER_REF = "ant.reuse.loader" ; public static ClassLoader getClassLoaderForPath ( Project p , Reference ref ) { return getClassLoaderForPath ( p , ref , false ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Reference ref , boolean reverseLoader ) { String pathId = ref . getRefId ( ) ; Object path = p . getReference ( pathId ) ; if ( ! ( path instanceof Path ) ) { throw new BuildException ( "The specified classpathref " + pathId + " does not reference a Path." ) ; } String loaderId = LOADER_ID_PREFIX + pathId ; return getClassLoaderForPath ( p , ( Path ) path , loaderId , reverseLoader ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId ) { return getClassLoaderForPath ( p , path , loaderId , false ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId , boolean reverseLoader ) { return getClassLoaderForPath ( p , path , loaderId , reverseLoader , isMagicPropertySet ( p ) ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId , boolean reverseLoader , boolean reuseLoader ) { ClassLoader cl = null ; if ( loaderId != null && reuseLoader ) { Object reusedLoader = p . getReference ( loaderId ) ; if ( reusedLoader != null && ! ( reusedLoader instanceof ClassLoader ) ) { throw new BuildException ( "The specified loader id " + loaderId + " does not reference a class loader" ) ; } cl = ( ClassLoader ) reusedLoader ; } if ( cl == null ) { cl = getUniqueClassLoaderForPath ( p , path , reverseLoader ) ; if ( loaderId != null && reuseLoader ) { p . addReference ( loaderId , cl ) ; } } return cl ; } public static ClassLoader getUniqueClassLoaderForPath ( Project p , Path path , boolean reverseLoader ) { AntClassLoader acl = p . createClassLoader ( path != null ? path : Path . systemClasspath ) ; if ( reverseLoader ) { acl . setParentFirst ( false ) ; acl . addJavaLibraries ( ) ; } return acl ; } public static Object newInstance ( String className , ClassLoader userDefinedLoader ) { try { Class clazz = userDefinedLoader . loadClass ( className ) ; Object o = clazz . newInstance ( ) ; return o ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class " + className + " not found by the specific classLoader." , e ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Could not instantiate " + className + ". Specified class should have a no " + "argument constructor." , e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Could not instantiate " + className + ". Specified class should have a " + "public constructor." , e ) ; } } public static Delegate getDelegate ( ProjectComponent component ) { return new Delegate ( component ) ; } private static boolean isMagicPropertySet ( Project p ) { return p . getProperty ( REUSE_LOADER_REF ) != null ; } public static class Delegate { private final ProjectComponent component ; private Path classpath ; private String classpathId ; private String className ; private String loaderId ; private boolean reverseLoader = false ; Delegate ( ProjectComponent component ) { this . component = component ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( component . getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClassname ( String fcqn ) { this . className = fcqn ; } public void setClasspathref ( Reference r ) { this . classpathId = r . getRefId ( ) ; createClasspath ( ) . setRefid ( r ) ; } public void setReverseLoader ( boolean reverseLoader ) { this . reverseLoader = reverseLoader ; } public void setLoaderRef ( Reference r ) { this . loaderId = r . getRefId ( ) ; } public ClassLoader getClassLoader ( ) { ClassLoader cl ; cl = ClasspathUtils . getClassLoaderForPath ( getContextProject ( ) , this . classpath , getClassLoadId ( ) , this . reverseLoader , loaderId != null || isMagicPropertySet ( getContextProject ( ) ) ) ; return cl ; } private Project getContextProject ( ) { return this . component . getProject ( ) ; } public String getClassLoadId ( ) { if ( this . loaderId == null && this . classpathId != null ) { return ClasspathUtils . LOADER_ID_PREFIX + this . classpathId ; } else { return this . loaderId ; } } public Object newInstance ( ) { ClassLoader cl = getClassLoader ( ) ; return ClasspathUtils . newInstance ( this . className , cl ) ; } public Path getClasspath ( ) { return classpath ; } public boolean isReverseLoader ( ) { return reverseLoader ; } } } 	1
package org . apache . tools . zip ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . io . UnsupportedEncodingException ; import java . util . Date ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . Deflater ; import java . util . zip . ZipException ; public class ZipOutputStream extends FilterOutputStream { private ZipEntry entry ; private String comment = "" ; private int level = Deflater . DEFAULT_COMPRESSION ; private boolean hasCompressionLevelChanged = false ; private int method = DEFLATED ; private Vector entries = new Vector ( ) ; private CRC32 crc = new CRC32 ( ) ; private long written = 0 ; private long dataStart = 0 ; private long localDataStart = 0 ; private ZipLong cdOffset = new ZipLong ( 0 ) ; private ZipLong cdLength = new ZipLong ( 0 ) ; private static final byte [ ] ZERO = { 0 , 0 } ; private static final byte [ ] LZERO = { 0 , 0 , 0 , 0 } ; private Hashtable offsets = new Hashtable ( ) ; private String encoding = null ; protected Deflater def = new Deflater ( Deflater . DEFAULT_COMPRESSION , true ) ; protected byte [ ] buf = new byte [ 512 ] ; private RandomAccessFile raf = null ; public static final int DEFLATED = ZipEntry . DEFLATED ; public static final int STORED = ZipEntry . STORED ; public ZipOutputStream ( OutputStream out ) { super ( out ) ; } public ZipOutputStream ( File file ) throws IOException { super ( null ) ; try { raf = new RandomAccessFile ( file , "rw" ) ; raf . setLength ( 0 ) ; } catch ( IOException e ) { if ( raf != null ) { try { raf . close ( ) ; } catch ( IOException inner ) { } raf = null ; } out = new FileOutputStream ( file ) ; } } public boolean isSeekable ( ) { return raf != null ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void finish ( ) throws IOException { closeEntry ( ) ; cdOffset = new ZipLong ( written ) ; for ( int i = 0 ; i < entries . size ( ) ; i ++ ) { writeCentralFileHeader ( ( ZipEntry ) entries . elementAt ( i ) ) ; } cdLength = new ZipLong ( written - cdOffset . getValue ( ) ) ; writeCentralDirectoryEnd ( ) ; offsets . clear ( ) ; entries . removeAllElements ( ) ; } public void closeEntry ( ) throws IOException { if ( entry == null ) { return ; } long realCrc = crc . getValue ( ) ; crc . reset ( ) ; if ( entry . getMethod ( ) == DEFLATED ) { def . finish ( ) ; while ( ! def . finished ( ) ) { deflate ( ) ; } entry . setSize ( def . getTotalIn ( ) ) ; entry . setComprSize ( def . getTotalOut ( ) ) ; entry . setCrc ( realCrc ) ; def . reset ( ) ; written += entry . getCompressedSize ( ) ; } else if ( raf == null ) { if ( entry . getCrc ( ) != realCrc ) { throw new ZipException ( "bad CRC checksum for entry " + entry . getName ( ) + ": " + Long . toHexString ( entry . getCrc ( ) ) + " instead of " + Long . toHexString ( realCrc ) ) ; } if ( entry . getSize ( ) != written - dataStart ) { throw new ZipException ( "bad size for entry " + entry . getName ( ) + ": " + entry . getSize ( ) + " instead of " + ( written - dataStart ) ) ; } } else { long size = written - dataStart ; entry . setSize ( size ) ; entry . setComprSize ( size ) ; entry . setCrc ( realCrc ) ; } if ( raf != null ) { long save = raf . getFilePointer ( ) ; raf . seek ( localDataStart ) ; writeOut ( ( new ZipLong ( entry . getCrc ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( entry . getCompressedSize ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( entry . getSize ( ) ) ) . getBytes ( ) ) ; raf . seek ( save ) ; } writeDataDescriptor ( entry ) ; entry = null ; } public void putNextEntry ( ZipEntry ze ) throws IOException { closeEntry ( ) ; entry = ze ; entries . addElement ( entry ) ; if ( entry . getMethod ( ) == - 1 ) { entry . setMethod ( method ) ; } if ( entry . getTime ( ) == - 1 ) { entry . setTime ( System . currentTimeMillis ( ) ) ; } if ( entry . getMethod ( ) == STORED && raf == null ) { if ( entry . getSize ( ) == - 1 ) { throw new ZipException ( "uncompressed size is required for" + " STORED method when not writing to a" + " file" ) ; } if ( entry . getCrc ( ) == - 1 ) { throw new ZipException ( "crc checksum is required for STORED" + " method when not writing to a file" ) ; } entry . setComprSize ( entry . getSize ( ) ) ; } if ( entry . getMethod ( ) == DEFLATED && hasCompressionLevelChanged ) { def . setLevel ( level ) ; hasCompressionLevelChanged = false ; } writeLocalFileHeader ( entry ) ; } public void setComment ( String comment ) { this . comment = comment ; } public void setLevel ( int level ) { hasCompressionLevelChanged = ( this . level != level ) ; this . level = level ; } public void setMethod ( int method ) { this . method = method ; } public void write ( byte [ ] b , int offset , int length ) throws IOException { if ( entry . getMethod ( ) == DEFLATED ) { if ( length > 0 ) { if ( ! def . finished ( ) ) { def . setInput ( b , offset , length ) ; while ( ! def . needsInput ( ) ) { deflate ( ) ; } } } } else { writeOut ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; } public void write ( int b ) throws IOException { byte [ ] buf = new byte [ 1 ] ; buf [ 0 ] = ( byte ) ( b & 0xff ) ; write ( buf , 0 , 1 ) ; } public void close ( ) throws IOException { finish ( ) ; if ( raf != null ) { raf . close ( ) ; } if ( out != null ) { out . close ( ) ; } } public void flush ( ) throws IOException { if ( out == null ) { out . flush ( ) ; } } protected static final ZipLong LFH_SIG = new ZipLong ( 0X04034B50L ) ; protected static final ZipLong DD_SIG = new ZipLong ( 0X08074B50L ) ; protected static final ZipLong CFH_SIG = new ZipLong ( 0X02014B50L ) ; protected static final ZipLong EOCD_SIG = new ZipLong ( 0X06054B50L ) ; protected final void deflate ( ) throws IOException { int len = def . deflate ( buf , 0 , buf . length ) ; if ( len > 0 ) { writeOut ( buf , 0 , len ) ; } } protected void writeLocalFileHeader ( ZipEntry ze ) throws IOException { offsets . put ( ze , new ZipLong ( written ) ) ; writeOut ( LFH_SIG . getBytes ( ) ) ; written += 4 ; if ( ze . getMethod ( ) == DEFLATED && raf == null ) { writeOut ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; writeOut ( ( new ZipShort ( 8 ) ) . getBytes ( ) ) ; } else { writeOut ( ( new ZipShort ( 10 ) ) . getBytes ( ) ) ; writeOut ( ZERO ) ; } written += 4 ; writeOut ( ( new ZipShort ( ze . getMethod ( ) ) ) . getBytes ( ) ) ; written += 2 ; writeOut ( toDosTime ( new Date ( ze . getTime ( ) ) ) . getBytes ( ) ) ; written += 4 ; localDataStart = written ; if ( ze . getMethod ( ) == DEFLATED || raf != null ) { writeOut ( LZERO ) ; writeOut ( LZERO ) ; writeOut ( LZERO ) ; } else { writeOut ( ( new ZipLong ( ze . getCrc ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; } written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; writeOut ( ( new ZipShort ( name . length ) ) . getBytes ( ) ) ; written += 2 ; byte [ ] extra = ze . getLocalFileDataExtra ( ) ; writeOut ( ( new ZipShort ( extra . length ) ) . getBytes ( ) ) ; written += 2 ; writeOut ( name ) ; written += name . length ; writeOut ( extra ) ; written += extra . length ; dataStart = written ; } protected void writeDataDescriptor ( ZipEntry ze ) throws IOException { if ( ze . getMethod ( ) != DEFLATED || raf != null ) { return ; } writeOut ( DD_SIG . getBytes ( ) ) ; writeOut ( ( new ZipLong ( entry . getCrc ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( entry . getCompressedSize ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( entry . getSize ( ) ) ) . getBytes ( ) ) ; written += 16 ; } protected void writeCentralFileHeader ( ZipEntry ze ) throws IOException { writeOut ( CFH_SIG . getBytes ( ) ) ; written += 4 ; writeOut ( ( new ZipShort ( ( ze . getPlatform ( ) << 8 ) | 20 ) ) . getBytes ( ) ) ; written += 2 ; if ( ze . getMethod ( ) == DEFLATED && raf == null ) { writeOut ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; writeOut ( ( new ZipShort ( 8 ) ) . getBytes ( ) ) ; } else { writeOut ( ( new ZipShort ( 10 ) ) . getBytes ( ) ) ; writeOut ( ZERO ) ; } written += 4 ; writeOut ( ( new ZipShort ( ze . getMethod ( ) ) ) . getBytes ( ) ) ; written += 2 ; writeOut ( toDosTime ( new Date ( ze . getTime ( ) ) ) . getBytes ( ) ) ; written += 4 ; writeOut ( ( new ZipLong ( ze . getCrc ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( ze . getCompressedSize ( ) ) ) . getBytes ( ) ) ; writeOut ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; writeOut ( ( new ZipShort ( name . length ) ) . getBytes ( ) ) ; written += 2 ; byte [ ] extra = ze . getCentralDirectoryExtra ( ) ; writeOut ( ( new ZipShort ( extra . length ) ) . getBytes ( ) ) ; written += 2 ; String comm = ze . getComment ( ) ; if ( comm == null ) { comm = "" ; } byte [ ] comment = getBytes ( comm ) ; writeOut ( ( new ZipShort ( comment . length ) ) . getBytes ( ) ) ; written += 2 ; writeOut ( ZERO ) ; written += 2 ; writeOut ( ( new ZipShort ( ze . getInternalAttributes ( ) ) ) . getBytes ( ) ) ; written += 2 ; writeOut ( ( new ZipLong ( ze . getExternalAttributes ( ) ) ) . getBytes ( ) ) ; written += 4 ; writeOut ( ( ( ZipLong ) offsets . get ( ze ) ) . getBytes ( ) ) ; written += 4 ; writeOut ( name ) ; written += name . length ; writeOut ( extra ) ; written += extra . length ; writeOut ( comment ) ; written += comment . length ; } protected void writeCentralDirectoryEnd ( ) throws IOException { writeOut ( EOCD_SIG . getBytes ( ) ) ; writeOut ( ZERO ) ; writeOut ( ZERO ) ; byte [ ] num = ( new ZipShort ( entries . size ( ) ) ) . getBytes ( ) ; writeOut ( num ) ; writeOut ( num ) ; writeOut ( cdLength . getBytes ( ) ) ; writeOut ( cdOffset . getBytes ( ) ) ; byte [ ] data = getBytes ( comment ) ; writeOut ( ( new ZipShort ( data . length ) ) . getBytes ( ) ) ; writeOut ( data ) ; } private static final ZipLong DOS_TIME_MIN = new ZipLong ( 0x00002100L ) ; protected static ZipLong toDosTime ( Date time ) { int year = time . getYear ( ) + 1900 ; int month = time . getMonth ( ) + 1 ; if ( year < 1980 ) { return DOS_TIME_MIN ; } long value = ( ( year - 1980 ) << 25 ) | ( month << 21 ) | ( time . getDate ( ) << 16 ) | ( time . getHours ( ) << 11 ) | ( time . getMinutes ( ) << 5 ) | ( time . getSeconds ( ) > > 1 ) ; byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000L ) > > 24 ) ; return new ZipLong ( result ) ; } protected byte [ ] getBytes ( String name ) throws ZipException { if ( encoding == null ) { return name . getBytes ( ) ; } else { try { return name . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } protected final void writeOut ( byte [ ] data ) throws IOException { writeOut ( data , 0 , data . length ) ; } protected final void writeOut ( byte [ ] data , int offset , int length ) throws IOException { if ( raf != null ) { raf . write ( data , offset , length ) ; } else { out . write ( data , offset , length ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Replace extends MatchingTask { private File src = null ; private NestedString token = null ; private NestedString value = new NestedString ( ) ; private File propertyFile = null ; private File replaceFilterFile = null ; private Properties properties = null ; private Vector replacefilters = new Vector ( ) ; private File dir = null ; private int fileCount ; private int replaceCount ; private boolean summary = false ; private String encoding = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; public class NestedString { private StringBuffer buf = new StringBuffer ( ) ; public void addText ( String val ) { buf . append ( val ) ; } public String getText ( ) { return buf . substring ( 0 ) ; } } public class Replacefilter { private String token ; private String value ; private String property ; public void validate ( ) throws BuildException { if ( token == null ) { String message = "token is a mandatory attribute " + "of replacefilter." ; throw new BuildException ( message ) ; } if ( "" . equals ( token ) ) { String message = "The token attribute must not be an empty " + "string." ; throw new BuildException ( message ) ; } if ( ( value != null ) && ( property != null ) ) { String message = "Either value or property " + "can be specified, but a replacefilter " + "element cannot have both." ; throw new BuildException ( message ) ; } if ( ( property != null ) ) { if ( propertyFile == null ) { String message = "The replacefilter's property attribute " + "can only be used with the replacetask's " + "propertyFile attribute." ; throw new BuildException ( message ) ; } if ( properties == null || properties . getProperty ( property ) == null ) { String message = "property \"" + property + "\" was not found in " + propertyFile . getPath ( ) ; throw new BuildException ( message ) ; } } } public String getReplaceValue ( ) { if ( property != null ) { return properties . getProperty ( property ) ; } else if ( value != null ) { return value ; } else if ( Replace . this . value != null ) { return Replace . this . value . getText ( ) ; } else { return new String ( "" ) ; } } public void setToken ( String token ) { this . token = token ; } public String getToken ( ) { return token ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setProperty ( String property ) { this . property = property ; } public String getProperty ( ) { return property ; } } public void execute ( ) throws BuildException { Vector savedFilters = ( Vector ) replacefilters . clone ( ) ; Properties savedProperties = properties == null ? null : ( Properties ) properties . clone ( ) ; try { if ( replaceFilterFile != null ) { Properties props = getProperties ( replaceFilterFile ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String token = e . nextElement ( ) . toString ( ) ; Replacefilter replaceFilter = createReplacefilter ( ) ; replaceFilter . setToken ( token ) ; replaceFilter . setValue ( props . getProperty ( token ) ) ; } } validateAttributes ( ) ; if ( propertyFile != null ) { properties = getProperties ( propertyFile ) ; } validateReplacefilters ( ) ; fileCount = 0 ; replaceCount = 0 ; if ( src != null ) { processFile ( src ) ; } if ( dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] srcs = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < srcs . length ; i ++ ) { File file = new File ( dir , srcs [ i ] ) ; processFile ( file ) ; } } if ( summary ) { log ( "Replaced " + replaceCount + " occurrences in " + fileCount + " files." , Project . MSG_INFO ) ; } } finally { replacefilters = savedFilters ; properties = savedProperties ; } } public void validateAttributes ( ) throws BuildException { if ( src == null && dir == null ) { String message = "Either the file or the dir attribute " + "must be specified" ; throw new BuildException ( message , getLocation ( ) ) ; } if ( propertyFile != null && ! propertyFile . exists ( ) ) { String message = "Property file " + propertyFile . getPath ( ) + " does not exist." ; throw new BuildException ( message , getLocation ( ) ) ; } if ( token == null && replacefilters . size ( ) == 0 ) { String message = "Either token or a nested replacefilter " + "must be specified" ; throw new BuildException ( message , getLocation ( ) ) ; } if ( token != null && "" . equals ( token . getText ( ) ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message , getLocation ( ) ) ; } } public void validateReplacefilters ( ) throws BuildException { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter element = ( Replacefilter ) replacefilters . elementAt ( i ) ; element . validate ( ) ; } } public Properties getProperties ( File propertyFile ) throws BuildException { Properties properties = new Properties ( ) ; try { properties . load ( new FileInputStream ( propertyFile ) ) ; } catch ( FileNotFoundException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") not found." ; throw new BuildException ( message ) ; } catch ( IOException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") cannot be loaded." ; throw new BuildException ( message ) ; } return properties ; } private void processFile ( File src ) throws BuildException { if ( ! src . exists ( ) ) { throw new BuildException ( "Replace: source file " + src . getPath ( ) + " doesn't exist" , getLocation ( ) ) ; } File temp = fileUtils . createTempFile ( "rep" , ".tmp" , fileUtils . getParentFile ( src ) ) ; temp . deleteOnExit ( ) ; Reader reader = null ; Writer writer = null ; try { reader = encoding == null ? new FileReader ( src ) : new InputStreamReader ( new FileInputStream ( src ) , encoding ) ; writer = encoding == null ? new FileWriter ( temp ) : new OutputStreamWriter ( new FileOutputStream ( temp ) , encoding ) ; BufferedReader br = new BufferedReader ( reader ) ; BufferedWriter bw = new BufferedWriter ( writer ) ; String buf = fileUtils . readFully ( br ) ; if ( buf == null ) { buf = "" ; } String newString = new String ( buf ) ; if ( token != null ) { String val = stringReplace ( value . getText ( ) , "\r\n" , "\n" , false ) ; val = stringReplace ( val , "\n" , StringUtils . LINE_SEP , false ) ; String tok = stringReplace ( token . getText ( ) , "\r\n" , "\n" , false ) ; tok = stringReplace ( tok , "\n" , StringUtils . LINE_SEP , false ) ; log ( "Replacing in " + src . getPath ( ) + ": " + token . getText ( ) + " --> " + value . getText ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , tok , val , true ) ; } if ( replacefilters . size ( ) > 0 ) { newString = processReplacefilters ( newString , src . getPath ( ) ) ; } boolean changes = ! newString . equals ( buf ) ; if ( changes ) { bw . write ( newString , 0 , newString . length ( ) ) ; bw . flush ( ) ; } bw . close ( ) ; writer = null ; br . close ( ) ; reader = null ; if ( changes ) { ++ fileCount ; fileUtils . rename ( temp , src ) ; temp = null ; } } catch ( IOException ioe ) { throw new BuildException ( "IOException in " + src + " - " + ioe . getClass ( ) . getName ( ) + ":" + ioe . getMessage ( ) , ioe , getLocation ( ) ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException e ) { } } if ( temp != null ) { temp . delete ( ) ; } } } private String processReplacefilters ( String buffer , String filename ) { String newString = new String ( buffer ) ; for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; log ( "Replacing in " + filename + ": " + filter . getToken ( ) + " --> " + filter . getReplaceValue ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , filter . getToken ( ) , filter . getReplaceValue ( ) , true ) ; } return newString ; } public void setFile ( File file ) { this . src = file ; } public void setSummary ( boolean summary ) { this . summary = summary ; } public void setReplaceFilterFile ( File filename ) { replaceFilterFile = filename ; } public void setDir ( File dir ) { this . dir = dir ; } public void setToken ( String token ) { createReplaceToken ( ) . addText ( token ) ; } public void setValue ( String value ) { createReplaceValue ( ) . addText ( value ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public NestedString createReplaceToken ( ) { if ( token == null ) { token = new NestedString ( ) ; } return token ; } public NestedString createReplaceValue ( ) { return value ; } public void setPropertyFile ( File filename ) { propertyFile = filename ; } public Replacefilter createReplacefilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . addElement ( filter ) ; return filter ; } private String stringReplace ( String str , String str1 , String str2 , boolean countReplaces ) { StringBuffer ret = new StringBuffer ( ) ; int start = 0 ; int found = str . indexOf ( str1 ) ; while ( found >= 0 ) { if ( found > start ) { ret . append ( str . substring ( start , found ) ) ; } if ( str2 != null ) { ret . append ( str2 ) ; } start = found + str1 . length ( ) ; found = str . indexOf ( str1 , start ) ; if ( countReplaces ) { ++ replaceCount ; } } if ( str . length ( ) > start ) { ret . append ( str . substring ( start , str . length ( ) ) ) ; } return ret . toString ( ) ; } } 	1
package org . apache . tools . ant . helper ; import java . io . File ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Vector ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . RuntimeConfigurable ; public class AntXMLContext { private Project project ; private File buildFile ; private Vector targetVector = new Vector ( ) ; private File buildFileParent ; private String currentProjectName ; private Locator locator ; private Target implicitTarget = new Target ( ) ; private Target currentTarget = null ; private Vector wStack = new Vector ( ) ; private boolean ignoreProjectTag = false ; private Map prefixMapping = new HashMap ( ) ; public AntXMLContext ( Project project ) { this . project = project ; implicitTarget . setProject ( project ) ; implicitTarget . setName ( "" ) ; targetVector . addElement ( implicitTarget ) ; } public void setBuildFile ( File buildFile ) { this . buildFile = buildFile ; this . buildFileParent = new File ( buildFile . getParent ( ) ) ; } public File getBuildFile ( ) { return buildFile ; } public File getBuildFileParent ( ) { return buildFileParent ; } public Project getProject ( ) { return project ; } public String getCurrentProjectName ( ) { return currentProjectName ; } public void setCurrentProjectName ( String name ) { this . currentProjectName = name ; } public RuntimeConfigurable currentWrapper ( ) { if ( wStack . size ( ) < 1 ) { return null ; } return ( RuntimeConfigurable ) wStack . elementAt ( wStack . size ( ) - 1 ) ; } public RuntimeConfigurable parentWrapper ( ) { if ( wStack . size ( ) < 2 ) { return null ; } return ( RuntimeConfigurable ) wStack . elementAt ( wStack . size ( ) - 2 ) ; } public void pushWrapper ( RuntimeConfigurable wrapper ) { wStack . addElement ( wrapper ) ; } public void popWrapper ( ) { if ( wStack . size ( ) > 0 ) { wStack . removeElementAt ( wStack . size ( ) - 1 ) ; } } public Vector getWrapperStack ( ) { return wStack ; } public void addTarget ( Target target ) { targetVector . addElement ( target ) ; currentTarget = target ; } public Target getCurrentTarget ( ) { return currentTarget ; } public Target getImplicitTarget ( ) { return implicitTarget ; } public void setCurrentTarget ( Target target ) { this . currentTarget = target ; } public void setImplicitTarget ( Target target ) { this . implicitTarget = target ; } public Vector getTargets ( ) { return targetVector ; } public void configureId ( Object element , Attributes attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , element ) ; } } public Locator getLocator ( ) { return locator ; } public void setLocator ( Locator locator ) { this . locator = locator ; } public boolean isIgnoringProjectTag ( ) { return ignoreProjectTag ; } public void setIgnoreProjectTag ( boolean flag ) { this . ignoreProjectTag = flag ; } public void startPrefixMapping ( String prefix , String uri ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null ) { list = new ArrayList ( ) ; prefixMapping . put ( prefix , list ) ; } list . add ( uri ) ; } public void endPrefixMapping ( String prefix ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null || list . size ( ) == 0 ) { return ; } list . remove ( list . size ( ) - 1 ) ; } public String getPrefixMapping ( String prefix ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null || list . size ( ) == 0 ) { return null ; } return ( String ) list . get ( list . size ( ) - 1 ) ; } } 	1
package org . apache . tools . ant ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Properties ; import java . util . Set ; import java . util . Stack ; import java . util . Vector ; import java . io . InputStream ; import java . io . IOException ; import java . lang . ref . WeakReference ; import java . lang . reflect . Modifier ; import org . apache . tools . ant . taskdefs . Typedef ; public class ComponentHelper { private AntTypeTable antTypeTable ; private Hashtable taskClassDefinitions = new Hashtable ( ) ; private boolean rebuildTaskClassDefinitions = true ; private Hashtable typeClassDefinitions = new Hashtable ( ) ; private boolean rebuildTypeClassDefinitions = true ; private Set checkedNamespaces = new HashSet ( ) ; private Stack antLibStack = new Stack ( ) ; private String antLibCurrentUri = null ; private Hashtable createdTasks = new Hashtable ( ) ; private ComponentHelper next ; private Project project ; public static ComponentHelper getComponentHelper ( Project project ) { ComponentHelper ph = ( ComponentHelper ) project . getReference ( "ant.ComponentHelper" ) ; if ( ph != null ) { return ph ; } ph = new ComponentHelper ( ) ; ph . setProject ( project ) ; project . addReference ( "ant.ComponentHelper" , ph ) ; return ph ; } protected ComponentHelper ( ) { } public void setNext ( ComponentHelper next ) { this . next = next ; } public ComponentHelper getNext ( ) { return next ; } public void setProject ( Project project ) { this . project = project ; antTypeTable = new AntTypeTable ( project ) ; } public void initSubProject ( ComponentHelper helper ) { AntTypeTable typeTable = helper . antTypeTable ; for ( Iterator i = typeTable . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { AntTypeDefinition def = ( AntTypeDefinition ) i . next ( ) ; antTypeTable . put ( def . getName ( ) , def ) ; } checkedNamespaces . add ( helper . checkedNamespaces ) ; } public Object createComponent ( UnknownElement ue , String ns , String componentType ) throws BuildException { Object component = createComponent ( componentType ) ; if ( component == null ) { return null ; } if ( component instanceof Task ) { Task task = ( Task ) component ; task . setLocation ( ue . getLocation ( ) ) ; task . setTaskType ( componentType ) ; task . setTaskName ( ue . getTaskName ( ) ) ; task . setOwningTarget ( ue . getOwningTarget ( ) ) ; task . init ( ) ; addCreatedTask ( componentType , task ) ; } return component ; } public Object createComponent ( String componentName ) { AntTypeDefinition def = getDefinition ( componentName ) ; if ( def == null ) { return null ; } return def . create ( project ) ; } public Class getComponentClass ( String componentName ) { AntTypeDefinition def = getDefinition ( componentName ) ; if ( def == null ) { return null ; } return def . getExposedClass ( project ) ; } public AntTypeDefinition getDefinition ( String componentName ) { checkNamespace ( componentName ) ; AntTypeDefinition ret = null ; ret = antTypeTable . getDefinition ( componentName ) ; return ret ; } public void initDefaultDefinitions ( ) { initTasks ( ) ; initTypes ( ) ; } public void addTaskDefinition ( String taskName , Class taskClass ) { checkTaskClass ( taskClass ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( taskName ) ; def . setClassLoader ( taskClass . getClassLoader ( ) ) ; def . setClass ( taskClass ) ; def . setAdapterClass ( TaskAdapter . class ) ; def . setClassName ( taskClass . getName ( ) ) ; def . setAdaptToClass ( Task . class ) ; updateDataTypeDefinition ( def ) ; } public void checkTaskClass ( final Class taskClass ) throws BuildException { if ( ! Modifier . isPublic ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is not public" ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( Modifier . isAbstract ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is abstract" ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } try { taskClass . getConstructor ( null ) ; } catch ( NoSuchMethodException e ) { final String message = "No public no-arg constructor in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( ! Task . class . isAssignableFrom ( taskClass ) ) { TaskAdapter . checkTaskClass ( taskClass , project ) ; } } public Hashtable getTaskDefinitions ( ) { synchronized ( taskClassDefinitions ) { synchronized ( antTypeTable ) { if ( rebuildTaskClassDefinitions ) { taskClassDefinitions . clear ( ) ; for ( Iterator i = antTypeTable . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; Class clazz = ( Class ) antTypeTable . getExposedClass ( name ) ; if ( clazz == null ) { continue ; } if ( Task . class . isAssignableFrom ( clazz ) ) { taskClassDefinitions . put ( name , antTypeTable . getTypeClass ( name ) ) ; } } rebuildTaskClassDefinitions = false ; } } } return taskClassDefinitions ; } public Hashtable getDataTypeDefinitions ( ) { synchronized ( typeClassDefinitions ) { synchronized ( antTypeTable ) { if ( rebuildTypeClassDefinitions ) { typeClassDefinitions . clear ( ) ; for ( Iterator i = antTypeTable . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; Class clazz = ( Class ) antTypeTable . getExposedClass ( name ) ; if ( clazz == null ) { continue ; } if ( ! ( Task . class . isAssignableFrom ( clazz ) ) ) { typeClassDefinitions . put ( name , antTypeTable . getTypeClass ( name ) ) ; } } rebuildTypeClassDefinitions = false ; } } } return typeClassDefinitions ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( typeName ) ; def . setClass ( typeClass ) ; updateDataTypeDefinition ( def ) ; String msg = " +User datatype: " + typeName + "     " + typeClass . getName ( ) ; project . log ( msg , Project . MSG_DEBUG ) ; } public void addDataTypeDefinition ( AntTypeDefinition def ) { updateDataTypeDefinition ( def ) ; } public Hashtable getAntTypeTable ( ) { return antTypeTable ; } public Task createTask ( String taskType ) throws BuildException { Task task = createNewTask ( taskType ) ; if ( task == null && taskType . equals ( "property" ) ) { addTaskDefinition ( "property" , org . apache . tools . ant . taskdefs . Property . class ) ; task = createNewTask ( taskType ) ; } if ( task != null ) { addCreatedTask ( taskType , task ) ; } return task ; } private Task createNewTask ( String taskType ) throws BuildException { Class c = getComponentClass ( taskType ) ; if ( c == null ) { return null ; } if ( ! ( Task . class . isAssignableFrom ( c ) ) ) { return null ; } Task task = ( Task ) createComponent ( taskType ) ; if ( task == null ) { return null ; } task . setTaskType ( taskType ) ; task . setTaskName ( taskType ) ; String msg = "   +Task: " + taskType ; project . log ( msg , Project . MSG_DEBUG ) ; return task ; } private void addCreatedTask ( String type , Task task ) { synchronized ( createdTasks ) { Vector v = ( Vector ) createdTasks . get ( type ) ; if ( v == null ) { v = new Vector ( ) ; createdTasks . put ( type , v ) ; } v . addElement ( new WeakReference ( task ) ) ; } } private void invalidateCreatedTasks ( String type ) { synchronized ( createdTasks ) { Vector v = ( Vector ) createdTasks . get ( type ) ; if ( v != null ) { Enumeration taskEnum = v . elements ( ) ; while ( taskEnum . hasMoreElements ( ) ) { WeakReference ref = ( WeakReference ) taskEnum . nextElement ( ) ; Task t = ( Task ) ref . get ( ) ; if ( t != null ) { t . markInvalid ( ) ; } } v . removeAllElements ( ) ; createdTasks . remove ( type ) ; } } } public Object createDataType ( String typeName ) throws BuildException { return createComponent ( typeName ) ; } public String getElementName ( Object element ) { Class elementClass = element . getClass ( ) ; for ( Iterator i = antTypeTable . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { AntTypeDefinition def = ( AntTypeDefinition ) i . next ( ) ; if ( elementClass == def . getExposedClass ( project ) ) { return "The <" + def . getName ( ) + "> type" ; } } return "Class " + elementClass . getName ( ) ; } private boolean validDefinition ( AntTypeDefinition def ) { if ( def . getTypeClass ( project ) == null || def . getExposedClass ( project ) == null ) { return false ; } return true ; } private boolean sameDefinition ( AntTypeDefinition def , AntTypeDefinition old ) { if ( ! validDefinition ( def ) || ! validDefinition ( old ) ) { return validDefinition ( def ) == validDefinition ( old ) ; } return def . sameDefinition ( old , project ) ; } private void updateDataTypeDefinition ( AntTypeDefinition def ) { String name = def . getName ( ) ; synchronized ( antTypeTable ) { rebuildTaskClassDefinitions = true ; rebuildTypeClassDefinitions = true ; AntTypeDefinition old = antTypeTable . getDefinition ( name ) ; if ( old != null ) { if ( sameDefinition ( def , old ) ) { return ; } int logLevel = Project . MSG_WARN ; if ( def . similarDefinition ( old , project ) ) { logLevel = Project . MSG_VERBOSE ; } Class oldClass = antTypeTable . getExposedClass ( name ) ; boolean isTask = ( oldClass != null && Task . class . isAssignableFrom ( oldClass ) ) ; project . log ( "Trying to override old definition of " + ( isTask ? "task" : "datatype" ) + " " + name , logLevel ) ; if ( isTask ) { invalidateCreatedTasks ( name ) ; } } project . log ( " +Datatype " + name + " " + def . getClassName ( ) , Project . MSG_DEBUG ) ; antTypeTable . put ( name , def ) ; } } public void enterAntLib ( String uri ) { antLibCurrentUri = uri ; antLibStack . push ( uri ) ; } public String getCurrentAntlibUri ( ) { return antLibCurrentUri ; } public void exitAntLib ( ) { antLibStack . pop ( ) ; if ( antLibStack . size ( ) != 0 ) { antLibCurrentUri = ( String ) antLibStack . peek ( ) ; } else { antLibCurrentUri = null ; } } private void initTasks ( ) { ClassLoader classLoader = null ; if ( project . getCoreLoader ( ) != null && ! ( "only" . equals ( project . getProperty ( "build.sysclasspath" ) ) ) ) { classLoader = project . getCoreLoader ( ) ; } String dataDefs = "/org/apache/tools/ant/taskdefs/defaults.properties" ; InputStream in = null ; try { Properties props = new Properties ( ) ; in = this . getClass ( ) . getResourceAsStream ( dataDefs ) ; if ( in == null ) { throw new BuildException ( "Can't load default task list" ) ; } props . load ( in ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String className = props . getProperty ( name ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( className ) ; def . setClassLoader ( classLoader ) ; def . setAdaptToClass ( Task . class ) ; def . setAdapterClass ( TaskAdapter . class ) ; antTypeTable . put ( name , def ) ; } } catch ( IOException ex ) { throw new BuildException ( "Can't load default type list" ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception ignore ) { } } } } private void initTypes ( ) { ClassLoader classLoader = null ; if ( project . getCoreLoader ( ) != null && ! ( "only" . equals ( project . getProperty ( "build.sysclasspath" ) ) ) ) { classLoader = project . getCoreLoader ( ) ; } String dataDefs = "/org/apache/tools/ant/types/defaults.properties" ; InputStream in = null ; try { Properties props = new Properties ( ) ; in = this . getClass ( ) . getResourceAsStream ( dataDefs ) ; if ( in == null ) { throw new BuildException ( "Can't load default datatype list" ) ; } props . load ( in ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String className = props . getProperty ( name ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( className ) ; def . setClassLoader ( classLoader ) ; antTypeTable . put ( name , def ) ; } } catch ( IOException ex ) { throw new BuildException ( "Can't load default type list" ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception ignore ) { } } } } private synchronized void checkNamespace ( String componentName ) { if ( componentName . indexOf ( ':' ) == - 1 ) { return ; } String uri = ProjectHelper . extractUriFromComponentName ( componentName ) ; if ( ! uri . startsWith ( ProjectHelper . ANTLIB_URI ) ) { return ; } if ( checkedNamespaces . contains ( uri ) ) { return ; } checkedNamespaces . add ( uri ) ; Typedef definer = new Typedef ( ) ; definer . setProject ( project ) ; definer . setURI ( uri ) ; definer . setResource ( uri . substring ( "antlib:" . length ( ) ) . replace ( '.' , '/' ) + "/antlib.xml" ) ; definer . setOnError ( new Typedef . OnError ( "ignore" ) ) ; definer . init ( ) ; definer . execute ( ) ; } private static class AntTypeTable extends Hashtable { private Project project ; public AntTypeTable ( Project project ) { this . project = project ; } public AntTypeDefinition getDefinition ( String key ) { AntTypeDefinition ret = ( AntTypeDefinition ) super . get ( key ) ; return ret ; } public Object get ( Object key ) { return getTypeClass ( ( String ) key ) ; } public Object create ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; if ( def == null ) { return null ; } return def . create ( project ) ; } public Class getTypeClass ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; if ( def == null ) { return null ; } return def . getTypeClass ( project ) ; } public Class getExposedClass ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; if ( def == null ) { return null ; } return def . getExposedClass ( project ) ; } public boolean contains ( Object clazz ) { for ( Iterator i = values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { AntTypeDefinition def = ( AntTypeDefinition ) i . next ( ) ; Class c = def . getExposedClass ( project ) ; if ( c == clazz ) { return true ; } } return false ; } public boolean containsValue ( Object value ) { return contains ( value ) ; } } } 	1
package org . apache . tools . ant ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . LoaderUtils ; public class AntClassLoader extends ClassLoader implements BuildListener { private class ResourceEnumeration implements Enumeration { private String resourceName ; private int pathElementsIndex ; private URL nextResource ; ResourceEnumeration ( String name ) { this . resourceName = name ; this . pathElementsIndex = 0 ; findNextResource ( ) ; } public boolean hasMoreElements ( ) { return ( this . nextResource != null ) ; } public Object nextElement ( ) { URL ret = this . nextResource ; findNextResource ( ) ; return ret ; } private void findNextResource ( ) { URL url = null ; while ( ( pathElementsIndex < pathComponents . size ( ) ) && ( url == null ) ) { try { File pathComponent = ( File ) pathComponents . elementAt ( pathElementsIndex ) ; url = getResourceURL ( pathComponent , this . resourceName ) ; pathElementsIndex ++ ; } catch ( BuildException e ) { } } this . nextResource = url ; } } private static final int BUFFER_SIZE = 8192 ; private static final int NUMBER_OF_STRINGS = 256 ; private Vector pathComponents = new Vector ( ) ; private Project project ; private boolean parentFirst = true ; private Vector systemPackages = new Vector ( ) ; private Vector loaderPackages = new Vector ( ) ; private boolean ignoreBase = false ; private ClassLoader parent = null ; private Hashtable zipFiles = new Hashtable ( ) ; private ClassLoader savedContextLoader = null ; private boolean isContextLoaderSaved = false ; private static Method getProtectionDomain = null ; private static Method defineClassProtectionDomain = null ; static { try { getProtectionDomain = Class . class . getMethod ( "getProtectionDomain" , new Class [ 0 ] ) ; Class protectionDomain = Class . forName ( "java.security.ProtectionDomain" ) ; Class [ ] args = new Class [ ] { String . class , byte [ ] . class , Integer . TYPE , Integer . TYPE , protectionDomain } ; defineClassProtectionDomain = ClassLoader . class . getDeclaredMethod ( "defineClass" , args ) ; } catch ( Exception e ) { } } public AntClassLoader ( ) { setParent ( null ) ; } public AntClassLoader ( Project project , Path classpath ) { setParent ( null ) ; setProject ( project ) ; setClassPath ( classpath ) ; } public AntClassLoader ( ClassLoader parent , Project project , Path classpath , boolean parentFirst ) { this ( project , classpath ) ; if ( parent != null ) { setParent ( parent ) ; } setParentFirst ( parentFirst ) ; addJavaLibraries ( ) ; } public AntClassLoader ( Project project , Path classpath , boolean parentFirst ) { this ( null , project , classpath , parentFirst ) ; } public AntClassLoader ( ClassLoader parent , boolean parentFirst ) { setParent ( parent ) ; project = null ; this . parentFirst = parentFirst ; } public void setProject ( Project project ) { this . project = project ; if ( project != null ) { project . addBuildListener ( this ) ; } } public void setClassPath ( Path classpath ) { pathComponents . removeAllElements ( ) ; if ( classpath != null ) { Path actualClasspath = classpath . concatSystemClasspath ( "ignore" ) ; String [ ] pathElements = actualClasspath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; ++ i ) { try { addPathElement ( pathElements [ i ] ) ; } catch ( BuildException e ) { } } } } public void setParent ( ClassLoader parent ) { if ( parent == null ) { this . parent = AntClassLoader . class . getClassLoader ( ) ; } else { this . parent = parent ; } } public void setParentFirst ( boolean parentFirst ) { this . parentFirst = parentFirst ; } protected void log ( String message , int priority ) { if ( project != null ) { project . log ( message , priority ) ; } } public void setThreadContextLoader ( ) { if ( isContextLoaderSaved ) { throw new BuildException ( "Context loader has not been reset" ) ; } if ( LoaderUtils . isContextLoaderAvailable ( ) ) { savedContextLoader = LoaderUtils . getContextClassLoader ( ) ; ClassLoader loader = this ; if ( project != null && "only" . equals ( project . getProperty ( "build.sysclasspath" ) ) ) { loader = this . getClass ( ) . getClassLoader ( ) ; } LoaderUtils . setContextClassLoader ( loader ) ; isContextLoaderSaved = true ; } } public void resetThreadContextLoader ( ) { if ( LoaderUtils . isContextLoaderAvailable ( ) && isContextLoaderSaved ) { LoaderUtils . setContextClassLoader ( savedContextLoader ) ; savedContextLoader = null ; isContextLoaderSaved = false ; } } public void addPathElement ( String pathElement ) throws BuildException { File pathComponent = project != null ? project . resolveFile ( pathElement ) : new File ( pathElement ) ; try { addPathFile ( pathComponent ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected void addPathFile ( File pathComponent ) throws IOException { pathComponents . addElement ( pathComponent ) ; } public String getClasspath ( ) { StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; Enumeration componentEnum = pathComponents . elements ( ) ; while ( componentEnum . hasMoreElements ( ) ) { if ( ! firstPass ) { sb . append ( System . getProperty ( "path.separator" ) ) ; } else { firstPass = false ; } sb . append ( ( ( File ) componentEnum . nextElement ( ) ) . getAbsolutePath ( ) ) ; } return sb . toString ( ) ; } public synchronized void setIsolated ( boolean isolated ) { ignoreBase = isolated ; } public static void initializeClass ( Class theClass ) { final Constructor [ ] cons = theClass . getDeclaredConstructors ( ) ; if ( cons != null ) { if ( cons . length > 0 && cons [ 0 ] != null ) { final String [ ] strs = new String [ NUMBER_OF_STRINGS ] ; try { cons [ 0 ] . newInstance ( strs ) ; } catch ( Throwable t ) { } } } } public void addSystemPackageRoot ( String packageRoot ) { systemPackages . addElement ( packageRoot + ( packageRoot . endsWith ( "." ) ? "" : "." ) ) ; } public void addLoaderPackageRoot ( String packageRoot ) { loaderPackages . addElement ( packageRoot + ( packageRoot . endsWith ( "." ) ? "" : "." ) ) ; } public Class forceLoadClass ( String classname ) throws ClassNotFoundException { log ( "force loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findClass ( classname ) ; } return theClass ; } public Class forceLoadSystemClass ( String classname ) throws ClassNotFoundException { log ( "force system loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findBaseClass ( classname ) ; } return theClass ; } public InputStream getResourceAsStream ( String name ) { InputStream resourceStream = null ; if ( isParentFirst ( name ) ) { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } } if ( resourceStream == null ) { log ( "Couldn't load ResourceStream for " + name , Project . MSG_DEBUG ) ; } return resourceStream ; } private InputStream loadResource ( String name ) { InputStream stream = null ; Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) && stream == null ) { File pathComponent = ( File ) e . nextElement ( ) ; stream = getResourceStream ( pathComponent , name ) ; } return stream ; } private InputStream loadBaseResource ( String name ) { if ( parent == null ) { return getSystemResourceAsStream ( name ) ; } else { return parent . getResourceAsStream ( name ) ; } } private InputStream getResourceStream ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { return new FileInputStream ( resource ) ; } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { return zipFile . getInputStream ( entry ) ; } } } catch ( Exception e ) { log ( "Ignoring Exception " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) + " reading resource " + resourceName + " from " + file , Project . MSG_VERBOSE ) ; } return null ; } private boolean isParentFirst ( String resourceName ) { boolean useParentFirst = parentFirst ; for ( Enumeration e = systemPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = true ; break ; } } for ( Enumeration e = loaderPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = false ; break ; } } return useParentFirst ; } public URL getResource ( String name ) { URL url = null ; if ( isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; } if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) && url == null ) { File pathComponent = ( File ) e . nextElement ( ) ; url = getResourceURL ( pathComponent , name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } if ( url == null && ! isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( url == null ) { log ( "Couldn't load Resource " + name , Project . MSG_DEBUG ) ; } return url ; } protected Enumeration findResources ( String name ) throws IOException { return new ResourceEnumeration ( name ) ; } protected URL getResourceURL ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { try { return new URL ( "file:" + resource . toString ( ) ) ; } catch ( MalformedURLException ex ) { return null ; } } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { try { return new URL ( "jar:file:" + file . toString ( ) + "!/" + entry ) ; } catch ( MalformedURLException ex ) { return null ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } protected synchronized Class loadClass ( String classname , boolean resolve ) throws ClassNotFoundException { Class theClass = findLoadedClass ( classname ) ; if ( theClass != null ) { return theClass ; } if ( isParentFirst ( classname ) ) { try { theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader " + "(parentFirst)" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader " + "(parentFirst)" , Project . MSG_DEBUG ) ; } } else { try { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { if ( ignoreBase ) { throw cnfe ; } theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( resolve ) { resolveClass ( theClass ) ; } return theClass ; } private String getClassFilename ( String classname ) { return classname . replace ( '.' , '/' ) + ".class" ; } protected Class defineClassFromData ( File container , byte [ ] classData , String classname ) throws IOException { if ( defineClassProtectionDomain != null ) { try { Object domain = getProtectionDomain . invoke ( Project . class , new Object [ 0 ] ) ; Object [ ] args = new Object [ ] { classname , classData , new Integer ( 0 ) , new Integer ( classData . length ) , domain } ; return ( Class ) defineClassProtectionDomain . invoke ( this , args ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof ClassFormatError ) { throw ( ClassFormatError ) t ; } else if ( t instanceof NoClassDefFoundError ) { throw ( NoClassDefFoundError ) t ; } else if ( t instanceof SecurityException ) { throw ( SecurityException ) t ; } else { throw new IOException ( t . toString ( ) ) ; } } catch ( Exception e ) { throw new IOException ( e . toString ( ) ) ; } } else { return defineClass ( classname , classData , 0 , classData . length ) ; } } private Class getClassFromStream ( InputStream stream , String classname , File container ) throws IOException , SecurityException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; int bytesRead = - 1 ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; while ( ( bytesRead = stream . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { baos . write ( buffer , 0 , bytesRead ) ; } byte [ ] classData = baos . toByteArray ( ) ; return defineClassFromData ( container , classData , classname ) ; } public Class findClass ( String name ) throws ClassNotFoundException { log ( "Finding class " + name , Project . MSG_DEBUG ) ; return findClassInComponents ( name ) ; } protected boolean isInPath ( File component ) { for ( Enumeration e = pathComponents . elements ( ) ; e . hasMoreElements ( ) ; ) { File pathComponent = ( File ) e . nextElement ( ) ; if ( pathComponent . equals ( component ) ) { return true ; } } return false ; } private Class findClassInComponents ( String name ) throws ClassNotFoundException { InputStream stream = null ; String classFilename = getClassFilename ( name ) ; try { Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) ) { File pathComponent = ( File ) e . nextElement ( ) ; try { stream = getResourceStream ( pathComponent , classFilename ) ; if ( stream != null ) { log ( "Loaded from " + pathComponent + " " + classFilename , Project . MSG_DEBUG ) ; return getClassFromStream ( stream , name , pathComponent ) ; } } catch ( SecurityException se ) { throw se ; } catch ( IOException ioe ) { log ( "Exception reading component " + pathComponent + " (reason: " + ioe . getMessage ( ) + ")" , Project . MSG_VERBOSE ) ; } } throw new ClassNotFoundException ( name ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } } private Class findBaseClass ( String name ) throws ClassNotFoundException { if ( parent == null ) { return findSystemClass ( name ) ; } else { return parent . loadClass ( name ) ; } } public synchronized void cleanup ( ) { for ( Enumeration e = zipFiles . elements ( ) ; e . hasMoreElements ( ) ; ) { ZipFile zipFile = ( ZipFile ) e . nextElement ( ) ; try { zipFile . close ( ) ; } catch ( IOException ioe ) { } } zipFiles = new Hashtable ( ) ; if ( project != null ) { project . removeBuildListener ( this ) ; } project = null ; } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { cleanup ( ) ; } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } public void addJavaLibraries ( ) { Vector packages = JavaEnvUtils . getJrePackages ( ) ; Enumeration e = packages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String packageName = ( String ) e . nextElement ( ) ; addSystemPackageRoot ( packageName ) ; } } } 	1
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import java . lang . reflect . Constructor ; public abstract class WeakishReference { private static Constructor referenceConstructor ; private final static String WEAK_REFERENCE_NAME = "org.apache.tools.ant.util.optional.WeakishReference12" ; public static WeakishReference createReference ( Object object ) { if ( referenceConstructor == null ) { createReferenceConstructor ( ) ; } try { return ( WeakishReference ) referenceConstructor . newInstance ( new Object [ ] { object } ) ; } catch ( Exception e ) { throw new BuildException ( "while creating a weakish reference" , e ) ; } } private static void createReferenceConstructor ( ) { Class [ ] ctor = new Class [ ] { Object . class } ; try { referenceConstructor = HardReference . class . getConstructor ( ctor ) ; } catch ( NoSuchMethodException e ) { throw new BuildException ( "when creating a Hard Reference constructor" , e ) ; } if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { try { Class clazz = Class . forName ( WEAK_REFERENCE_NAME ) ; referenceConstructor = clazz . getConstructor ( ctor ) ; } catch ( ClassNotFoundException e ) { } catch ( NoSuchMethodException e ) { } } } public abstract Object get ( ) ; public static class HardReference extends WeakishReference { private Object object ; public HardReference ( Object object ) { this . object = object ; } public Object get ( ) { return object ; } } } 	1
package org . apache . tools . ant ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Iterator ; import org . apache . tools . ant . util . CollectionUtils ; import org . xml . sax . AttributeList ; import org . xml . sax . helpers . AttributeListImpl ; public class RuntimeConfigurable implements Serializable { private static final String ANT_TYPE = "ant-type" ; private String elementTag = null ; private List children = null ; private transient Object wrappedObject = null ; private transient IntrospectionHelper . Creator creator ; private transient AttributeList attributes ; private List attributeNames = null ; private Map attributeMap = null ; private StringBuffer characters = null ; private boolean proxyConfigured = false ; private String polyType = null ; public RuntimeConfigurable ( Object proxy , String elementTag ) { wrappedObject = proxy ; this . elementTag = elementTag ; proxyConfigured = false ; if ( proxy instanceof Task ) { ( ( Task ) proxy ) . setRuntimeConfigurableWrapper ( this ) ; } } public void setProxy ( Object proxy ) { wrappedObject = proxy ; proxyConfigured = false ; } void setCreator ( IntrospectionHelper . Creator creator ) { this . creator = creator ; } public Object getProxy ( ) { return wrappedObject ; } public String getPolyType ( ) { return polyType ; } public void setPolyType ( String polyType ) { this . polyType = polyType ; } public void setAttributes ( AttributeList attributes ) { this . attributes = new AttributeListImpl ( attributes ) ; for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { setAttribute ( attributes . getName ( i ) , attributes . getValue ( i ) ) ; } } public void setAttribute ( String name , String value ) { if ( name . equalsIgnoreCase ( ANT_TYPE ) ) { this . polyType = value ; } else { if ( attributeNames == null ) { attributeNames = new ArrayList ( ) ; attributeMap = new HashMap ( ) ; } attributeNames . add ( name ) ; attributeMap . put ( name , value ) ; } } public Hashtable getAttributeMap ( ) { if ( attributeMap != null ) { return new Hashtable ( attributeMap ) ; } else { return new Hashtable ( 1 ) ; } } public AttributeList getAttributes ( ) { return attributes ; } public void addChild ( RuntimeConfigurable child ) { if ( children == null ) { children = new ArrayList ( ) ; } children . add ( child ) ; } RuntimeConfigurable getChild ( int index ) { return ( RuntimeConfigurable ) children . get ( index ) ; } public Enumeration getChildren ( ) { if ( children != null ) { return Collections . enumeration ( children ) ; } else { return new CollectionUtils . EmptyEnumeration ( ) ; } } public void addText ( String data ) { if ( data . length ( ) == 0 ) { return ; } if ( characters != null ) { characters . append ( data ) ; } else { characters = new StringBuffer ( data ) ; } } public void addText ( char [ ] buf , int start , int count ) { if ( count == 0 ) { return ; } if ( characters == null ) { characters = new StringBuffer ( count ) ; } characters . append ( buf , start , count ) ; } public StringBuffer getText ( ) { if ( characters != null ) { return characters ; } else { return new StringBuffer ( 0 ) ; } } public String getElementTag ( ) { return elementTag ; } public void maybeConfigure ( Project p ) throws BuildException { maybeConfigure ( p , true ) ; } public void maybeConfigure ( Project p , boolean configureChildren ) throws BuildException { String id = null ; if ( proxyConfigured ) { return ; } Object target = ( wrappedObject instanceof TypeAdapter ) ? ( ( TypeAdapter ) wrappedObject ) . getProxy ( ) : wrappedObject ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( p , target . getClass ( ) ) ; if ( attributeNames != null ) { for ( int i = 0 ; i < attributeNames . size ( ) ; i ++ ) { String name = ( String ) attributeNames . get ( i ) ; String value = ( String ) attributeMap . get ( name ) ; value = p . replaceProperties ( value ) ; try { ih . setAttribute ( p , target , name . toLowerCase ( Locale . US ) , value ) ; } catch ( BuildException be ) { if ( ! name . equals ( "id" ) ) { throw be ; } } } id = ( String ) attributeMap . get ( "id" ) ; } if ( characters != null ) { ProjectHelper . addText ( p , wrappedObject , characters . substring ( 0 ) ) ; } Enumeration e = getChildren ( ) ; while ( e . hasMoreElements ( ) ) { RuntimeConfigurable child = ( RuntimeConfigurable ) e . nextElement ( ) ; if ( child . wrappedObject instanceof Task ) { Task childTask = ( Task ) child . wrappedObject ; childTask . setRuntimeConfigurableWrapper ( child ) ; } if ( ( child . creator != null ) && configureChildren ) { child . maybeConfigure ( p ) ; child . creator . store ( ) ; continue ; } String tag = child . getElementTag ( ) . toLowerCase ( Locale . US ) ; if ( configureChildren && ih . supportsNestedElement ( tag ) ) { child . maybeConfigure ( p ) ; ProjectHelper . storeChild ( p , target , child . wrappedObject , tag ) ; } } if ( id != null ) { p . addReference ( id , wrappedObject ) ; } proxyConfigured = true ; } public void reconfigure ( Project p ) { proxyConfigured = false ; maybeConfigure ( p ) ; } public void applyPreSet ( RuntimeConfigurable r ) { if ( r . attributeMap != null ) { for ( Iterator i = r . attributeMap . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; if ( attributeMap == null || attributeMap . get ( name ) == null ) { setAttribute ( name , ( String ) r . attributeMap . get ( name ) ) ; } } } if ( r . polyType != null && polyType == null ) { polyType = r . polyType ; } if ( r . children != null ) { List newChildren = new ArrayList ( ) ; newChildren . addAll ( r . children ) ; if ( children != null ) { newChildren . addAll ( children ) ; } children = newChildren ; } if ( r . characters != null ) { if ( characters == null || characters . toString ( ) . trim ( ) . length ( ) == 0 ) { characters = new StringBuffer ( r . characters . toString ( ) ) ; } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Reference ; public class AntStructure extends Task { private final String lSep = System . getProperty ( "line.separator" ) ; private static final String BOOLEAN = "%boolean;" ; private static final String TASKS = "%tasks;" ; private static final String TYPES = "%types;" ; private Hashtable visited = new Hashtable ( ) ; private File output ; public void setOutput ( File output ) { this . output = output ; } public void execute ( ) throws BuildException { if ( output == null ) { throw new BuildException ( "output attribute is required" , getLocation ( ) ) ; } PrintWriter out = null ; try { try { out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( output ) , "UTF8" ) ) ; } catch ( UnsupportedEncodingException ue ) { out = new PrintWriter ( new FileWriter ( output ) ) ; } printHead ( out , getProject ( ) . getTaskDefinitions ( ) . keys ( ) , getProject ( ) . getDataTypeDefinitions ( ) . keys ( ) ) ; printTargetDecl ( out ) ; Enumeration dataTypes = getProject ( ) . getDataTypeDefinitions ( ) . keys ( ) ; while ( dataTypes . hasMoreElements ( ) ) { String typeName = ( String ) dataTypes . nextElement ( ) ; printElementDecl ( out , typeName , ( Class ) getProject ( ) . getDataTypeDefinitions ( ) . get ( typeName ) ) ; } Enumeration tasks = getProject ( ) . getTaskDefinitions ( ) . keys ( ) ; while ( tasks . hasMoreElements ( ) ) { String taskName = ( String ) tasks . nextElement ( ) ; printElementDecl ( out , taskName , ( Class ) getProject ( ) . getTaskDefinitions ( ) . get ( taskName ) ) ; } } catch ( IOException ioe ) { throw new BuildException ( "Error writing " + output . getAbsolutePath ( ) , ioe , getLocation ( ) ) ; } finally { if ( out != null ) { out . close ( ) ; } visited . clear ( ) ; } } private void printHead ( PrintWriter out , Enumeration tasks , Enumeration types ) { out . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>" ) ; out . println ( "<!ENTITY % boolean \"(true|false|on|off|yes|no)\">" ) ; out . print ( "<!ENTITY % tasks \"" ) ; boolean first = true ; while ( tasks . hasMoreElements ( ) ) { String taskName = ( String ) tasks . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( taskName ) ; } out . println ( "\">" ) ; out . print ( "<!ENTITY % types \"" ) ; first = true ; while ( types . hasMoreElements ( ) ) { String typeName = ( String ) types . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( typeName ) ; } out . println ( "\">" ) ; out . println ( "" ) ; out . print ( "<!ELEMENT project (target | " ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "<!ATTLIST project" ) ; out . println ( "          name    CDATA #IMPLIED" ) ; out . println ( "          default CDATA #IMPLIED" ) ; out . println ( "          basedir CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printTargetDecl ( PrintWriter out ) { out . print ( "<!ELEMENT target (" ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "" ) ; out . println ( "<!ATTLIST target" ) ; out . println ( "          id          ID    #IMPLIED" ) ; out . println ( "          name        CDATA #REQUIRED" ) ; out . println ( "          if          CDATA #IMPLIED" ) ; out . println ( "          unless      CDATA #IMPLIED" ) ; out . println ( "          depends     CDATA #IMPLIED" ) ; out . println ( "          description CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printElementDecl ( PrintWriter out , String name , Class element ) throws BuildException { if ( visited . containsKey ( name ) ) { return ; } visited . put ( name , "" ) ; IntrospectionHelper ih = null ; try { ih = IntrospectionHelper . getHelper ( element ) ; } catch ( Throwable t ) { return ; } StringBuffer sb = new StringBuffer ( "<!ELEMENT " ) ; sb . append ( name ) . append ( " " ) ; if ( org . apache . tools . ant . types . Reference . class . equals ( element ) ) { sb . append ( "EMPTY>" ) . append ( lSep ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; sb . append ( lSep ) . append ( "          refid IDREF #IMPLIED" ) ; sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; return ; } Vector v = new Vector ( ) ; if ( ih . supportsCharacters ( ) ) { v . addElement ( "#PCDATA" ) ; } if ( TaskContainer . class . isAssignableFrom ( element ) ) { v . addElement ( TASKS ) ; } Enumeration e = ih . getNestedElements ( ) ; while ( e . hasMoreElements ( ) ) { v . addElement ( e . nextElement ( ) ) ; } if ( v . isEmpty ( ) ) { sb . append ( "EMPTY" ) ; } else { sb . append ( "(" ) ; final int count = v . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( v . elementAt ( i ) ) ; } sb . append ( ")" ) ; if ( count > 1 || ! v . elementAt ( 0 ) . equals ( "#PCDATA" ) ) { sb . append ( "*" ) ; } } sb . append ( ">" ) ; out . println ( sb ) ; sb = new StringBuffer ( "<!ATTLIST " ) ; sb . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; e = ih . getAttributes ( ) ; while ( e . hasMoreElements ( ) ) { String attrName = ( String ) e . nextElement ( ) ; if ( "id" . equals ( attrName ) ) { continue ; } sb . append ( lSep ) . append ( "          " ) . append ( attrName ) . append ( " " ) ; Class type = ih . getAttributeType ( attrName ) ; if ( type . equals ( java . lang . Boolean . class ) || type . equals ( java . lang . Boolean . TYPE ) ) { sb . append ( BOOLEAN ) . append ( " " ) ; } else if ( Reference . class . isAssignableFrom ( type ) ) { sb . append ( "IDREF " ) ; } else if ( EnumeratedAttribute . class . isAssignableFrom ( type ) ) { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) type . newInstance ( ) ; String [ ] values = ea . getValues ( ) ; if ( values == null || values . length == 0 || ! areNmtokens ( values ) ) { sb . append ( "CDATA " ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( values [ i ] ) ; } sb . append ( ") " ) ; } } catch ( InstantiationException ie ) { sb . append ( "CDATA " ) ; } catch ( IllegalAccessException ie ) { sb . append ( "CDATA " ) ; } } else { sb . append ( "CDATA " ) ; } sb . append ( "#IMPLIED" ) ; } sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; final int count = v . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { String nestedName = ( String ) v . elementAt ( i ) ; if ( ! "#PCDATA" . equals ( nestedName ) && ! TASKS . equals ( nestedName ) && ! TYPES . equals ( nestedName ) ) { printElementDecl ( out , nestedName , ih . getElementType ( nestedName ) ) ; } } } protected boolean isNmtoken ( String s ) { final int length = s . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = s . charAt ( i ) ; if ( ! Character . isLetterOrDigit ( c ) && c != '.' && c != '-' && c != '_' && c != ':' ) { return false ; } } return true ; } protected boolean areNmtokens ( String [ ] s ) { for ( int i = 0 ; i < s . length ; i ++ ) { if ( ! isNmtoken ( s [ i ] ) ) { return false ; } } return true ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . util . HashMap ; import java . util . Map ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class WaitFor extends ConditionBase { private long maxWaitMillis = 1000L * 60L * 3L ; private long maxWaitMultiplier = 1L ; private long checkEveryMillis = 500L ; private long checkEveryMultiplier = 1L ; private String timeoutProperty ; public WaitFor ( ) { super ( "waitfor" ) ; } public void setMaxWait ( long time ) { maxWaitMillis = time ; } public void setMaxWaitUnit ( Unit unit ) { maxWaitMultiplier = unit . getMultiplier ( ) ; } public void setCheckEvery ( long time ) { checkEveryMillis = time ; } public void setCheckEveryUnit ( Unit unit ) { checkEveryMultiplier = unit . getMultiplier ( ) ; } public void setTimeoutProperty ( String p ) { timeoutProperty = p ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into " + getTaskName ( ) ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into " + getTaskName ( ) ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; long savedMaxWaitMillis = maxWaitMillis ; long savedCheckEveryMillis = checkEveryMillis ; try { maxWaitMillis *= maxWaitMultiplier ; checkEveryMillis *= checkEveryMultiplier ; long start = System . currentTimeMillis ( ) ; long end = start + maxWaitMillis ; while ( System . currentTimeMillis ( ) < end ) { if ( c . eval ( ) ) { processSuccess ( ) ; return ; } try { Thread . sleep ( checkEveryMillis ) ; } catch ( InterruptedException e ) { } } processTimeout ( ) ; } finally { maxWaitMillis = savedMaxWaitMillis ; checkEveryMillis = savedCheckEveryMillis ; } } protected void processSuccess ( ) { log ( getTaskName ( ) + ": condition was met" , Project . MSG_VERBOSE ) ; } protected void processTimeout ( ) { log ( getTaskName ( ) + ": timeout" , Project . MSG_VERBOSE ) ; if ( timeoutProperty != null ) { getProject ( ) . setNewProperty ( timeoutProperty , "true" ) ; } } public static class Unit extends EnumeratedAttribute { public static final String MILLISECOND = "millisecond" ; public static final String SECOND = "second" ; public static final String MINUTE = "minute" ; public static final String HOUR = "hour" ; public static final String DAY = "day" ; public static final String WEEK = "week" ; private static final String [ ] UNITS = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK } ; private Map timeTable = new HashMap ( ) ; public Unit ( ) { timeTable . put ( MILLISECOND , new Long ( 1L ) ) ; timeTable . put ( SECOND , new Long ( 1000L ) ) ; timeTable . put ( MINUTE , new Long ( 1000L * 60L ) ) ; timeTable . put ( HOUR , new Long ( 1000L * 60L * 60L ) ) ; timeTable . put ( DAY , new Long ( 1000L * 60L * 60L * 24L ) ) ; timeTable . put ( WEEK , new Long ( 1000L * 60L * 60L * 24L * 7L ) ) ; } public long getMultiplier ( ) { String key = getValue ( ) . toLowerCase ( ) ; Long l = ( Long ) timeTable . get ( key ) ; return l . longValue ( ) ; } public String [ ] getValues ( ) { return UNITS ; } } } 	1
package org . apache . tools . zip ; import java . util . zip . CRC32 ; import java . util . zip . ZipException ; public class AsiExtraField implements ZipExtraField , UnixStat , Cloneable { private static final ZipShort HEADER_ID = new ZipShort ( 0x756E ) ; private int mode = 0 ; private int uid = 0 ; private int gid = 0 ; private String link = "" ; private boolean dirFlag = false ; private CRC32 crc = new CRC32 ( ) ; public AsiExtraField ( ) { } public ZipShort getHeaderId ( ) { return HEADER_ID ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( 4 + 2 + 4 + 2 + 2 + getLinkedFile ( ) . getBytes ( ) . length ) ; } public ZipShort getCentralDirectoryLength ( ) { return getLocalFileDataLength ( ) ; } public byte [ ] getLocalFileDataData ( ) { byte [ ] data = new byte [ getLocalFileDataLength ( ) . getValue ( ) - 4 ] ; System . arraycopy ( ZipShort . getBytes ( getMode ( ) ) , 0 , data , 0 , 2 ) ; byte [ ] linkArray = getLinkedFile ( ) . getBytes ( ) ; System . arraycopy ( ZipLong . getBytes ( linkArray . length ) , 0 , data , 2 , 4 ) ; System . arraycopy ( ZipShort . getBytes ( getUserId ( ) ) , 0 , data , 6 , 2 ) ; System . arraycopy ( ZipShort . getBytes ( getGroupId ( ) ) , 0 , data , 8 , 2 ) ; System . arraycopy ( linkArray , 0 , data , 10 , linkArray . length ) ; crc . reset ( ) ; crc . update ( data ) ; long checksum = crc . getValue ( ) ; byte [ ] result = new byte [ data . length + 4 ] ; System . arraycopy ( ZipLong . getBytes ( checksum ) , 0 , result , 0 , 4 ) ; System . arraycopy ( data , 0 , result , 4 , data . length ) ; return result ; } public byte [ ] getCentralDirectoryData ( ) { return getLocalFileDataData ( ) ; } public void setUserId ( int uid ) { this . uid = uid ; } public int getUserId ( ) { return uid ; } public void setGroupId ( int gid ) { this . gid = gid ; } public int getGroupId ( ) { return gid ; } public void setLinkedFile ( String name ) { link = name ; mode = getMode ( mode ) ; } public String getLinkedFile ( ) { return link ; } public boolean isLink ( ) { return getLinkedFile ( ) . length ( ) != 0 ; } public void setMode ( int mode ) { this . mode = getMode ( mode ) ; } public int getMode ( ) { return mode ; } public void setDirectory ( boolean dirFlag ) { this . dirFlag = dirFlag ; mode = getMode ( mode ) ; } public boolean isDirectory ( ) { return dirFlag && ! isLink ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { long givenChecksum = ZipLong . getValue ( data , offset ) ; byte [ ] tmp = new byte [ length - 4 ] ; System . arraycopy ( data , offset + 4 , tmp , 0 , length - 4 ) ; crc . reset ( ) ; crc . update ( tmp ) ; long realChecksum = crc . getValue ( ) ; if ( givenChecksum != realChecksum ) { throw new ZipException ( "bad CRC checksum " + Long . toHexString ( givenChecksum ) + " instead of " + Long . toHexString ( realChecksum ) ) ; } int newMode = ZipShort . getValue ( tmp , 0 ) ; byte [ ] linkArray = new byte [ ( int ) ZipLong . getValue ( tmp , 2 ) ] ; uid = ZipShort . getValue ( tmp , 6 ) ; gid = ZipShort . getValue ( tmp , 8 ) ; if ( linkArray . length == 0 ) { link = "" ; } else { System . arraycopy ( tmp , 10 , linkArray , 0 , linkArray . length ) ; link = new String ( linkArray ) ; } setDirectory ( ( newMode & DIR_FLAG ) != 0 ) ; setMode ( newMode ) ; } protected int getMode ( int mode ) { int type = FILE_FLAG ; if ( isLink ( ) ) { type = LINK_FLAG ; } else if ( isDirectory ( ) ) { type = DIR_FLAG ; } return type | ( mode & PERM_MASK ) ; } } 	1
package org . apache . tools . ant . types . resources . comparators ; import java . io . File ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; public class FileSystem extends ResourceComparator { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected int resourceCompare ( Resource foo , Resource bar ) { File foofile = ( ( FileResource ) foo ) . getFile ( ) ; File barfile = ( ( FileResource ) bar ) . getFile ( ) ; return foofile . equals ( barfile ) ? 0 : FILE_UTILS . isLeadingPath ( foofile , barfile ) ? - 1 : FILE_UTILS . normalize ( foofile . getAbsolutePath ( ) ) . compareTo ( FILE_UTILS . normalize ( barfile . getAbsolutePath ( ) ) ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Rpm extends Task { private static final String PATH1 = "PATH=" ; private static final String PATH2 = "Path=" ; private static final String PATH3 = "path=" ; private static final int PATH_LEN = PATH1 . length ( ) ; private String specFile ; private File topDir ; private String command = "-bb" ; private String rpmBuildCommand = null ; private boolean cleanBuildDir = false ; private boolean removeSpec = false ; private boolean removeSource = false ; private File output ; private File error ; private boolean failOnError = false ; private boolean quiet = false ; public void execute ( ) throws BuildException { Commandline toExecute = new Commandline ( ) ; toExecute . setExecutable ( rpmBuildCommand == null ? guessRpmBuildCommand ( ) : rpmBuildCommand ) ; if ( topDir != null ) { toExecute . createArgument ( ) . setValue ( "--define" ) ; toExecute . createArgument ( ) . setValue ( "_topdir" + topDir ) ; } toExecute . createArgument ( ) . setLine ( command ) ; if ( cleanBuildDir ) { toExecute . createArgument ( ) . setValue ( "--clean" ) ; } if ( removeSpec ) { toExecute . createArgument ( ) . setValue ( "--rmspec" ) ; } if ( removeSource ) { toExecute . createArgument ( ) . setValue ( "--rmsource" ) ; } toExecute . createArgument ( ) . setValue ( "SPECS/" + specFile ) ; ExecuteStreamHandler streamhandler = null ; OutputStream outputstream = null ; OutputStream errorstream = null ; if ( error == null && output == null ) { if ( ! quiet ) { streamhandler = new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } else { streamhandler = new LogStreamHandler ( this , Project . MSG_DEBUG , Project . MSG_DEBUG ) ; } } else { if ( output != null ) { try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( output ) ) ; outputstream = new PrintStream ( bos ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else if ( ! quiet ) { outputstream = new LogOutputStream ( this , Project . MSG_INFO ) ; } else { outputstream = new LogOutputStream ( this , Project . MSG_DEBUG ) ; } if ( error != null ) { try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( error ) ) ; errorstream = new PrintStream ( bos ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else if ( ! quiet ) { errorstream = new LogOutputStream ( this , Project . MSG_WARN ) ; } else { errorstream = new LogOutputStream ( this , Project . MSG_DEBUG ) ; } streamhandler = new PumpStreamHandler ( outputstream , errorstream ) ; } Execute exe = getExecute ( toExecute , streamhandler ) ; try { log ( "Building the RPM based on the " + specFile + " file" ) ; int returncode = exe . execute ( ) ; if ( Execute . isFailure ( returncode ) ) { String msg = "'" + toExecute . getExecutable ( ) + "' failed with exit code " + returncode ; if ( failOnError ) { throw new BuildException ( msg ) ; } else { log ( msg , Project . MSG_ERR ) ; } } } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } finally { FileUtils . close ( outputstream ) ; FileUtils . close ( errorstream ) ; } } public void setTopDir ( File td ) { this . topDir = td ; } public void setCommand ( String c ) { this . command = c ; } public void setSpecFile ( String sf ) { if ( ( sf == null ) || ( sf . trim ( ) . equals ( "" ) ) ) { throw new BuildException ( "You must specify a spec file" , getLocation ( ) ) ; } this . specFile = sf ; } public void setCleanBuildDir ( boolean cbd ) { cleanBuildDir = cbd ; } public void setRemoveSpec ( boolean rs ) { removeSpec = rs ; } public void setRemoveSource ( boolean rs ) { removeSource = rs ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setRpmBuildCommand ( String c ) { this . rpmBuildCommand = c ; } public void setFailOnError ( boolean value ) { failOnError = value ; } public void setQuiet ( boolean value ) { quiet = value ; } protected String guessRpmBuildCommand ( ) { Vector env = Execute . getProcEnvironment ( ) ; String path = null ; for ( Enumeration e = env . elements ( ) ; e . hasMoreElements ( ) ; ) { String var = ( String ) e . nextElement ( ) ; if ( var . startsWith ( PATH1 ) || var . startsWith ( PATH2 ) || var . startsWith ( PATH3 ) ) { path = var . substring ( PATH_LEN ) ; break ; } } if ( path != null ) { Path p = new Path ( getProject ( ) , path ) ; String [ ] pElements = p . list ( ) ; for ( int i = 0 ; i < pElements . length ; i ++ ) { File f = new File ( pElements [ i ] , "rpmbuild" + ( Os . isFamily ( "dos" ) ? ".exe" : "" ) ) ; if ( f . canRead ( ) ) { return f . getAbsolutePath ( ) ; } } } return "rpm" ; } protected Execute getExecute ( Commandline toExecute , ExecuteStreamHandler streamhandler ) { Execute exe = new Execute ( streamhandler , null ) ; exe . setAntRun ( getProject ( ) ) ; if ( topDir == null ) { topDir = getProject ( ) . getBaseDir ( ) ; } exe . setWorkingDirectory ( topDir ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; return exe ; } } 	1
package org . apache . tools . zip ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . io . UnsupportedEncodingException ; import java . util . Date ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . Deflater ; import java . util . zip . ZipException ; public class ZipOutputStream extends FilterOutputStream { public static final int DEFLATED = java . util . zip . ZipEntry . DEFLATED ; public static final int DEFAULT_COMPRESSION = Deflater . DEFAULT_COMPRESSION ; public static final int STORED = java . util . zip . ZipEntry . STORED ; private ZipEntry entry ; private String comment = "" ; private int level = DEFAULT_COMPRESSION ; private boolean hasCompressionLevelChanged = false ; private int method = java . util . zip . ZipEntry . DEFLATED ; private Vector entries = new Vector ( ) ; private CRC32 crc = new CRC32 ( ) ; private long written = 0 ; private long dataStart = 0 ; private long localDataStart = 0 ; private long cdOffset = 0 ; private long cdLength = 0 ; private static final byte [ ] ZERO = { 0 , 0 } ; private static final byte [ ] LZERO = { 0 , 0 , 0 , 0 } ; private Hashtable offsets = new Hashtable ( ) ; private String encoding = null ; protected Deflater def = new Deflater ( level , true ) ; protected byte [ ] buf = new byte [ 512 ] ; private RandomAccessFile raf = null ; public ZipOutputStream ( OutputStream out ) { super ( out ) ; } public ZipOutputStream ( File file ) throws IOException { super ( null ) ; try { raf = new RandomAccessFile ( file , "rw" ) ; raf . setLength ( 0 ) ; } catch ( IOException e ) { if ( raf != null ) { try { raf . close ( ) ; } catch ( IOException inner ) { } raf = null ; } out = new FileOutputStream ( file ) ; } } public boolean isSeekable ( ) { return raf != null ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void finish ( ) throws IOException { closeEntry ( ) ; cdOffset = written ; for ( int i = 0 , entriesSize = entries . size ( ) ; i < entriesSize ; i ++ ) { writeCentralFileHeader ( ( ZipEntry ) entries . elementAt ( i ) ) ; } cdLength = written - cdOffset ; writeCentralDirectoryEnd ( ) ; offsets . clear ( ) ; entries . removeAllElements ( ) ; } public void closeEntry ( ) throws IOException { if ( entry == null ) { return ; } long realCrc = crc . getValue ( ) ; crc . reset ( ) ; if ( entry . getMethod ( ) == DEFLATED ) { def . finish ( ) ; while ( ! def . finished ( ) ) { deflate ( ) ; } entry . setSize ( adjustToLong ( def . getTotalIn ( ) ) ) ; entry . setCompressedSize ( adjustToLong ( def . getTotalOut ( ) ) ) ; entry . setCrc ( realCrc ) ; def . reset ( ) ; written += entry . getCompressedSize ( ) ; } else if ( raf == null ) { if ( entry . getCrc ( ) != realCrc ) { throw new ZipException ( "bad CRC checksum for entry " + entry . getName ( ) + ": " + Long . toHexString ( entry . getCrc ( ) ) + " instead of " + Long . toHexString ( realCrc ) ) ; } if ( entry . getSize ( ) != written - dataStart ) { throw new ZipException ( "bad size for entry " + entry . getName ( ) + ": " + entry . getSize ( ) + " instead of " + ( written - dataStart ) ) ; } } else { long size = written - dataStart ; entry . setSize ( size ) ; entry . setCompressedSize ( size ) ; entry . setCrc ( realCrc ) ; } if ( raf != null ) { long save = raf . getFilePointer ( ) ; raf . seek ( localDataStart ) ; writeOut ( ZipLong . getBytes ( entry . getCrc ( ) ) ) ; writeOut ( ZipLong . getBytes ( entry . getCompressedSize ( ) ) ) ; writeOut ( ZipLong . getBytes ( entry . getSize ( ) ) ) ; raf . seek ( save ) ; } writeDataDescriptor ( entry ) ; entry = null ; } public void putNextEntry ( ZipEntry ze ) throws IOException { closeEntry ( ) ; entry = ze ; entries . addElement ( entry ) ; if ( entry . getMethod ( ) == - 1 ) { entry . setMethod ( method ) ; } if ( entry . getTime ( ) == - 1 ) { entry . setTime ( System . currentTimeMillis ( ) ) ; } if ( entry . getMethod ( ) == STORED && raf == null ) { if ( entry . getSize ( ) == - 1 ) { throw new ZipException ( "uncompressed size is required for" + " STORED method when not writing to a" + " file" ) ; } if ( entry . getCrc ( ) == - 1 ) { throw new ZipException ( "crc checksum is required for STORED" + " method when not writing to a file" ) ; } entry . setCompressedSize ( entry . getSize ( ) ) ; } if ( entry . getMethod ( ) == DEFLATED && hasCompressionLevelChanged ) { def . setLevel ( level ) ; hasCompressionLevelChanged = false ; } writeLocalFileHeader ( entry ) ; } public void setComment ( String comment ) { this . comment = comment ; } public void setLevel ( int level ) { if ( level < Deflater . DEFAULT_COMPRESSION || level > Deflater . BEST_COMPRESSION ) { throw new IllegalArgumentException ( "Invalid compression level: " + level ) ; } hasCompressionLevelChanged = ( this . level != level ) ; this . level = level ; } public void setMethod ( int method ) { this . method = method ; } public void write ( byte [ ] b , int offset , int length ) throws IOException { if ( entry . getMethod ( ) == DEFLATED ) { if ( length > 0 ) { if ( ! def . finished ( ) ) { def . setInput ( b , offset , length ) ; while ( ! def . needsInput ( ) ) { deflate ( ) ; } } } } else { writeOut ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; } public void write ( int b ) throws IOException { byte [ ] buff = new byte [ 1 ] ; buff [ 0 ] = ( byte ) ( b & 0xff ) ; write ( buff , 0 , 1 ) ; } public void close ( ) throws IOException { finish ( ) ; if ( raf != null ) { raf . close ( ) ; } if ( out != null ) { out . close ( ) ; } } public void flush ( ) throws IOException { if ( out != null ) { out . flush ( ) ; } } protected static final byte [ ] LFH_SIG = ZipLong . getBytes ( 0X04034B50L ) ; protected static final byte [ ] DD_SIG = ZipLong . getBytes ( 0X08074B50L ) ; protected static final byte [ ] CFH_SIG = ZipLong . getBytes ( 0X02014B50L ) ; protected static final byte [ ] EOCD_SIG = ZipLong . getBytes ( 0X06054B50L ) ; protected final void deflate ( ) throws IOException { int len = def . deflate ( buf , 0 , buf . length ) ; if ( len > 0 ) { writeOut ( buf , 0 , len ) ; } } protected void writeLocalFileHeader ( ZipEntry ze ) throws IOException { offsets . put ( ze , ZipLong . getBytes ( written ) ) ; writeOut ( LFH_SIG ) ; written += 4 ; final int zipMethod = ze . getMethod ( ) ; if ( zipMethod == DEFLATED && raf == null ) { writeOut ( ZipShort . getBytes ( 20 ) ) ; writeOut ( ZipShort . getBytes ( 8 ) ) ; } else { writeOut ( ZipShort . getBytes ( 10 ) ) ; writeOut ( ZERO ) ; } written += 4 ; writeOut ( ZipShort . getBytes ( zipMethod ) ) ; written += 2 ; writeOut ( toDosTime ( ze . getTime ( ) ) ) ; written += 4 ; localDataStart = written ; if ( zipMethod == DEFLATED || raf != null ) { writeOut ( LZERO ) ; writeOut ( LZERO ) ; writeOut ( LZERO ) ; } else { writeOut ( ZipLong . getBytes ( ze . getCrc ( ) ) ) ; writeOut ( ZipLong . getBytes ( ze . getSize ( ) ) ) ; writeOut ( ZipLong . getBytes ( ze . getSize ( ) ) ) ; } written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; writeOut ( ZipShort . getBytes ( name . length ) ) ; written += 2 ; byte [ ] extra = ze . getLocalFileDataExtra ( ) ; writeOut ( ZipShort . getBytes ( extra . length ) ) ; written += 2 ; writeOut ( name ) ; written += name . length ; writeOut ( extra ) ; written += extra . length ; dataStart = written ; } protected void writeDataDescriptor ( ZipEntry ze ) throws IOException { if ( ze . getMethod ( ) != DEFLATED || raf != null ) { return ; } writeOut ( DD_SIG ) ; writeOut ( ZipLong . getBytes ( entry . getCrc ( ) ) ) ; writeOut ( ZipLong . getBytes ( entry . getCompressedSize ( ) ) ) ; writeOut ( ZipLong . getBytes ( entry . getSize ( ) ) ) ; written += 16 ; } protected void writeCentralFileHeader ( ZipEntry ze ) throws IOException { writeOut ( CFH_SIG ) ; written += 4 ; writeOut ( ZipShort . getBytes ( ( ze . getPlatform ( ) << 8 ) | 20 ) ) ; written += 2 ; if ( ze . getMethod ( ) == DEFLATED && raf == null ) { writeOut ( ZipShort . getBytes ( 20 ) ) ; writeOut ( ZipShort . getBytes ( 8 ) ) ; } else { writeOut ( ZipShort . getBytes ( 10 ) ) ; writeOut ( ZERO ) ; } written += 4 ; writeOut ( ZipShort . getBytes ( ze . getMethod ( ) ) ) ; written += 2 ; writeOut ( toDosTime ( ze . getTime ( ) ) ) ; written += 4 ; writeOut ( ZipLong . getBytes ( ze . getCrc ( ) ) ) ; writeOut ( ZipLong . getBytes ( ze . getCompressedSize ( ) ) ) ; writeOut ( ZipLong . getBytes ( ze . getSize ( ) ) ) ; written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; writeOut ( ZipShort . getBytes ( name . length ) ) ; written += 2 ; byte [ ] extra = ze . getCentralDirectoryExtra ( ) ; writeOut ( ZipShort . getBytes ( extra . length ) ) ; written += 2 ; String comm = ze . getComment ( ) ; if ( comm == null ) { comm = "" ; } byte [ ] commentB = getBytes ( comm ) ; writeOut ( ZipShort . getBytes ( commentB . length ) ) ; written += 2 ; writeOut ( ZERO ) ; written += 2 ; writeOut ( ZipShort . getBytes ( ze . getInternalAttributes ( ) ) ) ; written += 2 ; writeOut ( ZipLong . getBytes ( ze . getExternalAttributes ( ) ) ) ; written += 4 ; writeOut ( ( byte [ ] ) offsets . get ( ze ) ) ; written += 4 ; writeOut ( name ) ; written += name . length ; writeOut ( extra ) ; written += extra . length ; writeOut ( commentB ) ; written += commentB . length ; } protected void writeCentralDirectoryEnd ( ) throws IOException { writeOut ( EOCD_SIG ) ; writeOut ( ZERO ) ; writeOut ( ZERO ) ; byte [ ] num = ZipShort . getBytes ( entries . size ( ) ) ; writeOut ( num ) ; writeOut ( num ) ; writeOut ( ZipLong . getBytes ( cdLength ) ) ; writeOut ( ZipLong . getBytes ( cdOffset ) ) ; byte [ ] data = getBytes ( comment ) ; writeOut ( ZipShort . getBytes ( data . length ) ) ; writeOut ( data ) ; } private static final byte [ ] DOS_TIME_MIN = ZipLong . getBytes ( 0x00002100L ) ; protected static ZipLong toDosTime ( Date time ) { return new ZipLong ( toDosTime ( time . getTime ( ) ) ) ; } protected static byte [ ] toDosTime ( long t ) { Date time = new Date ( t ) ; int year = time . getYear ( ) + 1900 ; if ( year < 1980 ) { return DOS_TIME_MIN ; } int month = time . getMonth ( ) + 1 ; long value = ( ( year - 1980 ) << 25 ) | ( month << 21 ) | ( time . getDate ( ) << 16 ) | ( time . getHours ( ) << 11 ) | ( time . getMinutes ( ) << 5 ) | ( time . getSeconds ( ) > > 1 ) ; return ZipLong . getBytes ( value ) ; } protected byte [ ] getBytes ( String name ) throws ZipException { if ( encoding == null ) { return name . getBytes ( ) ; } else { try { return name . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } protected final void writeOut ( byte [ ] data ) throws IOException { writeOut ( data , 0 , data . length ) ; } protected final void writeOut ( byte [ ] data , int offset , int length ) throws IOException { if ( raf != null ) { raf . write ( data , offset , length ) ; } else { out . write ( data , offset , length ) ; } } protected static long adjustToLong ( int i ) { if ( i < 0 ) { return 2 * ( ( long ) Integer . MAX_VALUE ) + 2 + i ; } else { return i ; } } } 	1
package org . apache . tools . ant ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . SelectorScanner ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . util . FileUtils ; public class DirectoryScanner implements FileScanner , SelectorScanner , ResourceFactory { private static final boolean ON_VMS = Os . isFamily ( "openvms" ) ; protected static final String [ ] DEFAULTEXCLUDES = { "**/*~" , "**/#*#" , "**/.#*" , "**/%*%" , "**/._*" , "**/CVS" , "**/CVS/**" , "**/.cvsignore" , "**/SCCS" , "**/SCCS/**" , "**/vssver.scc" , "**/.svn" , "**/.svn/**" , "**/.DS_Store" } ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final boolean [ ] CS_SCAN_ONLY = new boolean [ ] { true } ; private static final boolean [ ] CS_THEN_NON_CS = new boolean [ ] { true , false } ; private static Vector defaultExcludes = new Vector ( ) ; static { resetDefaultExcludes ( ) ; } protected File basedir ; protected String [ ] includes ; protected String [ ] excludes ; protected FileSelector [ ] selectors = null ; protected Vector filesIncluded ; protected Vector filesNotIncluded ; protected Vector filesExcluded ; protected Vector dirsIncluded ; protected Vector dirsNotIncluded ; protected Vector dirsExcluded ; protected Vector filesDeselected ; protected Vector dirsDeselected ; protected boolean haveSlowResults = false ; protected boolean isCaseSensitive = true ; private boolean followSymlinks = true ; protected boolean everythingIncluded = true ; private Map fileListMap = new HashMap ( ) ; private Set scannedDirs = new HashSet ( ) ; private Set includeNonPatterns = new HashSet ( ) ; private Set excludeNonPatterns = new HashSet ( ) ; private String [ ] includePatterns ; private String [ ] excludePatterns ; private boolean areNonPatternSetsReady = false ; private boolean scanning = false ; private Object scanLock = new Object ( ) ; private boolean slowScanning = false ; private Object slowScanLock = new Object ( ) ; private IllegalStateException illegal = null ; public DirectoryScanner ( ) { } protected static boolean matchPatternStart ( String pattern , String str ) { return SelectorUtils . matchPatternStart ( pattern , str ) ; } protected static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . matchPatternStart ( pattern , str , isCaseSensitive ) ; } protected static boolean matchPath ( String pattern , String str ) { return SelectorUtils . matchPath ( pattern , str ) ; } protected static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . matchPath ( pattern , str , isCaseSensitive ) ; } public static boolean match ( String pattern , String str ) { return SelectorUtils . match ( pattern , str ) ; } protected static boolean match ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . match ( pattern , str , isCaseSensitive ) ; } public static String [ ] getDefaultExcludes ( ) { return ( String [ ] ) defaultExcludes . toArray ( new String [ defaultExcludes . size ( ) ] ) ; } public static boolean addDefaultExclude ( String s ) { if ( defaultExcludes . indexOf ( s ) == - 1 ) { defaultExcludes . add ( s ) ; return true ; } return false ; } public static boolean removeDefaultExclude ( String s ) { return defaultExcludes . remove ( s ) ; } public static void resetDefaultExcludes ( ) { defaultExcludes = new Vector ( ) ; for ( int i = 0 ; i < DEFAULTEXCLUDES . length ; i ++ ) { defaultExcludes . add ( DEFAULTEXCLUDES [ i ] ) ; } } public void setBasedir ( String basedir ) { setBasedir ( basedir == null ? ( File ) null : new File ( basedir . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ) ) ; } public synchronized void setBasedir ( File basedir ) { this . basedir = basedir ; } public synchronized File getBasedir ( ) { return basedir ; } public synchronized boolean isCaseSensitive ( ) { return isCaseSensitive ; } public synchronized void setCaseSensitive ( boolean isCaseSensitive ) { this . isCaseSensitive = isCaseSensitive ; } public synchronized boolean isFollowSymlinks ( ) { return followSymlinks ; } public synchronized void setFollowSymlinks ( boolean followSymlinks ) { this . followSymlinks = followSymlinks ; } public synchronized void setIncludes ( String [ ] includes ) { if ( includes == null ) { this . includes = null ; } else { this . includes = new String [ includes . length ] ; for ( int i = 0 ; i < includes . length ; i ++ ) { this . includes [ i ] = normalizePattern ( includes [ i ] ) ; } } } public synchronized void setExcludes ( String [ ] excludes ) { if ( excludes == null ) { this . excludes = null ; } else { this . excludes = new String [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i ++ ) { this . excludes [ i ] = normalizePattern ( excludes [ i ] ) ; } } } public synchronized void addExcludes ( String [ ] excludes ) { if ( excludes != null && excludes . length > 0 ) { if ( this . excludes != null && this . excludes . length > 0 ) { String [ ] tmp = new String [ excludes . length + this . excludes . length ] ; System . arraycopy ( this . excludes , 0 , tmp , 0 , this . excludes . length ) ; for ( int i = 0 ; i < excludes . length ; i ++ ) { tmp [ this . excludes . length + i ] = normalizePattern ( excludes [ i ] ) ; } this . excludes = tmp ; } else { setExcludes ( excludes ) ; } } } private static String normalizePattern ( String p ) { String pattern = p . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } return pattern ; } public synchronized void setSelectors ( FileSelector [ ] selectors ) { this . selectors = selectors ; } public synchronized boolean isEverythingIncluded ( ) { return everythingIncluded ; } public void scan ( ) throws IllegalStateException { synchronized ( scanLock ) { if ( scanning ) { while ( scanning ) { try { scanLock . wait ( ) ; } catch ( InterruptedException e ) { continue ; } } if ( illegal != null ) { throw illegal ; } return ; } scanning = true ; } try { synchronized ( this ) { illegal = null ; clearResults ( ) ; boolean nullIncludes = ( includes == null ) ; includes = nullIncludes ? new String [ ] { "**" } : includes ; boolean nullExcludes = ( excludes == null ) ; excludes = nullExcludes ? new String [ 0 ] : excludes ; if ( basedir == null ) { if ( nullIncludes ) { return ; } } else { if ( ! basedir . exists ( ) ) { illegal = new IllegalStateException ( "basedir " + basedir + " does not exist" ) ; } if ( ! basedir . isDirectory ( ) ) { illegal = new IllegalStateException ( "basedir " + basedir + " is not a directory" ) ; } if ( illegal != null ) { throw illegal ; } } if ( isIncluded ( "" ) ) { if ( ! isExcluded ( "" ) ) { if ( isSelected ( "" , basedir ) ) { dirsIncluded . addElement ( "" ) ; } else { dirsDeselected . addElement ( "" ) ; } } else { dirsExcluded . addElement ( "" ) ; } } else { dirsNotIncluded . addElement ( "" ) ; } checkIncludePatterns ( ) ; clearCaches ( ) ; includes = nullIncludes ? null : includes ; excludes = nullExcludes ? null : excludes ; } } finally { synchronized ( scanLock ) { scanning = false ; scanLock . notifyAll ( ) ; } } } private void checkIncludePatterns ( ) { Map newroots = new HashMap ( ) ; for ( int i = 0 ; i < includes . length ; i ++ ) { if ( FileUtils . isAbsolutePath ( includes [ i ] ) ) { if ( basedir != null && ! SelectorUtils . matchPatternStart ( includes [ i ] , basedir . getAbsolutePath ( ) , isCaseSensitive ( ) ) ) { continue ; } } else if ( basedir == null ) { continue ; } newroots . put ( SelectorUtils . rtrimWildcardTokens ( includes [ i ] ) , includes [ i ] ) ; } if ( newroots . containsKey ( "" ) && basedir != null ) { scandir ( basedir , "" , true ) ; } else { Iterator it = newroots . entrySet ( ) . iterator ( ) ; File canonBase = null ; if ( basedir != null ) { try { canonBase = basedir . getCanonicalFile ( ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; String currentelement = ( String ) entry . getKey ( ) ; if ( basedir == null && ! FileUtils . isAbsolutePath ( currentelement ) ) { continue ; } String originalpattern = ( String ) entry . getValue ( ) ; File myfile = new File ( basedir , currentelement ) ; if ( myfile . exists ( ) ) { try { String path = ( basedir == null ) ? myfile . getCanonicalPath ( ) : FILE_UTILS . removeLeadingPath ( canonBase , myfile . getCanonicalFile ( ) ) ; if ( ! path . equals ( currentelement ) || ON_VMS ) { myfile = findFile ( basedir , currentelement , true ) ; if ( myfile != null && basedir != null ) { currentelement = FILE_UTILS . removeLeadingPath ( basedir , myfile ) ; } } } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } if ( ( myfile == null || ! myfile . exists ( ) ) && ! isCaseSensitive ( ) ) { File f = findFile ( basedir , currentelement , false ) ; if ( f != null && f . exists ( ) ) { currentelement = ( basedir == null ) ? f . getAbsolutePath ( ) : FILE_UTILS . removeLeadingPath ( basedir , f ) ; myfile = f ; } } if ( myfile != null && myfile . exists ( ) ) { if ( ! followSymlinks && isSymlink ( basedir , currentelement ) ) { continue ; } if ( myfile . isDirectory ( ) ) { if ( isIncluded ( currentelement ) && currentelement . length ( ) > 0 ) { accountForIncludedDir ( currentelement , myfile , true ) ; } else { if ( currentelement . length ( ) > 0 ) { if ( currentelement . charAt ( currentelement . length ( ) - 1 ) != File . separatorChar ) { currentelement = currentelement + File . separatorChar ; } } scandir ( myfile , currentelement , true ) ; } } else { boolean included = isCaseSensitive ( ) ? originalpattern . equals ( currentelement ) : originalpattern . equalsIgnoreCase ( currentelement ) ; if ( included ) { accountForIncludedFile ( currentelement , myfile ) ; } } } } } } protected synchronized void clearResults ( ) { filesIncluded = new Vector ( ) ; filesNotIncluded = new Vector ( ) ; filesExcluded = new Vector ( ) ; filesDeselected = new Vector ( ) ; dirsIncluded = new Vector ( ) ; dirsNotIncluded = new Vector ( ) ; dirsExcluded = new Vector ( ) ; dirsDeselected = new Vector ( ) ; everythingIncluded = ( basedir != null ) ; scannedDirs . clear ( ) ; } protected void slowScan ( ) { synchronized ( slowScanLock ) { if ( haveSlowResults ) { return ; } if ( slowScanning ) { while ( slowScanning ) { try { slowScanLock . wait ( ) ; } catch ( InterruptedException e ) { } } return ; } slowScanning = true ; } try { synchronized ( this ) { boolean nullIncludes = ( includes == null ) ; includes = nullIncludes ? new String [ ] { "**" } : includes ; boolean nullExcludes = ( excludes == null ) ; excludes = nullExcludes ? new String [ 0 ] : excludes ; String [ ] excl = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( excl ) ; String [ ] notIncl = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( notIncl ) ; processSlowScan ( excl ) ; processSlowScan ( notIncl ) ; clearCaches ( ) ; includes = nullIncludes ? null : includes ; excludes = nullExcludes ? null : excludes ; } } finally { synchronized ( slowScanLock ) { haveSlowResults = true ; slowScanning = false ; slowScanLock . notifyAll ( ) ; } } } private void processSlowScan ( String [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ! couldHoldIncluded ( arr [ i ] ) ) { scandir ( new File ( basedir , arr [ i ] ) , arr [ i ] + File . separator , false ) ; } } } protected void scandir ( File dir , String vpath , boolean fast ) { if ( dir == null ) { throw new BuildException ( "dir must not be null." ) ; } else if ( ! dir . exists ( ) ) { throw new BuildException ( dir + " doesn't exist." ) ; } else if ( ! dir . isDirectory ( ) ) { throw new BuildException ( dir + " is not a directory." ) ; } if ( fast && hasBeenScanned ( vpath ) ) { return ; } String [ ] newfiles = dir . list ( ) ; if ( newfiles == null ) { throw new BuildException ( "IO error scanning directory '" + dir . getAbsolutePath ( ) + "'" ) ; } if ( ! followSymlinks ) { Vector noLinks = new Vector ( ) ; for ( int i = 0 ; i < newfiles . length ; i ++ ) { try { if ( FILE_UTILS . isSymbolicLink ( dir , newfiles [ i ] ) ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; ( file . isDirectory ( ) ? dirsExcluded : filesExcluded ) . addElement ( name ) ; } else { noLinks . addElement ( newfiles [ i ] ) ; } } catch ( IOException ioe ) { String msg = "IOException caught while checking " + "for links, couldn't get canonical path!" ; System . err . println ( msg ) ; noLinks . addElement ( newfiles [ i ] ) ; } } newfiles = ( String [ ] ) ( noLinks . toArray ( new String [ noLinks . size ( ) ] ) ) ; } for ( int i = 0 ; i < newfiles . length ; i ++ ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { if ( isIncluded ( name ) ) { accountForIncludedDir ( name , file , fast ) ; } else { everythingIncluded = false ; dirsNotIncluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } if ( ! fast ) { scandir ( file , name + File . separator , fast ) ; } } else if ( file . isFile ( ) ) { if ( isIncluded ( name ) ) { accountForIncludedFile ( name , file ) ; } else { everythingIncluded = false ; filesNotIncluded . addElement ( name ) ; } } } } private void accountForIncludedFile ( String name , File file ) { processIncluded ( name , file , filesIncluded , filesExcluded , filesDeselected ) ; } private void accountForIncludedDir ( String name , File file , boolean fast ) { processIncluded ( name , file , dirsIncluded , dirsExcluded , dirsDeselected ) ; if ( fast && couldHoldIncluded ( name ) && ! contentsExcluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } private void processIncluded ( String name , File file , Vector inc , Vector exc , Vector des ) { if ( inc . contains ( name ) || exc . contains ( name ) || des . contains ( name ) ) { return ; } boolean included = false ; if ( isExcluded ( name ) ) { exc . add ( name ) ; } else if ( isSelected ( name , file ) ) { included = true ; inc . add ( name ) ; } else { des . add ( name ) ; } everythingIncluded &= included ; } protected boolean isIncluded ( String name ) { ensureNonPatternSetsReady ( ) ; if ( isCaseSensitive ( ) ? includeNonPatterns . contains ( name ) : includeNonPatterns . contains ( name . toUpperCase ( ) ) ) { return true ; } for ( int i = 0 ; i < includePatterns . length ; i ++ ) { if ( matchPath ( includePatterns [ i ] , name , isCaseSensitive ( ) ) ) { return true ; } } return false ; } protected boolean couldHoldIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPatternStart ( includes [ i ] , name , isCaseSensitive ( ) ) && isMorePowerfulThanExcludes ( name , includes [ i ] ) && isDeeper ( includes [ i ] , name ) ) { return true ; } } return false ; } private boolean isDeeper ( String pattern , String name ) { Vector p = SelectorUtils . tokenizePath ( pattern ) ; Vector n = SelectorUtils . tokenizePath ( name ) ; return p . contains ( "**" ) || p . size ( ) > n . size ( ) ; } private boolean isMorePowerfulThanExcludes ( String name , String includepattern ) { String soughtexclude = name + File . separator + "**" ; for ( int counter = 0 ; counter < excludes . length ; counter ++ ) { if ( excludes [ counter ] . equals ( soughtexclude ) ) { return false ; } } return true ; } private boolean contentsExcluded ( String name ) { name = ( name . endsWith ( File . separator ) ) ? name : name + File . separator ; for ( int i = 0 ; i < excludes . length ; i ++ ) { String e = excludes [ i ] ; if ( e . endsWith ( "**" ) && SelectorUtils . matchPath ( e . substring ( 0 , e . length ( ) - 2 ) , name , isCaseSensitive ( ) ) ) { return true ; } } return false ; } protected boolean isExcluded ( String name ) { ensureNonPatternSetsReady ( ) ; if ( isCaseSensitive ( ) ? excludeNonPatterns . contains ( name ) : excludeNonPatterns . contains ( name . toUpperCase ( ) ) ) { return true ; } for ( int i = 0 ; i < excludePatterns . length ; i ++ ) { if ( matchPath ( excludePatterns [ i ] , name , isCaseSensitive ( ) ) ) { return true ; } } return false ; } protected boolean isSelected ( String name , File file ) { if ( selectors != null ) { for ( int i = 0 ; i < selectors . length ; i ++ ) { if ( ! selectors [ i ] . isSelected ( basedir , name , file ) ) { return false ; } } } return true ; } public synchronized String [ ] getIncludedFiles ( ) { if ( filesIncluded == null ) { throw new IllegalStateException ( "Must call scan() first" ) ; } String [ ] files = new String [ filesIncluded . size ( ) ] ; filesIncluded . copyInto ( files ) ; Arrays . sort ( files ) ; return files ; } public synchronized int getIncludedFilesCount ( ) { if ( filesIncluded == null ) { throw new IllegalStateException ( "Must call scan() first" ) ; } return filesIncluded . size ( ) ; } public synchronized String [ ] getNotIncludedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesNotIncluded . size ( ) ] ; filesNotIncluded . copyInto ( files ) ; return files ; } public synchronized String [ ] getExcludedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesExcluded . size ( ) ] ; filesExcluded . copyInto ( files ) ; return files ; } public synchronized String [ ] getDeselectedFiles ( ) { slowScan ( ) ; String [ ] files = new String [ filesDeselected . size ( ) ] ; filesDeselected . copyInto ( files ) ; return files ; } public synchronized String [ ] getIncludedDirectories ( ) { if ( dirsIncluded == null ) { throw new IllegalStateException ( "Must call scan() first" ) ; } String [ ] directories = new String [ dirsIncluded . size ( ) ] ; dirsIncluded . copyInto ( directories ) ; Arrays . sort ( directories ) ; return directories ; } public synchronized int getIncludedDirsCount ( ) { if ( dirsIncluded == null ) { throw new IllegalStateException ( "Must call scan() first" ) ; } return dirsIncluded . size ( ) ; } public synchronized String [ ] getNotIncludedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( directories ) ; return directories ; } public synchronized String [ ] getExcludedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( directories ) ; return directories ; } public synchronized String [ ] getDeselectedDirectories ( ) { slowScan ( ) ; String [ ] directories = new String [ dirsDeselected . size ( ) ] ; dirsDeselected . copyInto ( directories ) ; return directories ; } public synchronized void addDefaultExcludes ( ) { int excludesLength = excludes == null ? 0 : excludes . length ; String [ ] newExcludes ; newExcludes = new String [ excludesLength + defaultExcludes . size ( ) ] ; if ( excludesLength > 0 ) { System . arraycopy ( excludes , 0 , newExcludes , 0 , excludesLength ) ; } String [ ] defaultExcludesTemp = getDefaultExcludes ( ) ; for ( int i = 0 ; i < defaultExcludesTemp . length ; i ++ ) { newExcludes [ i + excludesLength ] = defaultExcludesTemp [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } excludes = newExcludes ; } public synchronized Resource getResource ( String name ) { return new FileResource ( basedir , name ) ; } private String [ ] list ( File file ) { String [ ] files = ( String [ ] ) fileListMap . get ( file ) ; if ( files == null ) { files = file . list ( ) ; if ( files != null ) { fileListMap . put ( file , files ) ; } } return files ; } private File findFile ( File base , String path , boolean cs ) { if ( FileUtils . isAbsolutePath ( path ) ) { if ( base == null ) { String [ ] s = FILE_UTILS . dissect ( path ) ; base = new File ( s [ 0 ] ) ; path = s [ 1 ] ; } else { File f = FILE_UTILS . normalize ( path ) ; String s = FILE_UTILS . removeLeadingPath ( base , f ) ; if ( s . equals ( f . getAbsolutePath ( ) ) ) { return null ; } path = s ; } } return findFile ( base , SelectorUtils . tokenizePath ( path ) , cs ) ; } private File findFile ( File base , Vector pathElements , boolean cs ) { if ( pathElements . size ( ) == 0 ) { return base ; } String current = ( String ) pathElements . remove ( 0 ) ; if ( base == null ) { return findFile ( new File ( current ) , pathElements , cs ) ; } if ( ! base . isDirectory ( ) ) { return null ; } String [ ] files = list ( base ) ; if ( files == null ) { throw new BuildException ( "IO error scanning directory " + base . getAbsolutePath ( ) ) ; } boolean [ ] matchCase = cs ? CS_SCAN_ONLY : CS_THEN_NON_CS ; for ( int i = 0 ; i < matchCase . length ; i ++ ) { for ( int j = 0 ; j < files . length ; j ++ ) { if ( matchCase [ i ] ? files [ j ] . equals ( current ) : files [ j ] . equalsIgnoreCase ( current ) ) { return findFile ( new File ( base , files [ j ] ) , pathElements , cs ) ; } } } return null ; } private boolean isSymlink ( File base , String path ) { return isSymlink ( base , SelectorUtils . tokenizePath ( path ) ) ; } private boolean isSymlink ( File base , Vector pathElements ) { if ( pathElements . size ( ) > 0 ) { String current = ( String ) pathElements . remove ( 0 ) ; try { return FILE_UTILS . isSymbolicLink ( base , current ) || isSymlink ( new File ( base , current ) , pathElements ) ; } catch ( IOException ioe ) { String msg = "IOException caught while checking " + "for links, couldn't get canonical path!" ; System . err . println ( msg ) ; } } return false ; } private boolean hasBeenScanned ( String vpath ) { return ! scannedDirs . add ( vpath ) ; } Set getScannedDirs ( ) { return scannedDirs ; } private synchronized void clearCaches ( ) { fileListMap . clear ( ) ; includeNonPatterns . clear ( ) ; excludeNonPatterns . clear ( ) ; includePatterns = null ; excludePatterns = null ; areNonPatternSetsReady = false ; } private synchronized void ensureNonPatternSetsReady ( ) { if ( ! areNonPatternSetsReady ) { includePatterns = fillNonPatternSet ( includeNonPatterns , includes ) ; excludePatterns = fillNonPatternSet ( excludeNonPatterns , excludes ) ; areNonPatternSetsReady = true ; } } private String [ ] fillNonPatternSet ( Set set , String [ ] patterns ) { ArrayList al = new ArrayList ( patterns . length ) ; for ( int i = 0 ; i < patterns . length ; i ++ ) { if ( ! SelectorUtils . hasWildcards ( patterns [ i ] ) ) { set . add ( isCaseSensitive ( ) ? patterns [ i ] : patterns [ i ] . toUpperCase ( ) ) ; } else { al . add ( patterns [ i ] ) ; } } return set . size ( ) == 0 ? patterns : ( String [ ] ) al . toArray ( new String [ al . size ( ) ] ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . compilers . AptExternalCompilerAdapter ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . util . Vector ; import java . io . File ; public class Apt extends Javac { private boolean compile = true ; private String factory ; private Path factoryPath ; private Vector options = new Vector ( ) ; private File preprocessDir ; public static final String EXECUTABLE_NAME = "apt" ; public static final String ERROR_IGNORING_COMPILER_OPTION = "Ignoring compiler attribute for the APT task, as it is fixed" ; public static final String ERROR_WRONG_JAVA_VERSION = "Apt task requires Java 1.5+" ; public static final String WARNING_IGNORING_FORK = "Apt only runs in its own JVM; fork=false option ignored" ; public static final class Option { private String name ; private String value ; public Option ( ) { } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } public Apt ( ) { super ( ) ; super . setCompiler ( AptExternalCompilerAdapter . class . getName ( ) ) ; setFork ( true ) ; } public String getAptExecutable ( ) { return JavaEnvUtils . getJdkExecutable ( EXECUTABLE_NAME ) ; } public void setCompiler ( String compiler ) { log ( ERROR_IGNORING_COMPILER_OPTION , Project . MSG_WARN ) ; } public void setFork ( boolean fork ) { if ( ! fork ) { log ( WARNING_IGNORING_FORK , Project . MSG_WARN ) ; } } public String getCompiler ( ) { return super . getCompiler ( ) ; } public boolean isCompile ( ) { return compile ; } public void setCompile ( boolean compile ) { this . compile = compile ; } public String getFactory ( ) { return factory ; } public void setFactory ( String factory ) { this . factory = factory ; } public void setFactoryPathRef ( Reference ref ) { createFactoryPath ( ) . setRefid ( ref ) ; } public Path createFactoryPath ( ) { if ( factoryPath == null ) { factoryPath = new Path ( getProject ( ) ) ; } return factoryPath . createPath ( ) ; } public Path getFactoryPath ( ) { return factoryPath ; } public Option createOption ( ) { Option opt = new Option ( ) ; options . add ( opt ) ; return opt ; } public Vector getOptions ( ) { return options ; } public File getPreprocessDir ( ) { return preprocessDir ; } public void setPreprocessDir ( File preprocessDir ) { this . preprocessDir = preprocessDir ; } public void execute ( ) throws BuildException { super . execute ( ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . util . ArrayList ; import java . util . List ; import java . util . Iterator ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . HashSet ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DynamicAttribute ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class MacroInstance extends Task implements DynamicAttribute , TaskContainer { private MacroDef macroDef ; private Map map = new HashMap ( ) ; private Map nsElements = null ; private Map presentElements ; private Hashtable localAttributes ; private String text = null ; private String implicitTag = null ; private List unknownElements = new ArrayList ( ) ; public void setMacroDef ( MacroDef macroDef ) { this . macroDef = macroDef ; } public MacroDef getMacroDef ( ) { return macroDef ; } public void setDynamicAttribute ( String name , String value ) { map . put ( name , value ) ; } public Object createDynamicElement ( String name ) throws BuildException { throw new BuildException ( "Not implemented any more" ) ; } private Map getNsElements ( ) { if ( nsElements == null ) { nsElements = new HashMap ( ) ; for ( Iterator i = macroDef . getElements ( ) . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; nsElements . put ( ( String ) entry . getKey ( ) , entry . getValue ( ) ) ; MacroDef . TemplateElement te = ( MacroDef . TemplateElement ) entry . getValue ( ) ; if ( te . isImplicit ( ) ) { implicitTag = te . getName ( ) ; } } } return nsElements ; } public void addTask ( Task nestedTask ) { unknownElements . add ( nestedTask ) ; } private void processTasks ( ) { if ( implicitTag != null ) { return ; } for ( Iterator i = unknownElements . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement ue = ( UnknownElement ) i . next ( ) ; String name = ProjectHelper . extractNameFromComponentName ( ue . getTag ( ) ) . toLowerCase ( Locale . US ) ; if ( getNsElements ( ) . get ( name ) == null ) { throw new BuildException ( "unsupported element " + name ) ; } if ( presentElements . get ( name ) != null ) { throw new BuildException ( "Element " + name + " already present" ) ; } presentElements . put ( name , ue ) ; } } public static class Element implements TaskContainer { private List unknownElements = new ArrayList ( ) ; public void addTask ( Task nestedTask ) { unknownElements . add ( nestedTask ) ; } public List getUnknownElements ( ) { return unknownElements ; } } private static final int STATE_NORMAL = 0 ; private static final int STATE_EXPECT_BRACKET = 1 ; private static final int STATE_EXPECT_NAME = 2 ; private String macroSubs ( String s , Map macroMapping ) { if ( s == null ) { return null ; } StringBuffer ret = new StringBuffer ( ) ; StringBuffer macroName = null ; int state = STATE_NORMAL ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { char ch = s . charAt ( i ) ; switch ( state ) { case STATE_NORMAL : if ( ch == '@' ) { state = STATE_EXPECT_BRACKET ; } else { ret . append ( ch ) ; } break ; case STATE_EXPECT_BRACKET : if ( ch == '{' ) { state = STATE_EXPECT_NAME ; macroName = new StringBuffer ( ) ; } else if ( ch == '@' ) { state = STATE_NORMAL ; ret . append ( '@' ) ; } else { state = STATE_NORMAL ; ret . append ( '@' ) ; ret . append ( ch ) ; } break ; case STATE_EXPECT_NAME : if ( ch == '}' ) { state = STATE_NORMAL ; String name = macroName . toString ( ) . toLowerCase ( Locale . US ) ; String value = ( String ) macroMapping . get ( name ) ; if ( value == null ) { ret . append ( "@{" ) ; ret . append ( name ) ; ret . append ( "}" ) ; } else { ret . append ( value ) ; } macroName = null ; } else { macroName . append ( ch ) ; } break ; default : break ; } } switch ( state ) { case STATE_NORMAL : break ; case STATE_EXPECT_BRACKET : ret . append ( '@' ) ; break ; case STATE_EXPECT_NAME : ret . append ( "@{" ) ; ret . append ( macroName . toString ( ) ) ; break ; default : break ; } return ret . toString ( ) ; } public void addText ( String text ) { this . text = text ; } private UnknownElement copy ( UnknownElement ue ) { UnknownElement ret = new UnknownElement ( ue . getTag ( ) ) ; ret . setNamespace ( ue . getNamespace ( ) ) ; ret . setProject ( getProject ( ) ) ; ret . setQName ( ue . getQName ( ) ) ; ret . setTaskType ( ue . getTaskType ( ) ) ; ret . setTaskName ( ue . getTaskName ( ) ) ; ret . setLocation ( macroDef . getBackTrace ( ) ? ue . getLocation ( ) : getLocation ( ) ) ; if ( getOwningTarget ( ) == null ) { Target t = new Target ( ) ; t . setProject ( getProject ( ) ) ; ret . setOwningTarget ( t ) ; } else { ret . setOwningTarget ( getOwningTarget ( ) ) ; } RuntimeConfigurable rc = new RuntimeConfigurable ( ret , ue . getTaskName ( ) ) ; rc . setPolyType ( ue . getWrapper ( ) . getPolyType ( ) ) ; Map m = ue . getWrapper ( ) . getAttributeMap ( ) ; for ( Iterator i = m . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; rc . setAttribute ( ( String ) entry . getKey ( ) , macroSubs ( ( String ) entry . getValue ( ) , localAttributes ) ) ; } rc . addText ( macroSubs ( ue . getWrapper ( ) . getText ( ) . toString ( ) , localAttributes ) ) ; Enumeration e = ue . getWrapper ( ) . getChildren ( ) ; while ( e . hasMoreElements ( ) ) { RuntimeConfigurable r = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement unknownElement = ( UnknownElement ) r . getProxy ( ) ; String tag = unknownElement . getTaskType ( ) ; if ( tag != null ) { tag = tag . toLowerCase ( Locale . US ) ; } MacroDef . TemplateElement templateElement = ( MacroDef . TemplateElement ) getNsElements ( ) . get ( tag ) ; if ( templateElement == null ) { UnknownElement child = copy ( unknownElement ) ; rc . addChild ( child . getWrapper ( ) ) ; ret . addChild ( child ) ; } else if ( templateElement . isImplicit ( ) ) { if ( unknownElements . size ( ) == 0 && ! templateElement . isOptional ( ) ) { throw new BuildException ( "Missing nested elements for implicit element " + templateElement . getName ( ) ) ; } for ( Iterator i = unknownElements . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement child = copy ( ( UnknownElement ) i . next ( ) ) ; rc . addChild ( child . getWrapper ( ) ) ; ret . addChild ( child ) ; } } else { UnknownElement presentElement = ( UnknownElement ) presentElements . get ( tag ) ; if ( presentElement == null ) { if ( ! templateElement . isOptional ( ) ) { throw new BuildException ( "Required nested element " + templateElement . getName ( ) + " missing" ) ; } continue ; } String presentText = presentElement . getWrapper ( ) . getText ( ) . toString ( ) ; if ( ! "" . equals ( presentText ) ) { rc . addText ( macroSubs ( presentText , localAttributes ) ) ; } List list = presentElement . getChildren ( ) ; if ( list != null ) { for ( Iterator i = list . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement child = copy ( ( UnknownElement ) i . next ( ) ) ; rc . addChild ( child . getWrapper ( ) ) ; ret . addChild ( child ) ; } } } } return ret ; } public void execute ( ) { presentElements = new HashMap ( ) ; getNsElements ( ) ; processTasks ( ) ; localAttributes = new Hashtable ( ) ; Set copyKeys = new HashSet ( map . keySet ( ) ) ; for ( Iterator i = macroDef . getAttributes ( ) . iterator ( ) ; i . hasNext ( ) ; ) { MacroDef . Attribute attribute = ( MacroDef . Attribute ) i . next ( ) ; String value = ( String ) map . get ( attribute . getName ( ) ) ; if ( value == null && "description" . equals ( attribute . getName ( ) ) ) { value = getDescription ( ) ; } if ( value == null ) { value = attribute . getDefault ( ) ; value = macroSubs ( value , localAttributes ) ; } if ( value == null ) { throw new BuildException ( "required attribute " + attribute . getName ( ) + " not set" ) ; } localAttributes . put ( attribute . getName ( ) , value ) ; copyKeys . remove ( attribute . getName ( ) ) ; } if ( copyKeys . contains ( "id" ) ) { copyKeys . remove ( "id" ) ; } if ( macroDef . getText ( ) != null ) { if ( text == null ) { if ( ! macroDef . getText ( ) . getOptional ( ) ) { throw new BuildException ( "required text missing" ) ; } text = "" ; } if ( macroDef . getText ( ) . getTrim ( ) ) { text = text . trim ( ) ; } localAttributes . put ( macroDef . getText ( ) . getName ( ) , text ) ; } else { if ( text != null && ! text . trim ( ) . equals ( "" ) ) { throw new BuildException ( "The \"" + getTaskName ( ) + "\" macro does not support" + " nested text data." ) ; } } if ( copyKeys . size ( ) != 0 ) { throw new BuildException ( "Unknown attribute" + ( copyKeys . size ( ) > 1 ? "s " : " " ) + copyKeys ) ; } UnknownElement c = copy ( macroDef . getNestedTask ( ) ) ; c . init ( ) ; try { c . perform ( ) ; } catch ( BuildException ex ) { if ( macroDef . getBackTrace ( ) ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } else { ex . setLocation ( getLocation ( ) ) ; throw ex ; } } finally { presentElements = null ; localAttributes = null ; } } } 	1
package org . apache . tools . ant . types ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Map ; import java . util . zip . ZipException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . ZipResource ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class ZipScanner extends ArchiveScanner { protected void fillMapsFromArchive ( Resource src , String encoding , Map fileEntries , Map matchFileEntries , Map dirEntries , Map matchDirEntries ) { ZipEntry entry = null ; ZipFile zf = null ; File srcFile = null ; if ( src instanceof FileResource ) { srcFile = ( ( FileResource ) src ) . getFile ( ) ; } else { throw new BuildException ( "only file resources are supported" ) ; } try { try { zf = new ZipFile ( srcFile , encoding ) ; } catch ( ZipException ex ) { throw new BuildException ( "problem reading " + srcFile , ex ) ; } catch ( IOException ex ) { throw new BuildException ( "problem opening " + srcFile , ex ) ; } Enumeration e = zf . getEntries ( ) ; while ( e . hasMoreElements ( ) ) { entry = ( ZipEntry ) e . nextElement ( ) ; Resource r = new ZipResource ( srcFile , encoding , entry ) ; String name = entry . getName ( ) ; if ( entry . isDirectory ( ) ) { name = trimSeparator ( name ) ; dirEntries . put ( name , r ) ; if ( match ( name ) ) { matchDirEntries . put ( name , r ) ; } } else { fileEntries . put ( name , r ) ; if ( match ( name ) ) { matchFileEntries . put ( name , r ) ; } } } } finally { if ( zf != null ) { try { zf . close ( ) ; } catch ( IOException ex ) { } } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . RedirectorElement ; import org . apache . tools . ant . util . FileUtils ; public class ExecTask extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String os ; private String osFamily ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Long timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private String resultProperty ; private boolean failIfExecFails = true ; private String executable ; private boolean resolveExecutable = false ; private boolean searchPath = false ; private boolean spawn = false ; private boolean incompatibleWithSpawn = false ; private String inputString ; private File input ; private File output ; private File error ; protected Redirector redirector = new Redirector ( this ) ; protected RedirectorElement redirectorElement ; private boolean vmLauncher = true ; public ExecTask ( ) { } public ExecTask ( Task owner ) { bindToOwner ( owner ) ; } public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public void setTimeout ( Long value ) { timeout = value ; incompatibleWithSpawn = true ; } public void setTimeout ( Integer value ) { setTimeout ( ( Long ) ( ( value == null ) ? null : new Long ( value . intValue ( ) ) ) ) ; } public void setExecutable ( String value ) { this . executable = value ; cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated.\n" + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { this . output = out ; incompatibleWithSpawn = true ; } public void setInput ( File input ) { if ( inputString != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } this . input = input ; incompatibleWithSpawn = true ; } public void setInputString ( String inputString ) { if ( input != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } this . inputString = inputString ; incompatibleWithSpawn = true ; } public void setLogError ( boolean logError ) { redirector . setLogError ( logError ) ; incompatibleWithSpawn |= logError ; } public void setError ( File error ) { this . error = error ; incompatibleWithSpawn = true ; } public void setOutputproperty ( String outputProp ) { redirector . setOutputProperty ( outputProp ) ; incompatibleWithSpawn = true ; } public void setErrorProperty ( String errorProperty ) { redirector . setErrorProperty ( errorProperty ) ; incompatibleWithSpawn = true ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; incompatibleWithSpawn |= fail ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setResolveExecutable ( boolean resolveExecutable ) { this . resolveExecutable = resolveExecutable ; } public void setSearchPath ( boolean searchPath ) { this . searchPath = searchPath ; } public boolean getResolveExecutable ( ) { return resolveExecutable ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; incompatibleWithSpawn = true ; } protected void maybeSetResultPropertyValue ( int result ) { if ( resultProperty != null ) { String res = Integer . toString ( result ) ; getProject ( ) . setNewProperty ( resultProperty , res ) ; } } public void setFailIfExecutionFails ( boolean flag ) { failIfExecFails = flag ; incompatibleWithSpawn = true ; } public void setAppend ( boolean append ) { redirector . setAppend ( append ) ; incompatibleWithSpawn = true ; } public void addConfiguredRedirector ( RedirectorElement redirectorElement ) { if ( this . redirectorElement != null ) { throw new BuildException ( "cannot have > 1 nested <redirector>s" ) ; } this . redirectorElement = redirectorElement ; incompatibleWithSpawn = true ; } public void setOsFamily ( String osFamily ) { this . osFamily = osFamily . toLowerCase ( Locale . US ) ; } protected String resolveExecutable ( String exec , boolean mustSearchPath ) { if ( ! resolveExecutable ) { return exec ; } File executableFile = getProject ( ) . resolveFile ( exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } if ( dir != null ) { executableFile = FILE_UTILS . resolveFile ( dir , exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } } if ( mustSearchPath ) { Path p = null ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { if ( isPath ( environment [ i ] ) ) { p = new Path ( getProject ( ) , environment [ i ] . substring ( 5 ) ) ; break ; } } } if ( p == null ) { Vector envVars = Execute . getProcEnvironment ( ) ; Enumeration e = envVars . elements ( ) ; while ( e . hasMoreElements ( ) ) { String line = ( String ) e . nextElement ( ) ; if ( isPath ( line ) ) { p = new Path ( getProject ( ) , line . substring ( 5 ) ) ; break ; } } } if ( p != null ) { String [ ] dirs = p . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { executableFile = FILE_UTILS . resolveFile ( new File ( dirs [ i ] ) , exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } } } } return exec ; } public void execute ( ) throws BuildException { if ( ! isValidOs ( ) ) { return ; } File savedDir = dir ; cmdl . setExecutable ( resolveExecutable ( executable , searchPath ) ) ; checkConfiguration ( ) ; try { runExec ( prepareExec ( ) ) ; } finally { dir = savedDir ; } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , getLocation ( ) ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory " + dir + " does not exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( dir + " is not a directory" ) ; } if ( spawn && incompatibleWithSpawn ) { getProject ( ) . log ( "spawn does not allow attributes related to input, " + "output, error, result" , Project . MSG_ERR ) ; getProject ( ) . log ( "spawn also does not allow timeout" , Project . MSG_ERR ) ; getProject ( ) . log ( "finally, spawn is not compatible " + "with a nested I/O <redirector>" , Project . MSG_ERR ) ; throw new BuildException ( "You have used an attribute " + "or nested element which is not compatible with spawn" ) ; } setupRedirector ( ) ; } protected void setupRedirector ( ) { redirector . setInput ( input ) ; redirector . setInputString ( inputString ) ; redirector . setOutput ( output ) ; redirector . setError ( error ) ; } protected boolean isValidOs ( ) { if ( osFamily != null && ! Os . isOs ( osFamily , null , null , null ) ) { return false ; } String myos = System . getProperty ( "os.name" ) ; log ( "Current OS is " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "This OS, " + myos + " was not found in the specified list of valid OSes: " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void setVMLauncher ( boolean vmLauncher ) { this . vmLauncher = vmLauncher ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } if ( redirectorElement != null ) { redirectorElement . configure ( redirector ) ; } Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( dir ) ; exe . setVMLauncher ( vmLauncher ) ; exe . setSpawn ( spawn ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected final void runExecute ( Execute exe ) throws IOException { int returnCode = - 1 ; if ( ! spawn ) { returnCode = exe . execute ( ) ; if ( exe . killedProcess ( ) ) { String msg = "Timeout: killed the sub-process" ; if ( failOnError ) { throw new BuildException ( msg ) ; } else { log ( msg , Project . MSG_WARN ) ; } } maybeSetResultPropertyValue ( returnCode ) ; redirector . complete ( ) ; if ( Execute . isFailure ( returnCode ) ) { if ( failOnError ) { throw new BuildException ( getTaskType ( ) + " returned: " + returnCode , getLocation ( ) ) ; } else { log ( "Result: " + returnCode , Project . MSG_ERR ) ; } } } else { exe . spawn ( ) ; } } protected void runExec ( Execute exe ) throws BuildException { log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( cmdl . getCommandline ( ) ) ; try { runExecute ( exe ) ; } catch ( IOException e ) { if ( failIfExecFails ) { throw new BuildException ( "Execute failed: " + e . toString ( ) , e , getLocation ( ) ) ; } else { log ( "Execute failed: " + e . toString ( ) , Project . MSG_ERR ) ; } } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { return redirector . createHandler ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { return ( timeout == null ) ? null : new ExecuteWatchdog ( timeout . longValue ( ) ) ; } protected void logFlush ( ) { } private boolean isPath ( String line ) { return line . startsWith ( "PATH=" ) || line . startsWith ( "Path=" ) ; } } 	1
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . zip . UnixStat ; public abstract class ArchiveFileSet extends FileSet { private static final int BASE_OCTAL = 8 ; public static final int DEFAULT_DIR_MODE = UnixStat . DIR_FLAG | UnixStat . DEFAULT_DIR_PERM ; public static final int DEFAULT_FILE_MODE = UnixStat . FILE_FLAG | UnixStat . DEFAULT_FILE_PERM ; private Resource src = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; private int fileMode = DEFAULT_FILE_MODE ; private int dirMode = DEFAULT_DIR_MODE ; private boolean fileModeHasBeenSet = false ; private boolean dirModeHasBeenSet = false ; public ArchiveFileSet ( ) { super ( ) ; } protected ArchiveFileSet ( FileSet fileset ) { super ( fileset ) ; } protected ArchiveFileSet ( ArchiveFileSet fileset ) { super ( fileset ) ; src = fileset . src ; prefix = fileset . prefix ; fullpath = fileset . fullpath ; hasDir = fileset . hasDir ; fileMode = fileset . fileMode ; dirMode = fileset . dirMode ; fileModeHasBeenSet = fileset . fileModeHasBeenSet ; dirModeHasBeenSet = fileset . dirModeHasBeenSet ; } public void setDir ( File dir ) throws BuildException { checkAttributesAllowed ( ) ; if ( src != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void addConfigured ( ResourceCollection a ) { checkChildrenAllowed ( ) ; if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } public void setSrc ( File srcFile ) { setSrcResource ( new FileResource ( srcFile ) ) ; } public void setSrcResource ( Resource src ) { checkArchiveAttributesAllowed ( ) ; if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . src = src ; } public File getSrc ( Project p ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( p ) ) . getSrc ( p ) ; } return getSrc ( ) ; } public File getSrc ( ) { if ( src instanceof FileResource ) { return ( ( FileResource ) src ) . getFile ( ) ; } return null ; } public void setPrefix ( String prefix ) { checkArchiveAttributesAllowed ( ) ; if ( ! prefix . equals ( "" ) && ! fullpath . equals ( "" ) ) { throw new BuildException ( "Cannot set both fullpath and prefix attributes" ) ; } this . prefix = prefix ; } public String getPrefix ( Project p ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( p ) ) . getPrefix ( p ) ; } return prefix ; } public void setFullpath ( String fullpath ) { checkArchiveAttributesAllowed ( ) ; if ( ! prefix . equals ( "" ) && ! fullpath . equals ( "" ) ) { throw new BuildException ( "Cannot set both fullpath and prefix attributes" ) ; } this . fullpath = fullpath ; } public String getFullpath ( Project p ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( p ) ) . getFullpath ( p ) ; } return fullpath ; } protected abstract ArchiveScanner newArchiveScanner ( ) ; public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( src == null ) { return super . getDirectoryScanner ( p ) ; } if ( ! src . isExists ( ) ) { throw new BuildException ( "the archive doesn't exist" ) ; } if ( src . isDirectory ( ) ) { throw new BuildException ( "the archive can't be a directory" ) ; } ArchiveScanner as = newArchiveScanner ( ) ; as . setSrc ( src ) ; super . setDir ( p . getBaseDir ( ) ) ; setupDirectoryScanner ( as , p ) ; as . init ( ) ; return as ; } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( ResourceCollection ) ( getRef ( getProject ( ) ) ) ) . iterator ( ) ; } if ( src == null ) { return super . iterator ( ) ; } ArchiveScanner as = ( ArchiveScanner ) getDirectoryScanner ( getProject ( ) ) ; return as . getResourceFiles ( ) ; } public int size ( ) { if ( isReference ( ) ) { return ( ( ResourceCollection ) ( getRef ( getProject ( ) ) ) ) . size ( ) ; } if ( src == null ) { return super . size ( ) ; } ArchiveScanner as = ( ArchiveScanner ) getDirectoryScanner ( getProject ( ) ) ; return as . getIncludedFilesCount ( ) ; } public boolean isFilesystemOnly ( ) { return src == null ; } public void setFileMode ( String octalString ) { checkArchiveAttributesAllowed ( ) ; integerSetFileMode ( Integer . parseInt ( octalString , BASE_OCTAL ) ) ; } public void integerSetFileMode ( int mode ) { fileModeHasBeenSet = true ; this . fileMode = UnixStat . FILE_FLAG | mode ; } public int getFileMode ( Project p ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( p ) ) . getFileMode ( p ) ; } return fileMode ; } public boolean hasFileModeBeenSet ( ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( getProject ( ) ) ) . hasFileModeBeenSet ( ) ; } return fileModeHasBeenSet ; } public void setDirMode ( String octalString ) { checkArchiveAttributesAllowed ( ) ; integerSetDirMode ( Integer . parseInt ( octalString , BASE_OCTAL ) ) ; } public void integerSetDirMode ( int mode ) { dirModeHasBeenSet = true ; this . dirMode = UnixStat . DIR_FLAG | mode ; } public int getDirMode ( Project p ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( p ) ) . getDirMode ( p ) ; } return dirMode ; } public boolean hasDirModeBeenSet ( ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( getProject ( ) ) ) . hasDirModeBeenSet ( ) ; } return dirModeHasBeenSet ; } protected void configureFileSet ( ArchiveFileSet zfs ) { zfs . setPrefix ( prefix ) ; zfs . setFullpath ( fullpath ) ; zfs . fileModeHasBeenSet = fileModeHasBeenSet ; zfs . fileMode = fileMode ; zfs . dirModeHasBeenSet = dirModeHasBeenSet ; zfs . dirMode = dirMode ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( ArchiveFileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } public String toString ( ) { if ( hasDir && getProject ( ) != null ) { return super . toString ( ) ; } else if ( src != null ) { return src . getName ( ) ; } else { return null ; } } public String getPrefix ( ) { return prefix ; } public String getFullpath ( ) { return fullpath ; } public int getFileMode ( ) { return fileMode ; } public int getDirMode ( ) { return dirMode ; } private void checkArchiveAttributesAllowed ( ) { if ( getProject ( ) == null || ( isReference ( ) && ( getRefid ( ) . getReferencedObject ( getProject ( ) ) instanceof ArchiveFileSet ) ) ) { checkAttributesAllowed ( ) ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . junit ; import java . lang . reflect . Method ; import junit . framework . Test ; import junit . framework . TestCase ; public class JUnitVersionHelper { private static Method testCaseName = null ; static { try { testCaseName = TestCase . class . getMethod ( "getName" , new Class [ 0 ] ) ; } catch ( NoSuchMethodException e ) { try { testCaseName = TestCase . class . getMethod ( "name" , new Class [ 0 ] ) ; } catch ( NoSuchMethodException e2 ) { } } } public static String getTestCaseName ( Test t ) { if ( t != null && t . getClass ( ) . getName ( ) . equals ( "junit.framework.JUnit4TestCaseFacade" ) ) { String name = t . toString ( ) ; if ( name . endsWith ( ")" ) ) { int paren = name . lastIndexOf ( '(' ) ; return name . substring ( 0 , paren ) ; } else { return name ; } } if ( t instanceof TestCase && testCaseName != null ) { try { return ( String ) testCaseName . invoke ( t , new Object [ 0 ] ) ; } catch ( Throwable e ) { } } else { try { Method getNameMethod = null ; try { getNameMethod = t . getClass ( ) . getMethod ( "getName" , new Class [ 0 ] ) ; } catch ( NoSuchMethodException e ) { getNameMethod = t . getClass ( ) . getMethod ( "name" , new Class [ 0 ] ) ; } if ( getNameMethod != null && getNameMethod . getReturnType ( ) == String . class ) { return ( String ) getNameMethod . invoke ( t , new Object [ 0 ] ) ; } } catch ( Throwable e ) { } } return "unknown" ; } static String getTestCaseClassName ( Test test ) { String className = test . getClass ( ) . getName ( ) ; if ( test instanceof JUnitTaskMirrorImpl . VmExitErrorTest ) { className = ( ( JUnitTaskMirrorImpl . VmExitErrorTest ) test ) . getClassName ( ) ; } else if ( className . equals ( "junit.framework.JUnit4TestCaseFacade" ) ) { String name = test . toString ( ) ; int paren = name . lastIndexOf ( '(' ) ; if ( paren != - 1 && name . endsWith ( ")" ) ) { className = name . substring ( paren + 1 , name . length ( ) - 1 ) ; } } return className ; } } 	1
package org . apache . tools . ant ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . lang . reflect . Constructor ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Map ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . jar . Attributes ; import java . util . jar . Attributes . Name ; import java . util . jar . JarFile ; import java . util . jar . Manifest ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . CollectionUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . LoaderUtils ; import org . apache . tools . ant . launch . Locator ; public class AntClassLoader extends ClassLoader implements SubBuildListener { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private class ResourceEnumeration implements Enumeration { private String resourceName ; private int pathElementsIndex ; private URL nextResource ; ResourceEnumeration ( String name ) { this . resourceName = name ; this . pathElementsIndex = 0 ; findNextResource ( ) ; } public boolean hasMoreElements ( ) { return ( this . nextResource != null ) ; } public Object nextElement ( ) { URL ret = this . nextResource ; findNextResource ( ) ; return ret ; } private void findNextResource ( ) { URL url = null ; while ( ( pathElementsIndex < pathComponents . size ( ) ) && ( url == null ) ) { try { File pathComponent = ( File ) pathComponents . elementAt ( pathElementsIndex ) ; url = getResourceURL ( pathComponent , this . resourceName ) ; pathElementsIndex ++ ; } catch ( BuildException e ) { } } this . nextResource = url ; } } private static final int BUFFER_SIZE = 8192 ; private static final int NUMBER_OF_STRINGS = 256 ; private Vector pathComponents = new Vector ( ) ; private Project project ; private boolean parentFirst = true ; private Vector systemPackages = new Vector ( ) ; private Vector loaderPackages = new Vector ( ) ; private boolean ignoreBase = false ; private ClassLoader parent = null ; private Hashtable zipFiles = new Hashtable ( ) ; private static Map pathMap = Collections . synchronizedMap ( new HashMap ( ) ) ; private ClassLoader savedContextLoader = null ; private boolean isContextLoaderSaved = false ; public AntClassLoader ( ClassLoader parent , Project project , Path classpath ) { setParent ( parent ) ; setClassPath ( classpath ) ; setProject ( project ) ; } public AntClassLoader ( ) { setParent ( null ) ; } public AntClassLoader ( Project project , Path classpath ) { setParent ( null ) ; setProject ( project ) ; setClassPath ( classpath ) ; } public AntClassLoader ( ClassLoader parent , Project project , Path classpath , boolean parentFirst ) { this ( project , classpath ) ; if ( parent != null ) { setParent ( parent ) ; } setParentFirst ( parentFirst ) ; addJavaLibraries ( ) ; } public AntClassLoader ( Project project , Path classpath , boolean parentFirst ) { this ( null , project , classpath , parentFirst ) ; } public AntClassLoader ( ClassLoader parent , boolean parentFirst ) { setParent ( parent ) ; project = null ; this . parentFirst = parentFirst ; } public void setProject ( Project project ) { this . project = project ; if ( project != null ) { project . addBuildListener ( this ) ; } } public void setClassPath ( Path classpath ) { pathComponents . removeAllElements ( ) ; if ( classpath != null ) { Path actualClasspath = classpath . concatSystemClasspath ( "ignore" ) ; String [ ] pathElements = actualClasspath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; ++ i ) { try { addPathElement ( pathElements [ i ] ) ; } catch ( BuildException e ) { } } } } public void setParent ( ClassLoader parent ) { if ( parent == null ) { this . parent = AntClassLoader . class . getClassLoader ( ) ; } else { this . parent = parent ; } } public void setParentFirst ( boolean parentFirst ) { this . parentFirst = parentFirst ; } protected void log ( String message , int priority ) { if ( project != null ) { project . log ( message , priority ) ; } } public void setThreadContextLoader ( ) { if ( isContextLoaderSaved ) { throw new BuildException ( "Context loader has not been reset" ) ; } if ( LoaderUtils . isContextLoaderAvailable ( ) ) { savedContextLoader = LoaderUtils . getContextClassLoader ( ) ; ClassLoader loader = this ; if ( project != null && "only" . equals ( project . getProperty ( "build.sysclasspath" ) ) ) { loader = this . getClass ( ) . getClassLoader ( ) ; } LoaderUtils . setContextClassLoader ( loader ) ; isContextLoaderSaved = true ; } } public void resetThreadContextLoader ( ) { if ( LoaderUtils . isContextLoaderAvailable ( ) && isContextLoaderSaved ) { LoaderUtils . setContextClassLoader ( savedContextLoader ) ; savedContextLoader = null ; isContextLoaderSaved = false ; } } public void addPathElement ( String pathElement ) throws BuildException { File pathComponent = project != null ? project . resolveFile ( pathElement ) : new File ( pathElement ) ; try { addPathFile ( pathComponent ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected void addPathFile ( File pathComponent ) throws IOException { pathComponents . addElement ( pathComponent ) ; if ( pathComponent . isDirectory ( ) ) { return ; } String absPathPlusTimeAndLength = pathComponent . getAbsolutePath ( ) + pathComponent . lastModified ( ) + "-" + pathComponent . length ( ) ; String classpath = ( String ) pathMap . get ( absPathPlusTimeAndLength ) ; if ( classpath == null ) { ZipFile jarFile = null ; InputStream manifestStream = null ; try { jarFile = new ZipFile ( pathComponent ) ; manifestStream = jarFile . getInputStream ( new ZipEntry ( "META-INF/MANIFEST.MF" ) ) ; if ( manifestStream == null ) { return ; } Reader manifestReader = new InputStreamReader ( manifestStream , "UTF-8" ) ; org . apache . tools . ant . taskdefs . Manifest manifest = new org . apache . tools . ant . taskdefs . Manifest ( manifestReader ) ; classpath = manifest . getMainSection ( ) . getAttributeValue ( "Class-Path" ) ; } catch ( org . apache . tools . ant . taskdefs . ManifestException e ) { } finally { if ( manifestStream != null ) { manifestStream . close ( ) ; } if ( jarFile != null ) { jarFile . close ( ) ; } } if ( classpath == null ) { classpath = "" ; } pathMap . put ( absPathPlusTimeAndLength , classpath ) ; } if ( ! "" . equals ( classpath ) ) { URL baseURL = FILE_UTILS . getFileURL ( pathComponent ) ; StringTokenizer st = new StringTokenizer ( classpath ) ; while ( st . hasMoreTokens ( ) ) { String classpathElement = st . nextToken ( ) ; URL libraryURL = new URL ( baseURL , classpathElement ) ; if ( ! libraryURL . getProtocol ( ) . equals ( "file" ) ) { log ( "Skipping jar library " + classpathElement + " since only relative URLs are supported by this" + " loader" , Project . MSG_VERBOSE ) ; continue ; } String decodedPath = Locator . decodeUri ( libraryURL . getFile ( ) ) ; File libraryFile = new File ( decodedPath ) ; if ( libraryFile . exists ( ) && ! isInPath ( libraryFile ) ) { addPathFile ( libraryFile ) ; } } } } public String getClasspath ( ) { StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; Enumeration componentEnum = pathComponents . elements ( ) ; while ( componentEnum . hasMoreElements ( ) ) { if ( ! firstPass ) { sb . append ( System . getProperty ( "path.separator" ) ) ; } else { firstPass = false ; } sb . append ( ( ( File ) componentEnum . nextElement ( ) ) . getAbsolutePath ( ) ) ; } return sb . toString ( ) ; } public synchronized void setIsolated ( boolean isolated ) { ignoreBase = isolated ; } public static void initializeClass ( Class theClass ) { final Constructor [ ] cons = theClass . getDeclaredConstructors ( ) ; if ( cons != null ) { if ( cons . length > 0 && cons [ 0 ] != null ) { final String [ ] strs = new String [ NUMBER_OF_STRINGS ] ; try { cons [ 0 ] . newInstance ( ( Object [ ] ) strs ) ; } catch ( Exception e ) { } } } } public void addSystemPackageRoot ( String packageRoot ) { systemPackages . addElement ( packageRoot + ( packageRoot . endsWith ( "." ) ? "" : "." ) ) ; } public void addLoaderPackageRoot ( String packageRoot ) { loaderPackages . addElement ( packageRoot + ( packageRoot . endsWith ( "." ) ? "" : "." ) ) ; } public Class forceLoadClass ( String classname ) throws ClassNotFoundException { log ( "force loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findClass ( classname ) ; } return theClass ; } public Class forceLoadSystemClass ( String classname ) throws ClassNotFoundException { log ( "force system loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findBaseClass ( classname ) ; } return theClass ; } public InputStream getResourceAsStream ( String name ) { InputStream resourceStream = null ; if ( isParentFirst ( name ) ) { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } } if ( resourceStream == null ) { log ( "Couldn't load ResourceStream for " + name , Project . MSG_DEBUG ) ; } return resourceStream ; } private InputStream loadResource ( String name ) { InputStream stream = null ; Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) && stream == null ) { File pathComponent = ( File ) e . nextElement ( ) ; stream = getResourceStream ( pathComponent , name ) ; } return stream ; } private InputStream loadBaseResource ( String name ) { if ( parent == null ) { return getSystemResourceAsStream ( name ) ; } else { return parent . getResourceAsStream ( name ) ; } } private InputStream getResourceStream ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { return new FileInputStream ( resource ) ; } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { return zipFile . getInputStream ( entry ) ; } } } catch ( Exception e ) { log ( "Ignoring Exception " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) + " reading resource " + resourceName + " from " + file , Project . MSG_VERBOSE ) ; } return null ; } private boolean isParentFirst ( String resourceName ) { boolean useParentFirst = parentFirst ; for ( Enumeration e = systemPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = true ; break ; } } for ( Enumeration e = loaderPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = false ; break ; } } return useParentFirst ; } private ClassLoader getRootLoader ( ) { ClassLoader ret = getClass ( ) . getClassLoader ( ) ; while ( ret != null && ret . getParent ( ) != null ) { ret = ret . getParent ( ) ; } return ret ; } public URL getResource ( String name ) { URL url = null ; if ( isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; } if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) && url == null ) { File pathComponent = ( File ) e . nextElement ( ) ; url = getResourceURL ( pathComponent , name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } if ( url == null && ! isParentFirst ( name ) ) { if ( ignoreBase ) { url = ( getRootLoader ( ) == null ) ? null : getRootLoader ( ) . getResource ( name ) ; } else { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; } if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( url == null ) { log ( "Couldn't load Resource " + name , Project . MSG_DEBUG ) ; } return url ; } protected Enumeration findResources ( String name ) throws IOException { Enumeration mine = new ResourceEnumeration ( name ) ; Enumeration base ; if ( parent != null && parent != getParent ( ) ) { base = parent . getResources ( name ) ; } else { base = new CollectionUtils . EmptyEnumeration ( ) ; } if ( isParentFirst ( name ) ) { return CollectionUtils . append ( base , mine ) ; } else if ( ignoreBase ) { return getRootLoader ( ) == null ? mine : CollectionUtils . append ( mine , getRootLoader ( ) . getResources ( name ) ) ; } else { return CollectionUtils . append ( mine , base ) ; } } protected URL getResourceURL ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { try { return FILE_UTILS . getFileURL ( resource ) ; } catch ( MalformedURLException ex ) { return null ; } } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { try { return new URL ( "jar:" + FILE_UTILS . getFileURL ( file ) + "!/" + entry ) ; } catch ( MalformedURLException ex ) { return null ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } protected synchronized Class loadClass ( String classname , boolean resolve ) throws ClassNotFoundException { Class theClass = findLoadedClass ( classname ) ; if ( theClass != null ) { return theClass ; } if ( isParentFirst ( classname ) ) { try { theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader " + "(parentFirst)" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader " + "(parentFirst)" , Project . MSG_DEBUG ) ; } } else { try { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { if ( ignoreBase ) { throw cnfe ; } theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( resolve ) { resolveClass ( theClass ) ; } return theClass ; } private String getClassFilename ( String classname ) { return classname . replace ( '.' , '/' ) + ".class" ; } protected Class defineClassFromData ( File container , byte [ ] classData , String classname ) throws IOException { definePackage ( container , classname ) ; return defineClass ( classname , classData , 0 , classData . length , Project . class . getProtectionDomain ( ) ) ; } protected void definePackage ( File container , String className ) throws IOException { int classIndex = className . lastIndexOf ( '.' ) ; if ( classIndex == - 1 ) { return ; } String packageName = className . substring ( 0 , classIndex ) ; if ( getPackage ( packageName ) != null ) { return ; } Manifest manifest = getJarManifest ( container ) ; if ( manifest == null ) { definePackage ( packageName , null , null , null , null , null , null , null ) ; } else { definePackage ( container , packageName , manifest ) ; } } private Manifest getJarManifest ( File container ) throws IOException { if ( container . isDirectory ( ) ) { return null ; } JarFile jarFile = null ; try { jarFile = new JarFile ( container ) ; return jarFile . getManifest ( ) ; } finally { if ( jarFile != null ) { jarFile . close ( ) ; } } } protected void definePackage ( File container , String packageName , Manifest manifest ) { String sectionName = packageName . replace ( '.' , '/' ) + "/" ; String specificationTitle = null ; String specificationVendor = null ; String specificationVersion = null ; String implementationTitle = null ; String implementationVendor = null ; String implementationVersion = null ; String sealedString = null ; URL sealBase = null ; Attributes sectionAttributes = manifest . getAttributes ( sectionName ) ; if ( sectionAttributes != null ) { specificationTitle = sectionAttributes . getValue ( Name . SPECIFICATION_TITLE ) ; specificationVendor = sectionAttributes . getValue ( Name . SPECIFICATION_VENDOR ) ; specificationVersion = sectionAttributes . getValue ( Name . SPECIFICATION_VERSION ) ; implementationTitle = sectionAttributes . getValue ( Name . IMPLEMENTATION_TITLE ) ; implementationVendor = sectionAttributes . getValue ( Name . IMPLEMENTATION_VENDOR ) ; implementationVersion = sectionAttributes . getValue ( Name . IMPLEMENTATION_VERSION ) ; sealedString = sectionAttributes . getValue ( Name . SEALED ) ; } Attributes mainAttributes = manifest . getMainAttributes ( ) ; if ( mainAttributes != null ) { if ( specificationTitle == null ) { specificationTitle = mainAttributes . getValue ( Name . SPECIFICATION_TITLE ) ; } if ( specificationVendor == null ) { specificationVendor = mainAttributes . getValue ( Name . SPECIFICATION_VENDOR ) ; } if ( specificationVersion == null ) { specificationVersion = mainAttributes . getValue ( Name . SPECIFICATION_VERSION ) ; } if ( implementationTitle == null ) { implementationTitle = mainAttributes . getValue ( Name . IMPLEMENTATION_TITLE ) ; } if ( implementationVendor == null ) { implementationVendor = mainAttributes . getValue ( Name . IMPLEMENTATION_VENDOR ) ; } if ( implementationVersion == null ) { implementationVersion = mainAttributes . getValue ( Name . IMPLEMENTATION_VERSION ) ; } if ( sealedString == null ) { sealedString = mainAttributes . getValue ( Name . SEALED ) ; } } if ( sealedString != null && sealedString . equalsIgnoreCase ( "true" ) ) { try { sealBase = new URL ( FileUtils . getFileUtils ( ) . toURI ( container . getAbsolutePath ( ) ) ) ; } catch ( MalformedURLException e ) { } } definePackage ( packageName , specificationTitle , specificationVersion , specificationVendor , implementationTitle , implementationVersion , implementationVendor , sealBase ) ; } private Class getClassFromStream ( InputStream stream , String classname , File container ) throws IOException , SecurityException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; int bytesRead = - 1 ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; while ( ( bytesRead = stream . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { baos . write ( buffer , 0 , bytesRead ) ; } byte [ ] classData = baos . toByteArray ( ) ; return defineClassFromData ( container , classData , classname ) ; } public Class findClass ( String name ) throws ClassNotFoundException { log ( "Finding class " + name , Project . MSG_DEBUG ) ; return findClassInComponents ( name ) ; } protected boolean isInPath ( File component ) { for ( Enumeration e = pathComponents . elements ( ) ; e . hasMoreElements ( ) ; ) { File pathComponent = ( File ) e . nextElement ( ) ; if ( pathComponent . equals ( component ) ) { return true ; } } return false ; } private Class findClassInComponents ( String name ) throws ClassNotFoundException { InputStream stream = null ; String classFilename = getClassFilename ( name ) ; try { Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) ) { File pathComponent = ( File ) e . nextElement ( ) ; try { stream = getResourceStream ( pathComponent , classFilename ) ; if ( stream != null ) { log ( "Loaded from " + pathComponent + " " + classFilename , Project . MSG_DEBUG ) ; return getClassFromStream ( stream , name , pathComponent ) ; } } catch ( SecurityException se ) { throw se ; } catch ( IOException ioe ) { log ( "Exception reading component " + pathComponent + " (reason: " + ioe . getMessage ( ) + ")" , Project . MSG_VERBOSE ) ; } } throw new ClassNotFoundException ( name ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } } private Class findBaseClass ( String name ) throws ClassNotFoundException { if ( parent == null ) { return findSystemClass ( name ) ; } else { return parent . loadClass ( name ) ; } } public synchronized void cleanup ( ) { for ( Enumeration e = zipFiles . elements ( ) ; e . hasMoreElements ( ) ; ) { ZipFile zipFile = ( ZipFile ) e . nextElement ( ) ; try { zipFile . close ( ) ; } catch ( IOException ioe ) { } } zipFiles = new Hashtable ( ) ; if ( project != null ) { project . removeBuildListener ( this ) ; } project = null ; } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { cleanup ( ) ; } public void subBuildFinished ( BuildEvent event ) { if ( event . getProject ( ) == project ) { cleanup ( ) ; } } public void subBuildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } public void addJavaLibraries ( ) { Vector packages = JavaEnvUtils . getJrePackages ( ) ; Enumeration e = packages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String packageName = ( String ) e . nextElement ( ) ; addSystemPackageRoot ( packageName ) ; } } public String toString ( ) { return "AntClassLoader[" + getClasspath ( ) + "]" ; } } 	1
package org . apache . tools . ant . taskdefs . optional . windows ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . ExecuteOn ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileSet ; import java . io . File ; public class Attrib extends ExecuteOn { private static final String ATTR_READONLY = "R" ; private static final String ATTR_ARCHIVE = "A" ; private static final String ATTR_SYSTEM = "S" ; private static final String ATTR_HIDDEN = "H" ; private static final String SET = "+" ; private static final String UNSET = "-" ; private boolean haveAttr = false ; public Attrib ( ) { super . setExecutable ( "attrib" ) ; super . setParallel ( false ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setFile ( src ) ; addFileset ( fs ) ; } public void setReadonly ( boolean value ) { addArg ( value , ATTR_READONLY ) ; } public void setArchive ( boolean value ) { addArg ( value , ATTR_ARCHIVE ) ; } public void setSystem ( boolean value ) { addArg ( value , ATTR_SYSTEM ) ; } public void setHidden ( boolean value ) { addArg ( value , ATTR_HIDDEN ) ; } protected void checkConfiguration ( ) { if ( ! haveAttr ( ) ) { throw new BuildException ( "Missing attribute parameter" , getLocation ( ) ) ; } super . checkConfiguration ( ) ; } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable attribute" , getLocation ( ) ) ; } public void setCommand ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the command attribute" , getLocation ( ) ) ; } public void setAddsourcefile ( boolean b ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the addsourcefile attribute" , getLocation ( ) ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the " + "skipemptyfileset attribute" , getLocation ( ) ) ; } public void setParallel ( boolean parallel ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the parallel attribute" , getLocation ( ) ) ; } public void setMaxParallel ( int max ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the maxparallel attribute" , getLocation ( ) ) ; } protected boolean isValidOs ( ) { return Os . isFamily ( "windows" ) && super . isValidOs ( ) ; } private static String getSignString ( boolean attr ) { return ( attr ? SET : UNSET ) ; } private void addArg ( boolean sign , String attribute ) { createArg ( ) . setValue ( getSignString ( sign ) + attribute ) ; haveAttr = true ; } private boolean haveAttr ( ) { return haveAttr ; } } 	1
package org . apache . tools . ant . taskdefs . optional . ssh ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . TeeOutputStream ; import org . apache . tools . ant . util . KeepAliveOutputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . StringReader ; import com . jcraft . jsch . ChannelExec ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; public class SSHExec extends SSHBase { private String command = null ; private long maxwait = 0 ; private Thread thread = null ; private String outputProperty = null ; private File outputFile = null ; private boolean append = false ; private static final String TIMEOUT_MESSAGE = "Timeout period exceeded, connection dropped." ; public SSHExec ( ) { super ( ) ; } public void setCommand ( String command ) { this . command = command ; } public void setTimeout ( long timeout ) { maxwait = timeout ; } public void setOutput ( File output ) { outputFile = output ; } public void setAppend ( boolean append ) { this . append = append ; } public void setOutputproperty ( String property ) { outputProperty = property ; } public void execute ( ) throws BuildException { if ( getHost ( ) == null ) { throw new BuildException ( "Host is required." ) ; } if ( getUserInfo ( ) . getName ( ) == null ) { throw new BuildException ( "Username is required." ) ; } if ( getUserInfo ( ) . getKeyfile ( ) == null && getUserInfo ( ) . getPassword ( ) == null ) { throw new BuildException ( "Password or Keyfile is required." ) ; } if ( command == null ) { throw new BuildException ( "Command is required." ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; TeeOutputStream tee = new TeeOutputStream ( out , new KeepAliveOutputStream ( System . out ) ) ; Session session = null ; try { session = openSession ( ) ; session . setTimeout ( ( int ) maxwait ) ; final ChannelExec channel = ( ChannelExec ) session . openChannel ( "exec" ) ; channel . setCommand ( command ) ; channel . setOutputStream ( tee ) ; channel . setExtOutputStream ( tee ) ; channel . connect ( ) ; thread = new Thread ( ) { public void run ( ) { while ( ! channel . isEOF ( ) ) { if ( thread == null ) { return ; } try { sleep ( 500 ) ; } catch ( Exception e ) { } } } } ; thread . start ( ) ; thread . join ( maxwait ) ; if ( thread . isAlive ( ) ) { thread = null ; if ( getFailonerror ( ) ) { throw new BuildException ( TIMEOUT_MESSAGE ) ; } else { log ( TIMEOUT_MESSAGE , Project . MSG_ERR ) ; } } else { if ( outputProperty != null ) { getProject ( ) . setProperty ( outputProperty , out . toString ( ) ) ; } if ( outputFile != null ) { writeToFile ( out . toString ( ) , append , outputFile ) ; } int ec = channel . getExitStatus ( ) ; if ( ec != 0 ) { String msg = "Remote command failed with exit status " + ec ; if ( getFailonerror ( ) ) { throw new BuildException ( msg ) ; } else { log ( msg , Project . MSG_ERR ) ; } } } } catch ( BuildException e ) { throw e ; } catch ( JSchException e ) { if ( e . getMessage ( ) . indexOf ( "session is down" ) >= 0 ) { if ( getFailonerror ( ) ) { throw new BuildException ( TIMEOUT_MESSAGE , e ) ; } else { log ( TIMEOUT_MESSAGE , Project . MSG_ERR ) ; } } else { if ( getFailonerror ( ) ) { throw new BuildException ( e ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_ERR ) ; } } } catch ( Exception e ) { if ( getFailonerror ( ) ) { throw new BuildException ( e ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_ERR ) ; } } finally { if ( session != null && session . isConnected ( ) ) { session . disconnect ( ) ; } } } private void writeToFile ( String from , boolean append , File to ) throws IOException { FileWriter out = null ; try { out = new FileWriter ( to . getAbsolutePath ( ) , append ) ; StringReader in = new StringReader ( from ) ; char [ ] buffer = new char [ 8192 ] ; int bytesRead ; while ( true ) { bytesRead = in . read ( buffer ) ; if ( bytesRead == - 1 ) { break ; } out . write ( buffer , 0 , bytesRead ) ; } out . flush ( ) ; } finally { if ( out != null ) { out . close ( ) ; } } } } 	1
package org . apache . tools . zip ; import java . util . Vector ; import java . util . zip . ZipException ; public class ZipEntry extends java . util . zip . ZipEntry implements Cloneable { private static final int PLATFORM_UNIX = 3 ; private static final int PLATFORM_FAT = 0 ; private int internalAttributes = 0 ; private int platform = PLATFORM_FAT ; private long externalAttributes = 0 ; private Vector extraFields = null ; private String name = null ; public ZipEntry ( String name ) { super ( name ) ; } public ZipEntry ( java . util . zip . ZipEntry entry ) throws ZipException { super ( entry ) ; byte [ ] extra = entry . getExtra ( ) ; if ( extra != null ) { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } else { setExtra ( ) ; } } public ZipEntry ( ZipEntry entry ) throws ZipException { this ( ( java . util . zip . ZipEntry ) entry ) ; setInternalAttributes ( entry . getInternalAttributes ( ) ) ; setExternalAttributes ( entry . getExternalAttributes ( ) ) ; setExtraFields ( entry . getExtraFields ( ) ) ; } protected ZipEntry ( ) { super ( "" ) ; } public Object clone ( ) { ZipEntry e = ( ZipEntry ) super . clone ( ) ; e . extraFields = extraFields != null ? ( Vector ) extraFields . clone ( ) : null ; e . setInternalAttributes ( getInternalAttributes ( ) ) ; e . setExternalAttributes ( getExternalAttributes ( ) ) ; e . setExtraFields ( getExtraFields ( ) ) ; return e ; } public int getInternalAttributes ( ) { return internalAttributes ; } public void setInternalAttributes ( int value ) { internalAttributes = value ; } public long getExternalAttributes ( ) { return externalAttributes ; } public void setExternalAttributes ( long value ) { externalAttributes = value ; } public void setUnixMode ( int mode ) { setExternalAttributes ( ( mode << 16 ) | ( ( mode & 0200 ) == 0 ? 1 : 0 ) | ( isDirectory ( ) ? 0x10 : 0 ) ) ; platform = PLATFORM_UNIX ; } public int getUnixMode ( ) { return ( int ) ( ( getExternalAttributes ( ) > > 16 ) & 0xFFFF ) ; } public int getPlatform ( ) { return platform ; } protected void setPlatform ( int platform ) { this . platform = platform ; } public void setExtraFields ( ZipExtraField [ ] fields ) { extraFields = new Vector ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { extraFields . addElement ( fields [ i ] ) ; } setExtra ( ) ; } public ZipExtraField [ ] getExtraFields ( ) { if ( extraFields == null ) { return new ZipExtraField [ 0 ] ; } ZipExtraField [ ] result = new ZipExtraField [ extraFields . size ( ) ] ; extraFields . copyInto ( result ) ; return result ; } public void addExtraField ( ZipExtraField ze ) { if ( extraFields == null ) { extraFields = new Vector ( ) ; } ZipShort type = ze . getHeaderId ( ) ; boolean done = false ; for ( int i = 0 , fieldsSize = extraFields . size ( ) ; ! done && i < fieldsSize ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . setElementAt ( ze , i ) ; done = true ; } } if ( ! done ) { extraFields . addElement ( ze ) ; } setExtra ( ) ; } public void removeExtraField ( ZipShort type ) { if ( extraFields == null ) { extraFields = new Vector ( ) ; } boolean done = false ; for ( int i = 0 , fieldsSize = extraFields . size ( ) ; ! done && i < fieldsSize ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . removeElementAt ( i ) ; done = true ; } } if ( ! done ) { throw new java . util . NoSuchElementException ( ) ; } setExtra ( ) ; } public void setExtra ( byte [ ] extra ) throws RuntimeException { try { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } protected void setExtra ( ) { super . setExtra ( ExtraFieldUtils . mergeLocalFileDataData ( getExtraFields ( ) ) ) ; } public byte [ ] getLocalFileDataExtra ( ) { byte [ ] extra = getExtra ( ) ; return extra != null ? extra : new byte [ 0 ] ; } public byte [ ] getCentralDirectoryExtra ( ) { return ExtraFieldUtils . mergeCentralDirectoryData ( getExtraFields ( ) ) ; } public void setComprSize ( long size ) { setCompressedSize ( size ) ; } public String getName ( ) { return name == null ? super . getName ( ) : name ; } public boolean isDirectory ( ) { return getName ( ) . endsWith ( "/" ) ; } protected void setName ( String name ) { this . name = name ; } public int hashCode ( ) { return getName ( ) . hashCode ( ) ; } public boolean equals ( Object o ) { return ( this == o ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . JavaResource ; import org . apache . tools . ant . util . FileUtils ; public class LoadProperties extends Task { private Resource src = null ; private final Vector filterChains = new Vector ( ) ; private String encoding = null ; public final void setSrcFile ( final File srcFile ) { addConfigured ( new FileResource ( srcFile ) ) ; } public void setResource ( String resource ) { assertSrcIsJavaResource ( ) ; ( ( JavaResource ) src ) . setName ( resource ) ; } public final void setEncoding ( final String encoding ) { this . encoding = encoding ; } public void setClasspath ( Path classpath ) { assertSrcIsJavaResource ( ) ; ( ( JavaResource ) src ) . setClasspath ( classpath ) ; } public Path createClasspath ( ) { assertSrcIsJavaResource ( ) ; return ( ( JavaResource ) src ) . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { assertSrcIsJavaResource ( ) ; ( ( JavaResource ) src ) . setClasspathRef ( r ) ; } public Path getClasspath ( ) { assertSrcIsJavaResource ( ) ; return ( ( JavaResource ) src ) . getClasspath ( ) ; } public final void execute ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "A source resource is required." ) ; } if ( ! src . isExists ( ) ) { if ( src instanceof JavaResource ) { log ( "Unable to find resource " + src , Project . MSG_WARN ) ; return ; } throw new BuildException ( "Source resource does not exist: " + src ) ; } BufferedInputStream bis = null ; Reader instream = null ; ByteArrayInputStream tis = null ; try { bis = new BufferedInputStream ( src . getInputStream ( ) ) ; if ( encoding == null ) { instream = new InputStreamReader ( bis ) ; } else { instream = new InputStreamReader ( bis , encoding ) ; } ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setPrimaryReader ( instream ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( getProject ( ) ) ; instream = crh . getAssembledReader ( ) ; String text = crh . readFully ( instream ) ; if ( text != null ) { if ( ! text . endsWith ( "\n" ) ) { text = text + "\n" ; } if ( encoding == null ) { tis = new ByteArrayInputStream ( text . getBytes ( ) ) ; } else { tis = new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } final Properties props = new Properties ( ) ; props . load ( tis ) ; Property propertyTask = new Property ( ) ; propertyTask . bindToOwner ( this ) ; propertyTask . addProperties ( props ) ; } } catch ( final IOException ioe ) { final String message = "Unable to load file: " + ioe . toString ( ) ; throw new BuildException ( message , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( bis ) ; FileUtils . close ( tis ) ; } } public final void addFilterChain ( FilterChain filter ) { filterChains . addElement ( filter ) ; } public void addConfigured ( ResourceCollection a ) { if ( src != null ) { throw new BuildException ( "only a single source is supported" ) ; } if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported" ) ; } src = ( Resource ) a . iterator ( ) . next ( ) ; } private void assertSrcIsJavaResource ( ) { if ( src == null ) { src = new JavaResource ( ) ; src . setProject ( getProject ( ) ) ; } else if ( ! ( src instanceof JavaResource ) ) { throw new BuildException ( "expected a java resource as source" ) ; } } } 	1
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileReader ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . InputStreamReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . types . Substitution ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . regexp . Regexp ; public class ReplaceRegExp extends Task { private File file ; private String flags ; private boolean byline ; private Vector filesets ; private RegularExpression regex ; private Substitution subs ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String encoding = null ; public ReplaceRegExp ( ) { super ( ) ; this . file = null ; this . filesets = new Vector ( ) ; this . flags = "" ; this . byline = false ; this . regex = null ; this . subs = null ; } public void setFile ( File file ) { this . file = file ; } public void setMatch ( String match ) { if ( regex != null ) { throw new BuildException ( "Only one regular expression is allowed" ) ; } regex = new RegularExpression ( ) ; regex . setPattern ( match ) ; } public void setReplace ( String replace ) { if ( subs != null ) { throw new BuildException ( "Only one substitution expression is " + "allowed" ) ; } subs = new Substitution ( ) ; subs . setExpression ( replace ) ; } public void setFlags ( String flags ) { this . flags = flags ; } public void setByLine ( String byline ) { Boolean res = Boolean . valueOf ( byline ) ; if ( res == null ) { res = Boolean . FALSE ; } this . byline = res . booleanValue ( ) ; } public void setByLine ( boolean byline ) { this . byline = byline ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public RegularExpression createRegexp ( ) { if ( regex != null ) { throw new BuildException ( "Only one regular expression is allowed." ) ; } regex = new RegularExpression ( ) ; return regex ; } public Substitution createSubstitution ( ) { if ( subs != null ) { throw new BuildException ( "Only one substitution expression is " + "allowed" ) ; } subs = new Substitution ( ) ; return subs ; } protected String doReplace ( RegularExpression r , Substitution s , String input , int options ) { String res = input ; Regexp regexp = r . getRegexp ( getProject ( ) ) ; if ( regexp . matches ( input , options ) ) { log ( "Found match; substituting" , Project . MSG_DEBUG ) ; res = regexp . substitute ( input , s . getExpression ( getProject ( ) ) , options ) ; } return res ; } protected void doReplace ( File f , int options ) throws IOException { File temp = FILE_UTILS . createTempFile ( "replace" , ".txt" , null ) ; temp . deleteOnExit ( ) ; Reader r = null ; Writer w = null ; try { if ( encoding == null ) { r = new FileReader ( f ) ; w = new FileWriter ( temp ) ; } else { r = new InputStreamReader ( new FileInputStream ( f ) , encoding ) ; w = new OutputStreamWriter ( new FileOutputStream ( temp ) , encoding ) ; } BufferedReader br = new BufferedReader ( r ) ; BufferedWriter bw = new BufferedWriter ( w ) ; PrintWriter pw = new PrintWriter ( bw ) ; boolean changes = false ; log ( "Replacing pattern '" + regex . getPattern ( getProject ( ) ) + "' with '" + subs . getExpression ( getProject ( ) ) + "' in '" + f . getPath ( ) + "'" + ( byline ? " by line" : "" ) + ( flags . length ( ) > 0 ? " with flags: '" + flags + "'" : "" ) + "." , Project . MSG_VERBOSE ) ; if ( byline ) { StringBuffer linebuf = new StringBuffer ( ) ; String line = null ; String res = null ; int c ; boolean hasCR = false ; do { c = br . read ( ) ; if ( c == '\r' ) { if ( hasCR ) { line = linebuf . toString ( ) ; res = doReplace ( regex , subs , line , options ) ; if ( ! res . equals ( line ) ) { changes = true ; } pw . print ( res ) ; pw . print ( '\r' ) ; linebuf = new StringBuffer ( ) ; } else { hasCR = true ; } } else if ( c == '\n' ) { line = linebuf . toString ( ) ; res = doReplace ( regex , subs , line , options ) ; if ( ! res . equals ( line ) ) { changes = true ; } pw . print ( res ) ; if ( hasCR ) { pw . print ( '\r' ) ; hasCR = false ; } pw . print ( '\n' ) ; linebuf = new StringBuffer ( ) ; } else { if ( ( hasCR ) || ( c < 0 ) ) { line = linebuf . toString ( ) ; res = doReplace ( regex , subs , line , options ) ; if ( ! res . equals ( line ) ) { changes = true ; } pw . print ( res ) ; if ( hasCR ) { pw . print ( '\r' ) ; hasCR = false ; } linebuf = new StringBuffer ( ) ; } if ( c >= 0 ) { linebuf . append ( ( char ) c ) ; } } } while ( c >= 0 ) ; pw . flush ( ) ; } else { String buf = FileUtils . readFully ( br ) ; if ( buf == null ) { buf = "" ; } String res = doReplace ( regex , subs , buf , options ) ; if ( ! res . equals ( buf ) ) { changes = true ; } pw . print ( res ) ; pw . flush ( ) ; } r . close ( ) ; r = null ; w . close ( ) ; w = null ; if ( changes ) { log ( "File has changed; saving the updated file" , Project . MSG_VERBOSE ) ; try { FILE_UTILS . rename ( temp , f ) ; temp = null ; } catch ( IOException e ) { throw new BuildException ( "Couldn't rename temporary file " + temp , getLocation ( ) ) ; } } else { log ( "No change made" , Project . MSG_DEBUG ) ; } } finally { FileUtils . close ( r ) ; FileUtils . close ( w ) ; if ( temp != null ) { temp . delete ( ) ; } } } public void execute ( ) throws BuildException { if ( regex == null ) { throw new BuildException ( "No expression to match." ) ; } if ( subs == null ) { throw new BuildException ( "Nothing to replace expression with." ) ; } if ( file != null && filesets . size ( ) > 0 ) { throw new BuildException ( "You cannot supply the 'file' attribute " + "and filesets at the same time." ) ; } int options = 0 ; if ( flags . indexOf ( 'g' ) != - 1 ) { options |= Regexp . REPLACE_ALL ; } if ( flags . indexOf ( 'i' ) != - 1 ) { options |= Regexp . MATCH_CASE_INSENSITIVE ; } if ( flags . indexOf ( 'm' ) != - 1 ) { options |= Regexp . MATCH_MULTILINE ; } if ( flags . indexOf ( 's' ) != - 1 ) { options |= Regexp . MATCH_SINGLELINE ; } if ( file != null && file . exists ( ) ) { try { doReplace ( file , options ) ; } catch ( IOException e ) { log ( "An error occurred processing file: '" + file . getAbsolutePath ( ) + "': " + e . toString ( ) , Project . MSG_ERR ) ; } } else if ( file != null ) { log ( "The following file is missing: '" + file . getAbsolutePath ( ) + "'" , Project . MSG_ERR ) ; } int sz = filesets . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { FileSet fs = ( FileSet ) ( filesets . elementAt ( i ) ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( fs . getDir ( getProject ( ) ) , files [ j ] ) ; if ( f . exists ( ) ) { try { doReplace ( f , options ) ; } catch ( Exception e ) { log ( "An error occurred processing file: '" + f . getAbsolutePath ( ) + "': " + e . toString ( ) , Project . MSG_ERR ) ; } } else { log ( "The following file is missing: '" + f . getAbsolutePath ( ) + "'" , Project . MSG_ERR ) ; } } } } } 	1
package org . apache . tools . ant . taskdefs . email ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . DateUtils ; public abstract class Mailer { protected String host = null ; protected int port = - 1 ; protected String user = null ; protected String password = null ; protected boolean SSL = false ; protected Message message ; protected EmailAddress from ; protected Vector replyToList = null ; protected Vector toList = null ; protected Vector ccList = null ; protected Vector bccList = null ; protected Vector files = null ; protected String subject = null ; protected Task task ; protected boolean includeFileNames = false ; protected Vector headers = null ; public void setHost ( String host ) { this . host = host ; } public void setPort ( int port ) { this . port = port ; } public void setUser ( String user ) { this . user = user ; } public void setPassword ( String password ) { this . password = password ; } public void setSSL ( boolean ssl ) { this . SSL = ssl ; } public void setMessage ( Message m ) { this . message = m ; } public void setFrom ( EmailAddress from ) { this . from = from ; } public void setReplyToList ( Vector list ) { this . replyToList = list ; } public void setToList ( Vector list ) { this . toList = list ; } public void setCcList ( Vector list ) { this . ccList = list ; } public void setBccList ( Vector list ) { this . bccList = list ; } public void setFiles ( Vector files ) { this . files = files ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setTask ( Task task ) { this . task = task ; } public void setIncludeFileNames ( boolean b ) { this . includeFileNames = b ; } public void setHeaders ( Vector v ) { this . headers = v ; } public abstract void send ( ) throws BuildException ; protected final String getDate ( ) { return DateUtils . getDateForHeader ( ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; public abstract class Pack extends Task { protected File zipFile ; protected File source ; private Resource src ; public void setZipfile ( File zipFile ) { this . zipFile = zipFile ; } public void setDestfile ( File zipFile ) { setZipfile ( zipFile ) ; } public void setSrc ( File src ) { setSrcResource ( new FileResource ( src ) ) ; } public void setSrcResource ( Resource src ) { if ( src . isDirectory ( ) ) { throw new BuildException ( "the source can't be a directory" ) ; } if ( src instanceof FileResource ) { source = ( ( FileResource ) src ) . getFile ( ) ; } else if ( ! supportsNonFileResources ( ) ) { throw new BuildException ( "Only FileSystem resources are" + " supported." ) ; } this . src = src ; } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } private void validate ( ) throws BuildException { if ( zipFile == null ) { throw new BuildException ( "zipfile attribute is required" , getLocation ( ) ) ; } if ( zipFile . isDirectory ( ) ) { throw new BuildException ( "zipfile attribute must not " + "represent a directory!" , getLocation ( ) ) ; } if ( getSrcResource ( ) == null ) { throw new BuildException ( "src attribute or nested resource is" + " required" , getLocation ( ) ) ; } } public void execute ( ) throws BuildException { validate ( ) ; Resource s = getSrcResource ( ) ; if ( ! s . isExists ( ) ) { log ( "Nothing to do: " + s . toString ( ) + " doesn't exist." ) ; } else if ( zipFile . lastModified ( ) < s . getLastModified ( ) ) { log ( "Building: " + zipFile . getAbsolutePath ( ) ) ; pack ( ) ; } else { log ( "Nothing to do: " + zipFile . getAbsolutePath ( ) + " is up to date." ) ; } } private void zipFile ( InputStream in , OutputStream zOut ) throws IOException { byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { zOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } protected void zipFile ( File file , OutputStream zOut ) throws IOException { zipResource ( new FileResource ( file ) , zOut ) ; } protected void zipResource ( Resource resource , OutputStream zOut ) throws IOException { InputStream rIn = resource . getInputStream ( ) ; try { zipFile ( rIn , zOut ) ; } finally { rIn . close ( ) ; } } protected abstract void pack ( ) ; public Resource getSrcResource ( ) { return src ; } protected boolean supportsNonFileResources ( ) { return false ; } } 	1
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . Vector ; import java . util . Iterator ; import java . util . Collections ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . AbstractSelectorContainer ; public class Files extends AbstractSelectorContainer implements Cloneable , ResourceCollection { private static final Iterator EMPTY_ITERATOR = Collections . EMPTY_SET . iterator ( ) ; private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private Vector selectors = new Vector ( ) ; private boolean useDefaultExcludes = true ; private boolean caseSensitive = true ; private boolean followSymlinks = true ; private DirectoryScanner ds = null ; public Files ( ) { super ( ) ; } protected Files ( Files f ) { this . defaultPatterns = f . defaultPatterns ; this . additionalPatterns = f . additionalPatterns ; this . selectors = f . selectors ; this . useDefaultExcludes = f . useDefaultExcludes ; this . caseSensitive = f . caseSensitive ; this . followSymlinks = f . followSymlinks ; this . ds = f . ds ; setProject ( f . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( hasPatterns ( defaultPatterns ) ) { throw tooManyAttributes ( ) ; } if ( ! additionalPatterns . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } if ( ! selectors . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } public synchronized PatternSet createPatternSet ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PatternSet patterns = new PatternSet ( ) ; additionalPatterns . addElement ( patterns ) ; ds = null ; return patterns ; } public synchronized PatternSet . NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } ds = null ; return defaultPatterns . createInclude ( ) ; } public synchronized PatternSet . NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } ds = null ; return defaultPatterns . createIncludesFile ( ) ; } public synchronized PatternSet . NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } ds = null ; return defaultPatterns . createExclude ( ) ; } public synchronized PatternSet . NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } ds = null ; return defaultPatterns . createExcludesFile ( ) ; } public synchronized void setIncludes ( String includes ) { checkAttributesAllowed ( ) ; defaultPatterns . setIncludes ( includes ) ; ds = null ; } public synchronized void appendIncludes ( String [ ] includes ) { checkAttributesAllowed ( ) ; if ( includes != null ) { for ( int i = 0 ; i < includes . length ; i ++ ) { defaultPatterns . createInclude ( ) . setName ( includes [ i ] ) ; } ds = null ; } } public synchronized void setExcludes ( String excludes ) { checkAttributesAllowed ( ) ; defaultPatterns . setExcludes ( excludes ) ; ds = null ; } public synchronized void appendExcludes ( String [ ] excludes ) { checkAttributesAllowed ( ) ; if ( excludes != null ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { defaultPatterns . createExclude ( ) . setName ( excludes [ i ] ) ; } ds = null ; } } public synchronized void setIncludesfile ( File incl ) throws BuildException { checkAttributesAllowed ( ) ; defaultPatterns . setIncludesfile ( incl ) ; ds = null ; } public synchronized void setExcludesfile ( File excl ) throws BuildException { checkAttributesAllowed ( ) ; defaultPatterns . setExcludesfile ( excl ) ; ds = null ; } public synchronized void setDefaultexcludes ( boolean useDefaultExcludes ) { checkAttributesAllowed ( ) ; this . useDefaultExcludes = useDefaultExcludes ; ds = null ; } public synchronized boolean getDefaultexcludes ( ) { return ( isReference ( ) ) ? getRef ( ) . getDefaultexcludes ( ) : useDefaultExcludes ; } public synchronized void setCaseSensitive ( boolean caseSensitive ) { checkAttributesAllowed ( ) ; this . caseSensitive = caseSensitive ; ds = null ; } public synchronized boolean isCaseSensitive ( ) { return ( isReference ( ) ) ? getRef ( ) . isCaseSensitive ( ) : caseSensitive ; } public synchronized void setFollowSymlinks ( boolean followSymlinks ) { checkAttributesAllowed ( ) ; this . followSymlinks = followSymlinks ; ds = null ; } public synchronized boolean isFollowSymlinks ( ) { return ( isReference ( ) ) ? getRef ( ) . isFollowSymlinks ( ) : followSymlinks ; } public synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return getRef ( ) . iterator ( ) ; } ensureDirectoryScannerSetup ( ) ; ds . scan ( ) ; int fct = ds . getIncludedFilesCount ( ) ; int dct = ds . getIncludedDirsCount ( ) ; if ( fct + dct == 0 ) { return EMPTY_ITERATOR ; } FileResourceIterator result = new FileResourceIterator ( ) ; if ( fct > 0 ) { result . addFiles ( ds . getIncludedFiles ( ) ) ; } if ( dct > 0 ) { result . addFiles ( ds . getIncludedDirectories ( ) ) ; } return result ; } public synchronized int size ( ) { if ( isReference ( ) ) { return getRef ( ) . size ( ) ; } ensureDirectoryScannerSetup ( ) ; ds . scan ( ) ; return ds . getIncludedFilesCount ( ) + ds . getIncludedDirsCount ( ) ; } public synchronized boolean hasPatterns ( ) { if ( isReference ( ) ) { return getRef ( ) . hasPatterns ( ) ; } if ( hasPatterns ( defaultPatterns ) ) { return true ; } for ( Iterator i = additionalPatterns . iterator ( ) ; i . hasNext ( ) ; ) { if ( hasPatterns ( ( PatternSet ) i . next ( ) ) ) { return true ; } } return false ; } public synchronized void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } super . appendSelector ( selector ) ; ds = null ; } public String toString ( ) { if ( isReference ( ) ) { return getRef ( ) . toString ( ) ; } Iterator i = iterator ( ) ; if ( ! i . hasNext ( ) ) { return "" ; } StringBuffer sb = new StringBuffer ( ) ; while ( i . hasNext ( ) ) { if ( sb . length ( ) > 0 ) { sb . append ( File . pathSeparatorChar ) ; } sb . append ( i . next ( ) ) ; } return sb . toString ( ) ; } public synchronized Object clone ( ) { if ( isReference ( ) ) { return getRef ( ) . clone ( ) ; } try { Files f = ( Files ) super . clone ( ) ; f . defaultPatterns = ( PatternSet ) defaultPatterns . clone ( ) ; f . additionalPatterns = new Vector ( additionalPatterns . size ( ) ) ; for ( Iterator iter = additionalPatterns . iterator ( ) ; iter . hasNext ( ) ; ) { PatternSet ps = ( PatternSet ) iter . next ( ) ; f . additionalPatterns . add ( ps . clone ( ) ) ; } f . selectors = new Vector ( selectors ) ; return f ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public String [ ] mergeIncludes ( Project p ) { return mergePatterns ( p ) . getIncludePatterns ( p ) ; } public String [ ] mergeExcludes ( Project p ) { return mergePatterns ( p ) . getExcludePatterns ( p ) ; } public synchronized PatternSet mergePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( ) . mergePatterns ( p ) ; } PatternSet ps = new PatternSet ( ) ; ps . append ( defaultPatterns , p ) ; final int count = additionalPatterns . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Object o = additionalPatterns . elementAt ( i ) ; ps . append ( ( PatternSet ) o , p ) ; } return ps ; } public boolean isFilesystemOnly ( ) { return true ; } protected Files getRef ( ) { return ( Files ) getCheckedRef ( ) ; } private synchronized void ensureDirectoryScannerSetup ( ) { if ( ds == null ) { ds = new DirectoryScanner ( ) ; PatternSet ps = mergePatterns ( getProject ( ) ) ; ds . setIncludes ( ps . getIncludePatterns ( getProject ( ) ) ) ; ds . setExcludes ( ps . getExcludePatterns ( getProject ( ) ) ) ; ds . setSelectors ( getSelectors ( getProject ( ) ) ) ; if ( useDefaultExcludes ) { ds . addDefaultExcludes ( ) ; } ds . setCaseSensitive ( caseSensitive ) ; ds . setFollowSymlinks ( followSymlinks ) ; } } private boolean hasPatterns ( PatternSet ps ) { return ps . getIncludePatterns ( getProject ( ) ) . length > 0 || ps . getExcludePatterns ( getProject ( ) ) . length > 0 ; } } 	1
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { void buildStarted ( BuildEvent event ) ; void buildFinished ( BuildEvent event ) ; void targetStarted ( BuildEvent event ) ; void targetFinished ( BuildEvent event ) ; void taskStarted ( BuildEvent event ) ; void taskFinished ( BuildEvent event ) ; void messageLogged ( BuildEvent event ) ; } 	1
package org . apache . tools . ant . filters ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . Reader ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . util . FileUtils ; public final class ReplaceTokens extends BaseParamFilterReader implements ChainableReader { private static final char DEFAULT_BEGIN_TOKEN = '@' ; private static final char DEFAULT_END_TOKEN = '@' ; private String queuedData = null ; private String replaceData = null ; private int replaceIndex = - 1 ; private int queueIndex = - 1 ; private Hashtable hash = new Hashtable ( ) ; private char beginToken = DEFAULT_BEGIN_TOKEN ; private char endToken = DEFAULT_END_TOKEN ; public ReplaceTokens ( ) { super ( ) ; } public ReplaceTokens ( final Reader in ) { super ( in ) ; } private int getNextChar ( ) throws IOException { if ( queueIndex != - 1 ) { final int ch = queuedData . charAt ( queueIndex ++ ) ; if ( queueIndex >= queuedData . length ( ) ) { queueIndex = - 1 ; } return ch ; } return in . read ( ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } if ( replaceIndex != - 1 ) { final int ch = replaceData . charAt ( replaceIndex ++ ) ; if ( replaceIndex >= replaceData . length ( ) ) { replaceIndex = - 1 ; } return ch ; } int ch = getNextChar ( ) ; if ( ch == beginToken ) { final StringBuffer key = new StringBuffer ( "" ) ; do { ch = getNextChar ( ) ; if ( ch != - 1 ) { key . append ( ( char ) ch ) ; } else { break ; } } while ( ch != endToken ) ; if ( ch == - 1 ) { if ( queuedData == null || queueIndex == - 1 ) { queuedData = key . toString ( ) ; } else { queuedData = key . toString ( ) + queuedData . substring ( queueIndex ) ; } queueIndex = 0 ; return beginToken ; } else { key . setLength ( key . length ( ) - 1 ) ; final String replaceWith = ( String ) hash . get ( key . toString ( ) ) ; if ( replaceWith != null ) { if ( replaceWith . length ( ) > 0 ) { replaceData = replaceWith ; replaceIndex = 0 ; } return read ( ) ; } else { String newData = key . toString ( ) + endToken ; if ( queuedData == null || queueIndex == - 1 ) { queuedData = newData ; } else { queuedData = newData + queuedData . substring ( queueIndex ) ; } queueIndex = 0 ; return beginToken ; } } } return ch ; } public void setBeginToken ( final char beginToken ) { this . beginToken = beginToken ; } private char getBeginToken ( ) { return beginToken ; } public void setEndToken ( final char endToken ) { this . endToken = endToken ; } private char getEndToken ( ) { return endToken ; } public void addConfiguredToken ( final Token token ) { hash . put ( token . getKey ( ) , token . getValue ( ) ) ; } private Properties getPropertiesFromFile ( String fileName ) { FileInputStream in = null ; Properties props = new Properties ( ) ; try { in = new FileInputStream ( fileName ) ; props . load ( in ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { FileUtils . close ( in ) ; } return props ; } private void setTokens ( final Hashtable hash ) { this . hash = hash ; } private Hashtable getTokens ( ) { return hash ; } public Reader chain ( final Reader rdr ) { ReplaceTokens newFilter = new ReplaceTokens ( rdr ) ; newFilter . setBeginToken ( getBeginToken ( ) ) ; newFilter . setEndToken ( getEndToken ( ) ) ; newFilter . setTokens ( getTokens ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { final String type = params [ i ] . getType ( ) ; if ( "tokenchar" . equals ( type ) ) { final String name = params [ i ] . getName ( ) ; String value = params [ i ] . getValue ( ) ; if ( "begintoken" . equals ( name ) ) { if ( value . length ( ) == 0 ) { throw new BuildException ( "Begin token cannot " + "be empty" ) ; } beginToken = params [ i ] . getValue ( ) . charAt ( 0 ) ; } else if ( "endtoken" . equals ( name ) ) { if ( value . length ( ) == 0 ) { throw new BuildException ( "End token cannot " + "be empty" ) ; } endToken = params [ i ] . getValue ( ) . charAt ( 0 ) ; } } else if ( "token" . equals ( type ) ) { final String name = params [ i ] . getName ( ) ; final String value = params [ i ] . getValue ( ) ; hash . put ( name , value ) ; } else if ( "propertiesfile" . equals ( type ) ) { Properties props = getPropertiesFromFile ( params [ i ] . getValue ( ) ) ; for ( Enumeration e = props . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = props . getProperty ( key ) ; hash . put ( key , value ) ; } } } } } } public static class Token { private String key ; private String value ; public final void setKey ( String key ) { this . key = key ; } public final void setValue ( String value ) { this . value = value ; } public final String getKey ( ) { return key ; } public final String getValue ( ) { return value ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . ResourceUtils ; import org . apache . tools . ant . util . SourceFileScanner ; public class UpToDate extends Task implements Condition { private String property ; private String value ; private File sourceFile ; private File targetFile ; private Vector sourceFileSets = new Vector ( ) ; private Union sourceResources = new Union ( ) ; protected Mapper mapperElement = null ; public void setProperty ( final String property ) { this . property = property ; } public void setValue ( final String value ) { this . value = value ; } private String getValue ( ) { return ( value != null ) ? value : "true" ; } public void setTargetFile ( final File file ) { this . targetFile = file ; } public void setSrcfile ( final File file ) { this . sourceFile = file ; } public void addSrcfiles ( final FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public Union createSrcResources ( ) { return sourceResources ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public boolean eval ( ) { if ( sourceFileSets . size ( ) == 0 && sourceResources . size ( ) == 0 && sourceFile == null ) { throw new BuildException ( "At least one srcfile or a nested " + "<srcfiles> or <srcresources> element " + "must be set." ) ; } if ( ( sourceFileSets . size ( ) > 0 || sourceResources . size ( ) > 0 ) && sourceFile != null ) { throw new BuildException ( "Cannot specify both the srcfile " + "attribute and a nested <srcfiles> " + "or <srcresources> element." ) ; } if ( targetFile == null && mapperElement == null ) { throw new BuildException ( "The targetfile attribute or a nested " + "mapper element must be set." ) ; } if ( targetFile != null && ! targetFile . exists ( ) ) { log ( "The targetfile \"" + targetFile . getAbsolutePath ( ) + "\" does not exist." , Project . MSG_VERBOSE ) ; return false ; } if ( sourceFile != null && ! sourceFile . exists ( ) ) { throw new BuildException ( sourceFile . getAbsolutePath ( ) + " not found." ) ; } boolean upToDate = true ; if ( sourceFile != null ) { if ( mapperElement == null ) { upToDate = upToDate && ( targetFile . lastModified ( ) >= sourceFile . lastModified ( ) ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; upToDate = upToDate && ( sfs . restrict ( new String [ ] { sourceFile . getAbsolutePath ( ) } , null , null , mapperElement . getImplementation ( ) ) . length == 0 ) ; } } Enumeration e = sourceFileSets . elements ( ) ; while ( upToDate && e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; upToDate = upToDate && scanDir ( fs . getDir ( getProject ( ) ) , ds . getIncludedFiles ( ) ) ; } if ( upToDate ) { Resource [ ] r = sourceResources . listResources ( ) ; upToDate = upToDate && ( ResourceUtils . selectOutOfDateSources ( this , r , getMapper ( ) , getProject ( ) ) . length == 0 ) ; } return upToDate ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required." , getLocation ( ) ) ; } boolean upToDate = eval ( ) ; if ( upToDate ) { getProject ( ) . setNewProperty ( property , getValue ( ) ) ; if ( mapperElement == null ) { log ( "File \"" + targetFile . getAbsolutePath ( ) + "\" is up-to-date." , Project . MSG_VERBOSE ) ; } else { log ( "All target files are up-to-date." , Project . MSG_VERBOSE ) ; } } } protected boolean scanDir ( File srcDir , String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; FileNameMapper mapper = getMapper ( ) ; File dir = srcDir ; if ( mapperElement == null ) { dir = null ; } return sfs . restrict ( files , srcDir , dir , mapper ) . length == 0 ; } private FileNameMapper getMapper ( ) { FileNameMapper mapper = null ; if ( mapperElement == null ) { MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( targetFile . getAbsolutePath ( ) ) ; mapper = mm ; } else { mapper = mapperElement . getImplementation ( ) ; } return mapper ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class ManifestTask extends Task { private Manifest nestedManifest = new Manifest ( ) ; private File manifestFile ; private Mode mode ; private String encoding ; public static class Mode extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "update" , "replace" } ; } } public ManifestTask ( ) { mode = new Mode ( ) ; mode . setValue ( "replace" ) ; } public void addConfiguredSection ( Manifest . Section section ) throws ManifestException { nestedManifest . addConfiguredSection ( section ) ; } public void addConfiguredAttribute ( Manifest . Attribute attribute ) throws ManifestException { nestedManifest . addConfiguredAttribute ( attribute ) ; } public void setFile ( File f ) { manifestFile = f ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setMode ( Mode m ) { mode = m ; } public void execute ( ) throws BuildException { if ( manifestFile == null ) { throw new BuildException ( "the file attribute is required" ) ; } Manifest toWrite = Manifest . getDefaultManifest ( ) ; Manifest current = null ; BuildException error = null ; if ( manifestFile . exists ( ) ) { FileInputStream fis = null ; InputStreamReader isr = null ; try { fis = new FileInputStream ( manifestFile ) ; if ( encoding == null ) { isr = new InputStreamReader ( fis , "UTF-8" ) ; } else { isr = new InputStreamReader ( fis , encoding ) ; } current = new Manifest ( isr ) ; } catch ( ManifestException m ) { error = new BuildException ( "Existing manifest " + manifestFile + " is invalid" , m , getLocation ( ) ) ; } catch ( IOException e ) { error = new BuildException ( "Failed to read " + manifestFile , e , getLocation ( ) ) ; } finally { FileUtils . close ( isr ) ; } } for ( Enumeration e = nestedManifest . getWarnings ( ) ; e . hasMoreElements ( ) ; ) { log ( "Manifest warning: " + ( String ) e . nextElement ( ) , Project . MSG_WARN ) ; } try { if ( mode . getValue ( ) . equals ( "update" ) && manifestFile . exists ( ) ) { if ( current != null ) { toWrite . merge ( current ) ; } else if ( error != null ) { throw error ; } } toWrite . merge ( nestedManifest ) ; } catch ( ManifestException m ) { throw new BuildException ( "Manifest is invalid" , m , getLocation ( ) ) ; } if ( toWrite . equals ( current ) ) { log ( "Manifest has not changed, do not recreate" , Project . MSG_VERBOSE ) ; return ; } PrintWriter w = null ; try { FileOutputStream fos = new FileOutputStream ( manifestFile ) ; OutputStreamWriter osw = new OutputStreamWriter ( fos , Manifest . JAR_ENCODING ) ; w = new PrintWriter ( osw ) ; toWrite . write ( w ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to write " + manifestFile , e , getLocation ( ) ) ; } finally { if ( w != null ) { w . close ( ) ; } } } } 	1
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; public class FileResource extends Resource implements Touchable { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final int NULL_FILE = Resource . getMagicNumber ( "null file" . getBytes ( ) ) ; private File file ; private File baseDir ; public FileResource ( ) { } public FileResource ( File b , String name ) { setFile ( FILE_UTILS . resolveFile ( b , name ) ) ; setBaseDir ( b ) ; } public FileResource ( File f ) { setFile ( f ) ; } public FileResource ( Project p , String s ) { this ( p . resolveFile ( s ) ) ; setProject ( p ) ; } public void setFile ( File f ) { checkAttributesAllowed ( ) ; file = f ; } public File getFile ( ) { return isReference ( ) ? ( ( FileResource ) getCheckedRef ( ) ) . getFile ( ) : file ; } public void setBaseDir ( File b ) { checkAttributesAllowed ( ) ; baseDir = b ; } public File getBaseDir ( ) { return isReference ( ) ? ( ( FileResource ) getCheckedRef ( ) ) . getBaseDir ( ) : baseDir ; } public void setRefid ( Reference r ) { if ( file != null || baseDir != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public String getName ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getName ( ) ; } File b = getBaseDir ( ) ; return b == null ? getNotNullFile ( ) . getName ( ) : FILE_UTILS . removeLeadingPath ( b , getNotNullFile ( ) ) ; } public boolean isExists ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) : getNotNullFile ( ) . exists ( ) ; } public long getLastModified ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getLastModified ( ) : getNotNullFile ( ) . lastModified ( ) ; } public boolean isDirectory ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . isDirectory ( ) : getNotNullFile ( ) . isDirectory ( ) ; } public long getSize ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) : getNotNullFile ( ) . length ( ) ; } public InputStream getInputStream ( ) throws IOException { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) : new FileInputStream ( getNotNullFile ( ) ) ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } File f = getNotNullFile ( ) ; if ( f . exists ( ) ) { if ( f . isFile ( ) ) { f . delete ( ) ; } } else { File p = f . getParentFile ( ) ; if ( p != null && ! ( p . exists ( ) ) ) { p . mkdirs ( ) ; } } return new FileOutputStream ( f ) ; } public int compareTo ( Object another ) { if ( isReference ( ) ) { return ( ( Comparable ) getCheckedRef ( ) ) . compareTo ( another ) ; } if ( this . equals ( another ) ) { return 0 ; } if ( another . getClass ( ) . equals ( getClass ( ) ) ) { FileResource otherfr = ( FileResource ) another ; File f = getFile ( ) ; if ( f == null ) { return - 1 ; } File of = otherfr . getFile ( ) ; if ( of == null ) { return 1 ; } return f . compareTo ( of ) ; } return super . compareTo ( another ) ; } public boolean equals ( Object another ) { if ( this == another ) { return true ; } if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( another ) ; } if ( ! ( another . getClass ( ) . equals ( getClass ( ) ) ) ) { return false ; } FileResource otherfr = ( FileResource ) another ; return getFile ( ) == null ? otherfr . getFile ( ) == null : getFile ( ) . equals ( otherfr . getFile ( ) ) ; } public int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return MAGIC * ( getFile ( ) == null ? NULL_FILE : getFile ( ) . hashCode ( ) ) ; } public String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } if ( file == null ) { return "(unbound file resource)" ; } String absolutePath = file . getAbsolutePath ( ) ; return FILE_UTILS . normalize ( absolutePath ) . getAbsolutePath ( ) ; } public boolean isFilesystemOnly ( ) { return ! isReference ( ) || ( ( FileResource ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } public void touch ( long modTime ) { if ( isReference ( ) ) { ( ( FileResource ) getCheckedRef ( ) ) . touch ( modTime ) ; return ; } getNotNullFile ( ) . setLastModified ( modTime ) ; } protected File getNotNullFile ( ) { if ( getFile ( ) == null ) { throw new BuildException ( "file attribute is null!" ) ; } return getFile ( ) ; } } 	1
package org . apache . tools . ant . launch ; import java . net . URL ; import java . net . URLClassLoader ; import java . net . MalformedURLException ; import java . io . File ; import java . util . StringTokenizer ; import java . util . List ; import java . util . ArrayList ; import java . util . Iterator ; public class Launcher { public static final String ANTHOME_PROPERTY = "ant.home" ; public static final String ANTLIBDIR_PROPERTY = "ant.library.dir" ; public static final String ANT_PRIVATEDIR = ".ant" ; public static final String ANT_PRIVATELIB = "lib" ; public static final String USER_LIBDIR = ANT_PRIVATEDIR + File . separatorChar + ANT_PRIVATELIB ; public static final String MAIN_CLASS = "org.apache.tools.ant.Main" ; public static final String USER_HOMEDIR = "user.home" ; private static final String JAVA_CLASS_PATH = "java.class.path" ; protected static final int EXIT_CODE_ERROR = 2 ; public static void main ( String [ ] args ) { int exitCode ; try { Launcher launcher = new Launcher ( ) ; exitCode = launcher . run ( args ) ; } catch ( LaunchException e ) { exitCode = EXIT_CODE_ERROR ; System . err . println ( e . getMessage ( ) ) ; } catch ( Throwable t ) { exitCode = EXIT_CODE_ERROR ; t . printStackTrace ( System . err ) ; } if ( exitCode != 0 ) { System . exit ( exitCode ) ; } } private void addPath ( String path , boolean getJars , List libPathURLs ) throws MalformedURLException { StringTokenizer tokenizer = new StringTokenizer ( path , File . pathSeparator ) ; while ( tokenizer . hasMoreElements ( ) ) { String elementName = tokenizer . nextToken ( ) ; File element = new File ( elementName ) ; if ( elementName . indexOf ( "%" ) != - 1 && ! element . exists ( ) ) { continue ; } if ( getJars && element . isDirectory ( ) ) { URL [ ] dirURLs = Locator . getLocationURLs ( element ) ; for ( int j = 0 ; j < dirURLs . length ; ++ j ) { libPathURLs . add ( dirURLs [ j ] ) ; } } libPathURLs . add ( Locator . fileToURL ( element ) ) ; } } private int run ( String [ ] args ) throws LaunchException , MalformedURLException { String antHomeProperty = System . getProperty ( ANTHOME_PROPERTY ) ; File antHome = null ; File sourceJar = Locator . getClassSource ( getClass ( ) ) ; File jarDir = sourceJar . getParentFile ( ) ; String mainClassname = MAIN_CLASS ; if ( antHomeProperty != null ) { antHome = new File ( antHomeProperty ) ; } if ( antHome == null || ! antHome . exists ( ) ) { antHome = jarDir . getParentFile ( ) ; System . setProperty ( ANTHOME_PROPERTY , antHome . getAbsolutePath ( ) ) ; } if ( ! antHome . exists ( ) ) { throw new LaunchException ( "Ant home is set incorrectly or " + "ant could not be located" ) ; } List libPaths = new ArrayList ( ) ; String cpString = null ; List argList = new ArrayList ( ) ; String [ ] newArgs ; boolean noUserLib = false ; boolean noClassPath = false ; for ( int i = 0 ; i < args . length ; ++ i ) { if ( args [ i ] . equals ( "-lib" ) ) { if ( i == args . length - 1 ) { throw new LaunchException ( "The -lib argument must " + "be followed by a library location" ) ; } libPaths . add ( args [ ++ i ] ) ; } else if ( args [ i ] . equals ( "-cp" ) ) { if ( i == args . length - 1 ) { throw new LaunchException ( "The -cp argument must " + "be followed by a classpath expression" ) ; } if ( cpString != null ) { throw new LaunchException ( "The -cp argument must " + "not be repeated" ) ; } cpString = args [ ++ i ] ; } else if ( args [ i ] . equals ( "--nouserlib" ) || args [ i ] . equals ( "-nouserlib" ) ) { noUserLib = true ; } else if ( args [ i ] . equals ( "--noclasspath" ) || args [ i ] . equals ( "-noclasspath" ) ) { noClassPath = true ; } else if ( args [ i ] . equals ( "-main" ) ) { if ( i == args . length - 1 ) { throw new LaunchException ( "The -main argument must " + "be followed by a library location" ) ; } mainClassname = args [ ++ i ] ; } else { argList . add ( args [ i ] ) ; } } if ( argList . size ( ) == args . length ) { newArgs = args ; } else { newArgs = ( String [ ] ) argList . toArray ( new String [ argList . size ( ) ] ) ; } URL [ ] libURLs = getLibPathURLs ( noClassPath ? null : cpString , libPaths ) ; URL [ ] systemURLs = getSystemURLs ( jarDir ) ; URL [ ] userURLs = noUserLib ? new URL [ 0 ] : getUserURLs ( ) ; URL [ ] jars = getJarArray ( libURLs , userURLs , systemURLs , Locator . getToolsJar ( ) ) ; StringBuffer baseClassPath = new StringBuffer ( System . getProperty ( JAVA_CLASS_PATH ) ) ; if ( baseClassPath . charAt ( baseClassPath . length ( ) - 1 ) == File . pathSeparatorChar ) { baseClassPath . setLength ( baseClassPath . length ( ) - 1 ) ; } for ( int i = 0 ; i < jars . length ; ++ i ) { baseClassPath . append ( File . pathSeparatorChar ) ; baseClassPath . append ( Locator . fromURI ( jars [ i ] . toString ( ) ) ) ; } System . setProperty ( JAVA_CLASS_PATH , baseClassPath . toString ( ) ) ; URLClassLoader loader = new URLClassLoader ( jars ) ; Thread . currentThread ( ) . setContextClassLoader ( loader ) ; Class mainClass = null ; int exitCode = 0 ; try { mainClass = loader . loadClass ( mainClassname ) ; AntMain main = ( AntMain ) mainClass . newInstance ( ) ; main . startAnt ( newArgs , null , null ) ; } catch ( InstantiationException ex ) { System . err . println ( "Incompatible version of " + mainClassname + " detected" ) ; File mainJar = Locator . getClassSource ( mainClass ) ; System . err . println ( "Location of this class " + mainJar ) ; exitCode = EXIT_CODE_ERROR ; } catch ( Throwable t ) { t . printStackTrace ( System . err ) ; exitCode = EXIT_CODE_ERROR ; } return exitCode ; } private URL [ ] getLibPathURLs ( String cpString , List libPaths ) throws MalformedURLException { List libPathURLs = new ArrayList ( ) ; if ( cpString != null ) { addPath ( cpString , false , libPathURLs ) ; } for ( Iterator i = libPaths . iterator ( ) ; i . hasNext ( ) ; ) { String libPath = ( String ) i . next ( ) ; addPath ( libPath , true , libPathURLs ) ; } return ( URL [ ] ) libPathURLs . toArray ( new URL [ libPathURLs . size ( ) ] ) ; } private URL [ ] getSystemURLs ( File antLauncherDir ) throws MalformedURLException { File antLibDir = null ; String antLibDirProperty = System . getProperty ( ANTLIBDIR_PROPERTY ) ; if ( antLibDirProperty != null ) { antLibDir = new File ( antLibDirProperty ) ; } if ( ( antLibDir == null ) || ! antLibDir . exists ( ) ) { antLibDir = antLauncherDir ; System . setProperty ( ANTLIBDIR_PROPERTY , antLibDir . getAbsolutePath ( ) ) ; } return Locator . getLocationURLs ( antLibDir ) ; } private URL [ ] getUserURLs ( ) throws MalformedURLException { File userLibDir = new File ( System . getProperty ( USER_HOMEDIR ) , USER_LIBDIR ) ; return Locator . getLocationURLs ( userLibDir ) ; } private URL [ ] getJarArray ( URL [ ] libJars , URL [ ] userJars , URL [ ] systemJars , File toolsJar ) throws MalformedURLException { int numJars = libJars . length + userJars . length + systemJars . length ; if ( toolsJar != null ) { numJars ++ ; } URL [ ] jars = new URL [ numJars ] ; System . arraycopy ( libJars , 0 , jars , 0 , libJars . length ) ; System . arraycopy ( userJars , 0 , jars , libJars . length , userJars . length ) ; System . arraycopy ( systemJars , 0 , jars , userJars . length + libJars . length , systemJars . length ) ; if ( toolsJar != null ) { jars [ jars . length - 1 ] = Locator . fileToURL ( toolsJar ) ; } return jars ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Stack ; import java . util . Vector ; import java . util . zip . CRC32 ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ArchiveFileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . types . ZipScanner ; import org . apache . tools . ant . types . resources . ArchiveResource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . GlobPatternMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . ResourceUtils ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipExtraField ; import org . apache . tools . zip . ZipFile ; import org . apache . tools . zip . ZipOutputStream ; public class Zip extends MatchingTask { protected File zipFile ; private ZipScanner zs ; private File baseDir ; protected Hashtable entries = new Hashtable ( ) ; private Vector groupfilesets = new Vector ( ) ; private Vector filesetsFromGroupfilesets = new Vector ( ) ; protected String duplicate = "add" ; private boolean doCompress = true ; private boolean doUpdate = false ; private boolean savedDoUpdate = false ; private boolean doFilesonly = false ; protected String archiveType = "zip" ; private static final long EMPTY_CRC = new CRC32 ( ) . getValue ( ) ; protected String emptyBehavior = "skip" ; private Vector resources = new Vector ( ) ; protected Hashtable addedDirs = new Hashtable ( ) ; private Vector addedFiles = new Vector ( ) ; protected boolean doubleFilePass = false ; protected boolean skipWriting = false ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private boolean addingNewFiles = false ; private String encoding ; private boolean keepCompression = false ; private boolean roundUp = true ; private String comment = "" ; private int level = ZipOutputStream . DEFAULT_COMPRESSION ; public void setZipfile ( File zipFile ) { setDestFile ( zipFile ) ; } public void setFile ( File file ) { setDestFile ( file ) ; } public void setDestFile ( File destFile ) { this . zipFile = destFile ; } public File getDestFile ( ) { return zipFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setCompress ( boolean c ) { doCompress = c ; } public boolean isCompress ( ) { return doCompress ; } public void setFilesonly ( boolean f ) { doFilesonly = f ; } public void setUpdate ( boolean c ) { doUpdate = c ; savedDoUpdate = c ; } public boolean isInUpdateMode ( ) { return doUpdate ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void addZipfileset ( ZipFileSet set ) { add ( set ) ; } public void add ( ResourceCollection a ) { resources . add ( a ) ; } public void addZipGroupFileset ( FileSet set ) { groupfilesets . addElement ( set ) ; } public void setDuplicate ( Duplicate df ) { duplicate = df . getValue ( ) ; } public static class WhenEmpty extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "fail" , "skip" , "create" } ; } } public void setWhenempty ( WhenEmpty we ) { emptyBehavior = we . getValue ( ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setKeepCompression ( boolean keep ) { keepCompression = keep ; } public void setComment ( String comment ) { this . comment = comment ; } public String getComment ( ) { return comment ; } public void setLevel ( int level ) { this . level = level ; } public int getLevel ( ) { return level ; } public void setRoundUp ( boolean r ) { roundUp = r ; } public void execute ( ) throws BuildException { if ( doubleFilePass ) { skipWriting = true ; executeMain ( ) ; skipWriting = false ; executeMain ( ) ; } else { executeMain ( ) ; } } public void executeMain ( ) throws BuildException { if ( baseDir == null && resources . size ( ) == 0 && groupfilesets . size ( ) == 0 && "zip" . equals ( archiveType ) ) { throw new BuildException ( "basedir attribute must be set, " + "or at least one " + "resource collection must be given!" ) ; } if ( zipFile == null ) { throw new BuildException ( "You must specify the " + archiveType + " file to create!" ) ; } if ( zipFile . exists ( ) && ! zipFile . isFile ( ) ) { throw new BuildException ( zipFile + " is not a file." ) ; } if ( zipFile . exists ( ) && ! zipFile . canWrite ( ) ) { throw new BuildException ( zipFile + " is read-only." ) ; } File renamedFile = null ; addingNewFiles = true ; if ( doUpdate && ! zipFile . exists ( ) ) { doUpdate = false ; log ( "ignoring update attribute as " + archiveType + " doesn't exist." , Project . MSG_DEBUG ) ; } for ( int i = 0 ; i < groupfilesets . size ( ) ; i ++ ) { log ( "Processing groupfileset " , Project . MSG_VERBOSE ) ; FileSet fs = ( FileSet ) groupfilesets . elementAt ( i ) ; FileScanner scanner = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = scanner . getIncludedFiles ( ) ; File basedir = scanner . getBasedir ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { log ( "Adding file " + files [ j ] + " to fileset" , Project . MSG_VERBOSE ) ; ZipFileSet zf = new ZipFileSet ( ) ; zf . setProject ( getProject ( ) ) ; zf . setSrc ( new File ( basedir , files [ j ] ) ) ; add ( zf ) ; filesetsFromGroupfilesets . addElement ( zf ) ; } } Vector vfss = new Vector ( ) ; if ( baseDir != null ) { FileSet fs = ( FileSet ) getImplicitFileSet ( ) . clone ( ) ; fs . setDir ( baseDir ) ; vfss . addElement ( fs ) ; } for ( int i = 0 ; i < resources . size ( ) ; i ++ ) { ResourceCollection rc = ( ResourceCollection ) resources . elementAt ( i ) ; vfss . addElement ( rc ) ; } ResourceCollection [ ] fss = new ResourceCollection [ vfss . size ( ) ] ; vfss . copyInto ( fss ) ; boolean success = false ; try { ArchiveState state = getResourcesToAdd ( fss , zipFile , false ) ; if ( ! state . isOutOfDate ( ) ) { return ; } if ( ! zipFile . exists ( ) && state . isWithoutAnyResources ( ) ) { createEmptyZip ( zipFile ) ; return ; } Resource [ ] [ ] addThem = state . getResourcesToAdd ( ) ; if ( doUpdate ) { renamedFile = FILE_UTILS . createTempFile ( "zip" , ".tmp" , zipFile . getParentFile ( ) ) ; renamedFile . deleteOnExit ( ) ; try { FILE_UTILS . rename ( zipFile , renamedFile ) ; } catch ( SecurityException e ) { throw new BuildException ( "Not allowed to rename old file (" + zipFile . getAbsolutePath ( ) + ") to temporary file" ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to rename old file (" + zipFile . getAbsolutePath ( ) + ") to temporary file" ) ; } } String action = doUpdate ? "Updating " : "Building " ; log ( action + archiveType + ": " + zipFile . getAbsolutePath ( ) ) ; ZipOutputStream zOut = null ; try { if ( ! skipWriting ) { zOut = new ZipOutputStream ( zipFile ) ; zOut . setEncoding ( encoding ) ; zOut . setMethod ( doCompress ? ZipOutputStream . DEFLATED : ZipOutputStream . STORED ) ; zOut . setLevel ( level ) ; } initZipOutputStream ( zOut ) ; for ( int i = 0 ; i < fss . length ; i ++ ) { if ( addThem [ i ] . length != 0 ) { addResources ( fss [ i ] , addThem [ i ] , zOut ) ; } } if ( doUpdate ) { addingNewFiles = false ; ZipFileSet oldFiles = new ZipFileSet ( ) ; oldFiles . setProject ( getProject ( ) ) ; oldFiles . setSrc ( renamedFile ) ; oldFiles . setDefaultexcludes ( false ) ; for ( int i = 0 ; i < addedFiles . size ( ) ; i ++ ) { PatternSet . NameEntry ne = oldFiles . createExclude ( ) ; ne . setName ( ( String ) addedFiles . elementAt ( i ) ) ; } DirectoryScanner ds = oldFiles . getDirectoryScanner ( getProject ( ) ) ; ( ( ZipScanner ) ds ) . setEncoding ( encoding ) ; String [ ] f = ds . getIncludedFiles ( ) ; Resource [ ] r = new Resource [ f . length ] ; for ( int i = 0 ; i < f . length ; i ++ ) { r [ i ] = ds . getResource ( f [ i ] ) ; } if ( ! doFilesonly ) { String [ ] d = ds . getIncludedDirectories ( ) ; Resource [ ] dr = new Resource [ d . length ] ; for ( int i = 0 ; i < d . length ; i ++ ) { dr [ i ] = ds . getResource ( d [ i ] ) ; } Resource [ ] tmp = r ; r = new Resource [ tmp . length + dr . length ] ; System . arraycopy ( dr , 0 , r , 0 , dr . length ) ; System . arraycopy ( tmp , 0 , r , dr . length , tmp . length ) ; } addResources ( oldFiles , r , zOut ) ; } if ( zOut != null ) { zOut . setComment ( comment ) ; } finalizeZipOutputStream ( zOut ) ; if ( doUpdate ) { if ( ! renamedFile . delete ( ) ) { log ( "Warning: unable to delete temporary file " + renamedFile . getName ( ) , Project . MSG_WARN ) ; } } success = true ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { if ( success ) { throw ex ; } } } } catch ( IOException ioe ) { String msg = "Problem creating " + archiveType + ": " + ioe . getMessage ( ) ; if ( ( ! doUpdate || renamedFile != null ) && ! zipFile . delete ( ) ) { msg += " (and the archive is probably corrupt but I could not " + "delete it)" ; } if ( doUpdate && renamedFile != null ) { try { FILE_UTILS . rename ( renamedFile , zipFile ) ; } catch ( IOException e ) { msg += " (and I couldn't rename the temporary file " + renamedFile . getName ( ) + " back)" ; } } throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { cleanUp ( ) ; } } protected final boolean isAddingNewFiles ( ) { return addingNewFiles ; } protected final void addResources ( FileSet fileset , Resource [ ] resources , ZipOutputStream zOut ) throws IOException { String prefix = "" ; String fullpath = "" ; int dirMode = ArchiveFileSet . DEFAULT_DIR_MODE ; int fileMode = ArchiveFileSet . DEFAULT_FILE_MODE ; ArchiveFileSet zfs = null ; if ( fileset instanceof ArchiveFileSet ) { zfs = ( ArchiveFileSet ) fileset ; prefix = zfs . getPrefix ( getProject ( ) ) ; fullpath = zfs . getFullpath ( getProject ( ) ) ; dirMode = zfs . getDirMode ( getProject ( ) ) ; fileMode = zfs . getFileMode ( getProject ( ) ) ; } if ( prefix . length ( ) > 0 && fullpath . length ( ) > 0 ) { throw new BuildException ( "Both prefix and fullpath attributes must" + " not be set on the same fileset." ) ; } if ( resources . length != 1 && fullpath . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only be specified" + " for filesets that specify a single" + " file." ) ; } if ( prefix . length ( ) > 0 ) { if ( ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } addParentDirs ( null , prefix , zOut , "" , dirMode ) ; } ZipFile zf = null ; try { boolean dealingWithFiles = false ; File base = null ; if ( zfs == null || zfs . getSrc ( getProject ( ) ) == null ) { dealingWithFiles = true ; base = fileset . getDir ( getProject ( ) ) ; } else if ( zfs instanceof ZipFileSet ) { zf = new ZipFile ( zfs . getSrc ( getProject ( ) ) , encoding ) ; } for ( int i = 0 ; i < resources . length ; i ++ ) { String name = null ; if ( fullpath . length ( ) > 0 ) { name = fullpath ; } else { name = resources [ i ] . getName ( ) ; } name = name . replace ( File . separatorChar , '/' ) ; if ( "" . equals ( name ) ) { continue ; } if ( resources [ i ] . isDirectory ( ) && ! name . endsWith ( "/" ) ) { name = name + "/" ; } if ( ! doFilesonly && ! dealingWithFiles && resources [ i ] . isDirectory ( ) && ! zfs . hasDirModeBeenSet ( ) ) { int nextToLastSlash = name . lastIndexOf ( "/" , name . length ( ) - 2 ) ; if ( nextToLastSlash != - 1 ) { addParentDirs ( base , name . substring ( 0 , nextToLastSlash + 1 ) , zOut , prefix , dirMode ) ; } if ( zf != null ) { ZipEntry ze = zf . getEntry ( resources [ i ] . getName ( ) ) ; addParentDirs ( base , name , zOut , prefix , ze . getUnixMode ( ) ) ; } else { ArchiveResource tr = ( ArchiveResource ) resources [ i ] ; addParentDirs ( base , name , zOut , prefix , tr . getMode ( ) ) ; } } else { addParentDirs ( base , name , zOut , prefix , dirMode ) ; } if ( ! resources [ i ] . isDirectory ( ) && dealingWithFiles ) { File f = FILE_UTILS . resolveFile ( base , resources [ i ] . getName ( ) ) ; zipFile ( f , zOut , prefix + name , fileMode ) ; } else if ( ! resources [ i ] . isDirectory ( ) ) { if ( zf != null ) { ZipEntry ze = zf . getEntry ( resources [ i ] . getName ( ) ) ; if ( ze != null ) { boolean oldCompress = doCompress ; if ( keepCompression ) { doCompress = ( ze . getMethod ( ) == ZipEntry . DEFLATED ) ; } try { zipFile ( zf . getInputStream ( ze ) , zOut , prefix + name , ze . getTime ( ) , zfs . getSrc ( getProject ( ) ) , zfs . hasFileModeBeenSet ( ) ? fileMode : ze . getUnixMode ( ) ) ; } finally { doCompress = oldCompress ; } } } else { ArchiveResource tr = ( ArchiveResource ) resources [ i ] ; InputStream is = null ; try { is = tr . getInputStream ( ) ; zipFile ( is , zOut , prefix + name , resources [ i ] . getLastModified ( ) , zfs . getSrc ( getProject ( ) ) , zfs . hasFileModeBeenSet ( ) ? fileMode : tr . getMode ( ) ) ; } finally { FileUtils . close ( is ) ; } } } } } finally { if ( zf != null ) { zf . close ( ) ; } } } protected final void addResources ( ResourceCollection rc , Resource [ ] resources , ZipOutputStream zOut ) throws IOException { if ( rc instanceof FileSet ) { addResources ( ( FileSet ) rc , resources , zOut ) ; return ; } for ( int i = 0 ; i < resources . length ; i ++ ) { String name = resources [ i ] . getName ( ) . replace ( File . separatorChar , '/' ) ; if ( "" . equals ( name ) ) { continue ; } if ( resources [ i ] . isDirectory ( ) && doFilesonly ) { continue ; } File base = null ; if ( resources [ i ] instanceof FileResource ) { base = ( ( FileResource ) resources [ i ] ) . getBaseDir ( ) ; } if ( resources [ i ] . isDirectory ( ) ) { if ( ! name . endsWith ( "/" ) ) { name = name + "/" ; } } addParentDirs ( base , name , zOut , "" , ArchiveFileSet . DEFAULT_DIR_MODE ) ; if ( ! resources [ i ] . isDirectory ( ) ) { if ( resources [ i ] instanceof FileResource ) { File f = ( ( FileResource ) resources [ i ] ) . getFile ( ) ; zipFile ( f , zOut , name , ArchiveFileSet . DEFAULT_FILE_MODE ) ; } else { InputStream is = null ; try { is = resources [ i ] . getInputStream ( ) ; zipFile ( is , zOut , name , resources [ i ] . getLastModified ( ) , null , ArchiveFileSet . DEFAULT_FILE_MODE ) ; } finally { FileUtils . close ( is ) ; } } } } } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected boolean createEmptyZip ( File zipFile ) throws BuildException { log ( "Note: creating empty " + archiveType + " archive " + zipFile , Project . MSG_INFO ) ; OutputStream os = null ; try { os = new FileOutputStream ( zipFile ) ; byte [ ] empty = new byte [ 22 ] ; empty [ 0 ] = 80 ; empty [ 1 ] = 75 ; empty [ 2 ] = 5 ; empty [ 3 ] = 6 ; os . write ( empty ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create empty ZIP archive " + "(" + ioe . getMessage ( ) + ")" , ioe , getLocation ( ) ) ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException e ) { } } } return true ; } private synchronized ZipScanner getZipScanner ( ) { if ( zs == null ) { zs = new ZipScanner ( ) ; zs . setEncoding ( encoding ) ; zs . setSrc ( zipFile ) ; } return zs ; } protected ArchiveState getResourcesToAdd ( ResourceCollection [ ] rcs , File zipFile , boolean needsUpdate ) throws BuildException { ArrayList filesets = new ArrayList ( ) ; ArrayList rest = new ArrayList ( ) ; for ( int i = 0 ; i < rcs . length ; i ++ ) { if ( rcs [ i ] instanceof FileSet ) { filesets . add ( rcs [ i ] ) ; } else { rest . add ( rcs [ i ] ) ; } } ResourceCollection [ ] rc = ( ResourceCollection [ ] ) rest . toArray ( new ResourceCollection [ rest . size ( ) ] ) ; ArchiveState as = getNonFileSetResourcesToAdd ( rc , zipFile , needsUpdate ) ; FileSet [ ] fs = ( FileSet [ ] ) filesets . toArray ( new FileSet [ filesets . size ( ) ] ) ; ArchiveState as2 = getResourcesToAdd ( fs , zipFile , as . isOutOfDate ( ) ) ; if ( ! as . isOutOfDate ( ) && as2 . isOutOfDate ( ) ) { as = getNonFileSetResourcesToAdd ( rc , zipFile , true ) ; } Resource [ ] [ ] toAdd = new Resource [ rcs . length ] [ ] ; int fsIndex = 0 ; int restIndex = 0 ; for ( int i = 0 ; i < rcs . length ; i ++ ) { if ( rcs [ i ] instanceof FileSet ) { toAdd [ i ] = as2 . getResourcesToAdd ( ) [ fsIndex ++ ] ; } else { toAdd [ i ] = as . getResourcesToAdd ( ) [ restIndex ++ ] ; } } return new ArchiveState ( as2 . isOutOfDate ( ) , toAdd ) ; } protected ArchiveState getResourcesToAdd ( FileSet [ ] filesets , File zipFile , boolean needsUpdate ) throws BuildException { Resource [ ] [ ] initialResources = grabResources ( filesets ) ; if ( isEmpty ( initialResources ) ) { if ( needsUpdate && doUpdate ) { return new ArchiveState ( true , initialResources ) ; } if ( emptyBehavior . equals ( "skip" ) ) { if ( doUpdate ) { log ( archiveType + " archive " + zipFile + " not updated because no new files were included." , Project . MSG_VERBOSE ) ; } else { log ( "Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included." , Project . MSG_WARN ) ; } } else if ( emptyBehavior . equals ( "fail" ) ) { throw new BuildException ( "Cannot create " + archiveType + " archive " + zipFile + ": no files were included." , getLocation ( ) ) ; } else { if ( ! zipFile . exists ( ) ) { needsUpdate = true ; } } return new ArchiveState ( needsUpdate , initialResources ) ; } if ( ! zipFile . exists ( ) ) { return new ArchiveState ( true , initialResources ) ; } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } Resource [ ] [ ] newerResources = new Resource [ filesets . length ] [ ] ; for ( int i = 0 ; i < filesets . length ; i ++ ) { if ( ! ( fileset instanceof ZipFileSet ) || ( ( ZipFileSet ) fileset ) . getSrc ( getProject ( ) ) == null ) { File base = filesets [ i ] . getDir ( getProject ( ) ) ; for ( int j = 0 ; j < initialResources [ i ] . length ; j ++ ) { File resourceAsFile = FILE_UTILS . resolveFile ( base , initialResources [ i ] [ j ] . getName ( ) ) ; if ( resourceAsFile . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include " + "itself" , getLocation ( ) ) ; } } } } for ( int i = 0 ; i < filesets . length ; i ++ ) { if ( initialResources [ i ] . length == 0 ) { newerResources [ i ] = new Resource [ ] { } ; continue ; } FileNameMapper myMapper = new IdentityMapper ( ) ; if ( filesets [ i ] instanceof ZipFileSet ) { ZipFileSet zfs = ( ZipFileSet ) filesets [ i ] ; if ( zfs . getFullpath ( getProject ( ) ) != null && ! zfs . getFullpath ( getProject ( ) ) . equals ( "" ) ) { MergingMapper fm = new MergingMapper ( ) ; fm . setTo ( zfs . getFullpath ( getProject ( ) ) ) ; myMapper = fm ; } else if ( zfs . getPrefix ( getProject ( ) ) != null && ! zfs . getPrefix ( getProject ( ) ) . equals ( "" ) ) { GlobPatternMapper gm = new GlobPatternMapper ( ) ; gm . setFrom ( "*" ) ; String prefix = zfs . getPrefix ( getProject ( ) ) ; if ( ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } gm . setTo ( prefix + "*" ) ; myMapper = gm ; } } Resource [ ] resources = initialResources [ i ] ; if ( doFilesonly ) { resources = selectFileResources ( resources ) ; } newerResources [ i ] = ResourceUtils . selectOutOfDateSources ( this , resources , myMapper , getZipScanner ( ) ) ; needsUpdate = needsUpdate || ( newerResources [ i ] . length > 0 ) ; if ( needsUpdate && ! doUpdate ) { break ; } } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } return new ArchiveState ( needsUpdate , newerResources ) ; } protected ArchiveState getNonFileSetResourcesToAdd ( ResourceCollection [ ] rcs , File zipFile , boolean needsUpdate ) throws BuildException { Resource [ ] [ ] initialResources = grabNonFileSetResources ( rcs ) ; if ( isEmpty ( initialResources ) ) { return new ArchiveState ( needsUpdate , initialResources ) ; } if ( ! zipFile . exists ( ) ) { return new ArchiveState ( true , initialResources ) ; } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } Resource [ ] [ ] newerResources = new Resource [ rcs . length ] [ ] ; for ( int i = 0 ; i < rcs . length ; i ++ ) { if ( initialResources [ i ] . length == 0 ) { newerResources [ i ] = new Resource [ ] { } ; continue ; } for ( int j = 0 ; j < initialResources [ i ] . length ; j ++ ) { if ( initialResources [ i ] [ j ] instanceof FileResource && zipFile . equals ( ( ( FileResource ) initialResources [ i ] [ j ] ) . getFile ( ) ) ) { throw new BuildException ( "A zip file cannot include " + "itself" , getLocation ( ) ) ; } } Resource [ ] rs = initialResources [ i ] ; if ( doFilesonly ) { rs = selectFileResources ( rs ) ; } newerResources [ i ] = ResourceUtils . selectOutOfDateSources ( this , rs , new IdentityMapper ( ) , getZipScanner ( ) ) ; needsUpdate = needsUpdate || ( newerResources [ i ] . length > 0 ) ; if ( needsUpdate && ! doUpdate ) { break ; } } if ( needsUpdate && ! doUpdate ) { return new ArchiveState ( true , initialResources ) ; } return new ArchiveState ( needsUpdate , newerResources ) ; } protected Resource [ ] [ ] grabResources ( FileSet [ ] filesets ) { Resource [ ] [ ] result = new Resource [ filesets . length ] [ ] ; for ( int i = 0 ; i < filesets . length ; i ++ ) { boolean skipEmptyNames = true ; if ( filesets [ i ] instanceof ZipFileSet ) { ZipFileSet zfs = ( ZipFileSet ) filesets [ i ] ; skipEmptyNames = zfs . getPrefix ( getProject ( ) ) . equals ( "" ) && zfs . getFullpath ( getProject ( ) ) . equals ( "" ) ; } DirectoryScanner rs = filesets [ i ] . getDirectoryScanner ( getProject ( ) ) ; if ( rs instanceof ZipScanner ) { ( ( ZipScanner ) rs ) . setEncoding ( encoding ) ; } Vector resources = new Vector ( ) ; if ( ! doFilesonly ) { String [ ] directories = rs . getIncludedDirectories ( ) ; for ( int j = 0 ; j < directories . length ; j ++ ) { if ( ! "" . equals ( directories [ j ] ) || ! skipEmptyNames ) { resources . addElement ( rs . getResource ( directories [ j ] ) ) ; } } } String [ ] files = rs . getIncludedFiles ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { if ( ! "" . equals ( files [ j ] ) || ! skipEmptyNames ) { resources . addElement ( rs . getResource ( files [ j ] ) ) ; } } result [ i ] = new Resource [ resources . size ( ) ] ; resources . copyInto ( result [ i ] ) ; } return result ; } protected Resource [ ] [ ] grabNonFileSetResources ( ResourceCollection [ ] rcs ) { Resource [ ] [ ] result = new Resource [ rcs . length ] [ ] ; for ( int i = 0 ; i < rcs . length ; i ++ ) { Iterator iter = rcs [ i ] . iterator ( ) ; ArrayList rs = new ArrayList ( ) ; int lastDir = 0 ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( r . isExists ( ) ) { if ( r . isDirectory ( ) ) { rs . add ( lastDir ++ , r ) ; } else { rs . add ( r ) ; } } } result [ i ] = ( Resource [ ] ) rs . toArray ( new Resource [ rs . size ( ) ] ) ; } return result ; } protected void zipDir ( File dir , ZipOutputStream zOut , String vPath , int mode ) throws IOException { zipDir ( dir , zOut , vPath , mode , null ) ; } protected void zipDir ( File dir , ZipOutputStream zOut , String vPath , int mode , ZipExtraField [ ] extra ) throws IOException { if ( doFilesonly ) { log ( "skipping directory " + vPath + " for file-only archive" , Project . MSG_VERBOSE ) ; return ; } if ( addedDirs . get ( vPath ) != null ) { return ; } log ( "adding directory " + vPath , Project . MSG_VERBOSE ) ; addedDirs . put ( vPath , vPath ) ; if ( ! skipWriting ) { ZipEntry ze = new ZipEntry ( vPath ) ; if ( dir != null && dir . exists ( ) ) { ze . setTime ( dir . lastModified ( ) + ( roundUp ? 1999 : 0 ) ) ; } else { ze . setTime ( System . currentTimeMillis ( ) + ( roundUp ? 1999 : 0 ) ) ; } ze . setSize ( 0 ) ; ze . setMethod ( ZipEntry . STORED ) ; ze . setCrc ( EMPTY_CRC ) ; ze . setUnixMode ( mode ) ; if ( extra != null ) { ze . setExtraFields ( extra ) ; } zOut . putNextEntry ( ze ) ; } } protected void zipFile ( InputStream in , ZipOutputStream zOut , String vPath , long lastModified , File fromArchive , int mode ) throws IOException { if ( entries . contains ( vPath ) ) { if ( duplicate . equals ( "preserve" ) ) { log ( vPath + " already added, skipping" , Project . MSG_INFO ) ; return ; } else if ( duplicate . equals ( "fail" ) ) { throw new BuildException ( "Duplicate file " + vPath + " was found and the duplicate " + "attribute is 'fail'." ) ; } else { log ( "duplicate file " + vPath + " found, adding." , Project . MSG_VERBOSE ) ; } } else { log ( "adding entry " + vPath , Project . MSG_VERBOSE ) ; } entries . put ( vPath , vPath ) ; if ( ! skipWriting ) { ZipEntry ze = new ZipEntry ( vPath ) ; ze . setTime ( lastModified ) ; ze . setMethod ( doCompress ? ZipEntry . DEFLATED : ZipEntry . STORED ) ; if ( ! zOut . isSeekable ( ) && ! doCompress ) { long size = 0 ; CRC32 cal = new CRC32 ( ) ; if ( ! in . markSupported ( ) ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; bos . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } else { in . mark ( Integer . MAX_VALUE ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . reset ( ) ; } ze . setSize ( size ) ; ze . setCrc ( cal . getValue ( ) ) ; } ze . setUnixMode ( mode ) ; zOut . putNextEntry ( ze ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { if ( count != 0 ) { zOut . write ( buffer , 0 , count ) ; } count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } addedFiles . addElement ( vPath ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( file . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , getLocation ( ) ) ; } FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut , vPath , file . lastModified ( ) + ( roundUp ? 1999 : 0 ) , null , mode ) ; } finally { fIn . close ( ) ; } } protected final void addParentDirs ( File baseDir , String entry , ZipOutputStream zOut , String prefix , int dirMode ) throws IOException { if ( ! doFilesonly ) { Stack directories = new Stack ( ) ; int slashPos = entry . length ( ) ; while ( ( slashPos = entry . lastIndexOf ( '/' , slashPos - 1 ) ) != - 1 ) { String dir = entry . substring ( 0 , slashPos + 1 ) ; if ( addedDirs . get ( prefix + dir ) != null ) { break ; } directories . push ( dir ) ; } while ( ! directories . isEmpty ( ) ) { String dir = ( String ) directories . pop ( ) ; File f = null ; if ( baseDir != null ) { f = new File ( baseDir , dir ) ; } else { f = new File ( dir ) ; } zipDir ( f , zOut , prefix + dir , dirMode ) ; } } } protected void cleanUp ( ) { addedDirs . clear ( ) ; addedFiles . removeAllElements ( ) ; entries . clear ( ) ; addingNewFiles = false ; doUpdate = savedDoUpdate ; Enumeration e = filesetsFromGroupfilesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { ZipFileSet zf = ( ZipFileSet ) e . nextElement ( ) ; resources . removeElement ( zf ) ; } filesetsFromGroupfilesets . removeAllElements ( ) ; } public void reset ( ) { resources . removeAllElements ( ) ; zipFile = null ; baseDir = null ; groupfilesets . removeAllElements ( ) ; duplicate = "add" ; archiveType = "zip" ; doCompress = true ; emptyBehavior = "skip" ; doUpdate = false ; doFilesonly = false ; encoding = null ; } protected static final boolean isEmpty ( Resource [ ] [ ] r ) { for ( int i = 0 ; i < r . length ; i ++ ) { if ( r [ i ] . length > 0 ) { return false ; } } return true ; } protected Resource [ ] selectFileResources ( Resource [ ] orig ) { if ( orig . length == 0 ) { return orig ; } Vector v = new Vector ( orig . length ) ; for ( int i = 0 ; i < orig . length ; i ++ ) { if ( ! orig [ i ] . isDirectory ( ) ) { v . addElement ( orig [ i ] ) ; } else { log ( "Ignoring directory " + orig [ i ] . getName ( ) + " as only files will be added." , Project . MSG_VERBOSE ) ; } } if ( v . size ( ) != orig . length ) { Resource [ ] r = new Resource [ v . size ( ) ] ; v . copyInto ( r ) ; return r ; } return orig ; } public static class Duplicate extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "preserve" , "fail" } ; } } public static class ArchiveState { private boolean outOfDate ; private Resource [ ] [ ] resourcesToAdd ; ArchiveState ( boolean state , Resource [ ] [ ] r ) { outOfDate = state ; resourcesToAdd = r ; } public boolean isOutOfDate ( ) { return outOfDate ; } public Resource [ ] [ ] getResourcesToAdd ( ) { return resourcesToAdd ; } public boolean isWithoutAnyResources ( ) { if ( resourcesToAdd == null ) { return true ; } for ( int counter = 0 ; counter < resourcesToAdd . length ; counter ++ ) { if ( resourcesToAdd [ counter ] != null ) { if ( resourcesToAdd [ counter ] . length > 0 ) { return false ; } } } return true ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . unix ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; public abstract class AbstractAccessTask extends org . apache . tools . ant . taskdefs . ExecuteOn { public AbstractAccessTask ( ) { super . setParallel ( true ) ; super . setSkipEmptyFilesets ( true ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setFile ( src ) ; addFileset ( fs ) ; } public void setCommand ( Commandline cmdl ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the command attribute" , getLocation ( ) ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the " + "skipemptyfileset attribute" , getLocation ( ) ) ; } public void setAddsourcefile ( boolean b ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the addsourcefile attribute" , getLocation ( ) ) ; } protected boolean isValidOs ( ) { return Os . isFamily ( "unix" ) && super . isValidOs ( ) ; } } 	1
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; private boolean handleDirSep = false ; private boolean caseSensitive = true ; public void setHandleDirSep ( boolean handleDirSep ) { this . handleDirSep = handleDirSep ; } public void setCaseSensitive ( boolean caseSensitive ) { this . caseSensitive = caseSensitive ; } public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! modifyName ( sourceFileName ) . startsWith ( modifyName ( fromPrefix ) ) || ! modifyName ( sourceFileName ) . endsWith ( modifyName ( fromPostfix ) ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } private String modifyName ( String name ) { if ( ! caseSensitive ) { name = name . toLowerCase ( ) ; } if ( handleDirSep ) { if ( name . indexOf ( '\\' ) != - 1 ) { name = name . replace ( '\\' , '/' ) ; } } return name ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class War extends Jar { private File deploymentDescriptor ; private boolean needxmlfile = true ; private File addedWebXmlFile ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final String XML_DESCRIPTOR_PATH = "WEB-INF/web.xml" ; private static final String XML_DESCRIPTOR_PATH_LC = XML_DESCRIPTOR_PATH . toLowerCase ( Locale . ENGLISH ) ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { setDestFile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( XML_DESCRIPTOR_PATH ) ; super . addFileset ( fs ) ; } public void setNeedxmlfile ( boolean needxmlfile ) { this . needxmlfile = needxmlfile ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { String vPathLowerCase = vPath . toLowerCase ( Locale . ENGLISH ) ; boolean addFile = true ; if ( XML_DESCRIPTOR_PATH_LC . equals ( vPathLowerCase ) ) { if ( addedWebXmlFile != null ) { addFile = false ; if ( ! FILE_UTILS . fileNameEquals ( addedWebXmlFile , file ) ) { log ( "Warning: selected " + archiveType + " files include a second " + XML_DESCRIPTOR_PATH + " which will be ignored.\n" + "The duplicate entry is at " + file + '\n' + "The file that will be used is " + addedWebXmlFile , Project . MSG_WARN ) ; } } else { addedWebXmlFile = file ; addFile = true ; deploymentDescriptor = file ; } } if ( addFile ) { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { if ( addedWebXmlFile == null && deploymentDescriptor == null && needxmlfile && ! isInUpdateMode ( ) ) { throw new BuildException ( "No WEB-INF/web.xml file was added.\n" + "If this is your intent, set needxml='false' " ) ; } addedWebXmlFile = null ; super . cleanUp ( ) ; } } 	1
package org . apache . tools . ant . util ; import java . io . File ; import java . io . Reader ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . BufferedInputStream ; import java . util . Arrays ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . TimeComparison ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . Touchable ; import org . apache . tools . ant . types . resources . selectors . Or ; import org . apache . tools . ant . types . resources . selectors . And ; import org . apache . tools . ant . types . resources . selectors . Not ; import org . apache . tools . ant . types . resources . selectors . Date ; import org . apache . tools . ant . types . resources . selectors . Type ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . selectors . SelectorUtils ; public class ResourceUtils { private static final class Outdated implements ResourceSelector { private Resource control ; private long granularity ; private Outdated ( Resource control , long granularity ) { this . control = control ; this . granularity = granularity ; } public boolean isSelected ( Resource r ) { return SelectorUtils . isOutOfDate ( control , r , granularity ) ; } } private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final ResourceSelector NOT_EXISTS = new Not ( new Exists ( ) ) ; public static Resource [ ] selectOutOfDateSources ( ProjectComponent logTo , Resource [ ] source , FileNameMapper mapper , ResourceFactory targets ) { return selectOutOfDateSources ( logTo , source , mapper , targets , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public static Resource [ ] selectOutOfDateSources ( ProjectComponent logTo , Resource [ ] source , FileNameMapper mapper , ResourceFactory targets , long granularity ) { Union u = new Union ( ) ; u . addAll ( Arrays . asList ( source ) ) ; ResourceCollection rc = selectOutOfDateSources ( logTo , u , mapper , targets , granularity ) ; return rc . size ( ) == 0 ? new Resource [ 0 ] : ( ( Union ) rc ) . listResources ( ) ; } public static ResourceCollection selectOutOfDateSources ( ProjectComponent logTo , ResourceCollection source , FileNameMapper mapper , ResourceFactory targets , long granularity ) { if ( source . size ( ) == 0 ) { logTo . log ( "No sources found." , Project . MSG_VERBOSE ) ; return Resources . NONE ; } source = Union . getInstance ( source ) ; logFuture ( logTo , source , granularity ) ; Union result = new Union ( ) ; for ( Iterator iter = source . iterator ( ) ; iter . hasNext ( ) ; ) { Resource sr = ( Resource ) iter . next ( ) ; String srName = sr . getName ( ) ; srName = srName == null ? srName : srName . replace ( '/' , File . separatorChar ) ; String [ ] targetnames = null ; try { targetnames = mapper . mapFileName ( srName ) ; } catch ( Exception e ) { logTo . log ( "Caught " + e + " mapping resource " + sr , Project . MSG_VERBOSE ) ; } if ( targetnames == null || targetnames . length == 0 ) { logTo . log ( sr + " skipped - don\'t know how to handle it" , Project . MSG_VERBOSE ) ; continue ; } Union targetColl = new Union ( ) ; for ( int i = 0 ; i < targetnames . length ; i ++ ) { targetColl . add ( targets . getResource ( targetnames [ i ] . replace ( File . separatorChar , '/' ) ) ) ; } Restrict r = new Restrict ( ) ; r . add ( new And ( new ResourceSelector [ ] { Type . FILE , new Or ( new ResourceSelector [ ] { NOT_EXISTS , new Outdated ( sr , granularity ) } ) } ) ) ; r . add ( targetColl ) ; if ( r . size ( ) > 0 ) { result . add ( sr ) ; Resource t = ( Resource ) ( r . iterator ( ) . next ( ) ) ; logTo . log ( sr . getName ( ) + " added as " + t . getName ( ) + ( t . isExists ( ) ? " is outdated." : " doesn\'t exist." ) , Project . MSG_VERBOSE ) ; continue ; } logTo . log ( sr . getName ( ) + " omitted as " + targetColl . toString ( ) + ( targetColl . size ( ) == 1 ? " is" : " are " ) + " up to date." , Project . MSG_VERBOSE ) ; } return result ; } public static void copyResource ( Resource source , Resource dest ) throws IOException { copyResource ( source , dest , null ) ; } public static void copyResource ( Resource source , Resource dest , Project project ) throws IOException { copyResource ( source , dest , null , null , false , false , null , null , project ) ; } public static void copyResource ( Resource source , Resource dest , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { if ( ! overwrite ) { long slm = source . getLastModified ( ) ; if ( dest . isExists ( ) && slm != 0 && dest . getLastModified ( ) > slm ) { return ; } } final boolean filterSetsAvailable = ( filters != null && filters . hasFilters ( ) ) ; final boolean filterChainsAvailable = ( filterChains != null && filterChains . size ( ) > 0 ) ; if ( filterSetsAvailable ) { BufferedReader in = null ; BufferedWriter out = null ; try { InputStreamReader isr = null ; if ( inputEncoding == null ) { isr = new InputStreamReader ( source . getInputStream ( ) ) ; } else { isr = new InputStreamReader ( source . getInputStream ( ) , inputEncoding ) ; } in = new BufferedReader ( isr ) ; OutputStreamWriter osw = null ; if ( outputEncoding == null ) { osw = new OutputStreamWriter ( dest . getOutputStream ( ) ) ; } else { osw = new OutputStreamWriter ( dest . getOutputStream ( ) , outputEncoding ) ; } out = new BufferedWriter ( osw ) ; if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( FileUtils . BUF_SIZE ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } LineTokenizer lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; String newline = null ; String line = lineTokenizer . getToken ( in ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { newline = filters . replaceTokens ( line ) ; out . write ( newline ) ; } line = lineTokenizer . getToken ( in ) ; } } finally { FileUtils . close ( out ) ; FileUtils . close ( in ) ; } } else if ( filterChainsAvailable || ( inputEncoding != null && ! inputEncoding . equals ( outputEncoding ) ) || ( inputEncoding == null && outputEncoding != null ) ) { BufferedReader in = null ; BufferedWriter out = null ; try { InputStreamReader isr = null ; if ( inputEncoding == null ) { isr = new InputStreamReader ( source . getInputStream ( ) ) ; } else { isr = new InputStreamReader ( source . getInputStream ( ) , inputEncoding ) ; } in = new BufferedReader ( isr ) ; OutputStreamWriter osw = null ; if ( outputEncoding == null ) { osw = new OutputStreamWriter ( dest . getOutputStream ( ) ) ; } else { osw = new OutputStreamWriter ( dest . getOutputStream ( ) , outputEncoding ) ; } out = new BufferedWriter ( osw ) ; if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( FileUtils . BUF_SIZE ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } char [ ] buffer = new char [ FileUtils . BUF_SIZE ] ; while ( true ) { int nRead = in . read ( buffer , 0 , buffer . length ) ; if ( nRead == - 1 ) { break ; } out . write ( buffer , 0 , nRead ) ; } } finally { FileUtils . close ( out ) ; FileUtils . close ( in ) ; } } else { InputStream in = null ; OutputStream out = null ; try { in = source . getInputStream ( ) ; out = dest . getOutputStream ( ) ; byte [ ] buffer = new byte [ FileUtils . BUF_SIZE ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } finally { FileUtils . close ( out ) ; FileUtils . close ( in ) ; } } if ( preserveLastModified && dest instanceof Touchable ) { setLastModified ( ( Touchable ) dest , source . getLastModified ( ) ) ; } } public static void setLastModified ( Touchable t , long time ) { t . touch ( ( time < 0 ) ? System . currentTimeMillis ( ) : time ) ; } public static boolean contentEquals ( Resource r1 , Resource r2 , boolean text ) throws IOException { if ( r1 . isExists ( ) != r2 . isExists ( ) ) { return false ; } if ( ! r1 . isExists ( ) ) { return true ; } if ( r1 . isDirectory ( ) || r2 . isDirectory ( ) ) { return false ; } if ( r1 . equals ( r2 ) ) { return true ; } if ( ! text && r1 . getSize ( ) != r2 . getSize ( ) ) { return false ; } return compareContent ( r1 , r2 , text ) == 0 ; } public static int compareContent ( Resource r1 , Resource r2 , boolean text ) throws IOException { if ( r1 . equals ( r2 ) ) { return 0 ; } boolean e1 = r1 . isExists ( ) ; boolean e2 = r2 . isExists ( ) ; if ( ! ( e1 || e2 ) ) { return 0 ; } if ( e1 != e2 ) { return e1 ? 1 : - 1 ; } boolean d1 = r1 . isDirectory ( ) ; boolean d2 = r2 . isDirectory ( ) ; if ( d1 && d2 ) { return 0 ; } if ( d1 || d2 ) { return d1 ? - 1 : 1 ; } return text ? textCompare ( r1 , r2 ) : binaryCompare ( r1 , r2 ) ; } private static int binaryCompare ( Resource r1 , Resource r2 ) throws IOException { InputStream in1 = null ; InputStream in2 = null ; try { in1 = new BufferedInputStream ( r1 . getInputStream ( ) ) ; in2 = new BufferedInputStream ( r2 . getInputStream ( ) ) ; for ( int b1 = in1 . read ( ) ; b1 != - 1 ; b1 = in1 . read ( ) ) { int b2 = in2 . read ( ) ; if ( b1 != b2 ) { return b1 > b2 ? 1 : - 1 ; } } return in2 . read ( ) == - 1 ? 0 : - 1 ; } finally { FileUtils . close ( in1 ) ; FileUtils . close ( in2 ) ; } } private static int textCompare ( Resource r1 , Resource r2 ) throws IOException { BufferedReader in1 = null ; BufferedReader in2 = null ; try { in1 = new BufferedReader ( new InputStreamReader ( r1 . getInputStream ( ) ) ) ; in2 = new BufferedReader ( new InputStreamReader ( r2 . getInputStream ( ) ) ) ; String expected = in1 . readLine ( ) ; while ( expected != null ) { String actual = in2 . readLine ( ) ; if ( ! expected . equals ( actual ) ) { return expected . compareTo ( actual ) ; } expected = in1 . readLine ( ) ; } return in2 . readLine ( ) == null ? 0 : - 1 ; } finally { FileUtils . close ( in1 ) ; FileUtils . close ( in2 ) ; } } private static void logFuture ( ProjectComponent logTo , ResourceCollection rc , long granularity ) { long now = System . currentTimeMillis ( ) + granularity ; Date sel = new Date ( ) ; sel . setMillis ( now ) ; sel . setWhen ( TimeComparison . AFTER ) ; Restrict future = new Restrict ( ) ; future . add ( sel ) ; future . add ( rc ) ; for ( Iterator iter = future . iterator ( ) ; iter . hasNext ( ) ; ) { logTo . log ( "Warning: " + ( ( Resource ) iter . next ( ) ) . getName ( ) + " modified in the future." , Project . MSG_WARN ) ; } } } 	1
package org . apache . tools . ant . util . optional ; import org . apache . tools . ant . BuildException ; import java . util . Iterator ; import org . apache . tools . ant . util . ScriptRunnerBase ; import org . apache . tools . ant . util . ReflectUtil ; import org . apache . tools . ant . util . ReflectWrapper ; public class JavaxScriptRunner extends ScriptRunnerBase { private ReflectWrapper engine ; public String getManagerName ( ) { return "javax" ; } public boolean supportsLanguage ( ) { if ( engine != null ) { return true ; } checkLanguage ( ) ; ClassLoader origLoader = replaceContextLoader ( ) ; try { return createEngine ( ) != null ; } catch ( Exception ex ) { return false ; } finally { restoreContextLoader ( origLoader ) ; } } public void executeScript ( String execName ) throws BuildException { evaluateScript ( execName ) ; } public Object evaluateScript ( String execName ) throws BuildException { checkLanguage ( ) ; ClassLoader origLoader = replaceContextLoader ( ) ; try { ReflectWrapper engine = createEngine ( ) ; if ( engine == null ) { throw new BuildException ( "Unable to create javax script engine for " + getLanguage ( ) ) ; } for ( Iterator i = getBeans ( ) . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; Object value = getBeans ( ) . get ( key ) ; engine . invoke ( "put" , String . class , key , Object . class , value ) ; } return engine . invoke ( "eval" , String . class , getScript ( ) ) ; } catch ( Exception be ) { Throwable t = be ; Throwable te = ( Throwable ) ReflectUtil . invoke ( be , "getCause" ) ; if ( te != null ) { if ( te instanceof BuildException ) { throw ( BuildException ) te ; } else { t = te ; } } throw new BuildException ( t ) ; } finally { restoreContextLoader ( origLoader ) ; } } private ReflectWrapper createEngine ( ) throws Exception { if ( engine != null ) { return engine ; } ReflectWrapper manager = new ReflectWrapper ( getClass ( ) . getClassLoader ( ) , "javax.script.ScriptEngineManager" ) ; Object e = manager . invoke ( "getEngineByName" , String . class , getLanguage ( ) ) ; if ( e == null ) { return null ; } ReflectWrapper ret = new ReflectWrapper ( e ) ; if ( getKeepEngine ( ) ) { this . engine = ret ; } return ret ; } } 	1
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import java . io . IOException ; import java . io . File ; import java . util . List ; import java . util . LinkedList ; import java . util . Iterator ; import java . util . ArrayList ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FileSet ; public class Scp extends SSHBase { private static final String [ ] FROM_ATTRS = { "file" , "localfile" , "remotefile" } ; private static final String [ ] TO_ATTRS = { "todir" , "localtodir" , "remotetodir" , "localtofile" , "remotetofile" } ; private String fromUri ; private String toUri ; private List fileSets = null ; private boolean isFromRemote , isToRemote ; private boolean isSftp = false ; public void setFile ( String aFromUri ) { setFromUri ( aFromUri ) ; this . isFromRemote = isRemoteUri ( this . fromUri ) ; } public void setTodir ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = isRemoteUri ( this . toUri ) ; } public void setLocalFile ( String aFromUri ) { setFromUri ( aFromUri ) ; this . isFromRemote = false ; } public void setRemoteFile ( String aFromUri ) { setFromUri ( aFromUri ) ; this . isFromRemote = true ; } public void setLocalTodir ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = false ; } public void setRemoteTodir ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = true ; } public void setLocalTofile ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = false ; } public void setRemoteTofile ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = true ; } public void setSftp ( boolean yesOrNo ) { isSftp = yesOrNo ; } public void addFileset ( FileSet set ) { if ( fileSets == null ) { fileSets = new LinkedList ( ) ; } fileSets . add ( set ) ; } public void init ( ) throws BuildException { super . init ( ) ; this . toUri = null ; this . fromUri = null ; this . fileSets = null ; } public void execute ( ) throws BuildException { if ( toUri == null ) { throw exactlyOne ( TO_ATTRS ) ; } if ( fromUri == null && fileSets == null ) { throw exactlyOne ( FROM_ATTRS , "one or more nested filesets" ) ; } try { if ( isFromRemote && ! isToRemote ) { download ( fromUri , toUri ) ; } else if ( ! isFromRemote && isToRemote ) { if ( fileSets != null ) { upload ( fileSets , toUri ) ; } else { upload ( fromUri , toUri ) ; } } else if ( isFromRemote && isToRemote ) { throw new BuildException ( "Copying from a remote server to a remote server is not supported." ) ; } else { throw new BuildException ( "'todir' and 'file' attributes " + "must have syntax like the following: " + "user:password@host:/path" ) ; } } catch ( Exception e ) { if ( getFailonerror ( ) ) { throw new BuildException ( e ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_ERR ) ; } } } private void download ( String fromSshUri , String toPath ) throws JSchException , IOException { String file = parseUri ( fromSshUri ) ; Session session = null ; try { session = openSession ( ) ; ScpFromMessage message = null ; if ( ! isSftp ) { message = new ScpFromMessage ( getVerbose ( ) , session , file , getProject ( ) . resolveFile ( toPath ) , fromSshUri . endsWith ( "*" ) ) ; } else { message = new ScpFromMessageBySftp ( getVerbose ( ) , session , file , getProject ( ) . resolveFile ( toPath ) , fromSshUri . endsWith ( "*" ) ) ; } log ( "Receiving file: " + file ) ; message . setLogListener ( this ) ; message . execute ( ) ; } finally { if ( session != null ) { session . disconnect ( ) ; } } } private void upload ( List fileSet , String toSshUri ) throws IOException , JSchException { String file = parseUri ( toSshUri ) ; Session session = null ; try { List list = new ArrayList ( fileSet . size ( ) ) ; for ( Iterator i = fileSet . iterator ( ) ; i . hasNext ( ) ; ) { FileSet set = ( FileSet ) i . next ( ) ; Directory d = createDirectory ( set ) ; if ( d != null ) { list . add ( d ) ; } } if ( ! list . isEmpty ( ) ) { session = openSession ( ) ; ScpToMessage message = null ; if ( ! isSftp ) { message = new ScpToMessage ( getVerbose ( ) , session , list , file ) ; } else { message = new ScpToMessageBySftp ( getVerbose ( ) , session , list , file ) ; } message . setLogListener ( this ) ; message . execute ( ) ; } } finally { if ( session != null ) { session . disconnect ( ) ; } } } private void upload ( String fromPath , String toSshUri ) throws IOException , JSchException { String file = parseUri ( toSshUri ) ; Session session = null ; try { session = openSession ( ) ; ScpToMessage message = null ; if ( ! isSftp ) { message = new ScpToMessage ( getVerbose ( ) , session , getProject ( ) . resolveFile ( fromPath ) , file ) ; } else { message = new ScpToMessageBySftp ( getVerbose ( ) , session , getProject ( ) . resolveFile ( fromPath ) , file ) ; } message . setLogListener ( this ) ; message . execute ( ) ; } finally { if ( session != null ) { session . disconnect ( ) ; } } } private String parseUri ( String uri ) { int indexOfAt = uri . lastIndexOf ( '@' ) ; int indexOfColon = uri . indexOf ( ':' ) ; if ( indexOfColon > - 1 && indexOfColon < indexOfAt ) { setUsername ( uri . substring ( 0 , indexOfColon ) ) ; setPassword ( uri . substring ( indexOfColon + 1 , indexOfAt ) ) ; } else { setUsername ( uri . substring ( 0 , indexOfAt ) ) ; } if ( getUserInfo ( ) . getPassword ( ) == null && getUserInfo ( ) . getPassphrase ( ) == null ) { throw new BuildException ( "neither password nor passphrase for user " + getUserInfo ( ) . getName ( ) + " has been " + "given.  Can't authenticate." ) ; } int indexOfPath = uri . indexOf ( ':' , indexOfAt + 1 ) ; if ( indexOfPath == - 1 ) { throw new BuildException ( "no remote path in " + uri ) ; } setHost ( uri . substring ( indexOfAt + 1 , indexOfPath ) ) ; String remotePath = uri . substring ( indexOfPath + 1 ) ; if ( remotePath . equals ( "" ) ) { remotePath = "." ; } return remotePath ; } private boolean isRemoteUri ( String uri ) { boolean isRemote = true ; int indexOfAt = uri . indexOf ( '@' ) ; if ( indexOfAt < 0 ) { isRemote = false ; } return isRemote ; } private Directory createDirectory ( FileSet set ) { DirectoryScanner scanner = set . getDirectoryScanner ( getProject ( ) ) ; Directory root = new Directory ( scanner . getBasedir ( ) ) ; String [ ] files = scanner . getIncludedFiles ( ) ; if ( files . length != 0 ) { for ( int j = 0 ; j < files . length ; j ++ ) { String [ ] path = Directory . getPath ( files [ j ] ) ; Directory current = root ; File currentParent = scanner . getBasedir ( ) ; for ( int i = 0 ; i < path . length ; i ++ ) { File file = new File ( currentParent , path [ i ] ) ; if ( file . isDirectory ( ) ) { current . addDirectory ( new Directory ( file ) ) ; current = current . getChild ( file ) ; currentParent = current . getDirectory ( ) ; } else if ( file . isFile ( ) ) { current . addFile ( file ) ; } } } } else { root = null ; } return root ; } private void setFromUri ( String fromUri ) { if ( this . fromUri != null ) { throw exactlyOne ( FROM_ATTRS ) ; } this . fromUri = fromUri ; } private void setToUri ( String toUri ) { if ( this . toUri != null ) { throw exactlyOne ( TO_ATTRS ) ; } this . toUri = toUri ; } private BuildException exactlyOne ( String [ ] attrs ) { return exactlyOne ( attrs , null ) ; } private BuildException exactlyOne ( String [ ] attrs , String alt ) { StringBuffer buf = new StringBuffer ( "Exactly one of " ) . append ( '[' ) . append ( attrs [ 0 ] ) ; for ( int i = 1 ; i < attrs . length ; i ++ ) { buf . append ( '|' ) . append ( attrs [ i ] ) ; } buf . append ( ']' ) ; if ( alt != null ) { buf . append ( " or " ) . append ( alt ) ; } return new BuildException ( buf . append ( " is required." ) . toString ( ) ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . junit ; public class Constants { static final String HALT_ON_ERROR = "haltOnError=" ; static final String HALT_ON_FAILURE = "haltOnFailure=" ; static final String FILTERTRACE = "filtertrace=" ; static final String CRASHFILE = "crashfile=" ; static final String BEFORE_FIRST_TEST = "BeforeFirstTest" ; static final String PROPSFILE = "propsfile=" ; static final String SHOWOUTPUT = "showoutput=" ; static final String OUTPUT_TO_FORMATTERS = "outputtoformatters=" ; static final String FORMATTER = "formatter=" ; static final String LOGTESTLISTENEREVENTS = "logtestlistenerevents=" ; static final String TESTSFILE = "testsfile=" ; static final String TERMINATED_SUCCESSFULLY = "terminated successfully" ; } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Available extends Task implements Condition { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String property ; private String classname ; private String filename ; private File file ; private Path filepath ; private String resource ; private FileDir type ; private Path classpath ; private AntClassLoader loader ; private String value = "true" ; private boolean isTask = false ; private boolean ignoreSystemclasses = false ; private boolean searchParents = false ; public void setSearchParents ( boolean searchParents ) { this . searchParents = searchParents ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setFilepath ( Path filepath ) { createFilepath ( ) . append ( filepath ) ; } public Path createFilepath ( ) { if ( this . filepath == null ) { this . filepath = new Path ( getProject ( ) ) ; } return this . filepath . createPath ( ) ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public void setClassname ( String classname ) { if ( ! "" . equals ( classname ) ) { this . classname = classname ; } } public void setFile ( File file ) { this . file = file ; this . filename = FILE_UTILS . removeLeadingPath ( getProject ( ) . getBaseDir ( ) , file ) ; } public void setResource ( String resource ) { this . resource = resource ; } public void setType ( String type ) { log ( "DEPRECATED - The setType(String) method has been deprecated." + " Use setType(Available.FileDir) instead." , Project . MSG_WARN ) ; this . type = new FileDir ( ) ; this . type . setValue ( type ) ; } public void setType ( FileDir type ) { this . type = type ; } public void setIgnoresystemclasses ( boolean ignore ) { this . ignoreSystemclasses = ignore ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required" , getLocation ( ) ) ; } isTask = true ; try { if ( eval ( ) ) { String oldvalue = getProject ( ) . getProperty ( property ) ; if ( null != oldvalue && ! oldvalue . equals ( value ) ) { log ( "DEPRECATED - <available> used to override an existing" + " property." + StringUtils . LINE_SEP + "  Build file should not reuse the same property" + " name for different values." , Project . MSG_WARN ) ; } getProject ( ) . setProperty ( property , value ) ; } } finally { isTask = false ; } } public boolean eval ( ) throws BuildException { try { if ( classname == null && file == null && resource == null ) { throw new BuildException ( "At least one of (classname|file|" + "resource) is required" , getLocation ( ) ) ; } if ( type != null ) { if ( file == null ) { throw new BuildException ( "The type attribute is only valid " + "when specifying the file " + "attribute." , getLocation ( ) ) ; } } if ( classpath != null ) { classpath . setProject ( getProject ( ) ) ; this . loader = getProject ( ) . createClassLoader ( classpath ) ; } String appendix = "" ; if ( isTask ) { appendix = " to set property " + property ; } else { setTaskName ( "available" ) ; } if ( ( classname != null ) && ! checkClass ( classname ) ) { log ( "Unable to load class " + classname + appendix , Project . MSG_VERBOSE ) ; return false ; } if ( ( file != null ) && ! checkFile ( ) ) { StringBuffer buf = new StringBuffer ( "Unable to find " ) ; if ( type != null ) { buf . append ( type ) . append ( ' ' ) ; } buf . append ( filename ) . append ( appendix ) ; log ( buf . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } if ( ( resource != null ) && ! checkResource ( resource ) ) { log ( "Unable to load resource " + resource + appendix , Project . MSG_VERBOSE ) ; return false ; } } finally { if ( loader != null ) { loader . cleanup ( ) ; loader = null ; } if ( ! isTask ) { setTaskName ( null ) ; } } return true ; } private boolean checkFile ( ) { if ( filepath == null ) { return checkFile ( file , filename ) ; } else { String [ ] paths = filepath . list ( ) ; for ( int i = 0 ; i < paths . length ; ++ i ) { log ( "Searching " + paths [ i ] , Project . MSG_DEBUG ) ; File path = new File ( paths [ i ] ) ; if ( path . exists ( ) && filename . equals ( paths [ i ] ) ) { if ( type == null ) { log ( "Found: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) && path . isDirectory ( ) ) { log ( "Found directory: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isFile ( ) && path . isFile ( ) ) { log ( "Found file: " + path , Project . MSG_VERBOSE ) ; return true ; } return false ; } File parent = path . getParentFile ( ) ; if ( parent != null && parent . exists ( ) && filename . equals ( parent . getAbsolutePath ( ) ) ) { if ( type == null ) { log ( "Found: " + parent , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) ) { log ( "Found directory: " + parent , Project . MSG_VERBOSE ) ; return true ; } return false ; } if ( path . exists ( ) && path . isDirectory ( ) ) { if ( checkFile ( new File ( path , filename ) , filename + " in " + path ) ) { return true ; } } while ( searchParents && parent != null && parent . exists ( ) ) { if ( checkFile ( new File ( parent , filename ) , filename + " in " + parent ) ) { return true ; } parent = parent . getParentFile ( ) ; } } } return false ; } private boolean checkFile ( File f , String text ) { if ( type != null ) { if ( type . isDir ( ) ) { if ( f . isDirectory ( ) ) { log ( "Found directory: " + text , Project . MSG_VERBOSE ) ; } return f . isDirectory ( ) ; } else if ( type . isFile ( ) ) { if ( f . isFile ( ) ) { log ( "Found file: " + text , Project . MSG_VERBOSE ) ; } return f . isFile ( ) ; } } if ( f . exists ( ) ) { log ( "Found: " + text , Project . MSG_VERBOSE ) ; } return f . exists ( ) ; } private boolean checkResource ( String resource ) { if ( loader != null ) { return ( loader . getResourceAsStream ( resource ) != null ) ; } else { ClassLoader cL = this . getClass ( ) . getClassLoader ( ) ; if ( cL != null ) { return ( cL . getResourceAsStream ( resource ) != null ) ; } else { return ( ClassLoader . getSystemResourceAsStream ( resource ) != null ) ; } } } private boolean checkClass ( String classname ) { try { if ( ignoreSystemclasses ) { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; if ( loader != null ) { try { loader . findClass ( classname ) ; } catch ( SecurityException se ) { return true ; } } else { return false ; } } else if ( loader != null ) { loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { Class . forName ( classname , true , l ) ; } else { Class . forName ( classname ) ; } } return true ; } catch ( ClassNotFoundException e ) { log ( "class \"" + classname + "\" was not found" , Project . MSG_DEBUG ) ; return false ; } catch ( NoClassDefFoundError e ) { log ( "Could not load dependent class \"" + e . getMessage ( ) + "\" for class \"" + classname + "\"" , Project . MSG_DEBUG ) ; return false ; } } public static class FileDir extends EnumeratedAttribute { private static final String [ ] VALUES = { "file" , "dir" } ; public String [ ] getValues ( ) { return VALUES ; } public boolean isDir ( ) { return "dir" . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFile ( ) { return "file" . equalsIgnoreCase ( getValue ( ) ) ; } } } 	1
package org . apache . tools . ant ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . io . IOException ; import org . apache . tools . ant . taskdefs . PreSetDef ; public class UnknownElement extends Task { private String elementName ; private String namespace = "" ; private String qname ; private Object realThing ; private List children = null ; private boolean presetDefed = false ; public UnknownElement ( String elementName ) { this . elementName = elementName ; } public List getChildren ( ) { return children ; } public String getTag ( ) { return elementName ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { if ( namespace . equals ( ProjectHelper . ANT_CURRENT_URI ) ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; namespace = helper . getCurrentAntlibUri ( ) ; } this . namespace = namespace == null ? "" : namespace ; } public String getQName ( ) { return qname ; } public void setQName ( String qname ) { this . qname = qname ; } public RuntimeConfigurable getWrapper ( ) { return super . getWrapper ( ) ; } public void maybeConfigure ( ) throws BuildException { if ( realThing != null ) { return ; } configure ( makeObject ( this , getWrapper ( ) ) ) ; } public void configure ( Object realObject ) { realThing = realObject ; getWrapper ( ) . setProxy ( realThing ) ; Task task = null ; if ( realThing instanceof Task ) { task = ( Task ) realThing ; task . setRuntimeConfigurableWrapper ( getWrapper ( ) ) ; if ( getWrapper ( ) . getId ( ) != null ) { this . getOwningTarget ( ) . replaceChild ( this , ( Task ) realThing ) ; } } if ( task != null ) { task . maybeConfigure ( ) ; } else { getWrapper ( ) . maybeConfigure ( getProject ( ) ) ; } handleChildren ( realThing , getWrapper ( ) ) ; } protected void handleOutput ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( realThing instanceof Task ) { return ( ( Task ) realThing ) . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } protected void handleErrorOutput ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void handleErrorFlush ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void execute ( ) { if ( realThing == null ) { throw new BuildException ( "Could not create task of type: " + elementName , getLocation ( ) ) ; } if ( realThing instanceof Task ) { ( ( Task ) realThing ) . execute ( ) ; } realThing = null ; getWrapper ( ) . setProxy ( null ) ; } public void addChild ( UnknownElement child ) { if ( children == null ) { children = new ArrayList ( ) ; } children . add ( child ) ; } protected void handleChildren ( Object parent , RuntimeConfigurable parentWrapper ) throws BuildException { if ( parent instanceof TypeAdapter ) { parent = ( ( TypeAdapter ) parent ) . getProxy ( ) ; } String parentUri = getNamespace ( ) ; Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( getProject ( ) , parentClass ) ; if ( children != null ) { Iterator it = children . iterator ( ) ; for ( int i = 0 ; it . hasNext ( ) ; i ++ ) { RuntimeConfigurable childWrapper = parentWrapper . getChild ( i ) ; UnknownElement child = ( UnknownElement ) it . next ( ) ; try { if ( ! handleChild ( parentUri , ih , parent , child , childWrapper ) ) { if ( ! ( parent instanceof TaskContainer ) ) { ih . throwNotSupported ( getProject ( ) , parent , child . getTag ( ) ) ; } else { TaskContainer container = ( TaskContainer ) parent ; container . addTask ( child ) ; } } } catch ( UnsupportedElementException ex ) { throw new BuildException ( parentWrapper . getElementTag ( ) + " doesn't support the nested \"" + ex . getElement ( ) + "\" element." , ex ) ; } } } } protected String getComponentName ( ) { return ProjectHelper . genComponentName ( getNamespace ( ) , getTag ( ) ) ; } public void applyPreSet ( UnknownElement u ) { if ( presetDefed ) { return ; } getWrapper ( ) . applyPreSet ( u . getWrapper ( ) ) ; if ( u . children != null ) { List newChildren = new ArrayList ( ) ; newChildren . addAll ( u . children ) ; if ( children != null ) { newChildren . addAll ( children ) ; } children = newChildren ; } presetDefed = true ; } protected Object makeObject ( UnknownElement ue , RuntimeConfigurable w ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String name = ue . getComponentName ( ) ; Object o = helper . createComponent ( ue , ue . getNamespace ( ) , name ) ; if ( o == null ) { throw getNotFoundException ( "task or type" , name ) ; } if ( o instanceof PreSetDef . PreSetDefinition ) { PreSetDef . PreSetDefinition def = ( PreSetDef . PreSetDefinition ) o ; o = def . createObject ( ue . getProject ( ) ) ; if ( o == null ) { throw getNotFoundException ( "preset " + name , def . getPreSets ( ) . getComponentName ( ) ) ; } ue . applyPreSet ( def . getPreSets ( ) ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . setTaskType ( ue . getTaskType ( ) ) ; task . setTaskName ( ue . getTaskName ( ) ) ; task . init ( ) ; } } if ( o instanceof UnknownElement ) { o = ( ( UnknownElement ) o ) . makeObject ( ( UnknownElement ) o , w ) ; } if ( o instanceof Task ) { ( ( Task ) o ) . setOwningTarget ( getOwningTarget ( ) ) ; } if ( o instanceof ProjectComponent ) { ( ( ProjectComponent ) o ) . setLocation ( getLocation ( ) ) ; } return o ; } protected Task makeTask ( UnknownElement ue , RuntimeConfigurable w ) { Task task = getProject ( ) . createTask ( ue . getTag ( ) ) ; if ( task != null ) { task . setLocation ( getLocation ( ) ) ; task . setOwningTarget ( getOwningTarget ( ) ) ; task . init ( ) ; } return task ; } protected BuildException getNotFoundException ( String what , String name ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String msg = helper . diagnoseCreationFailure ( name , what ) ; return new BuildException ( msg , getLocation ( ) ) ; } public String getTaskName ( ) { return realThing == null || ! ( realThing instanceof Task ) ? super . getTaskName ( ) : ( ( Task ) realThing ) . getTaskName ( ) ; } public Task getTask ( ) { if ( realThing instanceof Task ) { return ( Task ) realThing ; } return null ; } public Object getRealThing ( ) { return realThing ; } public void setRealThing ( Object realThing ) { this . realThing = realThing ; } private boolean handleChild ( String parentUri , IntrospectionHelper ih , Object parent , UnknownElement child , RuntimeConfigurable childWrapper ) { String childName = ProjectHelper . genComponentName ( child . getNamespace ( ) , child . getTag ( ) ) ; if ( ih . supportsNestedElement ( parentUri , childName ) ) { IntrospectionHelper . Creator creator = ih . getElementCreator ( getProject ( ) , parentUri , parent , childName , child ) ; creator . setPolyType ( childWrapper . getPolyType ( ) ) ; Object realChild = creator . create ( ) ; if ( realChild instanceof PreSetDef . PreSetDefinition ) { PreSetDef . PreSetDefinition def = ( PreSetDef . PreSetDefinition ) realChild ; realChild = creator . getRealObject ( ) ; child . applyPreSet ( def . getPreSets ( ) ) ; } childWrapper . setCreator ( creator ) ; childWrapper . setProxy ( realChild ) ; if ( realChild instanceof Task ) { Task childTask = ( Task ) realChild ; childTask . setRuntimeConfigurableWrapper ( childWrapper ) ; childTask . setTaskName ( childName ) ; childTask . setTaskType ( childName ) ; } if ( realChild instanceof ProjectComponent ) { ( ( ProjectComponent ) realChild ) . setLocation ( child . getLocation ( ) ) ; } childWrapper . maybeConfigure ( getProject ( ) ) ; child . handleChildren ( realChild , childWrapper ) ; creator . store ( ) ; return true ; } return false ; } public boolean similar ( Object obj ) { if ( obj == null ) { return false ; } if ( ! getClass ( ) . getName ( ) . equals ( obj . getClass ( ) . getName ( ) ) ) { return false ; } UnknownElement other = ( UnknownElement ) obj ; if ( ! equalsString ( elementName , other . elementName ) ) { return false ; } if ( ! namespace . equals ( other . namespace ) ) { return false ; } if ( ! qname . equals ( other . qname ) ) { return false ; } if ( ! getWrapper ( ) . getAttributeMap ( ) . equals ( other . getWrapper ( ) . getAttributeMap ( ) ) ) { return false ; } if ( ! getWrapper ( ) . getText ( ) . toString ( ) . equals ( other . getWrapper ( ) . getText ( ) . toString ( ) ) ) { return false ; } if ( children == null || children . size ( ) == 0 ) { return other . children == null || other . children . size ( ) == 0 ; } if ( other . children == null ) { return false ; } if ( children . size ( ) != other . children . size ( ) ) { return false ; } for ( int i = 0 ; i < children . size ( ) ; ++ i ) { UnknownElement child = ( UnknownElement ) children . get ( i ) ; if ( ! child . similar ( other . children . get ( i ) ) ) { return false ; } } return true ; } private static boolean equalsString ( String a , String b ) { return ( a == null ) ? ( b == null ) : a . equals ( b ) ; } public UnknownElement copy ( Project newProject ) { UnknownElement ret = new UnknownElement ( getTag ( ) ) ; ret . setNamespace ( getNamespace ( ) ) ; ret . setProject ( newProject ) ; ret . setQName ( getQName ( ) ) ; ret . setTaskType ( getTaskType ( ) ) ; ret . setTaskName ( getTaskName ( ) ) ; ret . setLocation ( getLocation ( ) ) ; if ( getOwningTarget ( ) == null ) { Target t = new Target ( ) ; t . setProject ( getProject ( ) ) ; ret . setOwningTarget ( t ) ; } else { ret . setOwningTarget ( getOwningTarget ( ) ) ; } RuntimeConfigurable copyRC = new RuntimeConfigurable ( ret , getTaskName ( ) ) ; copyRC . setPolyType ( getWrapper ( ) . getPolyType ( ) ) ; Map m = getWrapper ( ) . getAttributeMap ( ) ; for ( Iterator i = m . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; copyRC . setAttribute ( ( String ) entry . getKey ( ) , ( String ) entry . getValue ( ) ) ; } copyRC . addText ( getWrapper ( ) . getText ( ) . toString ( ) ) ; for ( Enumeration e = getWrapper ( ) . getChildren ( ) ; e . hasMoreElements ( ) ; ) { RuntimeConfigurable r = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement ueChild = ( UnknownElement ) r . getProxy ( ) ; UnknownElement copyChild = ueChild . copy ( newProject ) ; copyRC . addChild ( copyChild . getWrapper ( ) ) ; ret . addChild ( copyChild ) ; } return ret ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . security . DigestInputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . NoSuchProviderException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileInputStream ; import java . io . FileReader ; import java . io . BufferedReader ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Iterator ; import java . util . Hashtable ; import java . util . Enumeration ; import java . util . Set ; import java . util . Arrays ; import java . text . MessageFormat ; import java . text . ParseException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . Type ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Checksum extends MatchingTask implements Condition { private static class FileUnion extends Restrict { private Union u ; FileUnion ( ) { u = new Union ( ) ; super . add ( u ) ; super . add ( Type . FILE ) ; } public void add ( ResourceCollection rc ) { u . add ( rc ) ; } } private File file = null ; private File todir ; private String algorithm = "MD5" ; private String provider = null ; private String fileext ; private String property ; private Map allDigests = new HashMap ( ) ; private Map relativeFilePaths = new HashMap ( ) ; private String totalproperty ; private boolean forceOverwrite ; private String verifyProperty ; private FileUnion resources = null ; private Hashtable includeFileMap = new Hashtable ( ) ; private MessageDigest messageDigest ; private boolean isCondition ; private int readBufferSize = 8 * 1024 ; private MessageFormat format = FormatElement . getDefault ( ) . getFormat ( ) ; public void setFile ( File file ) { this . file = file ; } public void setTodir ( File todir ) { this . todir = todir ; } public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void setProvider ( String provider ) { this . provider = provider ; } public void setFileext ( String fileext ) { this . fileext = fileext ; } public void setProperty ( String property ) { this . property = property ; } public void setTotalproperty ( String totalproperty ) { this . totalproperty = totalproperty ; } public void setVerifyproperty ( String verifyProperty ) { this . verifyProperty = verifyProperty ; } public void setForceOverwrite ( boolean forceOverwrite ) { this . forceOverwrite = forceOverwrite ; } public void setReadBufferSize ( int size ) { this . readBufferSize = size ; } public void setFormat ( FormatElement e ) { format = e . getFormat ( ) ; } public void setPattern ( String p ) { format = new MessageFormat ( p ) ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { if ( rc == null ) { return ; } resources = ( resources == null ) ? new FileUnion ( ) : resources ; resources . add ( rc ) ; } public void execute ( ) throws BuildException { isCondition = false ; boolean value = validateAndExecute ( ) ; if ( verifyProperty != null ) { getProject ( ) . setNewProperty ( verifyProperty , ( value ? Boolean . TRUE . toString ( ) : Boolean . FALSE . toString ( ) ) ) ; } } public boolean eval ( ) throws BuildException { isCondition = true ; return validateAndExecute ( ) ; } private boolean validateAndExecute ( ) throws BuildException { String savedFileExt = fileext ; if ( file == null && ( resources == null || resources . size ( ) == 0 ) ) { throw new BuildException ( "Specify at least one source - a file or a resource collection." ) ; } if ( ! ( resources == null || resources . isFilesystemOnly ( ) ) ) { throw new BuildException ( "Can only calculate checksums for file-based resources." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Checksum cannot be generated for directories" ) ; } if ( file != null && totalproperty != null ) { throw new BuildException ( "File and Totalproperty cannot co-exist." ) ; } if ( property != null && fileext != null ) { throw new BuildException ( "Property and FileExt cannot co-exist." ) ; } if ( property != null ) { if ( forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when Property is specified" ) ; } int ct = 0 ; if ( resources != null ) { ct += resources . size ( ) ; } if ( file != null ) { ct ++ ; } if ( ct > 1 ) { throw new BuildException ( "Multiple files cannot be used when Property is specified" ) ; } } if ( verifyProperty != null ) { isCondition = true ; } if ( verifyProperty != null && forceOverwrite ) { throw new BuildException ( "VerifyProperty and ForceOverwrite cannot co-exist." ) ; } if ( isCondition && forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when conditions are being used." ) ; } messageDigest = null ; if ( provider != null ) { try { messageDigest = MessageDigest . getInstance ( algorithm , provider ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , getLocation ( ) ) ; } catch ( NoSuchProviderException noprovider ) { throw new BuildException ( noprovider , getLocation ( ) ) ; } } else { try { messageDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , getLocation ( ) ) ; } } if ( messageDigest == null ) { throw new BuildException ( "Unable to create Message Digest" , getLocation ( ) ) ; } if ( fileext == null ) { fileext = "." + algorithm ; } else if ( fileext . trim ( ) . length ( ) == 0 ) { throw new BuildException ( "File extension when specified must not be an empty string" ) ; } try { if ( resources != null ) { for ( Iterator i = resources . iterator ( ) ; i . hasNext ( ) ; ) { FileResource fr = ( FileResource ) i . next ( ) ; File src = fr . getFile ( ) ; if ( totalproperty != null || todir != null ) { relativeFilePaths . put ( src , fr . getName ( ) . replace ( File . separatorChar , '/' ) ) ; } addToIncludeFileMap ( src ) ; } } if ( file != null ) { if ( totalproperty != null || todir != null ) { relativeFilePaths . put ( file , file . getName ( ) . replace ( File . separatorChar , '/' ) ) ; } addToIncludeFileMap ( file ) ; } return generateChecksums ( ) ; } finally { fileext = savedFileExt ; includeFileMap . clear ( ) ; } } private void addToIncludeFileMap ( File file ) throws BuildException { if ( file . exists ( ) ) { if ( property == null ) { File checksumFile = getChecksumFile ( file ) ; if ( forceOverwrite || isCondition || ( file . lastModified ( ) > checksumFile . lastModified ( ) ) ) { includeFileMap . put ( file , checksumFile ) ; } else { log ( file + " omitted as " + checksumFile + " is up to date." , Project . MSG_VERBOSE ) ; if ( totalproperty != null ) { String checksum = readChecksum ( checksumFile ) ; byte [ ] digest = decodeHex ( checksum . toCharArray ( ) ) ; allDigests . put ( file , digest ) ; } } } else { includeFileMap . put ( file , property ) ; } } else { String message = "Could not find file " + file . getAbsolutePath ( ) + " to generate checksum for." ; log ( message ) ; throw new BuildException ( message , getLocation ( ) ) ; } } private File getChecksumFile ( File file ) { File directory ; if ( todir != null ) { String path = ( String ) relativeFilePaths . get ( file ) ; if ( path == null ) { throw new BuildException ( "Internal error: " + "relativeFilePaths could not match file" + file + "\n" + "please file a bug report on this" ) ; } directory = new File ( todir , path ) . getParentFile ( ) ; directory . mkdirs ( ) ; } else { directory = file . getParentFile ( ) ; } File checksumFile = new File ( directory , file . getName ( ) + fileext ) ; return checksumFile ; } private boolean generateChecksums ( ) throws BuildException { boolean checksumMatches = true ; FileInputStream fis = null ; FileOutputStream fos = null ; byte [ ] buf = new byte [ readBufferSize ] ; try { for ( Enumeration e = includeFileMap . keys ( ) ; e . hasMoreElements ( ) ; ) { messageDigest . reset ( ) ; File src = ( File ) e . nextElement ( ) ; if ( ! isCondition ) { log ( "Calculating " + algorithm + " checksum for " + src , Project . MSG_VERBOSE ) ; } fis = new FileInputStream ( src ) ; DigestInputStream dis = new DigestInputStream ( fis , messageDigest ) ; while ( dis . read ( buf , 0 , readBufferSize ) != - 1 ) { } dis . close ( ) ; fis . close ( ) ; fis = null ; byte [ ] fileDigest = messageDigest . digest ( ) ; if ( totalproperty != null ) { allDigests . put ( src , fileDigest ) ; } String checksum = createDigestString ( fileDigest ) ; Object destination = includeFileMap . get ( src ) ; if ( destination instanceof java . lang . String ) { String prop = ( String ) destination ; if ( isCondition ) { checksumMatches = checksumMatches && checksum . equals ( property ) ; } else { getProject ( ) . setNewProperty ( prop , checksum ) ; } } else if ( destination instanceof java . io . File ) { if ( isCondition ) { File existingFile = ( File ) destination ; if ( existingFile . exists ( ) ) { try { String suppliedChecksum = readChecksum ( existingFile ) ; checksumMatches = checksumMatches && checksum . equals ( suppliedChecksum ) ; } catch ( BuildException be ) { checksumMatches = false ; } } else { checksumMatches = false ; } } else { File dest = ( File ) destination ; fos = new FileOutputStream ( dest ) ; fos . write ( format . format ( new Object [ ] { checksum , src . getName ( ) , } ) . getBytes ( ) ) ; fos . write ( StringUtils . LINE_SEP . getBytes ( ) ) ; fos . close ( ) ; fos = null ; } } } if ( totalproperty != null ) { Set keys = allDigests . keySet ( ) ; Object [ ] keyArray = keys . toArray ( ) ; Arrays . sort ( keyArray ) ; messageDigest . reset ( ) ; for ( int i = 0 ; i < keyArray . length ; i ++ ) { File src = ( File ) keyArray [ i ] ; byte [ ] digest = ( byte [ ] ) allDigests . get ( src ) ; messageDigest . update ( digest ) ; String fileName = ( String ) relativeFilePaths . get ( src ) ; messageDigest . update ( fileName . getBytes ( ) ) ; } String totalChecksum = createDigestString ( messageDigest . digest ( ) ) ; getProject ( ) . setNewProperty ( totalproperty , totalChecksum ) ; } } catch ( Exception e ) { throw new BuildException ( e , getLocation ( ) ) ; } finally { FileUtils . close ( fis ) ; FileUtils . close ( fos ) ; } return checksumMatches ; } private String createDigestString ( byte [ ] fileDigest ) { StringBuffer checksumSb = new StringBuffer ( ) ; for ( int i = 0 ; i < fileDigest . length ; i ++ ) { String hexStr = Integer . toHexString ( 0x00ff & fileDigest [ i ] ) ; if ( hexStr . length ( ) < 2 ) { checksumSb . append ( "0" ) ; } checksumSb . append ( hexStr ) ; } return checksumSb . toString ( ) ; } public static byte [ ] decodeHex ( char [ ] data ) throws BuildException { int l = data . length ; if ( ( l & 0x01 ) != 0 ) { throw new BuildException ( "odd number of characters." ) ; } byte [ ] out = new byte [ l > > 1 ] ; for ( int i = 0 , j = 0 ; j < l ; i ++ ) { int f = Character . digit ( data [ j ++ ] , 16 ) << 4 ; f = f | Character . digit ( data [ j ++ ] , 16 ) ; out [ i ] = ( byte ) ( f & 0xFF ) ; } return out ; } private String readChecksum ( File f ) { BufferedReader diskChecksumReader = null ; try { diskChecksumReader = new BufferedReader ( new FileReader ( f ) ) ; Object [ ] result = format . parse ( diskChecksumReader . readLine ( ) ) ; if ( result == null || result . length == 0 || result [ 0 ] == null ) { throw new BuildException ( "failed to find a checksum" ) ; } return ( String ) result [ 0 ] ; } catch ( IOException e ) { throw new BuildException ( "Couldn't read checksum file " + f , e ) ; } catch ( ParseException e ) { throw new BuildException ( "Couldn't read checksum file " + f , e ) ; } finally { FileUtils . close ( diskChecksumReader ) ; } } public static class FormatElement extends EnumeratedAttribute { private static HashMap formatMap = new HashMap ( ) ; private static final String CHECKSUM = "CHECKSUM" ; private static final String MD5SUM = "MD5SUM" ; private static final String SVF = "SVF" ; static { formatMap . put ( CHECKSUM , new MessageFormat ( "{0}" ) ) ; formatMap . put ( MD5SUM , new MessageFormat ( "{0} *{1}" ) ) ; formatMap . put ( SVF , new MessageFormat ( "MD5 ({1}) = {0}" ) ) ; } public FormatElement ( ) { super ( ) ; } public static FormatElement getDefault ( ) { FormatElement e = new FormatElement ( ) ; e . setValue ( CHECKSUM ) ; return e ; } public MessageFormat getFormat ( ) { return ( MessageFormat ) formatMap . get ( getValue ( ) ) ; } public String [ ] getValues ( ) { return new String [ ] { CHECKSUM , MD5SUM , SVF } ; } } } 	1
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . Stack ; import java . util . Iterator ; import java . util . Collection ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; public abstract class BaseResourceCollectionWrapper extends DataType implements ResourceCollection , Cloneable { private static final String ONE_NESTED_MESSAGE = " expects exactly one nested resource collection." ; private ResourceCollection rc ; private Collection coll = null ; private boolean cache = true ; public synchronized void setCache ( boolean b ) { cache = b ; } public synchronized boolean isCache ( ) { return cache ; } public synchronized void add ( ResourceCollection c ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } if ( rc != null ) { throw oneNested ( ) ; } rc = c ; setChecked ( false ) ; } public final synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionWrapper ) getCheckedRef ( ) ) . iterator ( ) ; } dieOnCircularReference ( ) ; return new FailFast ( this , cacheCollection ( ) . iterator ( ) ) ; } public synchronized int size ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionWrapper ) getCheckedRef ( ) ) . size ( ) ; } dieOnCircularReference ( ) ; return cacheCollection ( ) . size ( ) ; } public synchronized boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionContainer ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } dieOnCircularReference ( ) ; if ( rc == null || rc . isFilesystemOnly ( ) ) { return true ; } for ( Iterator i = cacheCollection ( ) . iterator ( ) ; i . hasNext ( ) ; ) { if ( ! ( i . next ( ) instanceof FileResource ) ) { return false ; } } return true ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( rc instanceof DataType ) { stk . push ( rc ) ; invokeCircularReferenceCheck ( ( DataType ) rc , stk , p ) ; stk . pop ( ) ; } setChecked ( true ) ; } } protected final synchronized ResourceCollection getResourceCollection ( ) { dieOnCircularReference ( ) ; if ( rc == null ) { throw oneNested ( ) ; } return rc ; } protected abstract Collection getCollection ( ) ; public synchronized String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } if ( cacheCollection ( ) . size ( ) == 0 ) { return "" ; } StringBuffer sb = new StringBuffer ( ) ; for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { if ( sb . length ( ) > 0 ) { sb . append ( File . pathSeparatorChar ) ; } sb . append ( i . next ( ) ) ; } return sb . toString ( ) ; } private synchronized Collection cacheCollection ( ) { if ( coll == null || ! isCache ( ) ) { coll = getCollection ( ) ; } return coll ; } private BuildException oneNested ( ) { return new BuildException ( super . toString ( ) + ONE_NESTED_MESSAGE ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . Reader ; import java . io . FileReader ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . util . Vector ; import java . util . Enumeration ; import java . util . NoSuchElementException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . filters . FixCrLfFilter ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileUtils ; public class FixCRLF extends MatchingTask implements ChainableReader { public static final String ERROR_FILE_AND_SRCDIR = "srcdir and file are mutually exclusive" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private boolean preserveLastModified = false ; private File srcDir ; private File destDir = null ; private File file ; private FixCrLfFilter filter = new FixCrLfFilter ( ) ; private Vector fcv = null ; private String encoding = null ; private String outputEncoding = null ; public final Reader chain ( final Reader rdr ) { return filter . chain ( rdr ) ; } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setJavafiles ( boolean javafiles ) { filter . setJavafiles ( javafiles ) ; } public void setFile ( File file ) { this . file = file ; } public void setEol ( CrLf attr ) { filter . setEol ( FixCrLfFilter . CrLf . newInstance ( attr . getValue ( ) ) ) ; } public void setCr ( AddAsisRemove attr ) { log ( "DEPRECATED: The cr attribute has been deprecated," , Project . MSG_WARN ) ; log ( "Please use the eol attribute instead" , Project . MSG_WARN ) ; String option = attr . getValue ( ) ; CrLf c = new CrLf ( ) ; if ( option . equals ( "remove" ) ) { c . setValue ( "lf" ) ; } else if ( option . equals ( "asis" ) ) { c . setValue ( "asis" ) ; } else { c . setValue ( "crlf" ) ; } setEol ( c ) ; } public void setTab ( AddAsisRemove attr ) { filter . setTab ( FixCrLfFilter . AddAsisRemove . newInstance ( attr . getValue ( ) ) ) ; } public void setTablength ( int tlength ) throws BuildException { try { filter . setTablength ( tlength ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } public void setEof ( AddAsisRemove attr ) { filter . setEof ( FixCrLfFilter . AddAsisRemove . newInstance ( attr . getValue ( ) ) ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setFixlast ( boolean fixlast ) { filter . setFixlast ( fixlast ) ; } public void setPreserveLastModified ( boolean preserve ) { preserveLastModified = preserve ; } public void execute ( ) throws BuildException { validate ( ) ; String enc = encoding == null ? "default" : encoding ; log ( "options:" + " eol=" + filter . getEol ( ) . getValue ( ) + " tab=" + filter . getTab ( ) . getValue ( ) + " eof=" + filter . getEof ( ) . getValue ( ) + " tablength=" + filter . getTablength ( ) + " encoding=" + enc + " outputencoding=" + ( outputEncoding == null ? enc : outputEncoding ) , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { processFile ( files [ i ] ) ; } } private void validate ( ) throws BuildException { if ( file != null ) { if ( srcDir != null ) { throw new BuildException ( ERROR_FILE_AND_SRCDIR ) ; } fileset . setFile ( file ) ; srcDir = file . getParentFile ( ) ; } if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } } private void processFile ( String file ) throws BuildException { File srcFile = new File ( srcDir , file ) ; long lastModified = srcFile . lastModified ( ) ; File destD = destDir == null ? srcDir : destDir ; if ( fcv == null ) { FilterChain fc = new FilterChain ( ) ; fc . add ( filter ) ; fcv = new Vector ( 1 ) ; fcv . add ( fc ) ; } File tmpFile = FILE_UTILS . createTempFile ( "fixcrlf" , "" , null ) ; tmpFile . deleteOnExit ( ) ; try { FILE_UTILS . copyFile ( srcFile , tmpFile , null , fcv , false , false , encoding , outputEncoding == null ? encoding : outputEncoding , getProject ( ) ) ; File destFile = new File ( destD , file ) ; boolean destIsWrong = true ; if ( destFile . exists ( ) ) { log ( "destFile exists" , Project . MSG_DEBUG ) ; destIsWrong = ! FILE_UTILS . contentEquals ( destFile , tmpFile ) ; log ( destFile + ( destIsWrong ? " is being written" : " is not written, as the contents are identical" ) , Project . MSG_DEBUG ) ; } if ( destIsWrong ) { FILE_UTILS . rename ( tmpFile , destFile ) ; if ( preserveLastModified ) { log ( "preserved lastModified" , Project . MSG_DEBUG ) ; FILE_UTILS . setFileLastModified ( destFile , lastModified ) ; } tmpFile = null ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected class OneLiner implements Enumeration { private static final int UNDEF = - 1 ; private static final int NOTJAVA = 0 ; private static final int LOOKING = 1 ; private static final int INBUFLEN = 8192 ; private static final int LINEBUFLEN = 200 ; private static final char CTRLZ = '' ; private int state = filter . getJavafiles ( ) ? LOOKING : NOTJAVA ; private StringBuffer eolStr = new StringBuffer ( LINEBUFLEN ) ; private StringBuffer eofStr = new StringBuffer ( ) ; private BufferedReader reader ; private StringBuffer line = new StringBuffer ( ) ; private boolean reachedEof = false ; private File srcFile ; public OneLiner ( File srcFile ) throws BuildException { this . srcFile = srcFile ; try { reader = new BufferedReader ( ( ( encoding == null ) ? new FileReader ( srcFile ) : new InputStreamReader ( new FileInputStream ( srcFile ) , encoding ) ) , INBUFLEN ) ; nextLine ( ) ; } catch ( IOException e ) { throw new BuildException ( srcFile + ": " + e . getMessage ( ) , e , getLocation ( ) ) ; } } protected void nextLine ( ) throws BuildException { int ch = - 1 ; int eolcount = 0 ; eolStr = new StringBuffer ( ) ; line = new StringBuffer ( ) ; try { ch = reader . read ( ) ; while ( ch != - 1 && ch != '\r' && ch != '\n' ) { line . append ( ( char ) ch ) ; ch = reader . read ( ) ; } if ( ch == - 1 && line . length ( ) == 0 ) { reachedEof = true ; return ; } switch ( ( char ) ch ) { case '\r' : ++ eolcount ; eolStr . append ( '\r' ) ; reader . mark ( 2 ) ; ch = reader . read ( ) ; switch ( ch ) { case '\r' : ch = reader . read ( ) ; if ( ( char ) ( ch ) == '\n' ) { eolcount += 2 ; eolStr . append ( "\r\n" ) ; } else { reader . reset ( ) ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; case - 1 : break ; default : reader . reset ( ) ; break ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; default : } if ( eolcount == 0 ) { int i = line . length ( ) ; while ( -- i >= 0 && line . charAt ( i ) == CTRLZ ) { } if ( i < line . length ( ) - 1 ) { eofStr . append ( line . toString ( ) . substring ( i + 1 ) ) ; if ( i < 0 ) { line . setLength ( 0 ) ; reachedEof = true ; } else { line . setLength ( i + 1 ) ; } } } } catch ( IOException e ) { throw new BuildException ( srcFile + ": " + e . getMessage ( ) , e , getLocation ( ) ) ; } } public String getEofStr ( ) { return eofStr . substring ( 0 ) ; } public int getState ( ) { return state ; } public void setState ( int state ) { this . state = state ; } public boolean hasMoreElements ( ) { return ! reachedEof ; } public Object nextElement ( ) throws NoSuchElementException { if ( ! hasMoreElements ( ) ) { throw new NoSuchElementException ( "OneLiner" ) ; } BufferLine tmpLine = new BufferLine ( line . toString ( ) , eolStr . substring ( 0 ) ) ; nextLine ( ) ; return tmpLine ; } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } class BufferLine { private int next = 0 ; private int column = 0 ; private int lookahead = UNDEF ; private String line ; private String eolStr ; public BufferLine ( String line , String eolStr ) throws BuildException { next = 0 ; column = 0 ; this . line = line ; this . eolStr = eolStr ; } public int getNext ( ) { return next ; } public void setNext ( int next ) { this . next = next ; } public int getLookahead ( ) { return lookahead ; } public void setLookahead ( int lookahead ) { this . lookahead = lookahead ; } public char getChar ( int i ) { return line . charAt ( i ) ; } public char getNextChar ( ) { return getChar ( next ) ; } public char getNextCharInc ( ) { return getChar ( next ++ ) ; } public int getColumn ( ) { return column ; } public void setColumn ( int col ) { column = col ; } public int incColumn ( ) { return column ++ ; } public int length ( ) { return line . length ( ) ; } public int getEolLength ( ) { return eolStr . length ( ) ; } public String getLineString ( ) { return line ; } public String getEol ( ) { return eolStr ; } public String substring ( int begin ) { return line . substring ( begin ) ; } public String substring ( int begin , int end ) { return line . substring ( begin , end ) ; } public void setState ( int state ) { OneLiner . this . setState ( state ) ; } public int getState ( ) { return OneLiner . this . getState ( ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } public static class CrLf extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" , "mac" , "unix" , "dos" } ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapter ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapterFactory ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . GlobPatternMapper ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; public class Javac extends MatchingTask { private static final String FAIL_MSG = "Compile failed; see the compiler error output for details." ; private static final String JAVAC16 = "javac1.6" ; private static final String JAVAC15 = "javac1.5" ; private static final String JAVAC14 = "javac1.4" ; private static final String JAVAC13 = "javac1.3" ; private static final String JAVAC12 = "javac1.2" ; private static final String JAVAC11 = "javac1.1" ; private static final String MODERN = "modern" ; private static final String CLASSIC = "classic" ; private static final String EXTJAVAC = "extJavac" ; private Path src ; private File destDir ; private Path compileClasspath ; private Path compileSourcepath ; private String encoding ; private boolean debug = false ; private boolean optimize = false ; private boolean deprecation = false ; private boolean depend = false ; private boolean verbose = false ; private String targetAttribute ; private Path bootclasspath ; private Path extdirs ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private boolean fork = false ; private String forkedExecutable = null ; private boolean nowarn = false ; private String memoryInitialSize ; private String memoryMaximumSize ; private FacadeTaskHelper facade = null ; protected boolean failOnError = true ; protected boolean listFiles = false ; protected File [ ] compileList = new File [ 0 ] ; private String source ; private String debugLevel ; private File tmpDir ; public Javac ( ) { facade = new FacadeTaskHelper ( assumedJavaVersion ( ) ) ; } private String assumedJavaVersion ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) { return JAVAC12 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) { return JAVAC13 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) { return JAVAC14 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_5 ) ) { return JAVAC15 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_6 ) ) { return JAVAC16 ; } else { return CLASSIC ; } } public String getDebugLevel ( ) { return debugLevel ; } public void setDebugLevel ( String v ) { this . debugLevel = v ; } public String getSource ( ) { return source != null ? source : getProject ( ) . getProperty ( MagicNames . BUILD_JAVAC_SOURCE ) ; } public void setSource ( String v ) { this . source = v ; } public Path createSrc ( ) { if ( src == null ) { src = new Path ( getProject ( ) ) ; } return src . createPath ( ) ; } protected Path recreateSrc ( ) { src = null ; return createSrc ( ) ; } public void setSrcdir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcdir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setSourcepath ( Path sourcepath ) { if ( compileSourcepath == null ) { compileSourcepath = sourcepath ; } else { compileSourcepath . append ( sourcepath ) ; } } public Path getSourcepath ( ) { return compileSourcepath ; } public Path createSourcepath ( ) { if ( compileSourcepath == null ) { compileSourcepath = new Path ( getProject ( ) ) ; } return compileSourcepath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } } public Path getBootclasspath ( ) { return bootclasspath ; } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path getExtdirs ( ) { return extdirs ; } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( getProject ( ) ) ; } return extdirs . createPath ( ) ; } public void setListfiles ( boolean list ) { listFiles = list ; } public boolean getListfiles ( ) { return listFiles ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setProceed ( boolean proceed ) { failOnError = ! proceed ; } public boolean getFailonerror ( ) { return failOnError ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean getDeprecation ( ) { return deprecation ; } public void setMemoryInitialSize ( String memoryInitialSize ) { this . memoryInitialSize = memoryInitialSize ; } public String getMemoryInitialSize ( ) { return memoryInitialSize ; } public void setMemoryMaximumSize ( String memoryMaximumSize ) { this . memoryMaximumSize = memoryMaximumSize ; } public String getMemoryMaximumSize ( ) { return memoryMaximumSize ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setOptimize ( boolean optimize ) { this . optimize = optimize ; } public boolean getOptimize ( ) { return optimize ; } public void setDepend ( boolean depend ) { this . depend = depend ; } public boolean getDepend ( ) { return depend ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setTarget ( String target ) { this . targetAttribute = target ; } public String getTarget ( ) { return targetAttribute != null ? targetAttribute : getProject ( ) . getProperty ( MagicNames . BUILD_JAVAC_TARGET ) ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setFork ( boolean f ) { fork = f ; } public void setExecutable ( String forkExec ) { forkedExecutable = forkExec ; } public String getExecutable ( ) { return forkedExecutable ; } public boolean isForkedJavac ( ) { return fork || "extJavac" . equals ( getCompiler ( ) ) ; } public String getJavacExecutable ( ) { if ( forkedExecutable == null && isForkedJavac ( ) ) { forkedExecutable = getSystemJavac ( ) ; } else if ( forkedExecutable != null && ! isForkedJavac ( ) ) { forkedExecutable = null ; } return forkedExecutable ; } public void setNowarn ( boolean flag ) { this . nowarn = flag ; } public boolean getNowarn ( ) { return nowarn ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { String chosen = facade . getExplicitChoice ( ) ; try { String appliedCompiler = getCompiler ( ) ; facade . setImplementation ( appliedCompiler ) ; String [ ] result = facade . getArgs ( ) ; String altCompilerName = getAltCompilerName ( facade . getImplementation ( ) ) ; if ( result . length == 0 && altCompilerName != null ) { facade . setImplementation ( altCompilerName ) ; result = facade . getArgs ( ) ; } return result ; } finally { facade . setImplementation ( chosen ) ; } } private String getAltCompilerName ( String anImplementation ) { if ( JAVAC16 . equalsIgnoreCase ( anImplementation ) || JAVAC15 . equalsIgnoreCase ( anImplementation ) || JAVAC14 . equalsIgnoreCase ( anImplementation ) || JAVAC13 . equalsIgnoreCase ( anImplementation ) ) { return MODERN ; } if ( JAVAC12 . equalsIgnoreCase ( anImplementation ) || JAVAC11 . equalsIgnoreCase ( anImplementation ) ) { return CLASSIC ; } if ( MODERN . equalsIgnoreCase ( anImplementation ) ) { String nextSelected = assumedJavaVersion ( ) ; if ( JAVAC16 . equalsIgnoreCase ( nextSelected ) || JAVAC15 . equalsIgnoreCase ( nextSelected ) || JAVAC14 . equalsIgnoreCase ( nextSelected ) || JAVAC13 . equalsIgnoreCase ( nextSelected ) ) { return nextSelected ; } } if ( CLASSIC . equals ( anImplementation ) ) { return assumedJavaVersion ( ) ; } if ( EXTJAVAC . equalsIgnoreCase ( anImplementation ) ) { return assumedJavaVersion ( ) ; } return null ; } public void setTempdir ( File tmpDir ) { this . tmpDir = tmpDir ; } public File getTempdir ( ) { return tmpDir ; } public void execute ( ) throws BuildException { checkParameters ( ) ; resetFileLists ( ) ; String [ ] list = src . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = getProject ( ) . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , getLocation ( ) ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir != null ? destDir : srcDir , files ) ; } compile ( ) ; } protected void resetFileLists ( ) { compileList = new File [ 0 ] ; } protected void scanDir ( File srcDir , File destDir , String [ ] files ) { GlobPatternMapper m = new GlobPatternMapper ( ) ; m . setFrom ( "*.java" ) ; m . setTo ( "*.class" ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; File [ ] newFiles = sfs . restrictAsFiles ( files , srcDir , destDir , m ) ; if ( newFiles . length > 0 ) { File [ ] newCompileList = new File [ compileList . length + newFiles . length ] ; System . arraycopy ( compileList , 0 , newCompileList , 0 , compileList . length ) ; System . arraycopy ( newFiles , 0 , newCompileList , compileList . length , newFiles . length ) ; compileList = newCompileList ; } } public File [ ] getFileList ( ) { return compileList ; } protected boolean isJdkCompiler ( String compilerImpl ) { return MODERN . equals ( compilerImpl ) || CLASSIC . equals ( compilerImpl ) || JAVAC16 . equals ( compilerImpl ) || JAVAC15 . equals ( compilerImpl ) || JAVAC14 . equals ( compilerImpl ) || JAVAC13 . equals ( compilerImpl ) || JAVAC12 . equals ( compilerImpl ) || JAVAC11 . equals ( compilerImpl ) ; } protected String getSystemJavac ( ) { return JavaEnvUtils . getJdkExecutable ( "javac" ) ; } public void setCompiler ( String compiler ) { facade . setImplementation ( compiler ) ; } public String getCompiler ( ) { String compilerImpl = getCompilerVersion ( ) ; if ( fork ) { if ( isJdkCompiler ( compilerImpl ) ) { compilerImpl = "extJavac" ; } else { log ( "Since compiler setting isn't classic or modern," + "ignoring fork setting." , Project . MSG_WARN ) ; } } return compilerImpl ; } public String getCompilerVersion ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.compiler" ) ) ; return facade . getImplementation ( ) ; } protected void checkParameters ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( src . size ( ) == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( destDir != null && ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist " + "or is not a directory" , getLocation ( ) ) ; } } protected void compile ( ) { String compilerImpl = getCompiler ( ) ; if ( compileList . length > 0 ) { log ( "Compiling " + compileList . length + " source file" + ( compileList . length == 1 ? "" : "s" ) + ( destDir != null ? " to " + destDir : "" ) ) ; if ( listFiles ) { for ( int i = 0 ; i < compileList . length ; i ++ ) { String filename = compileList [ i ] . getAbsolutePath ( ) ; log ( filename ) ; } } CompilerAdapter adapter = CompilerAdapterFactory . getCompiler ( compilerImpl , this ) ; adapter . setJavac ( this ) ; if ( ! adapter . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , getLocation ( ) ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	1
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; import java . util . Iterator ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . FileResourceIterator ; public abstract class ArchiveScanner extends DirectoryScanner { protected File srcFile ; private Resource src ; private Resource lastScannedResource ; private TreeMap fileEntries = new TreeMap ( ) ; private TreeMap dirEntries = new TreeMap ( ) ; private TreeMap matchFileEntries = new TreeMap ( ) ; private TreeMap matchDirEntries = new TreeMap ( ) ; private String encoding ; public void scan ( ) { if ( src == null ) { return ; } super . scan ( ) ; } public void setSrc ( File srcFile ) { setSrc ( new FileResource ( srcFile ) ) ; } public void setSrc ( Resource src ) { this . src = src ; if ( src instanceof FileResource ) { srcFile = ( ( FileResource ) src ) . getFile ( ) ; } } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String [ ] getIncludedFiles ( ) { if ( src == null ) { return super . getIncludedFiles ( ) ; } scanme ( ) ; Set s = matchFileEntries . keySet ( ) ; return ( String [ ] ) ( s . toArray ( new String [ s . size ( ) ] ) ) ; } public int getIncludedFilesCount ( ) { if ( src == null ) { return super . getIncludedFilesCount ( ) ; } scanme ( ) ; return matchFileEntries . size ( ) ; } public String [ ] getIncludedDirectories ( ) { if ( src == null ) { return super . getIncludedDirectories ( ) ; } scanme ( ) ; Set s = matchDirEntries . keySet ( ) ; return ( String [ ] ) ( s . toArray ( new String [ s . size ( ) ] ) ) ; } public int getIncludedDirsCount ( ) { if ( src == null ) { return super . getIncludedDirsCount ( ) ; } scanme ( ) ; return matchDirEntries . size ( ) ; } Iterator getResourceFiles ( ) { if ( src == null ) { return new FileResourceIterator ( getBasedir ( ) , getIncludedFiles ( ) ) ; } scanme ( ) ; return matchFileEntries . values ( ) . iterator ( ) ; } Iterator getResourceDirectories ( ) { if ( src == null ) { return new FileResourceIterator ( getBasedir ( ) , getIncludedDirectories ( ) ) ; } scanme ( ) ; return matchDirEntries . values ( ) . iterator ( ) ; } public void init ( ) { if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } } public boolean match ( String path ) { String vpath = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; return isIncluded ( vpath ) && ! isExcluded ( vpath ) ; } public Resource getResource ( String name ) { if ( src == null ) { return super . getResource ( name ) ; } if ( name . equals ( "" ) ) { return new Resource ( "" , true , Long . MAX_VALUE , true ) ; } scanme ( ) ; if ( fileEntries . containsKey ( name ) ) { return ( Resource ) fileEntries . get ( name ) ; } name = trimSeparator ( name ) ; if ( dirEntries . containsKey ( name ) ) { return ( Resource ) dirEntries . get ( name ) ; } return new Resource ( name ) ; } protected abstract void fillMapsFromArchive ( Resource archive , String encoding , Map fileEntries , Map matchFileEntries , Map dirEntries , Map matchDirEntries ) ; private void scanme ( ) { Resource thisresource = new Resource ( src . getName ( ) , src . isExists ( ) , src . getLastModified ( ) ) ; if ( lastScannedResource != null && lastScannedResource . getName ( ) . equals ( thisresource . getName ( ) ) && lastScannedResource . getLastModified ( ) == thisresource . getLastModified ( ) ) { return ; } init ( ) ; fileEntries . clear ( ) ; dirEntries . clear ( ) ; matchFileEntries . clear ( ) ; matchDirEntries . clear ( ) ; fillMapsFromArchive ( src , encoding , fileEntries , matchFileEntries , dirEntries , matchDirEntries ) ; lastScannedResource = thisresource ; } protected static final String trimSeparator ( String s ) { return s . endsWith ( "/" ) ? s . substring ( 0 , s . length ( ) - 1 ) : s ; } } 	1
package org . apache . tools . ant . types . resources ; import java . io . IOException ; import java . io . InputStream ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; public class JavaResource extends Resource { private Path classpath ; private Reference loader ; public JavaResource ( ) { } public JavaResource ( String name , Path path ) { setName ( name ) ; classpath = path ; } public void setClasspath ( Path classpath ) { checkAttributesAllowed ( ) ; if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { checkChildrenAllowed ( ) ; if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { checkAttributesAllowed ( ) ; createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return isReference ( ) ? ( ( JavaResource ) getCheckedRef ( ) ) . getClasspath ( ) : classpath ; } public void setLoaderRef ( Reference r ) { checkAttributesAllowed ( ) ; loader = r ; } public void setRefid ( Reference r ) { if ( loader != null || classpath != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public boolean isExists ( ) { InputStream is = null ; try { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) : ( is = getInputStream ( ) ) != null ; } catch ( IOException ex ) { return false ; } finally { FileUtils . close ( is ) ; } } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } ClassLoader cl = null ; if ( loader != null ) { cl = ( ClassLoader ) loader . getReferencedObject ( ) ; } if ( cl == null ) { if ( getClasspath ( ) != null ) { cl = getProject ( ) . createClassLoader ( classpath ) ; } else { cl = JavaResource . class . getClassLoader ( ) ; } if ( loader != null && cl != null ) { getProject ( ) . addReference ( loader . getRefId ( ) , cl ) ; } } return cl == null ? ClassLoader . getSystemResourceAsStream ( getName ( ) ) : cl . getResourceAsStream ( getName ( ) ) ; } public int compareTo ( Object another ) { if ( isReference ( ) ) { return ( ( Comparable ) getCheckedRef ( ) ) . compareTo ( another ) ; } if ( another . getClass ( ) . equals ( getClass ( ) ) ) { JavaResource otherjr = ( JavaResource ) another ; if ( ! getName ( ) . equals ( otherjr . getName ( ) ) ) { return getName ( ) . compareTo ( otherjr . getName ( ) ) ; } if ( loader != otherjr . loader ) { if ( loader == null ) { return - 1 ; } if ( otherjr . loader == null ) { return 1 ; } return loader . getRefId ( ) . compareTo ( otherjr . loader . getRefId ( ) ) ; } Path p = getClasspath ( ) ; Path op = otherjr . getClasspath ( ) ; if ( p != op ) { if ( p == null ) { return - 1 ; } if ( op == null ) { return 1 ; } return p . toString ( ) . compareTo ( op . toString ( ) ) ; } return 0 ; } return super . compareTo ( another ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import javax . xml . parsers . SAXParser ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . xml . sax . SAXException ; public class IPlanetDeploymentTool extends GenericDeploymentTool { private File iashome ; private String jarSuffix = ".jar" ; private boolean keepgenerated = false ; private boolean debug = false ; private String descriptorName ; private String iasDescriptorName ; private String displayName ; private static final String IAS_DD = "ias-ejb-jar.xml" ; public void setIashome ( File iashome ) { this . iashome = iashome ; } public void setKeepgenerated ( boolean keepgenerated ) { this . keepgenerated = keepgenerated ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setSuffix ( String jarSuffix ) { this . jarSuffix = jarSuffix ; } public void setGenericJarSuffix ( String inString ) { log ( "Since a generic JAR file is not created during processing, the " + "iPlanet Deployment Tool does not support the " + "\"genericjarsuffix\" attribute.  It will be ignored." , Project . MSG_WARN ) ; } public void processDescriptor ( String descriptorName , SAXParser saxParser ) { this . descriptorName = descriptorName ; this . iasDescriptorName = null ; log ( "iPlanet Deployment Tool processing: " + descriptorName + " (and " + getIasDescriptorName ( ) + ")" , Project . MSG_VERBOSE ) ; super . processDescriptor ( descriptorName , saxParser ) ; } protected void checkConfiguration ( String descriptorFileName , SAXParser saxParser ) throws BuildException { int startOfName = descriptorFileName . lastIndexOf ( File . separatorChar ) + 1 ; String stdXml = descriptorFileName . substring ( startOfName ) ; if ( stdXml . equals ( EJB_DD ) && ( getConfig ( ) . baseJarName == null ) ) { String msg = "No name specified for the completed JAR file.  The EJB" + " descriptor should be prepended with the JAR " + "name or it should be specified using the " + "attribute \"basejarname\" in the \"ejbjar\" task." ; throw new BuildException ( msg , getLocation ( ) ) ; } File iasDescriptor = new File ( getConfig ( ) . descriptorDir , getIasDescriptorName ( ) ) ; if ( ( ! iasDescriptor . exists ( ) ) || ( ! iasDescriptor . isFile ( ) ) ) { String msg = "The iAS-specific EJB descriptor (" + iasDescriptor + ") was not found." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( iashome != null ) && ( ! iashome . isDirectory ( ) ) ) { String msg = "If \"iashome\" is specified, it must be a valid " + "directory (it was set to " + iashome + ")." ; throw new BuildException ( msg , getLocation ( ) ) ; } } protected Hashtable parseEjbFiles ( String descriptorFileName , SAXParser saxParser ) throws IOException , SAXException { Hashtable files ; IPlanetEjbc ejbc = new IPlanetEjbc ( new File ( getConfig ( ) . descriptorDir , descriptorFileName ) , new File ( getConfig ( ) . descriptorDir , getIasDescriptorName ( ) ) , getConfig ( ) . srcDir , getCombinedClasspath ( ) . toString ( ) , saxParser ) ; ejbc . setRetainSource ( keepgenerated ) ; ejbc . setDebugOutput ( debug ) ; if ( iashome != null ) { ejbc . setIasHomeDir ( iashome ) ; } try { ejbc . execute ( ) ; } catch ( IPlanetEjbc . EjbcException e ) { throw new BuildException ( "An error has occurred while trying to " + "execute the iAS ejbc utility" , e , getLocation ( ) ) ; } displayName = ejbc . getDisplayName ( ) ; files = ejbc . getEjbFiles ( ) ; String [ ] cmpDescriptors = ejbc . getCmpDescriptors ( ) ; if ( cmpDescriptors . length > 0 ) { File baseDir = getConfig ( ) . descriptorDir ; int endOfPath = descriptorFileName . lastIndexOf ( File . separator ) ; String relativePath = descriptorFileName . substring ( 0 , endOfPath + 1 ) ; for ( int i = 0 ; i < cmpDescriptors . length ; i ++ ) { int endOfCmp = cmpDescriptors [ i ] . lastIndexOf ( '/' ) ; String cmpDescriptor = cmpDescriptors [ i ] . substring ( endOfCmp + 1 ) ; File cmpFile = new File ( baseDir , relativePath + cmpDescriptor ) ; if ( ! cmpFile . exists ( ) ) { throw new BuildException ( "The CMP descriptor file (" + cmpFile + ") could not be found." , getLocation ( ) ) ; } files . put ( cmpDescriptors [ i ] , cmpFile ) ; } } return files ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { ejbFiles . put ( META_DIR + IAS_DD , new File ( getConfig ( ) . descriptorDir , getIasDescriptorName ( ) ) ) ; } File getVendorOutputJarFile ( String baseName ) { File jarFile = new File ( getDestDir ( ) , baseName + jarSuffix ) ; log ( "JAR file name: " + jarFile . toString ( ) , Project . MSG_VERBOSE ) ; return jarFile ; } protected String getPublicId ( ) { return null ; } private String getIasDescriptorName ( ) { if ( iasDescriptorName != null ) { return iasDescriptorName ; } String path = "" ; String basename ; String remainder ; int startOfFileName = descriptorName . lastIndexOf ( File . separatorChar ) ; if ( startOfFileName != - 1 ) { path = descriptorName . substring ( 0 , startOfFileName + 1 ) ; } if ( descriptorName . substring ( startOfFileName + 1 ) . equals ( EJB_DD ) ) { basename = "" ; remainder = EJB_DD ; } else { int endOfBaseName = descriptorName . indexOf ( getConfig ( ) . baseNameTerminator , startOfFileName ) ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . lastIndexOf ( '.' ) - 1 ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . length ( ) - 1 ; } } basename = descriptorName . substring ( startOfFileName + 1 , endOfBaseName + 1 ) ; remainder = descriptorName . substring ( endOfBaseName + 1 ) ; } iasDescriptorName = path + basename + "ias-" + remainder ; return iasDescriptorName ; } } 	1
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . io . OutputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import java . util . Iterator ; import java . util . Properties ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . security . Provider ; import java . security . Security ; import javax . activation . DataHandler ; import javax . activation . FileDataSource ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . Authenticator ; import javax . mail . MessagingException ; import javax . mail . PasswordAuthentication ; import javax . mail . internet . MimeMessage ; import javax . mail . internet . MimeBodyPart ; import javax . mail . internet . MimeMultipart ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . AddressException ; import org . apache . tools . ant . BuildException ; public class MimeMailer extends Mailer { private static final String SSL_FACTORY = "javax.net.ssl.SSLSocketFactory" ; private static final String DEFAULT_CHARSET = System . getProperty ( "file.encoding" ) ; class StringDataSource implements javax . activation . DataSource { private String data = null ; private String type = null ; private String charset = null ; private ByteArrayOutputStream out ; public InputStream getInputStream ( ) throws IOException { if ( data == null && out == null ) { throw new IOException ( "No data" ) ; } if ( out != null ) { String encodedOut = out . toString ( charset ) ; data = ( data != null ) ? data . concat ( encodedOut ) : encodedOut ; out = null ; } return new ByteArrayInputStream ( data . getBytes ( charset ) ) ; } public OutputStream getOutputStream ( ) throws IOException { out = ( out == null ) ? new ByteArrayOutputStream ( ) : out ; return out ; } public void setContentType ( String type ) { this . type = type . toLowerCase ( ) ; } public String getContentType ( ) { if ( type != null && type . indexOf ( "charset" ) > 0 && type . startsWith ( "text/" ) ) { return type ; } return new StringBuffer ( type != null ? type : "text/plain" ) . append ( "; charset=" ) . append ( charset ) . toString ( ) ; } public String getName ( ) { return "StringDataSource" ; } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } public void send ( ) { try { Properties props = new Properties ( ) ; props . put ( "mail.smtp.host" , host ) ; props . put ( "mail.smtp.port" , String . valueOf ( port ) ) ; Session sesh ; Authenticator auth ; if ( SSL ) { try { Provider p = ( Provider ) Class . forName ( "com.sun.net.ssl.internal.ssl.Provider" ) . newInstance ( ) ; Security . addProvider ( p ) ; } catch ( Exception e ) { throw new BuildException ( "could not instantiate ssl " + "security provider, check that you have JSSE in " + "your classpath" ) ; } props . put ( "mail.smtp.socketFactory.class" , SSL_FACTORY ) ; props . put ( "mail.smtp.socketFactory.fallback" , "false" ) ; } if ( user == null && password == null ) { sesh = Session . getDefaultInstance ( props , null ) ; } else { props . put ( "mail.smtp.auth" , "true" ) ; auth = new SimpleAuthenticator ( user , password ) ; sesh = Session . getInstance ( props , auth ) ; } MimeMessage msg = new MimeMessage ( sesh ) ; MimeMultipart attachments = new MimeMultipart ( ) ; if ( from . getName ( ) == null ) { msg . setFrom ( new InternetAddress ( from . getAddress ( ) ) ) ; } else { msg . setFrom ( new InternetAddress ( from . getAddress ( ) , from . getName ( ) ) ) ; } msg . setReplyTo ( internetAddresses ( replyToList ) ) ; msg . setRecipients ( Message . RecipientType . TO , internetAddresses ( toList ) ) ; msg . setRecipients ( Message . RecipientType . CC , internetAddresses ( ccList ) ) ; msg . setRecipients ( Message . RecipientType . BCC , internetAddresses ( bccList ) ) ; String charset = parseCharSetFromMimeType ( message . getMimeType ( ) ) ; if ( charset != null ) { message . setCharset ( charset ) ; } else { charset = message . getCharset ( ) ; if ( charset == null ) { charset = DEFAULT_CHARSET ; message . setCharset ( charset ) ; } } StringDataSource sds = new StringDataSource ( ) ; sds . setContentType ( message . getMimeType ( ) ) ; sds . setCharset ( charset ) ; if ( subject != null ) { msg . setSubject ( subject , charset ) ; } msg . addHeader ( "Date" , getDate ( ) ) ; for ( Iterator iter = headers . iterator ( ) ; iter . hasNext ( ) ; ) { Header h = ( Header ) iter . next ( ) ; msg . addHeader ( h . getName ( ) , h . getValue ( ) ) ; } PrintStream out = new PrintStream ( sds . getOutputStream ( ) ) ; message . print ( out ) ; out . close ( ) ; MimeBodyPart textbody = new MimeBodyPart ( ) ; textbody . setDataHandler ( new DataHandler ( sds ) ) ; attachments . addBodyPart ( textbody ) ; Enumeration e = files . elements ( ) ; while ( e . hasMoreElements ( ) ) { File file = ( File ) e . nextElement ( ) ; MimeBodyPart body ; body = new MimeBodyPart ( ) ; if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getAbsolutePath ( ) + "\" does not exist or is not " + "readable." ) ; } FileDataSource fileData = new FileDataSource ( file ) ; DataHandler fileDataHandler = new DataHandler ( fileData ) ; body . setDataHandler ( fileDataHandler ) ; body . setFileName ( file . getName ( ) ) ; attachments . addBodyPart ( body ) ; } msg . setContent ( attachments ) ; Transport . send ( msg ) ; } catch ( MessagingException e ) { throw new BuildException ( "Problem while sending mime mail:" , e ) ; } catch ( IOException e ) { throw new BuildException ( "Problem while sending mime mail:" , e ) ; } } private static InternetAddress [ ] internetAddresses ( Vector list ) throws AddressException , UnsupportedEncodingException { InternetAddress [ ] addrs = new InternetAddress [ list . size ( ) ] ; for ( int i = 0 ; i < list . size ( ) ; ++ i ) { EmailAddress addr = ( EmailAddress ) list . elementAt ( i ) ; String name = addr . getName ( ) ; addrs [ i ] = ( name == null ) ? new InternetAddress ( addr . getAddress ( ) ) : new InternetAddress ( addr . getAddress ( ) , name ) ; } return addrs ; } private String parseCharSetFromMimeType ( String type ) { int pos ; if ( type == null || ( pos = type . indexOf ( "charset" ) ) < 0 ) { return null ; } StringTokenizer token = new StringTokenizer ( type . substring ( pos ) , "=; " ) ; token . nextToken ( ) ; return token . nextToken ( ) ; } static class SimpleAuthenticator extends Authenticator { private String user = null ; private String password = null ; public SimpleAuthenticator ( String user , String password ) { this . user = user ; this . password = password ; } public PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( user , password ) ; } } } 	1
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class IsSigned extends DataType implements Condition { private static final String SIG_START = "META-INF/" ; private static final String SIG_END = ".SF" ; private static final int SHORT_SIG_LIMIT = 8 ; private String name ; private File file ; public void setFile ( File file ) { this . file = file ; } public void setName ( String name ) { this . name = name ; } public static boolean isSigned ( File zipFile , String name ) throws IOException { ZipFile jarFile = null ; try { jarFile = new ZipFile ( zipFile ) ; if ( null == name ) { Enumeration entries = jarFile . getEntries ( ) ; while ( entries . hasMoreElements ( ) ) { String eName = ( ( ZipEntry ) entries . nextElement ( ) ) . getName ( ) ; if ( eName . startsWith ( SIG_START ) && eName . endsWith ( SIG_END ) ) { return true ; } } return false ; } boolean shortSig = jarFile . getEntry ( SIG_START + name . toUpperCase ( ) + SIG_END ) != null ; boolean longSig = false ; if ( name . length ( ) > SHORT_SIG_LIMIT ) { longSig = jarFile . getEntry ( SIG_START + name . substring ( 0 , SHORT_SIG_LIMIT ) . toUpperCase ( ) + SIG_END ) != null ; } return shortSig || longSig ; } finally { ZipFile . closeQuietly ( jarFile ) ; } } public boolean eval ( ) { if ( file == null ) { throw new BuildException ( "The file attribute must be set." ) ; } if ( file != null && ! file . exists ( ) ) { log ( "The file \"" + file . getAbsolutePath ( ) + "\" does not exist." , Project . MSG_VERBOSE ) ; return false ; } boolean r = false ; try { r = isSigned ( file , name ) ; } catch ( IOException e ) { log ( "Got IOException reading file \"" + file . getAbsolutePath ( ) + "\"" + e , Project . MSG_WARN ) ; } if ( r ) { log ( "File \"" + file . getAbsolutePath ( ) + "\" is signed." , Project . MSG_VERBOSE ) ; } return r ; } } 	1
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import java . io . ByteArrayOutputStream ; import java . util . StringTokenizer ; public class CvsVersion extends AbstractCvsTask { static final long VERSION_1_11_2 = 11102 ; static final long MULTIPLY = 100 ; private String clientVersion ; private String serverVersion ; private String clientVersionProperty ; private String serverVersionProperty ; public String getClientVersion ( ) { return clientVersion ; } public String getServerVersion ( ) { return serverVersion ; } public void setClientVersionProperty ( String clientVersionProperty ) { this . clientVersionProperty = clientVersionProperty ; } public void setServerVersionProperty ( String serverVersionProperty ) { this . serverVersionProperty = serverVersionProperty ; } public boolean supportsCvsLogWithSOption ( ) { if ( serverVersion == null ) { return false ; } StringTokenizer tokenizer = new StringTokenizer ( serverVersion , "." ) ; long counter = MULTIPLY * MULTIPLY ; long version = 0 ; while ( tokenizer . hasMoreTokens ( ) ) { String s = tokenizer . nextToken ( ) ; int i = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isDigit ( s . charAt ( i ) ) ) { break ; } } String s2 = s . substring ( 0 , i ) ; version = version + counter * Long . parseLong ( s2 ) ; if ( counter == 1 ) { break ; } counter = counter / MULTIPLY ; } return ( version >= VERSION_1_11_2 ) ; } public void execute ( ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; this . setOutputStream ( bos ) ; ByteArrayOutputStream berr = new ByteArrayOutputStream ( ) ; this . setErrorStream ( berr ) ; setCommand ( "version" ) ; super . execute ( ) ; String output = bos . toString ( ) ; StringTokenizer st = new StringTokenizer ( output ) ; boolean client = false ; boolean server = false ; boolean cvs = false ; while ( st . hasMoreTokens ( ) ) { String currentToken = st . nextToken ( ) ; if ( currentToken . equals ( "Client:" ) ) { client = true ; } else if ( currentToken . equals ( "Server:" ) ) { server = true ; } else if ( currentToken . equals ( "(CVS)" ) ) { cvs = true ; } if ( client && cvs ) { if ( st . hasMoreTokens ( ) ) { clientVersion = st . nextToken ( ) ; } client = false ; cvs = false ; } else if ( server && cvs ) { if ( st . hasMoreTokens ( ) ) { serverVersion = st . nextToken ( ) ; } server = false ; cvs = false ; } } if ( clientVersionProperty != null ) { getProject ( ) . setNewProperty ( clientVersionProperty , clientVersion ) ; } if ( serverVersionProperty != null ) { getProject ( ) . setNewProperty ( serverVersionProperty , serverVersion ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . DynamicConfigurator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; public class XSLTProcess extends MatchingTask implements XSLTLogger { private File destDir = null ; private File baseDir = null ; private String xslFile = null ; private Resource xslResource = null ; private String targetExtension = ".html" ; private String fileNameParameter = null ; private String fileDirParameter = null ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private String processor ; private Path classpath = null ; private XSLTLiaison liaison ; private boolean stylesheetLoaded = false ; private boolean force = false ; private Vector outputProperties = new Vector ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; private static final String TRAX_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private boolean performDirectoryScan = true ; private Factory factory = null ; private boolean reuseLoadedStylesheet = true ; private AntClassLoader loader = null ; private Mapper mapperElement = null ; private Union resources = new Union ( ) ; private boolean useImplicitFileset = true ; public static final String PROCESSOR_TRAX = "trax" ; public XSLTProcess ( ) { } public void setScanIncludedDirectories ( boolean b ) { performDirectoryScan = b ; } public void setReloadStylesheet ( boolean b ) { reuseLoadedStylesheet = ! b ; } public void addMapper ( Mapper mapper ) { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = mapper ; } public void add ( ResourceCollection rc ) { resources . add ( rc ) ; } public void addConfiguredStyle ( Resources rc ) { if ( rc . size ( ) != 1 ) { throw new BuildException ( "The style element must be specified" + " with exactly one nested resource." ) ; } setXslResource ( ( Resource ) rc . iterator ( ) . next ( ) ) ; } public void setXslResource ( Resource xslResource ) { this . xslResource = xslResource ; } public void add ( FileNameMapper fileNameMapper ) throws BuildException { Mapper mapper = new Mapper ( getProject ( ) ) ; mapper . add ( fileNameMapper ) ; addMapper ( mapper ) ; } public void execute ( ) throws BuildException { if ( "style" . equals ( getTaskType ( ) ) ) { log ( "Warning: the task name <style> is deprecated. Use <xslt> instead." , Project . MSG_WARN ) ; } File savedBaseDir = baseDir ; DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( xslResource == null && xslFile == null ) { throw new BuildException ( "specify the " + "stylesheet either as a filename in style " + "attribute or as a nested resource" , getLocation ( ) ) ; } if ( xslResource != null && xslFile != null ) { throw new BuildException ( "specify the " + "stylesheet either as a filename in style " + "attribute or as a nested resource but not " + "as both" , getLocation ( ) ) ; } if ( inFile != null && ! inFile . exists ( ) ) { throw new BuildException ( "input file " + inFile . toString ( ) + " does not exist" , getLocation ( ) ) ; } try { if ( baseDir == null ) { baseDir = getProject ( ) . resolveFile ( "." ) ; } liaison = getLiaison ( ) ; if ( liaison instanceof XSLTLoggerAware ) { ( ( XSLTLoggerAware ) liaison ) . setLogger ( this ) ; } log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; if ( xslFile != null ) { File stylesheet = getProject ( ) . resolveFile ( xslFile ) ; if ( ! stylesheet . exists ( ) ) { stylesheet = FILE_UTILS . resolveFile ( baseDir , xslFile ) ; if ( stylesheet . exists ( ) ) { log ( "DEPRECATED - the 'style' attribute should be relative " + "to the project's" ) ; log ( "             basedir, not the tasks's basedir." ) ; } } FileResource fr = new FileResource ( ) ; fr . setProject ( getProject ( ) ) ; fr . setFile ( stylesheet ) ; xslResource = fr ; } if ( inFile != null && outFile != null ) { process ( inFile , outFile , xslResource ) ; return ; } checkDest ( ) ; if ( useImplicitFileset ) { scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , xslResource ) ; } if ( performDirectoryScan ) { dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , dirs [ j ] + File . separator + list [ i ] , destDir , xslResource ) ; } } } } else { if ( resources . size ( ) == 0 ) { throw new BuildException ( "no resources specified" ) ; } } processResources ( xslResource ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; loader = null ; } liaison = null ; stylesheetLoaded = false ; baseDir = savedBaseDir ; } } public void setForce ( boolean force ) { this . force = force ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = xslFile ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProcessor ( String processor ) { this . processor = processor ; } public void setUseImplicitFileset ( boolean useimplicitfileset ) { useImplicitFileset = useimplicitfileset ; } public void addConfiguredXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog . addConfiguredXMLCatalog ( xmlCatalog ) ; } public void setFileNameParameter ( String fileNameParameter ) { this . fileNameParameter = fileNameParameter ; } public void setFileDirParameter ( String fileDirParameter ) { this . fileDirParameter = fileDirParameter ; } private void resolveProcessor ( String proc ) throws Exception { String classname ; if ( proc . equals ( PROCESSOR_TRAX ) ) { classname = TRAX_LIAISON_CLASS ; } else { classname = proc ; } Class clazz = loadClass ( classname ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } private Class loadClass ( String classname ) throws Exception { if ( classpath == null ) { return Class . forName ( classname ) ; } else { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setThreadContextLoader ( ) ; Class c = Class . forName ( classname , true , loader ) ; return c ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void checkDest ( ) { if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } } private void processResources ( Resource stylesheet ) { Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } File base = baseDir ; String name = r . getName ( ) ; if ( r instanceof FileResource ) { FileResource f = ( FileResource ) r ; base = f . getBaseDir ( ) ; if ( base == null ) { name = f . getFile ( ) . getAbsolutePath ( ) ; } } process ( base , name , destDir , stylesheet ) ; } } private void process ( File baseDir , String xmlFile , File destDir , Resource stylesheet ) throws BuildException { File outF = null ; File inF = null ; try { long styleSheetLastModified = stylesheet . getLastModified ( ) ; inF = new File ( baseDir , xmlFile ) ; if ( inF . isDirectory ( ) ) { log ( "Skipping " + inF + " it is a directory." , Project . MSG_VERBOSE ) ; return ; } FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else { mapper = new StyleMapper ( ) ; } String [ ] outFileName = mapper . mapFileName ( xmlFile ) ; if ( outFileName == null || outFileName . length == 0 ) { log ( "Skipping " + inFile + " it cannot get mapped to output." , Project . MSG_VERBOSE ) ; return ; } else if ( outFileName == null || outFileName . length > 1 ) { log ( "Skipping " + inFile + " its mapping is ambiguos." , Project . MSG_VERBOSE ) ; return ; } outF = new File ( destDir , outFileName [ 0 ] ) ; if ( force || inF . lastModified ( ) > outF . lastModified ( ) || styleSheetLastModified > outF . lastModified ( ) ) { ensureDirectoryFor ( outF ) ; log ( "Processing " + inF + " to " + outF ) ; configureLiaison ( stylesheet ) ; setLiaisonDynamicFileParameters ( liaison , inF ) ; liaison . transform ( inF , outF ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outF != null ) { outF . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , Resource stylesheet ) throws BuildException { try { long styleSheetLastModified = stylesheet . getLastModified ( ) ; log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( force || inFile . lastModified ( ) >= outFile . lastModified ( ) || styleSheetLastModified >= outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; configureLiaison ( stylesheet ) ; setLiaisonDynamicFileParameters ( liaison , inFile ) ; liaison . transform ( inFile , outFile ) ; } else { log ( "Skipping input file " + inFile + " because it is older than output file " + outFile + " and so is the stylesheet " + stylesheet , Project . MSG_DEBUG ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = targetFile . getParentFile ( ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } public Factory getFactory ( ) { return factory ; } public XMLCatalog getXMLCatalog ( ) { xmlCatalog . setProject ( getProject ( ) ) ; return xmlCatalog ; } public Enumeration getOutputProperties ( ) { return outputProperties . elements ( ) ; } protected XSLTLiaison getLiaison ( ) { if ( liaison == null ) { if ( processor != null ) { try { resolveProcessor ( processor ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } else { try { resolveProcessor ( PROCESSOR_TRAX ) ; } catch ( Throwable e1 ) { e1 . printStackTrace ( ) ; throw new BuildException ( e1 ) ; } } } return liaison ; } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public static class Param { private String name = null ; private String expression = null ; private String ifProperty ; private String unlessProperty ; private Project project ; public void setProject ( Project project ) { this . project = project ; } public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) { throw new BuildException ( "Name attribute is missing." ) ; } return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) { throw new BuildException ( "Expression attribute is missing." ) ; } return expression ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean shouldUse ( ) { if ( ifProperty != null && project . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && project . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } } public OutputProperty createOutputProperty ( ) { OutputProperty p = new OutputProperty ( ) ; outputProperties . addElement ( p ) ; return p ; } public static class OutputProperty { private String name ; private String value ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } public void init ( ) throws BuildException { super . init ( ) ; xmlCatalog . setProject ( getProject ( ) ) ; } protected void configureLiaison ( File stylesheet ) throws BuildException { FileResource fr = new FileResource ( ) ; fr . setProject ( getProject ( ) ) ; fr . setFile ( stylesheet ) ; configureLiaison ( fr ) ; } protected void configureLiaison ( Resource stylesheet ) throws BuildException { if ( stylesheetLoaded && reuseLoadedStylesheet ) { return ; } stylesheetLoaded = true ; try { log ( "Loading stylesheet " + stylesheet , Project . MSG_INFO ) ; if ( liaison instanceof XSLTLiaison2 ) { ( ( XSLTLiaison2 ) liaison ) . configure ( this ) ; } if ( liaison instanceof XSLTLiaison3 ) { ( ( XSLTLiaison3 ) liaison ) . setStylesheet ( stylesheet ) ; } else { if ( stylesheet instanceof FileResource ) { liaison . setStylesheet ( ( ( FileResource ) stylesheet ) . getFile ( ) ) ; } else { throw new BuildException ( liaison . getClass ( ) . toString ( ) + " accepts the stylesheet only as a file" , getLocation ( ) ) ; } } for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; if ( p . shouldUse ( ) ) { liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } } } catch ( Exception ex ) { log ( "Failed to transform using stylesheet " + stylesheet , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } private void setLiaisonDynamicFileParameters ( XSLTLiaison liaison , File inFile ) throws Exception { if ( fileNameParameter != null ) { liaison . addParam ( fileNameParameter , inFile . getName ( ) ) ; } if ( fileDirParameter != null ) { String fileName = FileUtils . getRelativePath ( baseDir , inFile ) ; File file = new File ( fileName ) ; liaison . addParam ( fileDirParameter , ( file . getParent ( ) != null ) ? file . getParent ( ) . replace ( '\\' , '/' ) : "." ) ; } } public Factory createFactory ( ) throws BuildException { if ( factory != null ) { throw new BuildException ( "'factory' element must be unique" ) ; } factory = new Factory ( ) ; return factory ; } public static class Factory { private String name ; private Vector attributes = new Vector ( ) ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addAttribute ( Attribute attr ) { attributes . addElement ( attr ) ; } public Enumeration getAttributes ( ) { return attributes . elements ( ) ; } public static class Attribute implements DynamicConfigurator { private String name ; private Object value ; public String getName ( ) { return name ; } public Object getValue ( ) { return value ; } public Object createDynamicElement ( String name ) throws BuildException { return null ; } public void setDynamicAttribute ( String name , String value ) throws BuildException { if ( "name" . equalsIgnoreCase ( name ) ) { this . name = value ; } else if ( "value" . equalsIgnoreCase ( name ) ) { if ( "true" . equalsIgnoreCase ( value ) ) { this . value = Boolean . TRUE ; } else if ( "false" . equalsIgnoreCase ( value ) ) { this . value = Boolean . FALSE ; } else { try { this . value = new Integer ( value ) ; } catch ( NumberFormatException e ) { this . value = value ; } } } else { throw new BuildException ( "Unsupported attribute: " + name ) ; } } } } private class StyleMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String xmlFile ) { int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { xmlFile = xmlFile . substring ( 0 , dotPos ) ; } return new String [ ] { xmlFile + targetExtension } ; } } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Union ; import java . io . File ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . StringTokenizer ; import java . util . Vector ; import java . sql . Connection ; import java . sql . Statement ; import java . sql . SQLException ; import java . sql . SQLWarning ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; public class SQLExec extends JDBCTask { public static class DelimiterType extends EnumeratedAttribute { public static final String NORMAL = "normal" , ROW = "row" ; public String [ ] getValues ( ) { return new String [ ] { NORMAL , ROW } ; } } private int goodSql = 0 ; private int totalSql = 0 ; private Connection conn = null ; private Union resources = new Union ( ) ; private Statement statement = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private boolean showtrailers = true ; private File output = null ; private String onError = "abort" ; private String encoding = null ; private boolean append = false ; private boolean keepformat = false ; private boolean escapeProcessing = true ; private boolean expandProperties = false ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void setExpandProperties ( boolean expandProperties ) { this . expandProperties = expandProperties ; } public boolean getExpandProperties ( ) { return expandProperties ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { resources . add ( rc ) ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . delimiterType = delimiterType . getValue ( ) ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setShowtrailers ( boolean showtrailers ) { this . showtrailers = showtrailers ; } public void setOutput ( File output ) { this . output = output ; } public void setAppend ( boolean append ) { this . append = append ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void setKeepformat ( boolean keepformat ) { this . keepformat = keepformat ; } public void setEscapeProcessing ( boolean enable ) { escapeProcessing = enable ; } public void execute ( ) throws BuildException { Vector savedTransaction = ( Vector ) transactions . clone ( ) ; String savedSqlCommand = sqlCommand ; sqlCommand = sqlCommand . trim ( ) ; try { if ( srcFile == null && sqlCommand . length ( ) == 0 && resources . size ( ) == 0 ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file or resource " + "collection, " + "transactions or sql statement " + "must be set!" , getLocation ( ) ) ; } } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , getLocation ( ) ) ; } Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; Transaction t = createTransaction ( ) ; t . setSrcResource ( r ) ; } Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; conn = getConnection ( ) ; if ( ! isValidRdbms ( conn ) ) { return ; } try { statement = conn . createStatement ( ) ; statement . setEscapeProcessing ( escapeProcessing ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getAbsolutePath ( ) , append ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! isAutocommit ( ) ) { log ( "Committing transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { closeQuietly ( ) ; throw new BuildException ( e , getLocation ( ) ) ; } catch ( SQLException e ) { closeQuietly ( ) ; throw new BuildException ( e , getLocation ( ) ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException ex ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } finally { transactions = savedTransaction ; sqlCommand = savedSqlCommand ; } } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { StringBuffer sql = new StringBuffer ( ) ; String line ; BufferedReader in = new BufferedReader ( reader ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( ! keepformat ) { line = line . trim ( ) ; } line = getProject ( ) . replaceProperties ( line ) ; if ( ! keepformat ) { if ( line . startsWith ( "//" ) ) { continue ; } if ( line . startsWith ( "--" ) ) { continue ; } StringTokenizer st = new StringTokenizer ( line ) ; if ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( "REM" . equalsIgnoreCase ( token ) ) { continue ; } } } if ( ! keepformat ) { sql . append ( " " ) ; sql . append ( line ) ; } else { sql . append ( "\n" ) ; sql . append ( line ) ; } if ( ! keepformat ) { if ( line . indexOf ( "--" ) >= 0 ) { sql . append ( "\n" ) ; } } if ( ( delimiterType . equals ( DelimiterType . NORMAL ) && StringUtils . endsWith ( sql , delimiter ) ) || ( delimiterType . equals ( DelimiterType . ROW ) && line . equals ( delimiter ) ) ) { execSQL ( sql . substring ( 0 , sql . length ( ) - delimiter . length ( ) ) , out ) ; sql . replace ( 0 , sql . length ( ) , "" ) ; } } if ( sql . length ( ) > 0 ) { execSQL ( sql . toString ( ) , out ) ; } } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) { return ; } ResultSet resultSet = null ; try { totalSql ++ ; log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; boolean ret ; int updateCount = 0 , updateCountTotal = 0 ; ret = statement . execute ( sql ) ; updateCount = statement . getUpdateCount ( ) ; resultSet = statement . getResultSet ( ) ; do { if ( ! ret ) { if ( updateCount != - 1 ) { updateCountTotal += updateCount ; } } else { if ( print ) { printResults ( resultSet , out ) ; } } ret = statement . getMoreResults ( ) ; if ( ret ) { updateCount = statement . getUpdateCount ( ) ; resultSet = statement . getResultSet ( ) ; } } while ( ret ) ; log ( updateCountTotal + " rows affected" , Project . MSG_VERBOSE ) ; if ( print && showtrailers ) { out . println ( updateCountTotal + " rows affected" ) ; } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) { throw e ; } log ( e . toString ( ) , Project . MSG_ERR ) ; } finally { if ( resultSet != null ) { resultSet . close ( ) ; } } } protected void printResults ( PrintStream out ) throws SQLException { ResultSet rs = statement . getResultSet ( ) ; try { printResults ( rs , out ) ; } finally { if ( rs != null ) { rs . close ( ) ; } } } protected void printResults ( ResultSet rs , PrintStream out ) throws SQLException { if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line = new StringBuffer ( ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line = new StringBuffer ( ) ; } } out . println ( ) ; } private void closeQuietly ( ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private Resource tSrcResource = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { if ( src != null ) { setSrcResource ( new FileResource ( src ) ) ; } } public void setSrcResource ( Resource src ) { if ( tSrcResource != null ) { throw new BuildException ( "only one resource per transaction" ) ; } tSrcResource = src ; } public void addText ( String sql ) { if ( sql != null ) { if ( getExpandProperties ( ) ) { sql = getProject ( ) . replaceProperties ( sql ) ; } this . tSqlCommand += sql ; } } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource " + "collections are supported." ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcResource != null ) { log ( "Executing resource: " + tSrcResource . toString ( ) , Project . MSG_INFO ) ; InputStream is = null ; Reader reader = null ; try { is = tSrcResource . getInputStream ( ) ; reader = ( encoding == null ) ? new InputStreamReader ( is ) : new InputStreamReader ( is , encoding ) ; runStatements ( reader , out ) ; } finally { FileUtils . close ( is ) ; FileUtils . close ( reader ) ; } } } } } 	1
package org . apache . tools . ant . util ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . io . OutputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . text . DecimalFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . PathTokenizer ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . launch . Locator ; public class FileUtils { private static final FileUtils PRIMARY_INSTANCE = new FileUtils ( ) ; private static Random rand = new Random ( System . currentTimeMillis ( ) + Runtime . getRuntime ( ) . freeMemory ( ) ) ; private static boolean onNetWare = Os . isFamily ( "netware" ) ; private static boolean onDos = Os . isFamily ( "dos" ) ; private static boolean onWin9x = Os . isFamily ( "win9x" ) ; private static boolean onWindows = Os . isFamily ( "windows" ) ; static final int BUF_SIZE = 8192 ; public static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000 ; public static final long UNIX_FILE_TIMESTAMP_GRANULARITY = 1000 ; public static final long NTFS_FILE_TIMESTAMP_GRANULARITY = 1 ; private Object cacheFromUriLock = new Object ( ) ; private String cacheFromUriRequest = null ; private String cacheFromUriResponse = null ; public static FileUtils newFileUtils ( ) { return new FileUtils ( ) ; } public static FileUtils getFileUtils ( ) { return PRIMARY_INSTANCE ; } protected FileUtils ( ) { } public URL getFileURL ( File file ) throws MalformedURLException { return new URL ( toURI ( file . getAbsolutePath ( ) ) ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , null , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified , encoding ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , encoding , project ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , inputEncoding , outputEncoding , project ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , null , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { copyFile ( sourceFile , destFile , filters , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , preserveLastModified , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( sourceFile , destFile , filters , null , overwrite , preserveLastModified , encoding , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( sourceFile , destFile , filters , filterChains , overwrite , preserveLastModified , encoding , encoding , project ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { ResourceUtils . copyResource ( new FileResource ( sourceFile ) , new FileResource ( destFile ) , filters , filterChains , overwrite , preserveLastModified , inputEncoding , outputEncoding , project ) ; } public void setFileLastModified ( File file , long time ) { ResourceUtils . setLastModified ( new FileResource ( file ) , time ) ; } public File resolveFile ( File file , String filename ) { if ( ! isAbsolutePath ( filename ) ) { char sep = File . separatorChar ; filename = filename . replace ( '/' , sep ) . replace ( '\\' , sep ) ; if ( isContextRelativePath ( filename ) ) { file = null ; String udir = System . getProperty ( "user.dir" ) ; if ( filename . charAt ( 0 ) == sep && udir . charAt ( 0 ) == sep ) { filename = dissect ( udir ) [ 0 ] + filename . substring ( 1 ) ; } } filename = new File ( file , filename ) . getAbsolutePath ( ) ; } return normalize ( filename ) ; } public static boolean isContextRelativePath ( String filename ) { if ( ! ( onDos || onNetWare ) || filename . length ( ) == 0 ) { return false ; } char sep = File . separatorChar ; filename = filename . replace ( '/' , sep ) . replace ( '\\' , sep ) ; char c = filename . charAt ( 0 ) ; int len = filename . length ( ) ; return ( c == sep && ( len == 1 || filename . charAt ( 1 ) != sep ) ) || ( Character . isLetter ( c ) && len > 1 && filename . indexOf ( ':' ) == 1 && ( len == 2 || filename . charAt ( 2 ) != sep ) ) ; } public static boolean isAbsolutePath ( String filename ) { int len = filename . length ( ) ; if ( len == 0 ) { return false ; } char sep = File . separatorChar ; filename = filename . replace ( '/' , sep ) . replace ( '\\' , sep ) ; char c = filename . charAt ( 0 ) ; if ( ! ( onDos || onNetWare ) ) { return ( c == sep ) ; } if ( c == sep ) { if ( ! ( onDos && len > 4 && filename . charAt ( 1 ) == sep ) ) { return false ; } int nextsep = filename . indexOf ( sep , 2 ) ; return nextsep > 2 && nextsep + 1 < len ; } int colon = filename . indexOf ( ':' ) ; return ( Character . isLetter ( c ) && colon == 1 && filename . length ( ) > 2 && filename . charAt ( 2 ) == sep ) || ( onNetWare && colon > 0 ) ; } public static String translatePath ( String toProcess ) { if ( toProcess == null || toProcess . length ( ) == 0 ) { return "" ; } StringBuffer path = new StringBuffer ( toProcess . length ( ) + 50 ) ; PathTokenizer tokenizer = new PathTokenizer ( toProcess ) ; while ( tokenizer . hasMoreTokens ( ) ) { String pathComponent = tokenizer . nextToken ( ) ; pathComponent = pathComponent . replace ( '/' , File . separatorChar ) ; pathComponent = pathComponent . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) != 0 ) { path . append ( File . pathSeparatorChar ) ; } path . append ( pathComponent ) ; } return path . toString ( ) ; } public File normalize ( final String path ) { Stack s = new Stack ( ) ; String [ ] dissect = dissect ( path ) ; s . push ( dissect [ 0 ] ) ; StringTokenizer tok = new StringTokenizer ( dissect [ 1 ] , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String thisToken = tok . nextToken ( ) ; if ( "." . equals ( thisToken ) ) { continue ; } else if ( ".." . equals ( thisToken ) ) { if ( s . size ( ) < 2 ) { return new File ( path ) ; } s . pop ( ) ; } else { s . push ( thisToken ) ; } } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i > 1 ) { sb . append ( File . separatorChar ) ; } sb . append ( s . elementAt ( i ) ) ; } return new File ( sb . toString ( ) ) ; } public String [ ] dissect ( String path ) { char sep = File . separatorChar ; path = path . replace ( '/' , sep ) . replace ( '\\' , sep ) ; if ( ! isAbsolutePath ( path ) ) { throw new BuildException ( path + " is not an absolute path" ) ; } String root = null ; int colon = path . indexOf ( ':' ) ; if ( colon > 0 && ( onDos || onNetWare ) ) { int next = colon + 1 ; root = path . substring ( 0 , next ) ; char [ ] ca = path . toCharArray ( ) ; root += sep ; next = ( ca [ next ] == sep ) ? next + 1 : next ; StringBuffer sbPath = new StringBuffer ( ) ; for ( int i = next ; i < ca . length ; i ++ ) { if ( ca [ i ] != sep || ca [ i - 1 ] != sep ) { sbPath . append ( ca [ i ] ) ; } } path = sbPath . toString ( ) ; } else if ( path . length ( ) > 1 && path . charAt ( 1 ) == sep ) { int nextsep = path . indexOf ( sep , 2 ) ; nextsep = path . indexOf ( sep , nextsep + 1 ) ; root = ( nextsep > 2 ) ? path . substring ( 0 , nextsep + 1 ) : path ; path = path . substring ( root . length ( ) ) ; } else { root = File . separator ; path = path . substring ( 1 ) ; } return new String [ ] { root , path } ; } public String toVMSPath ( File f ) { String osPath ; String path = normalize ( f . getAbsolutePath ( ) ) . getPath ( ) ; String name = f . getName ( ) ; boolean isAbsolute = path . charAt ( 0 ) == File . separatorChar ; boolean isDirectory = f . isDirectory ( ) && ! name . regionMatches ( true , name . length ( ) - 4 , ".DIR" , 0 , 4 ) ; String device = null ; StringBuffer directory = null ; String file = null ; int index = 0 ; if ( isAbsolute ) { index = path . indexOf ( File . separatorChar , 1 ) ; if ( index == - 1 ) { return path . substring ( 1 ) + ":[000000]" ; } else { device = path . substring ( 1 , index ++ ) ; } } if ( isDirectory ) { directory = new StringBuffer ( path . substring ( index ) . replace ( File . separatorChar , '.' ) ) ; } else { int dirEnd = path . lastIndexOf ( File . separatorChar , path . length ( ) ) ; if ( dirEnd == - 1 || dirEnd < index ) { file = path . substring ( index ) ; } else { directory = new StringBuffer ( path . substring ( index , dirEnd ) . replace ( File . separatorChar , '.' ) ) ; index = dirEnd + 1 ; if ( path . length ( ) > index ) { file = path . substring ( index ) ; } } } if ( ! isAbsolute && directory != null ) { directory . insert ( 0 , '.' ) ; } osPath = ( ( device != null ) ? device + ":" : "" ) + ( ( directory != null ) ? "[" + directory + "]" : "" ) + ( ( file != null ) ? file : "" ) ; return osPath ; } public File createTempFile ( String prefix , String suffix , File parentDir ) { return createTempFile ( prefix , suffix , parentDir , false ) ; } public File createTempFile ( String prefix , String suffix , File parentDir , boolean deleteOnExit ) { File result = null ; String parent = ( parentDir == null ) ? System . getProperty ( "java.io.tmpdir" ) : parentDir . getPath ( ) ; DecimalFormat fmt = new DecimalFormat ( "#####" ) ; synchronized ( rand ) { do { result = new File ( parent , prefix + fmt . format ( Math . abs ( rand . nextInt ( ) ) ) + suffix ) ; } while ( result . exists ( ) ) ; } if ( deleteOnExit ) { result . deleteOnExit ( ) ; } return result ; } public boolean contentEquals ( File f1 , File f2 ) throws IOException { return contentEquals ( f1 , f2 , false ) ; } public boolean contentEquals ( File f1 , File f2 , boolean textfile ) throws IOException { return ResourceUtils . contentEquals ( new FileResource ( f1 ) , new FileResource ( f2 ) , textfile ) ; } public File getParentFile ( File f ) { return ( f == null ) ? null : f . getParentFile ( ) ; } public static final String readFully ( Reader rdr ) throws IOException { return readFully ( rdr , BUF_SIZE ) ; } public static final String readFully ( Reader rdr , int bufferSize ) throws IOException { if ( bufferSize <= 0 ) { throw new IllegalArgumentException ( "Buffer size must be greater " + "than 0" ) ; } final char [ ] buffer = new char [ bufferSize ] ; int bufferLength = 0 ; StringBuffer textBuffer = null ; while ( bufferLength != - 1 ) { bufferLength = rdr . read ( buffer ) ; if ( bufferLength > 0 ) { textBuffer = ( textBuffer == null ) ? new StringBuffer ( ) : textBuffer ; textBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; } } return ( textBuffer == null ) ? null : textBuffer . toString ( ) ; } public boolean createNewFile ( File f ) throws IOException { return f . createNewFile ( ) ; } public boolean createNewFile ( File f , boolean mkdirs ) throws IOException { File parent = f . getParentFile ( ) ; if ( mkdirs && ! ( parent . exists ( ) ) ) { parent . mkdirs ( ) ; } return f . createNewFile ( ) ; } public boolean isSymbolicLink ( File parent , String name ) throws IOException { if ( parent == null ) { File f = new File ( name ) ; parent = f . getParentFile ( ) ; name = f . getName ( ) ; } File toTest = new File ( parent . getCanonicalPath ( ) , name ) ; return ! toTest . getAbsolutePath ( ) . equals ( toTest . getCanonicalPath ( ) ) ; } public String removeLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( l . equals ( p ) ) { return "" ; } if ( ! l . endsWith ( File . separator ) ) { l += File . separator ; } return ( p . startsWith ( l ) ) ? p . substring ( l . length ( ) ) : p ; } public boolean isLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( l . equals ( p ) ) { return true ; } if ( ! l . endsWith ( File . separator ) ) { l += File . separator ; } return p . startsWith ( l ) ; } public String toURI ( String path ) { Class uriClazz = null ; try { uriClazz = Class . forName ( "java.net.URI" ) ; } catch ( ClassNotFoundException e ) { } if ( uriClazz != null ) { try { File f = new File ( path ) . getAbsoluteFile ( ) ; java . lang . reflect . Method toURIMethod = File . class . getMethod ( "toURI" , new Class [ 0 ] ) ; Object uriObj = toURIMethod . invoke ( f , new Object [ ] { } ) ; java . lang . reflect . Method toASCIIStringMethod = uriClazz . getMethod ( "toASCIIString" , new Class [ 0 ] ) ; return ( String ) toASCIIStringMethod . invoke ( uriObj , new Object [ ] { } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } boolean isDir = new File ( path ) . isDirectory ( ) ; StringBuffer sb = new StringBuffer ( "file:" ) ; path = resolveFile ( null , path ) . getPath ( ) ; sb . append ( "//" ) ; if ( ! path . startsWith ( File . separator ) ) { sb . append ( "/" ) ; } path = path . replace ( '\\' , '/' ) ; try { sb . append ( Locator . encodeURI ( path ) ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( exc ) ; } if ( isDir && ! path . endsWith ( "/" ) ) { sb . append ( '/' ) ; } return sb . toString ( ) ; } public String fromURI ( String uri ) { synchronized ( cacheFromUriLock ) { if ( uri . equals ( cacheFromUriRequest ) ) { return cacheFromUriResponse ; } String path = Locator . fromURI ( uri ) ; String ret = isAbsolutePath ( path ) ? normalize ( path ) . getAbsolutePath ( ) : path ; cacheFromUriRequest = uri ; cacheFromUriResponse = ret ; return ret ; } } public boolean fileNameEquals ( File f1 , File f2 ) { return normalize ( f1 . getAbsolutePath ( ) ) . equals ( normalize ( f2 . getAbsolutePath ( ) ) ) ; } public void rename ( File from , File to ) throws IOException { if ( to . exists ( ) && ! to . delete ( ) ) { throw new IOException ( "Failed to delete " + to + " while trying to rename " + from ) ; } File parent = to . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new IOException ( "Failed to create directory " + parent + " while trying to rename " + from ) ; } if ( ! from . renameTo ( to ) ) { copyFile ( from , to ) ; if ( ! from . delete ( ) ) { throw new IOException ( "Failed to delete " + from + " while trying to rename it." ) ; } } } public long getFileTimestampGranularity ( ) { if ( onWin9x ) { return FAT_FILE_TIMESTAMP_GRANULARITY ; } else if ( onWindows ) { return NTFS_FILE_TIMESTAMP_GRANULARITY ; } else if ( onDos ) { return FAT_FILE_TIMESTAMP_GRANULARITY ; } return UNIX_FILE_TIMESTAMP_GRANULARITY ; } public boolean isUpToDate ( File source , File dest , long granularity ) { if ( ! dest . exists ( ) ) { return false ; } long sourceTime = source . lastModified ( ) ; long destTime = dest . lastModified ( ) ; return isUpToDate ( sourceTime , destTime , granularity ) ; } public boolean isUpToDate ( File source , File dest ) { return isUpToDate ( source , dest , getFileTimestampGranularity ( ) ) ; } public boolean isUpToDate ( long sourceTime , long destTime , long granularity ) { if ( destTime == - 1 ) { return false ; } return destTime >= sourceTime + granularity ; } public boolean isUpToDate ( long sourceTime , long destTime ) { return isUpToDate ( sourceTime , destTime , getFileTimestampGranularity ( ) ) ; } public static void close ( Writer device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void close ( Reader device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void close ( OutputStream device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void close ( InputStream device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void delete ( File file ) { if ( file != null ) { file . delete ( ) ; } } public static String getRelativePath ( File fromFile , File toFile ) throws Exception { String fromPath = fromFile . getCanonicalPath ( ) ; String toPath = toFile . getCanonicalPath ( ) ; String [ ] fromPathStack = getPathStack ( fromPath ) ; String [ ] toPathStack = getPathStack ( toPath ) ; if ( 0 < toPathStack . length && 0 < fromPathStack . length ) { if ( ! fromPathStack [ 0 ] . equals ( toPathStack [ 0 ] ) ) { return getPath ( Arrays . asList ( toPathStack ) ) ; } } else { return getPath ( Arrays . asList ( toPathStack ) ) ; } int minLength = Math . min ( fromPathStack . length , toPathStack . length ) ; int same = 1 ; for ( ; same < minLength ; same ++ ) { if ( ! fromPathStack [ same ] . equals ( toPathStack [ same ] ) ) { break ; } } List relativePathStack = new ArrayList ( ) ; for ( int i = same ; i < fromPathStack . length ; i ++ ) { relativePathStack . add ( ".." ) ; } for ( int i = same ; i < toPathStack . length ; i ++ ) { relativePathStack . add ( toPathStack [ i ] ) ; } return getPath ( relativePathStack ) ; } public static String [ ] getPathStack ( String path ) { String normalizedPath = path . replace ( File . separatorChar , '/' ) ; Object [ ] tokens = StringUtils . split ( normalizedPath , '/' ) . toArray ( ) ; String [ ] rv = new String [ tokens . length ] ; System . arraycopy ( tokens , 0 , rv , 0 , tokens . length ) ; return rv ; } public static String getPath ( List pathStack ) { return getPath ( pathStack , '/' ) ; } public static String getPath ( final List pathStack , final char separatorChar ) { final StringBuffer buffer = new StringBuffer ( ) ; final Iterator iter = pathStack . iterator ( ) ; if ( iter . hasNext ( ) ) { buffer . append ( iter . next ( ) ) ; } while ( iter . hasNext ( ) ) { buffer . append ( separatorChar ) ; buffer . append ( iter . next ( ) ) ; } return buffer . toString ( ) ; } public String getDefaultEncoding ( ) { InputStreamReader is = new InputStreamReader ( new InputStream ( ) { public int read ( ) { return - 1 ; } } ) ; try { return is . getEncoding ( ) ; } finally { close ( is ) ; } } } 	1
package org . apache . tools . ant ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; public class PropertyHelper { private Project project ; private PropertyHelper next ; private Hashtable properties = new Hashtable ( ) ; private Hashtable userProperties = new Hashtable ( ) ; private Hashtable inheritedProperties = new Hashtable ( ) ; protected PropertyHelper ( ) { } public void setProject ( Project p ) { this . project = p ; } public void setNext ( PropertyHelper next ) { this . next = next ; } public PropertyHelper getNext ( ) { return next ; } public static synchronized PropertyHelper getPropertyHelper ( Project project ) { PropertyHelper helper = ( PropertyHelper ) project . getReference ( MagicNames . REFID_PROPERTY_HELPER ) ; if ( helper != null ) { return helper ; } helper = new PropertyHelper ( ) ; helper . setProject ( project ) ; project . addReference ( MagicNames . REFID_PROPERTY_HELPER , helper ) ; return helper ; } public boolean setPropertyHook ( String ns , String name , Object value , boolean inherited , boolean user , boolean isNew ) { if ( getNext ( ) != null ) { boolean subst = getNext ( ) . setPropertyHook ( ns , name , value , inherited , user , isNew ) ; if ( subst ) { return true ; } } return false ; } public Object getPropertyHook ( String ns , String name , boolean user ) { if ( getNext ( ) != null ) { Object o = getNext ( ) . getPropertyHook ( ns , name , user ) ; if ( o != null ) { return o ; } } if ( name . startsWith ( "toString:" ) ) { name = name . substring ( "toString:" . length ( ) ) ; Object v = project . getReference ( name ) ; return ( v == null ) ? null : v . toString ( ) ; } return null ; } public void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { parsePropertyStringDefault ( value , fragments , propertyRefs ) ; } public String replaceProperties ( String ns , String value , Hashtable keys ) throws BuildException { if ( value == null || value . indexOf ( '$' ) == - 1 ) { return value ; } Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; parsePropertyString ( value , fragments , propertyRefs ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; Object replacement = null ; if ( keys != null ) { replacement = keys . get ( propertyName ) ; } if ( replacement == null ) { replacement = getProperty ( ns , propertyName ) ; } if ( replacement == null ) { project . log ( "Property \"" + propertyName + "\" has not been set" , Project . MSG_VERBOSE ) ; } fragment = ( replacement != null ) ? replacement . toString ( ) : "${" + propertyName + "}" ; } sb . append ( fragment ) ; } return sb . toString ( ) ; } public synchronized boolean setProperty ( String ns , String name , Object value , boolean verbose ) { if ( null != userProperties . get ( name ) ) { if ( verbose ) { project . log ( "Override ignored for user property \"" + name + "\"" , Project . MSG_VERBOSE ) ; } return false ; } boolean done = setPropertyHook ( ns , name , value , false , false , false ) ; if ( done ) { return true ; } if ( null != properties . get ( name ) && verbose ) { project . log ( "Overriding previous definition of property \"" + name + "\"" , Project . MSG_VERBOSE ) ; } if ( verbose ) { project . log ( "Setting project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; } properties . put ( name , value ) ; return true ; } public synchronized void setNewProperty ( String ns , String name , Object value ) { if ( null != properties . get ( name ) ) { project . log ( "Override ignored for property \"" + name + "\"" , Project . MSG_VERBOSE ) ; return ; } boolean done = setPropertyHook ( ns , name , value , false , false , true ) ; if ( done ) { return ; } project . log ( "Setting project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; if ( name != null && value != null ) { properties . put ( name , value ) ; } } public synchronized void setUserProperty ( String ns , String name , Object value ) { project . log ( "Setting ro project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; userProperties . put ( name , value ) ; boolean done = setPropertyHook ( ns , name , value , false , true , false ) ; if ( done ) { return ; } properties . put ( name , value ) ; } public synchronized void setInheritedProperty ( String ns , String name , Object value ) { inheritedProperties . put ( name , value ) ; project . log ( "Setting ro project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; userProperties . put ( name , value ) ; boolean done = setPropertyHook ( ns , name , value , true , false , false ) ; if ( done ) { return ; } properties . put ( name , value ) ; } public synchronized Object getProperty ( String ns , String name ) { if ( name == null ) { return null ; } Object o = getPropertyHook ( ns , name , false ) ; if ( o != null ) { return o ; } return properties . get ( name ) ; } public synchronized Object getUserProperty ( String ns , String name ) { if ( name == null ) { return null ; } Object o = getPropertyHook ( ns , name , true ) ; if ( o != null ) { return o ; } return userProperties . get ( name ) ; } public Hashtable getProperties ( ) { return new Hashtable ( properties ) ; } public Hashtable getUserProperties ( ) { return new Hashtable ( userProperties ) ; } protected Hashtable getInternalProperties ( ) { return properties ; } protected Hashtable getInternalUserProperties ( ) { return userProperties ; } protected Hashtable getInternalInheritedProperties ( ) { return inheritedProperties ; } public void copyInheritedProperties ( Project other ) { Enumeration e = inheritedProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = e . nextElement ( ) . toString ( ) ; if ( other . getUserProperty ( arg ) != null ) { continue ; } Object value = inheritedProperties . get ( arg ) ; other . setInheritedProperty ( arg , value . toString ( ) ) ; } } public void copyUserProperties ( Project other ) { Enumeration e = userProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object arg = e . nextElement ( ) ; if ( inheritedProperties . containsKey ( arg ) ) { continue ; } Object value = userProperties . get ( arg ) ; other . setUserProperty ( arg . toString ( ) , value . toString ( ) ) ; } } static void parsePropertyStringDefault ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { int prev = 0 ; int pos ; while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos > 0 ) { fragments . addElement ( value . substring ( prev , pos ) ) ; } if ( pos == ( value . length ( ) - 1 ) ) { fragments . addElement ( "$" ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { if ( value . charAt ( pos + 1 ) == '$' ) { fragments . addElement ( "$" ) ; prev = pos + 2 ; } else { fragments . addElement ( value . substring ( pos , pos + 2 ) ) ; prev = pos + 2 ; } } else { int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new BuildException ( "Syntax error in property: " + value ) ; } String propertyName = value . substring ( pos + 2 , endName ) ; fragments . addElement ( null ) ; propertyRefs . addElement ( propertyName ) ; prev = endName + 1 ; } } if ( prev < value . length ( ) ) { fragments . addElement ( value . substring ( prev ) ) ; } } } 	1
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; public class Substitution extends DataType { public static final String DATA_TYPE_NAME = "substitition" ; private String expression ; public Substitution ( ) { this . expression = null ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getExpression ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExpression ( p ) ; } return expression ; } public Substitution getRef ( Project p ) { return ( Substitution ) getCheckedRef ( p ) ; } } 	1
package org . apache . tools . zip ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipException ; public class ExtraFieldUtils { private static Hashtable implementations ; static { implementations = new Hashtable ( ) ; register ( AsiExtraField . class ) ; register ( JarMarker . class ) ; } public static void register ( Class c ) { try { ZipExtraField ze = ( ZipExtraField ) c . newInstance ( ) ; implementations . put ( ze . getHeaderId ( ) , c ) ; } catch ( ClassCastException cc ) { throw new RuntimeException ( c + " doesn\'t implement ZipExtraField" ) ; } catch ( InstantiationException ie ) { throw new RuntimeException ( c + " is not a concrete class" ) ; } catch ( IllegalAccessException ie ) { throw new RuntimeException ( c + "\'s no-arg constructor is not public" ) ; } } public static ZipExtraField createExtraField ( ZipShort headerId ) throws InstantiationException , IllegalAccessException { Class c = ( Class ) implementations . get ( headerId ) ; if ( c != null ) { return ( ZipExtraField ) c . newInstance ( ) ; } UnrecognizedExtraField u = new UnrecognizedExtraField ( ) ; u . setHeaderId ( headerId ) ; return u ; } public static ZipExtraField [ ] parse ( byte [ ] data ) throws ZipException { Vector v = new Vector ( ) ; int start = 0 ; while ( start <= data . length - 4 ) { ZipShort headerId = new ZipShort ( data , start ) ; int length = ( new ZipShort ( data , start + 2 ) ) . getValue ( ) ; if ( start + 4 + length > data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } try { ZipExtraField ze = createExtraField ( headerId ) ; ze . parseFromLocalFileData ( data , start + 4 , length ) ; v . addElement ( ze ) ; } catch ( InstantiationException ie ) { throw new ZipException ( ie . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new ZipException ( iae . getMessage ( ) ) ; } start += ( length + 4 ) ; } if ( start != data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } ZipExtraField [ ] result = new ZipExtraField [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public static byte [ ] mergeLocalFileDataData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getLocalFileDataLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getLocalFileDataLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getLocalFileDataData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } public static byte [ ] mergeCentralDirectoryData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getCentralDirectoryLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getCentralDirectoryLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getCentralDirectoryData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . PrintStream ; import java . io . OutputStream ; import java . util . Iterator ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . PropertyOutputStream ; public class Length extends Task implements Condition { private static final String ALL = "all" ; private static final String EACH = "each" ; private static final String STRING = "string" ; private static final String LENGTH_REQUIRED = "Use of the Length condition requires that the length attribute be set." ; private String property ; private String string ; private Boolean trim ; private String mode = ALL ; private Comparison when = Comparison . EQUAL ; private Long length ; private Resources resources ; public synchronized void setProperty ( String property ) { this . property = property ; } public synchronized void setFile ( File file ) { add ( new FileResource ( file ) ) ; } public synchronized void add ( FileSet fs ) { add ( ( ResourceCollection ) fs ) ; } public synchronized void add ( ResourceCollection c ) { if ( c == null ) { return ; } resources = ( resources == null ) ? new Resources ( ) : resources ; resources . add ( c ) ; } public synchronized void setLength ( long ell ) { length = new Long ( ell ) ; } public synchronized void setWhen ( When w ) { setWhen ( ( Comparison ) w ) ; } public synchronized void setWhen ( Comparison c ) { when = c ; } public synchronized void setMode ( FileMode m ) { this . mode = m . getValue ( ) ; } public synchronized void setString ( String string ) { this . string = string ; this . mode = STRING ; } public synchronized void setTrim ( boolean trim ) { this . trim = trim ? Boolean . TRUE : Boolean . FALSE ; } public boolean getTrim ( ) { return trim != null && trim . booleanValue ( ) ; } public void execute ( ) { validate ( ) ; PrintStream ps = new PrintStream ( ( property != null ) ? ( OutputStream ) new PropertyOutputStream ( getProject ( ) , property ) : ( OutputStream ) new LogOutputStream ( this , Project . MSG_INFO ) ) ; if ( STRING . equals ( mode ) ) { ps . print ( getLength ( string , getTrim ( ) ) ) ; ps . close ( ) ; } else if ( EACH . equals ( mode ) ) { handleResources ( new EachHandler ( ps ) ) ; } else if ( ALL . equals ( mode ) ) { handleResources ( new AllHandler ( ps ) ) ; } } public boolean eval ( ) { validate ( ) ; if ( length == null ) { throw new BuildException ( LENGTH_REQUIRED ) ; } Long ell = null ; if ( STRING . equals ( mode ) ) { ell = new Long ( getLength ( string , getTrim ( ) ) ) ; } else { ConditionHandler h = new ConditionHandler ( ) ; handleResources ( h ) ; ell = new Long ( h . getLength ( ) ) ; } return when . evaluate ( ell . compareTo ( length ) ) ; } private void validate ( ) { if ( string != null ) { if ( resources != null ) { throw new BuildException ( "the string length function" + " is incompatible with the file/resource length function" ) ; } if ( ! ( STRING . equals ( mode ) ) ) { throw new BuildException ( "the mode attribute is for use" + " with the file/resource length function" ) ; } } else if ( resources != null ) { if ( ! ( EACH . equals ( mode ) || ALL . equals ( mode ) ) ) { throw new BuildException ( "invalid mode setting for" + " file/resource length function: \"" + mode + "\"" ) ; } else if ( trim != null ) { throw new BuildException ( "the trim attribute is" + " for use with the string length function only" ) ; } } else { throw new BuildException ( "you must set either the string attribute" + " or specify one or more files using the file attribute or" + " nested resource collections" ) ; } } private void handleResources ( Handler h ) { for ( Iterator i = resources . iterator ( ) ; i . hasNext ( ) ; ) { Resource r = ( Resource ) i . next ( ) ; if ( ! r . isExists ( ) ) { log ( r + " does not exist" , Project . MSG_ERR ) ; } else if ( r . isDirectory ( ) ) { log ( r + " is a directory; length unspecified" , Project . MSG_ERR ) ; } else { h . handle ( r ) ; } } h . complete ( ) ; } private static long getLength ( String s , boolean t ) { return ( t ? s . trim ( ) : s ) . length ( ) ; } public static class FileMode extends EnumeratedAttribute { static final String [ ] MODES = new String [ ] { EACH , ALL } ; public String [ ] getValues ( ) { return MODES ; } } public static class When extends Comparison { } private abstract class Handler { private PrintStream ps ; Handler ( PrintStream ps ) { this . ps = ps ; } protected PrintStream getPs ( ) { return ps ; } protected abstract void handle ( Resource r ) ; void complete ( ) { ps . close ( ) ; } } private class EachHandler extends Handler { EachHandler ( PrintStream ps ) { super ( ps ) ; } protected void handle ( Resource r ) { getPs ( ) . print ( r . toString ( ) ) ; getPs ( ) . print ( " : " ) ; long size = r . getSize ( ) ; if ( size == Resource . UNKNOWN_SIZE ) { getPs ( ) . println ( "unknown" ) ; } else { getPs ( ) . println ( size ) ; } } } private class AllHandler extends Handler { private long accum = 0L ; AllHandler ( PrintStream ps ) { super ( ps ) ; } protected long getAccum ( ) { return accum ; } protected synchronized void handle ( Resource r ) { long size = r . getSize ( ) ; if ( size == Resource . UNKNOWN_SIZE ) { log ( "Size unknown for " + r . toString ( ) , Project . MSG_WARN ) ; } else { accum += size ; } } void complete ( ) { getPs ( ) . print ( accum ) ; super . complete ( ) ; } } private class ConditionHandler extends AllHandler { ConditionHandler ( ) { super ( null ) ; } void complete ( ) { } long getLength ( ) { return getAccum ( ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . Reader ; import java . io . Writer ; import java . io . FileReader ; import java . io . InputStream ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . OutputStream ; import java . io . StringReader ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . util . Arrays ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . StringResource ; import org . apache . tools . ant . types . resources . selectors . Not ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . ConcatResourceInputStream ; public class Concat extends Task { private static final int BUFFER_SIZE = 8192 ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final ResourceSelector EXISTS = new Exists ( ) ; private static final ResourceSelector NOT_EXISTS = new Not ( EXISTS ) ; private File destinationFile ; private boolean append ; private String encoding ; private String outputEncoding ; private boolean binary ; private StringBuffer textBuffer ; private Resources rc ; private Vector filterChains ; private boolean forceOverwrite = true ; private TextElement footer ; private TextElement header ; private boolean fixLastLine = false ; private String eolString ; private Writer outputWriter = null ; public Concat ( ) { reset ( ) ; } public void reset ( ) { append = false ; forceOverwrite = true ; destinationFile = null ; encoding = null ; outputEncoding = null ; fixLastLine = false ; filterChains = null ; footer = null ; header = null ; binary = false ; outputWriter = null ; textBuffer = null ; eolString = System . getProperty ( "line.separator" ) ; rc = null ; } public void setDestfile ( File destinationFile ) { this . destinationFile = destinationFile ; } public void setAppend ( boolean append ) { this . append = append ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; if ( outputEncoding == null ) { outputEncoding = encoding ; } } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setForce ( boolean force ) { this . forceOverwrite = force ; } public Path createPath ( ) { Path path = new Path ( getProject ( ) ) ; add ( path ) ; return path ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void addFilelist ( FileList list ) { add ( list ) ; } public void add ( ResourceCollection c ) { rc = rc == null ? new Resources ( ) : rc ; rc . add ( c ) ; } public void addFilterChain ( FilterChain filterChain ) { if ( filterChains == null ) { filterChains = new Vector ( ) ; } filterChains . addElement ( filterChain ) ; } public void addText ( String text ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( text . length ( ) ) ; } textBuffer . append ( text ) ; } public void addHeader ( TextElement headerToAdd ) { this . header = headerToAdd ; } public void addFooter ( TextElement footerToAdd ) { this . footer = footerToAdd ; } public void setFixLastLine ( boolean fixLastLine ) { this . fixLastLine = fixLastLine ; } public void setEol ( FixCRLF . CrLf crlf ) { String s = crlf . getValue ( ) ; if ( s . equals ( "cr" ) || s . equals ( "mac" ) ) { eolString = "\r" ; } else if ( s . equals ( "lf" ) || s . equals ( "unix" ) ) { eolString = "\n" ; } else if ( s . equals ( "crlf" ) || s . equals ( "dos" ) ) { eolString = "\r\n" ; } } public void setWriter ( Writer outputWriter ) { this . outputWriter = outputWriter ; } public void setBinary ( boolean binary ) { this . binary = binary ; } private ResourceCollection validate ( ) { sanitizeText ( ) ; if ( binary ) { if ( destinationFile == null ) { throw new BuildException ( "destfile attribute is required for binary concatenation" ) ; } if ( textBuffer != null ) { throw new BuildException ( "Nested text is incompatible with binary concatenation" ) ; } if ( encoding != null || outputEncoding != null ) { throw new BuildException ( "Seting input or output encoding is incompatible with binary" + " concatenation" ) ; } if ( filterChains != null ) { throw new BuildException ( "Setting filters is incompatible with binary concatenation" ) ; } if ( fixLastLine ) { throw new BuildException ( "Setting fixlastline is incompatible with binary concatenation" ) ; } if ( header != null || footer != null ) { throw new BuildException ( "Nested header or footer is incompatible with binary concatenation" ) ; } } if ( destinationFile != null && outputWriter != null ) { throw new BuildException ( "Cannot specify both a destination file and an output writer" ) ; } if ( rc == null && textBuffer == null ) { throw new BuildException ( "At least one resource must be provided, or some text." ) ; } if ( rc != null ) { if ( textBuffer != null ) { throw new BuildException ( "Cannot include inline text when using resources." ) ; } Restrict noexistRc = new Restrict ( ) ; noexistRc . add ( NOT_EXISTS ) ; noexistRc . add ( rc ) ; for ( Iterator i = noexistRc . iterator ( ) ; i . hasNext ( ) ; ) { log ( i . next ( ) + " does not exist." , Project . MSG_ERR ) ; } if ( destinationFile != null ) { for ( Iterator i = rc . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof FileResource ) { File f = ( ( FileResource ) o ) . getFile ( ) ; if ( FILE_UTILS . fileNameEquals ( f , destinationFile ) ) { throw new BuildException ( "Input file \"" + f + "\" is the same as the output file." ) ; } } } } Restrict existRc = new Restrict ( ) ; existRc . add ( EXISTS ) ; existRc . add ( rc ) ; boolean outofdate = destinationFile == null || forceOverwrite ; if ( ! outofdate ) { for ( Iterator i = existRc . iterator ( ) ; ! outofdate && i . hasNext ( ) ; ) { Resource r = ( Resource ) i . next ( ) ; outofdate = ( r . getLastModified ( ) == 0L || r . getLastModified ( ) > destinationFile . lastModified ( ) ) ; } } if ( ! outofdate ) { log ( destinationFile + " is up-to-date." , Project . MSG_VERBOSE ) ; return null ; } return existRc ; } else { StringResource s = new StringResource ( ) ; s . setProject ( getProject ( ) ) ; s . setValue ( textBuffer . toString ( ) ) ; return s ; } } public void execute ( ) { ResourceCollection c = validate ( ) ; if ( c == null ) { return ; } if ( c . size ( ) < 1 && header == null && footer == null ) { log ( "No existing resources and no nested text, doing nothing" , Project . MSG_INFO ) ; return ; } if ( binary ) { binaryCat ( c ) ; } else { cat ( c ) ; } } private void binaryCat ( ResourceCollection c ) { log ( "Binary concatenation of " + c . size ( ) + " resources to " + destinationFile ) ; FileOutputStream out = null ; InputStream in = null ; try { try { out = new FileOutputStream ( destinationFile ) ; } catch ( Exception t ) { throw new BuildException ( "Unable to open " + destinationFile + " for writing" , t ) ; } in = new ConcatResourceInputStream ( c ) ; ( ( ConcatResourceInputStream ) in ) . setManagingComponent ( this ) ; Thread t = new Thread ( new StreamPumper ( in , out ) ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { try { t . join ( ) ; } catch ( InterruptedException ee ) { } } } finally { FileUtils . close ( in ) ; if ( out != null ) { try { out . close ( ) ; } catch ( Exception ex ) { throw new BuildException ( "Unable to close " + destinationFile , ex ) ; } } } } private void cat ( ResourceCollection c ) { OutputStream os = null ; char [ ] buffer = new char [ BUFFER_SIZE ] ; try { PrintWriter writer = null ; if ( outputWriter != null ) { writer = new PrintWriter ( outputWriter ) ; } else { if ( destinationFile == null ) { os = new LogOutputStream ( this , Project . MSG_WARN ) ; } else { File parent = destinationFile . getParentFile ( ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } os = new FileOutputStream ( destinationFile . getAbsolutePath ( ) , append ) ; } if ( outputEncoding == null ) { writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( os ) ) ) ; } else { writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( os , outputEncoding ) ) ) ; } } if ( header != null ) { if ( header . getFiltering ( ) ) { concatenate ( buffer , writer , new StringReader ( header . getValue ( ) ) ) ; } else { writer . print ( header . getValue ( ) ) ; } } if ( c . size ( ) > 0 ) { concatenate ( buffer , writer , new MultiReader ( c ) ) ; } if ( footer != null ) { if ( footer . getFiltering ( ) ) { concatenate ( buffer , writer , new StringReader ( footer . getValue ( ) ) ) ; } else { writer . print ( footer . getValue ( ) ) ; } } writer . flush ( ) ; if ( os != null ) { os . flush ( ) ; } } catch ( IOException ioex ) { throw new BuildException ( "Error while concatenating: " + ioex . getMessage ( ) , ioex ) ; } finally { FileUtils . close ( os ) ; } } private void concatenate ( char [ ] buffer , Writer writer , Reader in ) throws IOException { if ( filterChains != null ) { ChainReaderHelper helper = new ChainReaderHelper ( ) ; helper . setBufferSize ( BUFFER_SIZE ) ; helper . setPrimaryReader ( in ) ; helper . setFilterChains ( filterChains ) ; helper . setProject ( getProject ( ) ) ; in = new BufferedReader ( helper . getAssembledReader ( ) ) ; } while ( true ) { int nRead = in . read ( buffer , 0 , buffer . length ) ; if ( nRead == - 1 ) { break ; } writer . write ( buffer , 0 , nRead ) ; } writer . flush ( ) ; } private void sanitizeText ( ) { if ( textBuffer != null ) { if ( textBuffer . substring ( 0 ) . trim ( ) . length ( ) == 0 ) { textBuffer = null ; } } } public static class TextElement extends ProjectComponent { private String value = "" ; private boolean trimLeading = false ; private boolean trim = false ; private boolean filtering = true ; private String encoding = null ; public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } private boolean getFiltering ( ) { return filtering ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setFile ( File file ) throws BuildException { if ( ! file . exists ( ) ) { throw new BuildException ( "File " + file + " does not exist." ) ; } BufferedReader reader = null ; try { if ( this . encoding == null ) { reader = new BufferedReader ( new FileReader ( file ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , this . encoding ) ) ; } value = FileUtils . readFully ( reader ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } finally { FileUtils . close ( reader ) ; } } public void addText ( String value ) { this . value += getProject ( ) . replaceProperties ( value ) ; } public void setTrimLeading ( boolean strip ) { this . trimLeading = strip ; } public void setTrim ( boolean trim ) { this . trim = trim ; } public String getValue ( ) { if ( value == null ) { value = "" ; } if ( value . trim ( ) . length ( ) == 0 ) { value = "" ; } if ( trimLeading ) { char [ ] current = value . toCharArray ( ) ; StringBuffer b = new StringBuffer ( current . length ) ; boolean startOfLine = true ; int pos = 0 ; while ( pos < current . length ) { char ch = current [ pos ++ ] ; if ( startOfLine ) { if ( ch == ' ' || ch == '\t' ) { continue ; } startOfLine = false ; } b . append ( ch ) ; if ( ch == '\n' || ch == '\r' ) { startOfLine = true ; } } value = b . toString ( ) ; } if ( trim ) { value = value . trim ( ) ; } return value ; } } private class MultiReader extends Reader { private Reader reader = null ; private int lastPos = 0 ; private char [ ] lastChars = new char [ eolString . length ( ) ] ; private boolean needAddSeparator = false ; private Iterator i ; private MultiReader ( ResourceCollection c ) { i = c . iterator ( ) ; } private Reader getReader ( ) throws IOException { if ( reader == null && i . hasNext ( ) ) { Resource r = ( Resource ) i . next ( ) ; log ( "Concating " + r . toLongString ( ) , Project . MSG_VERBOSE ) ; InputStream is = r . getInputStream ( ) ; reader = new BufferedReader ( encoding == null ? new InputStreamReader ( is ) : new InputStreamReader ( is , encoding ) ) ; Arrays . fill ( lastChars , ( char ) 0 ) ; } return reader ; } private void nextReader ( ) throws IOException { close ( ) ; reader = null ; } public int read ( ) throws IOException { if ( needAddSeparator ) { int ret = eolString . charAt ( lastPos ++ ) ; if ( lastPos >= eolString . length ( ) ) { lastPos = 0 ; needAddSeparator = false ; } return ret ; } while ( getReader ( ) != null ) { int ch = getReader ( ) . read ( ) ; if ( ch == - 1 ) { nextReader ( ) ; if ( fixLastLine && isMissingEndOfLine ( ) ) { needAddSeparator = true ; lastPos = 0 ; } } else { addLastChar ( ( char ) ch ) ; return ch ; } } return - 1 ; } public int read ( char [ ] cbuf , int off , int len ) throws IOException { int amountRead = 0 ; while ( getReader ( ) != null || needAddSeparator ) { if ( needAddSeparator ) { cbuf [ off ] = eolString . charAt ( lastPos ++ ) ; if ( lastPos >= eolString . length ( ) ) { lastPos = 0 ; needAddSeparator = false ; } len -- ; off ++ ; amountRead ++ ; if ( len == 0 ) { return amountRead ; } continue ; } int nRead = getReader ( ) . read ( cbuf , off , len ) ; if ( nRead == - 1 || nRead == 0 ) { nextReader ( ) ; if ( fixLastLine && isMissingEndOfLine ( ) ) { needAddSeparator = true ; lastPos = 0 ; } } else { if ( fixLastLine ) { for ( int i = nRead ; i > ( nRead - lastChars . length ) ; -- i ) { if ( i <= 0 ) { break ; } addLastChar ( cbuf [ off + i - 1 ] ) ; } } len -= nRead ; off += nRead ; amountRead += nRead ; if ( len == 0 ) { return amountRead ; } } } if ( amountRead == 0 ) { return - 1 ; } else { return amountRead ; } } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } private void addLastChar ( char ch ) { for ( int i = lastChars . length - 2 ; i >= 0 ; -- i ) { lastChars [ i ] = lastChars [ i + 1 ] ; } lastChars [ lastChars . length - 1 ] = ch ; } private boolean isMissingEndOfLine ( ) { for ( int i = 0 ; i < lastChars . length ; ++ i ) { if ( lastChars [ i ] != eolString . charAt ( i ) ) { return true ; } } return false ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; public abstract class Unpack extends Task { protected File source ; protected File dest ; protected Resource srcResource ; public void setSrc ( String src ) { log ( "DEPRECATED - The setSrc(String) method has been deprecated." + " Use setSrc(File) instead." ) ; setSrc ( getProject ( ) . resolveFile ( src ) ) ; } public void setDest ( String dest ) { log ( "DEPRECATED - The setDest(String) method has been deprecated." + " Use setDest(File) instead." ) ; setDest ( getProject ( ) . resolveFile ( dest ) ) ; } public void setSrc ( File src ) { setSrcResource ( new FileResource ( src ) ) ; } public void setSrcResource ( Resource src ) { if ( ! src . isExists ( ) ) { throw new BuildException ( "the archive doesn't exist" ) ; } if ( src . isDirectory ( ) ) { throw new BuildException ( "the archive can't be a directory" ) ; } if ( src instanceof FileResource ) { source = ( ( FileResource ) src ) . getFile ( ) ; } else if ( ! supportsNonFileResources ( ) ) { throw new BuildException ( "Only FileSystem resources are" + " supported." ) ; } srcResource = src ; } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } public void setDest ( File dest ) { this . dest = dest ; } private void validate ( ) throws BuildException { if ( srcResource == null ) { throw new BuildException ( "No Src specified" , getLocation ( ) ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String defaultExtension = getDefaultExtension ( ) ; createDestFile ( defaultExtension ) ; } } private void createDestFile ( String defaultExtension ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( defaultExtension != null && len > defaultExtension . length ( ) && defaultExtension . equalsIgnoreCase ( sourceName . substring ( len - defaultExtension . length ( ) ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - defaultExtension . length ( ) ) ) ; } else { dest = new File ( dest , sourceName ) ; } } public void execute ( ) throws BuildException { File savedDest = dest ; try { validate ( ) ; extract ( ) ; } finally { dest = savedDest ; } } protected abstract String getDefaultExtension ( ) ; protected abstract void extract ( ) ; protected boolean supportsNonFileResources ( ) { return false ; } } 	1
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; import java . net . URL ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import javax . xml . transform . TransformerConfigurationException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . XSLTLiaison3 ; import org . apache . tools . ant . taskdefs . XSLTLogger ; import org . apache . tools . ant . taskdefs . XSLTLoggerAware ; import org . apache . tools . ant . taskdefs . XSLTProcess ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . URLResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class TraXLiaison implements XSLTLiaison3 , ErrorListener , XSLTLoggerAware { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private Project project ; private String factoryName = null ; private TransformerFactory tfactory = null ; private Resource stylesheet ; private XSLTLogger logger ; private EntityResolver entityResolver ; private Transformer transformer ; private Templates templates ; private long templatesModTime ; private URIResolver uriResolver ; private Vector outputProperties = new Vector ( ) ; private Hashtable params = new Hashtable ( ) ; private Vector attributes = new Vector ( ) ; public TraXLiaison ( ) throws Exception { } public void setStylesheet ( File stylesheet ) throws Exception { FileResource fr = new FileResource ( ) ; fr . setProject ( project ) ; fr . setFile ( stylesheet ) ; setStylesheet ( fr ) ; } public void setStylesheet ( Resource stylesheet ) throws Exception { if ( this . stylesheet != null ) { transformer = null ; if ( ! this . stylesheet . equals ( stylesheet ) || ( stylesheet . getLastModified ( ) != templatesModTime ) ) { templates = null ; } } this . stylesheet = stylesheet ; } public void transform ( File infile , File outfile ) throws Exception { if ( transformer == null ) { createTransformer ( ) ; } InputStream fis = null ; OutputStream fos = null ; try { fis = new BufferedInputStream ( new FileInputStream ( infile ) ) ; fos = new BufferedOutputStream ( new FileOutputStream ( outfile ) ) ; StreamResult res = new StreamResult ( fos ) ; res . setSystemId ( JAXPUtils . getSystemId ( outfile ) ) ; Source src = getSource ( fis , infile ) ; setTransformationParameters ( ) ; transformer . transform ( src , res ) ; } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } try { if ( fos != null ) { fos . close ( ) ; } } catch ( IOException ignored ) { } } } private Source getSource ( InputStream is , File infile ) throws ParserConfigurationException , SAXException { Source src = null ; if ( entityResolver != null ) { if ( getFactory ( ) . getFeature ( SAXSource . FEATURE ) ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; XMLReader reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; reader . setEntityResolver ( entityResolver ) ; src = new SAXSource ( reader , new InputSource ( is ) ) ; } else { throw new IllegalStateException ( "xcatalog specified, but " + "parser doesn't support SAX" ) ; } } else { src = new StreamSource ( is ) ; } src . setSystemId ( JAXPUtils . getSystemId ( infile ) ) ; return src ; } private Source getSource ( InputStream is , Resource resource ) throws ParserConfigurationException , SAXException { Source src = null ; if ( entityResolver != null ) { if ( getFactory ( ) . getFeature ( SAXSource . FEATURE ) ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; XMLReader reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; reader . setEntityResolver ( entityResolver ) ; src = new SAXSource ( reader , new InputSource ( is ) ) ; } else { throw new IllegalStateException ( "xcatalog specified, but " + "parser doesn't support SAX" ) ; } } else { src = new StreamSource ( is ) ; } src . setSystemId ( resourceToURI ( resource ) ) ; return src ; } private String resourceToURI ( Resource resource ) { if ( resource instanceof FileResource ) { File f = ( ( FileResource ) resource ) . getFile ( ) ; return FILE_UTILS . toURI ( f . getAbsolutePath ( ) ) ; } if ( resource instanceof URLResource ) { URL u = ( ( URLResource ) resource ) . getURL ( ) ; return String . valueOf ( u ) ; } else { return resource . getName ( ) ; } } private void readTemplates ( ) throws IOException , TransformerConfigurationException , ParserConfigurationException , SAXException { InputStream xslStream = null ; try { xslStream = new BufferedInputStream ( stylesheet . getInputStream ( ) ) ; templatesModTime = stylesheet . getLastModified ( ) ; Source src = getSource ( xslStream , stylesheet ) ; templates = getFactory ( ) . newTemplates ( src ) ; } finally { if ( xslStream != null ) { xslStream . close ( ) ; } } } private void createTransformer ( ) throws Exception { if ( templates == null ) { readTemplates ( ) ; } transformer = templates . newTransformer ( ) ; transformer . setErrorListener ( this ) ; if ( uriResolver != null ) { transformer . setURIResolver ( uriResolver ) ; } for ( int i = 0 ; i < outputProperties . size ( ) ; i ++ ) { final String [ ] pair = ( String [ ] ) outputProperties . elementAt ( i ) ; transformer . setOutputProperty ( pair [ 0 ] , pair [ 1 ] ) ; } } private void setTransformationParameters ( ) { for ( final Enumeration enumeration = params . keys ( ) ; enumeration . hasMoreElements ( ) ; ) { final String name = ( String ) enumeration . nextElement ( ) ; final String value = ( String ) params . get ( name ) ; transformer . setParameter ( name , value ) ; } } private TransformerFactory getFactory ( ) throws BuildException { if ( tfactory != null ) { return tfactory ; } if ( factoryName == null ) { tfactory = TransformerFactory . newInstance ( ) ; } else { try { Class clazz = Class . forName ( factoryName ) ; tfactory = ( TransformerFactory ) clazz . newInstance ( ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } tfactory . setErrorListener ( this ) ; for ( int i = 0 ; i < attributes . size ( ) ; i ++ ) { final Object [ ] pair = ( Object [ ] ) attributes . elementAt ( i ) ; tfactory . setAttribute ( ( String ) pair [ 0 ] , pair [ 1 ] ) ; } if ( uriResolver != null ) { tfactory . setURIResolver ( uriResolver ) ; } return tfactory ; } public void setFactory ( String name ) { factoryName = name ; } public void setAttribute ( String name , Object value ) { final Object [ ] pair = new Object [ ] { name , value } ; attributes . addElement ( pair ) ; } public void setOutputProperty ( String name , String value ) { final String [ ] pair = new String [ ] { name , value } ; outputProperties . addElement ( pair ) ; } public void setEntityResolver ( EntityResolver aResolver ) { entityResolver = aResolver ; } public void setURIResolver ( URIResolver aResolver ) { uriResolver = aResolver ; } public void addParam ( String name , String value ) { params . put ( name , value ) ; } public void setLogger ( XSLTLogger l ) { logger = l ; } public void error ( TransformerException e ) { logError ( e , "Error" ) ; } public void fatalError ( TransformerException e ) { logError ( e , "Fatal Error" ) ; throw new BuildException ( "Fatal error during transformation" , e ) ; } public void warning ( TransformerException e ) { logError ( e , "Warning" ) ; } private void logError ( TransformerException e , String type ) { if ( logger == null ) { return ; } StringBuffer msg = new StringBuffer ( ) ; SourceLocator locator = e . getLocator ( ) ; if ( locator != null ) { String systemid = locator . getSystemId ( ) ; if ( systemid != null ) { String url = systemid ; if ( url . startsWith ( "file:" ) ) { url = FileUtils . getFileUtils ( ) . fromURI ( url ) ; } msg . append ( url ) ; } else { msg . append ( "Unknown file" ) ; } int line = locator . getLineNumber ( ) ; if ( line != - 1 ) { msg . append ( ":" ) ; msg . append ( line ) ; int column = locator . getColumnNumber ( ) ; if ( column != - 1 ) { msg . append ( ":" ) ; msg . append ( column ) ; } } } msg . append ( ": " ) ; msg . append ( type ) ; msg . append ( "! " ) ; msg . append ( e . getMessage ( ) ) ; if ( e . getCause ( ) != null ) { msg . append ( " Cause: " ) ; msg . append ( e . getCause ( ) ) ; } logger . log ( msg . toString ( ) ) ; } protected String getSystemId ( File file ) { return JAXPUtils . getSystemId ( file ) ; } public void configure ( XSLTProcess xsltTask ) { project = xsltTask . getProject ( ) ; XSLTProcess . Factory factory = xsltTask . getFactory ( ) ; if ( factory != null ) { setFactory ( factory . getName ( ) ) ; for ( Enumeration attrs = factory . getAttributes ( ) ; attrs . hasMoreElements ( ) ; ) { XSLTProcess . Factory . Attribute attr = ( XSLTProcess . Factory . Attribute ) attrs . nextElement ( ) ; setAttribute ( attr . getName ( ) , attr . getValue ( ) ) ; } } XMLCatalog xmlCatalog = xsltTask . getXMLCatalog ( ) ; if ( xmlCatalog != null ) { setEntityResolver ( xmlCatalog ) ; setURIResolver ( xmlCatalog ) ; } for ( Enumeration props = xsltTask . getOutputProperties ( ) ; props . hasMoreElements ( ) ; ) { XSLTProcess . OutputProperty prop = ( XSLTProcess . OutputProperty ) props . nextElement ( ) ; setOutputProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } } } 	1
package org . apache . tools . ant . launch ; import java . net . MalformedURLException ; import java . net . URL ; import java . io . File ; import java . io . FilenameFilter ; import java . io . ByteArrayOutputStream ; import java . io . UnsupportedEncodingException ; import java . text . CharacterIterator ; import java . text . StringCharacterIterator ; import java . util . Locale ; public final class Locator { public static final String URI_ENCODING = "UTF-8" ; private static boolean [ ] gNeedEscaping = new boolean [ 128 ] ; private static char [ ] gAfterEscaping1 = new char [ 128 ] ; private static char [ ] gAfterEscaping2 = new char [ 128 ] ; private static char [ ] gHexChs = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; static { for ( int i = 0 ; i <= 0x1f ; i ++ ) { gNeedEscaping [ i ] = true ; gAfterEscaping1 [ i ] = gHexChs [ i > > 4 ] ; gAfterEscaping2 [ i ] = gHexChs [ i & 0xf ] ; } gNeedEscaping [ 0x7f ] = true ; gAfterEscaping1 [ 0x7f ] = '7' ; gAfterEscaping2 [ 0x7f ] = 'F' ; char [ ] escChs = { ' ' , '<' , '>' , '#' , '%' , '"' , '{' , '}' , '|' , '\\' , '^' , '~' , '[' , ']' , '`' } ; int len = escChs . length ; char ch ; for ( int i = 0 ; i < len ; i ++ ) { ch = escChs [ i ] ; gNeedEscaping [ ch ] = true ; gAfterEscaping1 [ ch ] = gHexChs [ ch > > 4 ] ; gAfterEscaping2 [ ch ] = gHexChs [ ch & 0xf ] ; } } private Locator ( ) { } public static File getClassSource ( Class c ) { String classResource = c . getName ( ) . replace ( '.' , '/' ) + ".class" ; return getResourceSource ( c . getClassLoader ( ) , classResource ) ; } public static File getResourceSource ( ClassLoader c , String resource ) { if ( c == null ) { c = Locator . class . getClassLoader ( ) ; } URL url = null ; if ( c == null ) { url = ClassLoader . getSystemResource ( resource ) ; } else { url = c . getResource ( resource ) ; } if ( url != null ) { String u = url . toString ( ) ; if ( u . startsWith ( "jar:file:" ) ) { int pling = u . indexOf ( "!" ) ; String jarName = u . substring ( 4 , pling ) ; return new File ( fromURI ( jarName ) ) ; } else if ( u . startsWith ( "file:" ) ) { int tail = u . indexOf ( resource ) ; String dirName = u . substring ( 0 , tail ) ; return new File ( fromURI ( dirName ) ) ; } } return null ; } public static String fromURI ( String uri ) { Class uriClazz = null ; try { uriClazz = Class . forName ( "java.net.URI" ) ; } catch ( ClassNotFoundException cnfe ) { } if ( uriClazz != null && uri . startsWith ( "file:/" ) ) { try { java . lang . reflect . Method createMethod = uriClazz . getMethod ( "create" , new Class [ ] { String . class } ) ; Object uriObj = createMethod . invoke ( null , new Object [ ] { uri } ) ; java . lang . reflect . Constructor fileConst = File . class . getConstructor ( new Class [ ] { uriClazz } ) ; File f = ( File ) fileConst . newInstance ( new Object [ ] { uriObj } ) ; return f . getAbsolutePath ( ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { Throwable e2 = e . getTargetException ( ) ; if ( e2 instanceof IllegalArgumentException ) { throw ( IllegalArgumentException ) e2 ; } else { e2 . printStackTrace ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } URL url = null ; try { url = new URL ( uri ) ; } catch ( MalformedURLException emYouEarlEx ) { } if ( url == null || ! ( "file" . equals ( url . getProtocol ( ) ) ) ) { throw new IllegalArgumentException ( "Can only handle valid file: URIs" ) ; } StringBuffer buf = new StringBuffer ( url . getHost ( ) ) ; if ( buf . length ( ) > 0 ) { buf . insert ( 0 , File . separatorChar ) . insert ( 0 , File . separatorChar ) ; } String file = url . getFile ( ) ; int queryPos = file . indexOf ( '?' ) ; buf . append ( ( queryPos < 0 ) ? file : file . substring ( 0 , queryPos ) ) ; uri = buf . toString ( ) . replace ( '/' , File . separatorChar ) ; if ( File . pathSeparatorChar == ';' && uri . startsWith ( "\\" ) && uri . length ( ) > 2 && Character . isLetter ( uri . charAt ( 1 ) ) && uri . lastIndexOf ( ':' ) > - 1 ) { uri = uri . substring ( 1 ) ; } String path = null ; try { path = decodeUri ( uri ) ; String cwd = System . getProperty ( "user.dir" ) ; int posi = cwd . indexOf ( ":" ) ; if ( ( posi > 0 ) && path . startsWith ( File . separator ) ) { path = cwd . substring ( 0 , posi + 1 ) + path ; } } catch ( UnsupportedEncodingException exc ) { throw new IllegalStateException ( "Could not convert URI to path: " + exc . getMessage ( ) ) ; } return path ; } public static String decodeUri ( String uri ) throws UnsupportedEncodingException { if ( uri . indexOf ( '%' ) == - 1 ) { return uri ; } ByteArrayOutputStream sb = new ByteArrayOutputStream ( uri . length ( ) ) ; CharacterIterator iter = new StringCharacterIterator ( uri ) ; for ( char c = iter . first ( ) ; c != CharacterIterator . DONE ; c = iter . next ( ) ) { if ( c == '%' ) { char c1 = iter . next ( ) ; if ( c1 != CharacterIterator . DONE ) { int i1 = Character . digit ( c1 , 16 ) ; char c2 = iter . next ( ) ; if ( c2 != CharacterIterator . DONE ) { int i2 = Character . digit ( c2 , 16 ) ; sb . write ( ( char ) ( ( i1 << 4 ) + i2 ) ) ; } } } else { sb . write ( c ) ; } } return sb . toString ( URI_ENCODING ) ; } public static String encodeURI ( String path ) throws UnsupportedEncodingException { int i = 0 ; int len = path . length ( ) ; int ch = 0 ; StringBuffer sb = null ; for ( ; i < len ; i ++ ) { ch = path . charAt ( i ) ; if ( ch >= 128 ) { break ; } if ( gNeedEscaping [ ch ] ) { if ( sb == null ) { sb = new StringBuffer ( path . substring ( 0 , i ) ) ; } sb . append ( '%' ) ; sb . append ( gAfterEscaping1 [ ch ] ) ; sb . append ( gAfterEscaping2 [ ch ] ) ; } else if ( sb != null ) { sb . append ( ( char ) ch ) ; } } if ( i < len ) { if ( sb == null ) { sb = new StringBuffer ( path . substring ( 0 , i ) ) ; } byte [ ] bytes = null ; byte b ; bytes = path . substring ( i ) . getBytes ( URI_ENCODING ) ; len = bytes . length ; for ( i = 0 ; i < len ; i ++ ) { b = bytes [ i ] ; if ( b < 0 ) { ch = b + 256 ; sb . append ( '%' ) ; sb . append ( gHexChs [ ch > > 4 ] ) ; sb . append ( gHexChs [ ch & 0xf ] ) ; } else if ( gNeedEscaping [ b ] ) { sb . append ( '%' ) ; sb . append ( gAfterEscaping1 [ b ] ) ; sb . append ( gAfterEscaping2 [ b ] ) ; } else { sb . append ( ( char ) b ) ; } } } return sb == null ? path : sb . toString ( ) ; } public static URL fileToURL ( File file ) throws MalformedURLException { try { return new URL ( encodeURI ( file . toURL ( ) . toString ( ) ) ) ; } catch ( UnsupportedEncodingException ex ) { throw new MalformedURLException ( ex . toString ( ) ) ; } } public static File getToolsJar ( ) { boolean toolsJarAvailable = false ; try { Class . forName ( "com.sun.tools.javac.Main" ) ; toolsJarAvailable = true ; } catch ( Exception e ) { try { Class . forName ( "sun.tools.javac.Main" ) ; toolsJarAvailable = true ; } catch ( Exception e2 ) { } } if ( toolsJarAvailable ) { return null ; } String javaHome = System . getProperty ( "java.home" ) ; File toolsJar = new File ( javaHome + "/lib/tools.jar" ) ; if ( toolsJar . exists ( ) ) { return toolsJar ; } if ( javaHome . toLowerCase ( Locale . US ) . endsWith ( File . separator + "jre" ) ) { javaHome = javaHome . substring ( 0 , javaHome . length ( ) - 4 ) ; toolsJar = new File ( javaHome + "/lib/tools.jar" ) ; } if ( ! toolsJar . exists ( ) ) { System . out . println ( "Unable to locate tools.jar. " + "Expected to find it in " + toolsJar . getPath ( ) ) ; return null ; } return toolsJar ; } public static URL [ ] getLocationURLs ( File location ) throws MalformedURLException { return getLocationURLs ( location , new String [ ] { ".jar" } ) ; } public static URL [ ] getLocationURLs ( File location , final String [ ] extensions ) throws MalformedURLException { URL [ ] urls = new URL [ 0 ] ; if ( ! location . exists ( ) ) { return urls ; } if ( ! location . isDirectory ( ) ) { urls = new URL [ 1 ] ; String path = location . getPath ( ) ; for ( int i = 0 ; i < extensions . length ; ++ i ) { if ( path . toLowerCase ( ) . endsWith ( extensions [ i ] ) ) { urls [ 0 ] = fileToURL ( location ) ; break ; } } return urls ; } File [ ] matches = location . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { for ( int i = 0 ; i < extensions . length ; ++ i ) { if ( name . toLowerCase ( ) . endsWith ( extensions [ i ] ) ) { return true ; } } return false ; } } ) ; urls = new URL [ matches . length ] ; for ( int i = 0 ; i < matches . length ; ++ i ) { urls [ i ] = fileToURL ( matches [ i ] ) ; } return urls ; } } 	1
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . FileUtils ; public final class SelectorUtils { private static SelectorUtils instance = new SelectorUtils ( ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private SelectorUtils ( ) { } public static SelectorUtils getInstance ( ) { return instance ; } public static boolean matchPatternStart ( String pattern , String str ) { return matchPatternStart ( pattern , str , true ) ; } public static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } String [ ] patDirs = tokenizePathAsArray ( pattern ) ; String [ ] strDirs = tokenizePathAsArray ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . length - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxStart ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxStart ] , isCaseSensitive ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } public static boolean matchPath ( String pattern , String str ) { return matchPath ( pattern , str , true ) ; } public static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { String [ ] patDirs = tokenizePathAsArray ( pattern ) ; String [ ] strDirs = tokenizePathAsArray ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . length - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxStart ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxStart ] , isCaseSensitive ) ) { patDirs = null ; strDirs = null ; return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { patDirs = null ; strDirs = null ; return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxEnd ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxEnd ] , isCaseSensitive ) ) { patDirs = null ; strDirs = null ; return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs [ i ] . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = patDirs [ patIdxStart + j + 1 ] ; String subStr = strDirs [ strIdxStart + i + j ] ; if ( ! match ( subPat , subStr , isCaseSensitive ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { patDirs = null ; strDirs = null ; return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } public static boolean match ( String pattern , String str ) { return match ( pattern , str , true ) ; } public static boolean match ( String pattern , String str , boolean isCaseSensitive ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ i ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ i ] ) ) { return false ; } } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart ] ) ) { return false ; } } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxEnd ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxEnd ] ) ) { return false ; } } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart + i + j ] ) ) { continue strLoop ; } } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public static Vector tokenizePath ( String path ) { return tokenizePath ( path , File . separator ) ; } public static Vector tokenizePath ( String path , String separator ) { Vector ret = new Vector ( ) ; if ( FileUtils . isAbsolutePath ( path ) ) { String [ ] s = FILE_UTILS . dissect ( path ) ; ret . add ( s [ 0 ] ) ; path = s [ 1 ] ; } StringTokenizer st = new StringTokenizer ( path , separator ) ; while ( st . hasMoreTokens ( ) ) { ret . addElement ( st . nextToken ( ) ) ; } return ret ; } private static String [ ] tokenizePathAsArray ( String path ) { String root = null ; if ( FileUtils . isAbsolutePath ( path ) ) { String [ ] s = FILE_UTILS . dissect ( path ) ; root = s [ 0 ] ; path = s [ 1 ] ; } char sep = File . separatorChar ; int start = 0 ; int len = path . length ( ) ; int count = 0 ; for ( int pos = 0 ; pos < len ; pos ++ ) { if ( path . charAt ( pos ) == sep ) { if ( pos != start ) { count ++ ; } start = pos + 1 ; } } if ( len != start ) { count ++ ; } String [ ] l = new String [ count + ( ( root == null ) ? 0 : 1 ) ] ; if ( root != null ) { l [ 0 ] = root ; count = 1 ; } else { count = 0 ; } start = 0 ; for ( int pos = 0 ; pos < len ; pos ++ ) { if ( path . charAt ( pos ) == sep ) { if ( pos != start ) { String tok = path . substring ( start , pos ) ; l [ count ++ ] = tok ; } start = pos + 1 ; } } if ( len != start ) { String tok = path . substring ( start ) ; l [ count ] = tok ; } return l ; } public static boolean isOutOfDate ( File src , File target , int granularity ) { if ( ! src . exists ( ) ) { return false ; } if ( ! target . exists ( ) ) { return true ; } if ( ( src . lastModified ( ) - granularity ) > target . lastModified ( ) ) { return true ; } return false ; } public static boolean isOutOfDate ( Resource src , Resource target , int granularity ) { return isOutOfDate ( src , target , ( long ) granularity ) ; } public static boolean isOutOfDate ( Resource src , Resource target , long granularity ) { if ( ! src . isExists ( ) ) { return false ; } if ( ! target . isExists ( ) ) { return true ; } if ( ( src . getLastModified ( ) - granularity ) > target . getLastModified ( ) ) { return true ; } return false ; } public static String removeWhitespace ( String input ) { StringBuffer result = new StringBuffer ( ) ; if ( input != null ) { StringTokenizer st = new StringTokenizer ( input ) ; while ( st . hasMoreTokens ( ) ) { result . append ( st . nextToken ( ) ) ; } } return result . toString ( ) ; } public static boolean hasWildcards ( String input ) { return ( input . indexOf ( '*' ) != - 1 || input . indexOf ( '?' ) != - 1 ) ; } public static String rtrimWildcardTokens ( String input ) { String [ ] tokens = tokenizePathAsArray ( input ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . length ; i ++ ) { if ( hasWildcards ( tokens [ i ] ) ) { break ; } if ( i > 0 && sb . charAt ( sb . length ( ) - 1 ) != File . separatorChar ) { sb . append ( File . separator ) ; } sb . append ( tokens [ i ] ) ; } return sb . toString ( ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; public class Move extends Copy { public Move ( ) { super ( ) ; setOverwrite ( true ) ; } protected void validateAttributes ( ) throws BuildException { if ( file != null && file . isDirectory ( ) ) { if ( ( destFile != null && destDir != null ) || ( destFile == null && destDir == null ) ) { throw new BuildException ( "One and only one of tofile and todir " + "must be set." ) ; } destFile = ( destFile == null ) ? new File ( destDir , file . getName ( ) ) : destFile ; destDir = ( destDir == null ) ? destFile . getParentFile ( ) : destDir ; completeDirMap . put ( file , destFile ) ; file = null ; } else { super . validateAttributes ( ) ; } } protected void doFileOperations ( ) { if ( completeDirMap . size ( ) > 0 ) { Enumeration e = completeDirMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { File fromDir = ( File ) e . nextElement ( ) ; File toDir = ( File ) completeDirMap . get ( fromDir ) ; boolean renamed = false ; try { log ( "Attempting to rename dir: " + fromDir + " to " + toDir , verbosity ) ; renamed = renameFile ( fromDir , toDir , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename dir " + fromDir + " to " + toDir + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } if ( ! renamed ) { FileSet fs = new FileSet ( ) ; fs . setProject ( getProject ( ) ) ; fs . setDir ( fromDir ) ; addFileset ( fs ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; scan ( fromDir , toDir , files , dirs ) ; } } } int moveCount = fileCopyMap . size ( ) ; if ( moveCount > 0 ) { log ( "Moving " + moveCount + " file" + ( ( moveCount == 1 ) ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; File f = new File ( fromFile ) ; boolean selfMove = false ; if ( f . exists ( ) ) { String [ ] toFiles = ( String [ ] ) fileCopyMap . get ( fromFile ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = ( String ) toFiles [ i ] ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-move of " + fromFile , verbosity ) ; selfMove = true ; continue ; } File d = new File ( toFile ) ; if ( ( i + 1 ) == toFiles . length && ! selfMove ) { moveFile ( f , d , filtering , forceOverwrite ) ; } else { copyFile ( f , d , filtering , forceOverwrite ) ; } } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . keys ( ) ; int createCount = 0 ; while ( e . hasMoreElements ( ) ) { String fromDirName = ( String ) e . nextElement ( ) ; String [ ] toDirNames = ( String [ ] ) dirCopyMap . get ( fromDirName ) ; boolean selfMove = false ; for ( int i = 0 ; i < toDirNames . length ; i ++ ) { if ( fromDirName . equals ( toDirNames [ i ] ) ) { log ( "Skipping self-move of " + fromDirName , verbosity ) ; selfMove = true ; continue ; } File d = new File ( toDirNames [ i ] ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { createCount ++ ; } } } File fromDir = new File ( fromDirName ) ; if ( ! selfMove && okToDelete ( fromDir ) ) { deleteDir ( fromDir ) ; } } if ( createCount > 0 ) { log ( "Moved " + dirCopyMap . size ( ) + " empty director" + ( dirCopyMap . size ( ) == 1 ? "y" : "ies" ) + " to " + createCount + " empty director" + ( createCount == 1 ? "y" : "ies" ) + " under " + destDir . getAbsolutePath ( ) ) ; } } } private void moveFile ( File fromFile , File toFile , boolean filtering , boolean overwrite ) { boolean moved = false ; try { log ( "Attempting to rename: " + fromFile + " to " + toFile , verbosity ) ; moved = renameFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } if ( ! moved ) { copyFile ( fromFile , toFile , filtering , overwrite ) ; if ( ! fromFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + "file " + fromFile . getAbsolutePath ( ) ) ; } } } private void copyFile ( File fromFile , File toFile , boolean filtering , boolean overwrite ) { try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = getFilterSets ( ) . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } getFileUtils ( ) . copyFile ( fromFile , toFile , executionFilters , getFilterChains ( ) , forceOverwrite , getPreserveLastModified ( ) , getEncoding ( ) , getOutputEncoding ( ) , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } protected boolean okToDelete ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { return false ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { if ( ! okToDelete ( f ) ) { return false ; } } else { return false ; } } return true ; } protected void deleteDir ( File d ) { deleteDir ( d , false ) ; } protected void deleteDir ( File d , boolean deleteFiles ) { String [ ] list = d . list ( ) ; if ( list == null ) { return ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { deleteDir ( f ) ; } else if ( deleteFiles && ! ( f . delete ( ) ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } else { throw new BuildException ( "UNEXPECTED ERROR - The file " + f . getAbsolutePath ( ) + " should not exist!" ) ; } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + d . getAbsolutePath ( ) ) ; } } protected boolean renameFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException , BuildException { boolean renamed = false ; if ( ( getFilterSets ( ) . size ( ) + getFilterChains ( ) . size ( ) == 0 ) && ! ( filtering || destFile . isDirectory ( ) ) ) { File parent = destFile . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) { parent . mkdirs ( ) ; } if ( destFile . isFile ( ) && ! destFile . equals ( sourceFile ) && ! destFile . delete ( ) ) { throw new BuildException ( "Unable to remove existing " + "file " + destFile ) ; } renamed = sourceFile . renameTo ( destFile ) ; } return renamed ; } } 	1
package org . apache . tools . ant ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . taskdefs . PreSetDef ; public final class IntrospectionHelper { private static final Map EMPTY_MAP = Collections . unmodifiableMap ( new HashMap ( 0 ) ) ; private static final Map HELPERS = new Hashtable ( ) ; private static final Map PRIMITIVE_TYPE_MAP = new HashMap ( 8 ) ; static { Class [ ] primitives = { Boolean . TYPE , Byte . TYPE , Character . TYPE , Short . TYPE , Integer . TYPE , Long . TYPE , Float . TYPE , Double . TYPE } ; Class [ ] wrappers = { Boolean . class , Byte . class , Character . class , Short . class , Integer . class , Long . class , Float . class , Double . class } ; for ( int i = 0 ; i < primitives . length ; i ++ ) { PRIMITIVE_TYPE_MAP . put ( primitives [ i ] , wrappers [ i ] ) ; } } private static final int MAX_REPORT_NESTED_TEXT = 20 ; private static final String ELLIPSIS = "..." ; private Hashtable attributeTypes = new Hashtable ( ) ; private Hashtable attributeSetters = new Hashtable ( ) ; private Hashtable nestedTypes = new Hashtable ( ) ; private Hashtable nestedCreators = new Hashtable ( ) ; private List addTypeMethods = new ArrayList ( ) ; private Method addText = null ; private Class bean ; private IntrospectionHelper ( final Class bean ) { this . bean = bean ; Method [ ] methods = bean . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final Method m = methods [ i ] ; final String name = m . getName ( ) ; Class returnType = m . getReturnType ( ) ; Class [ ] args = m . getParameterTypes ( ) ; if ( args . length == 1 && java . lang . Void . TYPE . equals ( returnType ) && ( "add" . equals ( name ) || "addConfigured" . equals ( name ) ) ) { insertAddTypeMethod ( m ) ; continue ; } if ( org . apache . tools . ant . ProjectComponent . class . isAssignableFrom ( bean ) && args . length == 1 && isHiddenSetMethod ( name , args [ 0 ] ) ) { continue ; } if ( isContainer ( ) && args . length == 1 && "addTask" . equals ( name ) && org . apache . tools . ant . Task . class . equals ( args [ 0 ] ) ) { continue ; } if ( "addText" . equals ( name ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && java . lang . String . class . equals ( args [ 0 ] ) ) { addText = methods [ i ] ; } else if ( name . startsWith ( "set" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! args [ 0 ] . isArray ( ) ) { String propName = getPropertyName ( name , "set" ) ; if ( attributeSetters . get ( propName ) != null ) { if ( java . lang . String . class . equals ( args [ 0 ] ) ) { continue ; } } AttributeSetter as = createAttributeSetter ( m , args [ 0 ] , propName ) ; if ( as != null ) { attributeTypes . put ( propName , args [ 0 ] ) ; attributeSetters . put ( propName , as ) ; } } else if ( name . startsWith ( "create" ) && ! returnType . isArray ( ) && ! returnType . isPrimitive ( ) && args . length == 0 ) { String propName = getPropertyName ( name , "create" ) ; if ( nestedCreators . get ( propName ) == null ) { nestedTypes . put ( propName , returnType ) ; nestedCreators . put ( propName , new CreateNestedCreator ( m ) ) ; } } else if ( name . startsWith ( "addConfigured" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { Constructor constructor = null ; try { constructor = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; } catch ( NoSuchMethodException ex ) { constructor = args [ 0 ] . getConstructor ( new Class [ ] { Project . class } ) ; } String propName = getPropertyName ( name , "addConfigured" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new AddNestedCreator ( m , constructor , AddNestedCreator . ADD_CONFIGURED ) ) ; } catch ( NoSuchMethodException nse ) { } } else if ( name . startsWith ( "add" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { Constructor constructor = null ; try { constructor = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; } catch ( NoSuchMethodException ex ) { constructor = args [ 0 ] . getConstructor ( new Class [ ] { Project . class } ) ; } String propName = getPropertyName ( name , "add" ) ; if ( nestedTypes . get ( propName ) != null ) { continue ; } nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new AddNestedCreator ( m , constructor , AddNestedCreator . ADD ) ) ; } catch ( NoSuchMethodException nse ) { } } } } private boolean isHiddenSetMethod ( String name , Class type ) { if ( "setLocation" . equals ( name ) && org . apache . tools . ant . Location . class . equals ( type ) ) { return true ; } if ( "setTaskType" . equals ( name ) && java . lang . String . class . equals ( type ) ) { return true ; } return false ; } public static synchronized IntrospectionHelper getHelper ( Class c ) { return getHelper ( null , c ) ; } public static IntrospectionHelper getHelper ( Project p , Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) HELPERS . get ( c . getName ( ) ) ; if ( ih == null || ih . bean != c ) { ih = new IntrospectionHelper ( c ) ; if ( p != null ) { HELPERS . put ( c . getName ( ) , ih ) ; } } return ih ; } public void setAttribute ( Project p , Object element , String attributeName , String value ) throws BuildException { AttributeSetter as = ( AttributeSetter ) attributeSetters . get ( attributeName . toLowerCase ( Locale . US ) ) ; if ( as == null ) { if ( element instanceof DynamicAttributeNS ) { DynamicAttributeNS dc = ( DynamicAttributeNS ) element ; String uriPlusPrefix = ProjectHelper . extractUriFromComponentName ( attributeName ) ; String uri = ProjectHelper . extractUriFromComponentName ( uriPlusPrefix ) ; String localName = ProjectHelper . extractNameFromComponentName ( attributeName ) ; String qName = ( "" . equals ( uri ) ? localName : ( uri + ":" + localName ) ) ; dc . setDynamicAttribute ( uri , localName , qName , value ) ; return ; } else if ( element instanceof DynamicAttribute ) { DynamicAttribute dc = ( DynamicAttribute ) element ; dc . setDynamicAttribute ( attributeName . toLowerCase ( Locale . US ) , value ) ; return ; } else { if ( attributeName . indexOf ( ':' ) != - 1 ) { return ; } String msg = getElementName ( p , element ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new UnsupportedAttributeException ( msg , attributeName ) ; } } try { as . set ( p , element , value ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void addText ( Project project , Object element , String text ) throws BuildException { if ( addText == null ) { text = text . trim ( ) ; if ( text . length ( ) == 0 ) { return ; } else { String msg = project . getElementName ( element ) + " doesn't support nested text data (\"" + condenseText ( text ) + "\")." ; throw new BuildException ( msg ) ; } } try { addText . invoke ( element , new Object [ ] { text } ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void throwNotSupported ( Project project , Object parent , String elementName ) { String msg = project . getElementName ( parent ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new UnsupportedElementException ( msg , elementName ) ; } private NestedCreator getNestedCreator ( Project project , String parentUri , Object parent , String elementName , UnknownElement child ) throws BuildException { String uri = ProjectHelper . extractUriFromComponentName ( elementName ) ; String name = ProjectHelper . extractNameFromComponentName ( elementName ) ; if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } if ( parentUri . equals ( ProjectHelper . ANT_CORE_URI ) ) { parentUri = "" ; } NestedCreator nc = null ; if ( uri . equals ( parentUri ) || uri . equals ( "" ) ) { nc = ( NestedCreator ) nestedCreators . get ( name . toLowerCase ( Locale . US ) ) ; } if ( nc == null ) { nc = createAddTypeCreator ( project , parent , elementName ) ; } if ( nc == null && parent instanceof DynamicElementNS ) { DynamicElementNS dc = ( DynamicElementNS ) parent ; String qName = ( child == null ? name : child . getQName ( ) ) ; final Object nestedElement = dc . createDynamicElement ( ( child == null ? "" : child . getNamespace ( ) ) , name , qName ) ; if ( nestedElement != null ) { nc = new NestedCreator ( null ) { Object create ( Project project , Object parent , Object ignore ) { return nestedElement ; } } ; } } if ( nc == null && parent instanceof DynamicElement ) { DynamicElement dc = ( DynamicElement ) parent ; final Object nestedElement = dc . createDynamicElement ( name . toLowerCase ( Locale . US ) ) ; if ( nestedElement != null ) { nc = new NestedCreator ( null ) { Object create ( Project project , Object parent , Object ignore ) { return nestedElement ; } } ; } } if ( nc == null ) { throwNotSupported ( project , parent , elementName ) ; } return nc ; } public Object createElement ( Project project , Object parent , String elementName ) throws BuildException { NestedCreator nc = getNestedCreator ( project , "" , parent , elementName , null ) ; try { Object nestedElement = nc . create ( project , parent , null ) ; if ( project != null ) { project . setProjectReference ( nestedElement ) ; } return nestedElement ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Creator getElementCreator ( Project project , String parentUri , Object parent , String elementName , UnknownElement ue ) { NestedCreator nc = getNestedCreator ( project , parentUri , parent , elementName , ue ) ; return new Creator ( project , parent , nc ) ; } public boolean isDynamic ( ) { return DynamicElement . class . isAssignableFrom ( bean ) || DynamicElementNS . class . isAssignableFrom ( bean ) ; } public boolean isContainer ( ) { return TaskContainer . class . isAssignableFrom ( bean ) ; } public boolean supportsNestedElement ( String elementName ) { return nestedCreators . containsKey ( elementName . toLowerCase ( Locale . US ) ) || isDynamic ( ) || addTypeMethods . size ( ) != 0 ; } public boolean supportsNestedElement ( String parentUri , String elementName ) { if ( parentUri . equals ( ProjectHelper . ANT_CORE_URI ) ) { parentUri = "" ; } String uri = ProjectHelper . extractUriFromComponentName ( elementName ) ; if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } String name = ProjectHelper . extractNameFromComponentName ( elementName ) ; return ( nestedCreators . containsKey ( name . toLowerCase ( Locale . US ) ) && ( uri . equals ( parentUri ) || "" . equals ( uri ) ) ) || isDynamic ( ) || addTypeMethods . size ( ) != 0 ; } public void storeElement ( Project project , Object parent , Object child , String elementName ) throws BuildException { if ( elementName == null ) { return ; } NestedCreator ns = ( NestedCreator ) nestedCreators . get ( elementName . toLowerCase ( Locale . US ) ) ; if ( ns == null ) { return ; } try { ns . store ( parent , child ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Class getElementType ( String elementName ) throws BuildException { Class nt = ( Class ) nestedTypes . get ( elementName ) ; if ( nt == null ) { throw new UnsupportedElementException ( "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." , elementName ) ; } return nt ; } public Class getAttributeType ( String attributeName ) throws BuildException { Class at = ( Class ) attributeTypes . get ( attributeName ) ; if ( at == null ) { throw new UnsupportedAttributeException ( "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." , attributeName ) ; } return at ; } public Method getAddTextMethod ( ) throws BuildException { if ( ! supportsCharacters ( ) ) { throw new BuildException ( "Class " + bean . getName ( ) + " doesn't support nested text data." ) ; } return addText ; } public Method getElementMethod ( String elementName ) throws BuildException { Object creator = nestedCreators . get ( elementName ) ; if ( creator == null ) { throw new UnsupportedElementException ( "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." , elementName ) ; } return ( ( NestedCreator ) creator ) . method ; } public Method getAttributeMethod ( String attributeName ) throws BuildException { Object setter = attributeSetters . get ( attributeName ) ; if ( setter == null ) { throw new UnsupportedAttributeException ( "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." , attributeName ) ; } return ( ( AttributeSetter ) setter ) . method ; } public boolean supportsCharacters ( ) { return addText != null ; } public Enumeration getAttributes ( ) { return attributeSetters . keys ( ) ; } public Map getAttributeMap ( ) { return ( attributeTypes . size ( ) < 1 ) ? EMPTY_MAP : Collections . unmodifiableMap ( attributeTypes ) ; } public Enumeration getNestedElements ( ) { return nestedTypes . keys ( ) ; } public Map getNestedElementMap ( ) { return ( nestedTypes . size ( ) < 1 ) ? EMPTY_MAP : Collections . unmodifiableMap ( nestedTypes ) ; } public List getExtensionPoints ( ) { return ( addTypeMethods . size ( ) < 1 ) ? Collections . EMPTY_LIST : Collections . unmodifiableList ( addTypeMethods ) ; } private AttributeSetter createAttributeSetter ( final Method m , Class arg , final String attrName ) { final Class reflectedArg = PRIMITIVE_TYPE_MAP . containsKey ( arg ) ? ( Class ) PRIMITIVE_TYPE_MAP . get ( arg ) : arg ; if ( java . lang . String . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , ( Object [ ] ) ( new String [ ] { value } ) ) ; } } ; } else if ( java . lang . Character . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { if ( value . length ( ) == 0 ) { throw new BuildException ( "The value \"\" is not a " + "legal value for attribute \"" + attrName + "\"" ) ; } m . invoke ( parent , ( Object [ ] ) ( new Character [ ] { new Character ( value . charAt ( 0 ) ) } ) ) ; } } ; } else if ( java . lang . Boolean . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , ( Object [ ] ) ( new Boolean [ ] { Project . toBoolean ( value ) ? Boolean . TRUE : Boolean . FALSE } ) ) ; } } ; } else if ( java . lang . Class . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Object [ ] { Class . forName ( value ) } ) ; } catch ( ClassNotFoundException ce ) { throw new BuildException ( ce ) ; } } } ; } else if ( java . io . File . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Object [ ] { p . resolveFile ( value ) } ) ; } } ; } else if ( EnumeratedAttribute . class . isAssignableFrom ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) reflectedArg . newInstance ( ) ; ea . setValue ( value ) ; m . invoke ( parent , new Object [ ] { ea } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } else if ( reflectedArg . getSuperclass ( ) != null && reflectedArg . getSuperclass ( ) . getName ( ) . equals ( "java.lang.Enum" ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Object [ ] { reflectedArg . getMethod ( "valueOf" , new Class [ ] { String . class } ) . invoke ( null , new Object [ ] { value } ) } ) ; } catch ( InvocationTargetException x ) { if ( x . getTargetException ( ) instanceof IllegalArgumentException ) { throw new BuildException ( "'" + value + "' is not a permitted value for " + reflectedArg . getName ( ) ) ; } else { throw new BuildException ( x . getTargetException ( ) ) ; } } catch ( Exception x ) { throw new BuildException ( x ) ; } } } ; } else { boolean includeProject ; Constructor c ; try { c = reflectedArg . getConstructor ( new Class [ ] { Project . class , String . class } ) ; includeProject = true ; } catch ( NoSuchMethodException nme ) { try { c = reflectedArg . getConstructor ( new Class [ ] { String . class } ) ; includeProject = false ; } catch ( NoSuchMethodException nme2 ) { return null ; } } final boolean finalIncludeProject = includeProject ; final Constructor finalConstructor = c ; return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { Object [ ] args = ( finalIncludeProject ) ? new Object [ ] { p , value } : new Object [ ] { value } ; Object attribute = finalConstructor . newInstance ( args ) ; if ( p != null ) { p . setProjectReference ( attribute ) ; } m . invoke ( parent , new Object [ ] { attribute } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } } protected String getElementName ( Project project , Object element ) { return project . getElementName ( element ) ; } private String getPropertyName ( String methodName , String prefix ) { return methodName . substring ( prefix . length ( ) ) . toLowerCase ( Locale . US ) ; } public static final class Creator { private NestedCreator nestedCreator ; private Object parent ; private Project project ; private Object nestedObject ; private String polyType ; private Creator ( Project project , Object parent , NestedCreator nestedCreator ) { this . project = project ; this . parent = parent ; this . nestedCreator = nestedCreator ; } public void setPolyType ( String polyType ) { this . polyType = polyType ; } public Object create ( ) { if ( polyType != null ) { if ( ! nestedCreator . isPolyMorphic ( ) ) { throw new BuildException ( "Not allowed to use the polymorphic form" + " for this element" ) ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; nestedObject = helper . createComponent ( polyType ) ; if ( nestedObject == null ) { throw new BuildException ( "Unable to create object of type " + polyType ) ; } } try { nestedObject = nestedCreator . create ( project , parent , nestedObject ) ; if ( project != null ) { project . setProjectReference ( nestedObject ) ; } return nestedObject ; } catch ( IllegalAccessException ex ) { throw new BuildException ( ex ) ; } catch ( InstantiationException ex ) { throw new BuildException ( ex ) ; } catch ( IllegalArgumentException ex ) { if ( polyType != null ) { throw new BuildException ( "Invalid type used " + polyType ) ; } throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Object getRealObject ( ) { return nestedCreator . getRealObject ( ) ; } public void store ( ) { try { nestedCreator . store ( parent , nestedObject ) ; } catch ( IllegalAccessException ex ) { throw new BuildException ( ex ) ; } catch ( InstantiationException ex ) { throw new BuildException ( ex ) ; } catch ( IllegalArgumentException ex ) { if ( polyType != null ) { throw new BuildException ( "Invalid type used " + polyType ) ; } throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } } private abstract static class NestedCreator { private Method method ; NestedCreator ( Method m ) { this . method = m ; } Method getMethod ( ) { return method ; } boolean isPolyMorphic ( ) { return false ; } Object getRealObject ( ) { return null ; } abstract Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { } } private class CreateNestedCreator extends NestedCreator { CreateNestedCreator ( Method m ) { super ( m ) ; } Object create ( Project project , Object parent , Object ignore ) throws InvocationTargetException , IllegalAccessException { return getMethod ( ) . invoke ( parent , new Object [ ] { } ) ; } } private class AddNestedCreator extends NestedCreator { static final int ADD = 1 ; static final int ADD_CONFIGURED = 2 ; private Constructor constructor ; private int behavior ; AddNestedCreator ( Method m , Constructor c , int behavior ) { super ( m ) ; this . constructor = c ; this . behavior = behavior ; } boolean isPolyMorphic ( ) { return true ; } Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( child == null ) { child = constructor . newInstance ( ( constructor . getParameterTypes ( ) . length == 0 ) ? new Object [ ] { } : new Object [ ] { project } ) ; } if ( child instanceof PreSetDef . PreSetDefinition ) { child = ( ( PreSetDef . PreSetDefinition ) child ) . createObject ( project ) ; } if ( behavior == ADD ) { istore ( parent , child ) ; } return child ; } void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( behavior == ADD_CONFIGURED ) { istore ( parent , child ) ; } } private void istore ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { getMethod ( ) . invoke ( parent , new Object [ ] { child } ) ; } } private abstract static class AttributeSetter { private Method method ; AttributeSetter ( Method m ) { this . method = m ; } abstract void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException ; } public static void clearCache ( ) { HELPERS . clear ( ) ; } private NestedCreator createAddTypeCreator ( Project project , Object parent , String elementName ) throws BuildException { if ( addTypeMethods . size ( ) == 0 ) { return null ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; Object addedObject = null ; Method addMethod = null ; Class clazz = helper . getComponentClass ( elementName ) ; if ( clazz == null ) { return null ; } addMethod = findMatchingMethod ( clazz , addTypeMethods ) ; if ( addMethod == null ) { return null ; } addedObject = helper . createComponent ( elementName ) ; if ( addedObject == null ) { return null ; } Object rObject = addedObject ; if ( addedObject instanceof PreSetDef . PreSetDefinition ) { rObject = ( ( PreSetDef . PreSetDefinition ) addedObject ) . createObject ( project ) ; } final Object nestedObject = addedObject ; final Object realObject = rObject ; return new NestedCreator ( addMethod ) { Object create ( Project project , Object parent , Object ignore ) throws InvocationTargetException , IllegalAccessException { if ( ! getMethod ( ) . getName ( ) . endsWith ( "Configured" ) ) { getMethod ( ) . invoke ( parent , new Object [ ] { realObject } ) ; } return nestedObject ; } Object getRealObject ( ) { return realObject ; } void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( getMethod ( ) . getName ( ) . endsWith ( "Configured" ) ) { getMethod ( ) . invoke ( parent , new Object [ ] { realObject } ) ; } } } ; } private void insertAddTypeMethod ( Method method ) { Class argClass = method . getParameterTypes ( ) [ 0 ] ; for ( int c = 0 ; c < addTypeMethods . size ( ) ; ++ c ) { Method current = ( Method ) addTypeMethods . get ( c ) ; if ( current . getParameterTypes ( ) [ 0 ] . equals ( argClass ) ) { if ( method . getName ( ) . equals ( "addConfigured" ) ) { addTypeMethods . set ( c , method ) ; } return ; } if ( current . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( argClass ) ) { addTypeMethods . add ( c , method ) ; return ; } } addTypeMethods . add ( method ) ; } private Method findMatchingMethod ( Class paramClass , List methods ) { Class matchedClass = null ; Method matchedMethod = null ; for ( int i = 0 ; i < methods . size ( ) ; ++ i ) { Method method = ( Method ) methods . get ( i ) ; Class methodClass = method . getParameterTypes ( ) [ 0 ] ; if ( methodClass . isAssignableFrom ( paramClass ) ) { if ( matchedClass == null ) { matchedClass = methodClass ; matchedMethod = method ; } else { if ( ! methodClass . isAssignableFrom ( matchedClass ) ) { throw new BuildException ( "ambiguous: types " + matchedClass . getName ( ) + " and " + methodClass . getName ( ) + " match " + paramClass . getName ( ) ) ; } } } } return matchedMethod ; } private String condenseText ( final String text ) { if ( text . length ( ) <= MAX_REPORT_NESTED_TEXT ) { return text ; } int ends = ( MAX_REPORT_NESTED_TEXT - ELLIPSIS . length ( ) ) / 2 ; return new StringBuffer ( text ) . replace ( ends , text . length ( ) - ends , ELLIPSIS ) . toString ( ) ; } } 	1
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileUtils ; public class ChangeLogTask extends AbstractCvsTask { private File usersFile ; private Vector cvsUsers = new Vector ( ) ; private File inputDir ; private File destFile ; private Date startDate ; private Date endDate ; private final Vector filesets = new Vector ( ) ; public void setDir ( final File inputDir ) { this . inputDir = inputDir ; } public void setDestfile ( final File destFile ) { this . destFile = destFile ; } public void setUsersfile ( final File usersFile ) { this . usersFile = usersFile ; } public void addUser ( final CvsUser user ) { cvsUsers . addElement ( user ) ; } public void setStart ( final Date start ) { this . startDate = start ; } public void setEnd ( final Date endDate ) { this . endDate = endDate ; } public void setDaysinpast ( final int days ) { final long time = System . currentTimeMillis ( ) - ( long ) days * 24 * 60 * 60 * 1000 ; setStart ( new Date ( time ) ) ; } public void addFileset ( final FileSet fileSet ) { filesets . addElement ( fileSet ) ; } public void execute ( ) throws BuildException { File savedDir = inputDir ; try { validate ( ) ; final Properties userList = new Properties ( ) ; loadUserlist ( userList ) ; for ( int i = 0 , size = cvsUsers . size ( ) ; i < size ; i ++ ) { final CvsUser user = ( CvsUser ) cvsUsers . get ( i ) ; user . validate ( ) ; userList . put ( user . getUserID ( ) , user . getDisplayname ( ) ) ; } setCommand ( "log" ) ; if ( getTag ( ) != null ) { CvsVersion myCvsVersion = new CvsVersion ( ) ; myCvsVersion . setProject ( getProject ( ) ) ; myCvsVersion . setTaskName ( "cvsversion" ) ; myCvsVersion . setCvsRoot ( getCvsRoot ( ) ) ; myCvsVersion . setCvsRsh ( getCvsRsh ( ) ) ; myCvsVersion . setPassfile ( getPassFile ( ) ) ; myCvsVersion . setDest ( inputDir ) ; myCvsVersion . execute ( ) ; if ( myCvsVersion . supportsCvsLogWithSOption ( ) ) { addCommandArgument ( "-S" ) ; } } if ( null != startDate ) { final SimpleDateFormat outputDate = new SimpleDateFormat ( "yyyy-MM-dd" ) ; final String dateRange = ">=" + outputDate . format ( startDate ) ; addCommandArgument ( "-d" ) ; addCommandArgument ( dateRange ) ; } if ( ! filesets . isEmpty ( ) ) { final Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { final FileSet fileSet = ( FileSet ) e . nextElement ( ) ; final DirectoryScanner scanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; final String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { addCommandArgument ( files [ i ] ) ; } } } final ChangeLogParser parser = new ChangeLogParser ( ) ; final RedirectingStreamHandler handler = new RedirectingStreamHandler ( parser ) ; log ( getCommand ( ) , Project . MSG_VERBOSE ) ; setDest ( inputDir ) ; setExecuteStreamHandler ( handler ) ; try { super . execute ( ) ; } finally { final String errors = handler . getErrors ( ) ; if ( null != errors ) { log ( errors , Project . MSG_ERR ) ; } } final CVSEntry [ ] entrySet = parser . getEntrySetAsArray ( ) ; final CVSEntry [ ] filteredEntrySet = filterEntrySet ( entrySet ) ; replaceAuthorIdWithName ( userList , filteredEntrySet ) ; writeChangeLog ( filteredEntrySet ) ; } finally { inputDir = savedDir ; } } private void validate ( ) throws BuildException { if ( null == inputDir ) { inputDir = getProject ( ) . getBaseDir ( ) ; } if ( null == destFile ) { final String message = "Destfile must be set." ; throw new BuildException ( message ) ; } if ( ! inputDir . exists ( ) ) { final String message = "Cannot find base dir " + inputDir . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } if ( null != usersFile && ! usersFile . exists ( ) ) { final String message = "Cannot find user lookup list " + usersFile . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } } private void loadUserlist ( final Properties userList ) throws BuildException { if ( null != usersFile ) { try { userList . load ( new FileInputStream ( usersFile ) ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } } } private CVSEntry [ ] filterEntrySet ( final CVSEntry [ ] entrySet ) { final Vector results = new Vector ( ) ; for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry cvsEntry = entrySet [ i ] ; final Date date = cvsEntry . getDate ( ) ; if ( null == date ) { continue ; } if ( null != startDate && startDate . after ( date ) ) { continue ; } if ( null != endDate && endDate . before ( date ) ) { continue ; } results . addElement ( cvsEntry ) ; } final CVSEntry [ ] resultArray = new CVSEntry [ results . size ( ) ] ; results . copyInto ( resultArray ) ; return resultArray ; } private void replaceAuthorIdWithName ( final Properties userList , final CVSEntry [ ] entrySet ) { for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry entry = entrySet [ i ] ; if ( userList . containsKey ( entry . getAuthor ( ) ) ) { entry . setAuthor ( userList . getProperty ( entry . getAuthor ( ) ) ) ; } } } private void writeChangeLog ( final CVSEntry [ ] entrySet ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( destFile ) ; final PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; final ChangeLogWriter serializer = new ChangeLogWriter ( ) ; serializer . printChangeLog ( writer , entrySet ) ; } catch ( final UnsupportedEncodingException uee ) { getProject ( ) . log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { FileUtils . close ( output ) ; } } } 	1
package org . apache . tools . ant . taskdefs . cvslib ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . TimeZone ; class ChangeLogParser { private static final int GET_FILE = 1 ; private static final int GET_DATE = 2 ; private static final int GET_COMMENT = 3 ; private static final int GET_REVISION = 4 ; private static final int GET_PREVIOUS_REV = 5 ; private static final SimpleDateFormat INPUT_DATE = new SimpleDateFormat ( "yyyy/MM/dd HH:mm:ss" , Locale . US ) ; private static final SimpleDateFormat CVS1129_INPUT_DATE = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss Z" , Locale . US ) ; static { TimeZone utc = TimeZone . getTimeZone ( "UTC" ) ; INPUT_DATE . setTimeZone ( utc ) ; CVS1129_INPUT_DATE . setTimeZone ( utc ) ; } private String file ; private String date ; private String author ; private String comment ; private String revision ; private String previousRevision ; private int status = GET_FILE ; private final Hashtable entries = new Hashtable ( ) ; public CVSEntry [ ] getEntrySetAsArray ( ) { final CVSEntry [ ] array = new CVSEntry [ entries . size ( ) ] ; int i = 0 ; for ( Enumeration e = entries . elements ( ) ; e . hasMoreElements ( ) ; ) { array [ i ++ ] = ( CVSEntry ) e . nextElement ( ) ; } return array ; } public void stdout ( final String line ) { switch ( status ) { case GET_FILE : reset ( ) ; processFile ( line ) ; break ; case GET_REVISION : processRevision ( line ) ; break ; case GET_DATE : processDate ( line ) ; break ; case GET_COMMENT : processComment ( line ) ; break ; case GET_PREVIOUS_REV : processGetPreviousRevision ( line ) ; break ; default : break ; } } private void processComment ( final String line ) { final String lineSeparator = System . getProperty ( "line.separator" ) ; if ( line . equals ( "=============================================================================" ) ) { final int end = comment . length ( ) - lineSeparator . length ( ) ; comment = comment . substring ( 0 , end ) ; saveEntry ( ) ; status = GET_FILE ; } else if ( line . equals ( "----------------------------" ) ) { final int end = comment . length ( ) - lineSeparator . length ( ) ; comment = comment . substring ( 0 , end ) ; status = GET_PREVIOUS_REV ; } else { comment += line + lineSeparator ; } } private void processFile ( final String line ) { if ( line . startsWith ( "Working file:" ) ) { file = line . substring ( 14 , line . length ( ) ) ; status = GET_REVISION ; } } private void processRevision ( final String line ) { if ( line . startsWith ( "revision" ) ) { revision = line . substring ( 9 ) ; status = GET_DATE ; } else if ( line . startsWith ( "======" ) ) { status = GET_FILE ; } } private void processDate ( final String line ) { if ( line . startsWith ( "date:" ) ) { int endOfDateIndex = line . indexOf ( ';' ) ; date = line . substring ( "date: " . length ( ) , endOfDateIndex ) ; int startOfAuthorIndex = line . indexOf ( "author: " , endOfDateIndex + 1 ) ; int endOfAuthorIndex = line . indexOf ( ';' , startOfAuthorIndex + 1 ) ; author = line . substring ( "author: " . length ( ) + startOfAuthorIndex , endOfAuthorIndex ) ; status = GET_COMMENT ; comment = "" ; } } private void processGetPreviousRevision ( final String line ) { if ( ! line . startsWith ( "revision " ) ) { throw new IllegalStateException ( "Unexpected line from CVS: " + line ) ; } previousRevision = line . substring ( "revision " . length ( ) ) ; saveEntry ( ) ; revision = previousRevision ; status = GET_DATE ; } private void saveEntry ( ) { final String entryKey = date + author + comment ; CVSEntry entry ; if ( ! entries . containsKey ( entryKey ) ) { Date dateObject = parseDate ( date ) ; entry = new CVSEntry ( dateObject , author , comment ) ; entries . put ( entryKey , entry ) ; } else { entry = ( CVSEntry ) entries . get ( entryKey ) ; } entry . addFile ( file , revision , previousRevision ) ; } private Date parseDate ( final String date ) { try { return INPUT_DATE . parse ( date ) ; } catch ( ParseException e ) { try { return CVS1129_INPUT_DATE . parse ( date ) ; } catch ( ParseException e2 ) { throw new IllegalStateException ( "Invalid date format: " + date ) ; } } } public void reset ( ) { this . file = null ; this . date = null ; this . author = null ; this . comment = null ; this . revision = null ; this . previousRevision = null ; } } 	1
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . DOMUtils ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class CvsTagDiff extends AbstractCvsTask { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final DOMElementWriter DOM_WRITER = new DOMElementWriter ( ) ; static final String FILE_STRING = "File " ; static final String TO_STRING = " to " ; static final String FILE_IS_NEW = " is new;" ; static final String REVISION = "revision " ; static final String FILE_HAS_CHANGED = " changed from revision " ; static final String FILE_WAS_REMOVED = " is removed" ; private String mypackage ; private String mystartTag ; private String myendTag ; private String mystartDate ; private String myendDate ; private File mydestfile ; public void setPackage ( String p ) { mypackage = p ; } public void setStartTag ( String s ) { mystartTag = s ; } public void setStartDate ( String s ) { mystartDate = s ; } public void setEndTag ( String s ) { myendTag = s ; } public void setEndDate ( String s ) { myendDate = s ; } public void setDestFile ( File f ) { mydestfile = f ; } public void execute ( ) throws BuildException { validate ( ) ; addCommandArgument ( "rdiff" ) ; addCommandArgument ( "-s" ) ; if ( mystartTag != null ) { addCommandArgument ( "-r" ) ; addCommandArgument ( mystartTag ) ; } else { addCommandArgument ( "-D" ) ; addCommandArgument ( mystartDate ) ; } if ( myendTag != null ) { addCommandArgument ( "-r" ) ; addCommandArgument ( myendTag ) ; } else { addCommandArgument ( "-D" ) ; addCommandArgument ( myendDate ) ; } StringTokenizer myTokenizer = new StringTokenizer ( mypackage ) ; while ( myTokenizer . hasMoreTokens ( ) ) { addCommandArgument ( myTokenizer . nextToken ( ) ) ; } setCommand ( "" ) ; File tmpFile = null ; try { tmpFile = FILE_UTILS . createTempFile ( "cvstagdiff" , ".log" , null ) ; tmpFile . deleteOnExit ( ) ; setOutput ( tmpFile ) ; super . execute ( ) ; CvsTagEntry [ ] entries = parseRDiff ( tmpFile ) ; writeTagDiff ( entries ) ; } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private CvsTagEntry [ ] parseRDiff ( File tmpFile ) throws BuildException { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( tmpFile ) ) ; String toBeRemoved = FILE_STRING + mypackage + "/" ; int headerLength = toBeRemoved . length ( ) ; Vector entries = new Vector ( ) ; String line = reader . readLine ( ) ; int index ; CvsTagEntry entry = null ; while ( null != line ) { if ( line . length ( ) > headerLength ) { if ( line . startsWith ( toBeRemoved ) ) { line = line . substring ( headerLength ) ; } else { line = line . substring ( FILE_STRING . length ( ) ) ; } if ( ( index = line . indexOf ( FILE_IS_NEW ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = null ; int indexrev = - 1 ; if ( ( indexrev = line . indexOf ( REVISION , index ) ) != - 1 ) { rev = line . substring ( indexrev + REVISION . length ( ) ) ; } entry = new CvsTagEntry ( filename , rev ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_HAS_CHANGED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; int revSeparator = line . indexOf ( " to " , index ) ; String prevRevision = line . substring ( index + FILE_HAS_CHANGED . length ( ) , revSeparator ) ; String revision = line . substring ( revSeparator + TO_STRING . length ( ) ) ; entry = new CvsTagEntry ( filename , revision , prevRevision ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_WAS_REMOVED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = null ; int indexrev = - 1 ; if ( ( indexrev = line . indexOf ( REVISION , index ) ) != - 1 ) { rev = line . substring ( indexrev + REVISION . length ( ) ) ; } entry = new CvsTagEntry ( filename , null , rev ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } } line = reader . readLine ( ) ; } CvsTagEntry [ ] array = new CvsTagEntry [ entries . size ( ) ] ; entries . copyInto ( array ) ; return array ; } catch ( IOException e ) { throw new BuildException ( "Error in parsing" , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; } } } } private void writeTagDiff ( CvsTagEntry [ ] entries ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( mydestfile ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; writer . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; Document doc = DOMUtils . newDocument ( ) ; Element root = doc . createElement ( "tagdiff" ) ; if ( mystartTag != null ) { root . setAttribute ( "startTag" , mystartTag ) ; } else { root . setAttribute ( "startDate" , mystartDate ) ; } if ( myendTag != null ) { root . setAttribute ( "endTag" , myendTag ) ; } else { root . setAttribute ( "endDate" , myendDate ) ; } root . setAttribute ( "cvsroot" , getCvsRoot ( ) ) ; root . setAttribute ( "package" , mypackage ) ; DOM_WRITER . openElement ( root , writer , 0 , "\t" ) ; writer . println ( ) ; for ( int i = 0 , c = entries . length ; i < c ; i ++ ) { writeTagEntry ( doc , writer , entries [ i ] ) ; } DOM_WRITER . closeElement ( root , writer , 0 , "\t" , true ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( UnsupportedEncodingException uee ) { log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( IOException ioe ) { log ( ioe . toString ( ) , Project . MSG_ERR ) ; } } } } private void writeTagEntry ( Document doc , PrintWriter writer , CvsTagEntry entry ) throws IOException { Element ent = doc . createElement ( "entry" ) ; Element f = DOMUtils . createChildElement ( ent , "file" ) ; DOMUtils . appendCDATAElement ( f , "name" , entry . getFile ( ) ) ; if ( entry . getRevision ( ) != null ) { DOMUtils . appendTextElement ( f , "revision" , entry . getRevision ( ) ) ; } if ( entry . getPreviousRevision ( ) != null ) { DOMUtils . appendTextElement ( f , "prevrevision" , entry . getPreviousRevision ( ) ) ; } DOM_WRITER . write ( ent , writer , 1 , "\t" ) ; } private void validate ( ) throws BuildException { if ( null == mypackage ) { throw new BuildException ( "Package/module must be set." ) ; } if ( null == mydestfile ) { throw new BuildException ( "Destfile must be set." ) ; } if ( null == mystartTag && null == mystartDate ) { throw new BuildException ( "Start tag or start date must be set." ) ; } if ( null != mystartTag && null != mystartDate ) { throw new BuildException ( "Only one of start tag and start date " + "must be set." ) ; } if ( null == myendTag && null == myendDate ) { throw new BuildException ( "End tag or end date must be set." ) ; } if ( null != myendTag && null != myendDate ) { throw new BuildException ( "Only one of end tag and end date must " + "be set." ) ; } } } 	1
package org . apache . tools . bzip2 ; import java . io . OutputStream ; import java . io . IOException ; public class CBZip2OutputStream extends OutputStream implements BZip2Constants { public static final int MIN_BLOCKSIZE = 1 ; public static final int MAX_BLOCKSIZE = 9 ; protected static final int SETMASK = ( 1 << 21 ) ; protected static final int CLEARMASK = ( ~ SETMASK ) ; protected static final int GREATER_ICOST = 15 ; protected static final int LESSER_ICOST = 0 ; protected static final int SMALL_THRESH = 20 ; protected static final int DEPTH_THRESH = 10 ; protected static final int WORK_FACTOR = 30 ; protected static final int QSORT_STACK_SIZE = 1000 ; private static final int [ ] INCS = { 1 , 4 , 13 , 40 , 121 , 364 , 1093 , 3280 , 9841 , 29524 , 88573 , 265720 , 797161 , 2391484 } ; protected static void hbMakeCodeLengths ( char [ ] len , int [ ] freq , int alphaSize , int maxLen ) { final int [ ] heap = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] weight = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] parent = new int [ MAX_ALPHA_SIZE * 2 ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { weight [ i + 1 ] = ( freq [ i ] == 0 ? 1 : freq [ i ] ) << 8 ; } for ( boolean tooLong = true ; tooLong ; ) { tooLong = false ; int nNodes = alphaSize ; int nHeap = 0 ; heap [ 0 ] = 0 ; weight [ 0 ] = 0 ; parent [ 0 ] = - 2 ; for ( int i = 1 ; i <= alphaSize ; i ++ ) { parent [ i ] = - 1 ; nHeap ++ ; heap [ nHeap ] = i ; int zz = nHeap ; int tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } while ( nHeap > 1 ) { int n1 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; int yy = 0 ; int zz = 1 ; int tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; int n2 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; yy = 0 ; zz = 1 ; tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; nNodes ++ ; parent [ n1 ] = parent [ n2 ] = nNodes ; final int weight_n1 = weight [ n1 ] ; final int weight_n2 = weight [ n2 ] ; weight [ nNodes ] = ( ( ( weight_n1 & 0xffffff00 ) + ( weight_n2 & 0xffffff00 ) ) | ( 1 + ( ( ( weight_n1 & 0x000000ff ) > ( weight_n2 & 0x000000ff ) ) ? ( weight_n1 & 0x000000ff ) : ( weight_n2 & 0x000000ff ) ) ) ) ; parent [ nNodes ] = - 1 ; nHeap ++ ; heap [ nHeap ] = nNodes ; tmp = 0 ; zz = nHeap ; tmp = heap [ zz ] ; final int weight_tmp = weight [ tmp ] ; while ( weight_tmp < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } for ( int i = 1 ; i <= alphaSize ; i ++ ) { int j = 0 ; int k = i ; for ( int parent_k ; ( parent_k = parent [ k ] ) >= 0 ; ) { k = parent_k ; j ++ ; } len [ i - 1 ] = ( char ) j ; if ( j > maxLen ) { tooLong = true ; } } if ( tooLong ) { for ( int i = 1 ; i < alphaSize ; i ++ ) { int j = weight [ i ] > > 8 ; j = 1 + ( j > > 1 ) ; weight [ i ] = j << 8 ; } } } } private static void hbMakeCodeLengths ( final byte [ ] len , final int [ ] freq , final Data dat , final int alphaSize , final int maxLen ) { final int [ ] heap = dat . heap ; final int [ ] weight = dat . weight ; final int [ ] parent = dat . parent ; for ( int i = alphaSize ; -- i >= 0 ; ) { weight [ i + 1 ] = ( freq [ i ] == 0 ? 1 : freq [ i ] ) << 8 ; } for ( boolean tooLong = true ; tooLong ; ) { tooLong = false ; int nNodes = alphaSize ; int nHeap = 0 ; heap [ 0 ] = 0 ; weight [ 0 ] = 0 ; parent [ 0 ] = - 2 ; for ( int i = 1 ; i <= alphaSize ; i ++ ) { parent [ i ] = - 1 ; nHeap ++ ; heap [ nHeap ] = i ; int zz = nHeap ; int tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } while ( nHeap > 1 ) { int n1 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; int yy = 0 ; int zz = 1 ; int tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; int n2 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; yy = 0 ; zz = 1 ; tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; nNodes ++ ; parent [ n1 ] = parent [ n2 ] = nNodes ; final int weight_n1 = weight [ n1 ] ; final int weight_n2 = weight [ n2 ] ; weight [ nNodes ] = ( ( weight_n1 & 0xffffff00 ) + ( weight_n2 & 0xffffff00 ) ) | ( 1 + ( ( ( weight_n1 & 0x000000ff ) > ( weight_n2 & 0x000000ff ) ) ? ( weight_n1 & 0x000000ff ) : ( weight_n2 & 0x000000ff ) ) ) ; parent [ nNodes ] = - 1 ; nHeap ++ ; heap [ nHeap ] = nNodes ; tmp = 0 ; zz = nHeap ; tmp = heap [ zz ] ; final int weight_tmp = weight [ tmp ] ; while ( weight_tmp < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } for ( int i = 1 ; i <= alphaSize ; i ++ ) { int j = 0 ; int k = i ; for ( int parent_k ; ( parent_k = parent [ k ] ) >= 0 ; ) { k = parent_k ; j ++ ; } len [ i - 1 ] = ( byte ) j ; if ( j > maxLen ) { tooLong = true ; } } if ( tooLong ) { for ( int i = 1 ; i < alphaSize ; i ++ ) { int j = weight [ i ] > > 8 ; j = 1 + ( j > > 1 ) ; weight [ i ] = j << 8 ; } } } } private int last ; private int origPtr ; private final int blockSize100k ; private boolean blockRandomised ; private int bsBuff ; private int bsLive ; private final CRC crc = new CRC ( ) ; private int nInUse ; private int nMTF ; private int workDone ; private int workLimit ; private boolean firstAttempt ; private int currentChar = - 1 ; private int runLength = 0 ; private int blockCRC ; private int combinedCRC ; private int allowableBlockSize ; private CBZip2OutputStream . Data data ; private OutputStream out ; public static int chooseBlockSize ( long inputLength ) { return ( inputLength > 0 ) ? ( int ) Math . min ( ( inputLength / 132000 ) + 1 , 9 ) : MAX_BLOCKSIZE ; } public CBZip2OutputStream ( final OutputStream out ) throws IOException { this ( out , MAX_BLOCKSIZE ) ; } public CBZip2OutputStream ( final OutputStream out , final int blockSize ) throws IOException { super ( ) ; if ( blockSize < 1 ) { throw new IllegalArgumentException ( "blockSize(" + blockSize + ") < 1" ) ; } if ( blockSize > 9 ) { throw new IllegalArgumentException ( "blockSize(" + blockSize + ") > 9" ) ; } this . blockSize100k = blockSize ; this . out = out ; init ( ) ; } public void write ( final int b ) throws IOException { if ( this . out != null ) { write0 ( b ) ; } else { throw new IOException ( "closed" ) ; } } private void writeRun ( ) throws IOException { final int lastShadow = this . last ; if ( lastShadow < this . allowableBlockSize ) { final int currentCharShadow = this . currentChar ; final Data dataShadow = this . data ; dataShadow . inUse [ currentCharShadow ] = true ; final byte ch = ( byte ) currentCharShadow ; int runLengthShadow = this . runLength ; this . crc . updateCRC ( currentCharShadow , runLengthShadow ) ; switch ( runLengthShadow ) { case 1 : dataShadow . block [ lastShadow + 2 ] = ch ; this . last = lastShadow + 1 ; break ; case 2 : dataShadow . block [ lastShadow + 2 ] = ch ; dataShadow . block [ lastShadow + 3 ] = ch ; this . last = lastShadow + 2 ; break ; case 3 : { final byte [ ] block = dataShadow . block ; block [ lastShadow + 2 ] = ch ; block [ lastShadow + 3 ] = ch ; block [ lastShadow + 4 ] = ch ; this . last = lastShadow + 3 ; } break ; default : { runLengthShadow -= 4 ; dataShadow . inUse [ runLengthShadow ] = true ; final byte [ ] block = dataShadow . block ; block [ lastShadow + 2 ] = ch ; block [ lastShadow + 3 ] = ch ; block [ lastShadow + 4 ] = ch ; block [ lastShadow + 5 ] = ch ; block [ lastShadow + 6 ] = ( byte ) runLengthShadow ; this . last = lastShadow + 5 ; } break ; } } else { endBlock ( ) ; initBlock ( ) ; writeRun ( ) ; } } protected void finalize ( ) throws Throwable { close ( ) ; super . finalize ( ) ; } public void close ( ) throws IOException { OutputStream outShadow = this . out ; if ( outShadow != null ) { try { if ( this . runLength > 0 ) { writeRun ( ) ; } this . currentChar = - 1 ; endBlock ( ) ; endCompression ( ) ; outShadow . close ( ) ; } finally { this . out = null ; this . data = null ; } } } public void flush ( ) throws IOException { OutputStream outShadow = this . out ; if ( outShadow != null ) { outShadow . flush ( ) ; } } private void init ( ) throws IOException { this . data = new Data ( this . blockSize100k ) ; bsPutUByte ( 'h' ) ; bsPutUByte ( '0' + this . blockSize100k ) ; this . combinedCRC = 0 ; initBlock ( ) ; } private void initBlock ( ) { this . crc . initialiseCRC ( ) ; this . last = - 1 ; boolean [ ] inUse = this . data . inUse ; for ( int i = 256 ; -- i >= 0 ; ) { inUse [ i ] = false ; } this . allowableBlockSize = ( this . blockSize100k * BZip2Constants . baseBlockSize ) - 20 ; } private void endBlock ( ) throws IOException { this . blockCRC = this . crc . getFinalCRC ( ) ; this . combinedCRC = ( this . combinedCRC << 1 ) | ( this . combinedCRC > > > 31 ) ; this . combinedCRC ^= this . blockCRC ; if ( this . last == - 1 ) { return ; } blockSort ( ) ; bsPutUByte ( 0x31 ) ; bsPutUByte ( 0x41 ) ; bsPutUByte ( 0x59 ) ; bsPutUByte ( 0x26 ) ; bsPutUByte ( 0x53 ) ; bsPutUByte ( 0x59 ) ; bsPutInt ( this . blockCRC ) ; if ( this . blockRandomised ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } moveToFrontCodeAndSend ( ) ; } private void endCompression ( ) throws IOException { bsPutUByte ( 0x17 ) ; bsPutUByte ( 0x72 ) ; bsPutUByte ( 0x45 ) ; bsPutUByte ( 0x38 ) ; bsPutUByte ( 0x50 ) ; bsPutUByte ( 0x90 ) ; bsPutInt ( this . combinedCRC ) ; bsFinishedWithStream ( ) ; } public final int getBlockSize ( ) { return this . blockSize100k ; } public void write ( final byte [ ] buf , int offs , final int len ) throws IOException { if ( offs < 0 ) { throw new IndexOutOfBoundsException ( "offs(" + offs + ") < 0." ) ; } if ( len < 0 ) { throw new IndexOutOfBoundsException ( "len(" + len + ") < 0." ) ; } if ( offs + len > buf . length ) { throw new IndexOutOfBoundsException ( "offs(" + offs + ") + len(" + len + ") > buf.length(" + buf . length + ")." ) ; } if ( this . out == null ) { throw new IOException ( "stream closed" ) ; } for ( int hi = offs + len ; offs < hi ; ) { write0 ( buf [ offs ++ ] ) ; } } private void write0 ( int b ) throws IOException { if ( this . currentChar != - 1 ) { b &= 0xff ; if ( this . currentChar == b ) { if ( ++ this . runLength > 254 ) { writeRun ( ) ; this . currentChar = - 1 ; this . runLength = 0 ; } } else { writeRun ( ) ; this . runLength = 1 ; this . currentChar = b ; } } else { this . currentChar = b & 0xff ; this . runLength ++ ; } } private static void hbAssignCodes ( final int [ ] code , final byte [ ] length , final int minLen , final int maxLen , final int alphaSize ) { int vec = 0 ; for ( int n = minLen ; n <= maxLen ; n ++ ) { for ( int i = 0 ; i < alphaSize ; i ++ ) { if ( ( length [ i ] & 0xff ) == n ) { code [ i ] = vec ; vec ++ ; } } vec <<= 1 ; } } private void bsFinishedWithStream ( ) throws IOException { while ( this . bsLive > 0 ) { int ch = this . bsBuff > > 24 ; this . out . write ( ch ) ; this . bsBuff <<= 8 ; this . bsLive -= 8 ; } } private void bsW ( final int n , final int v ) throws IOException { final OutputStream outShadow = this . out ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } this . bsBuff = bsBuffShadow | ( v << ( 32 - bsLiveShadow - n ) ) ; this . bsLive = bsLiveShadow + n ; } private void bsPutUByte ( final int c ) throws IOException { bsW ( 8 , c ) ; } private void bsPutInt ( final int u ) throws IOException { bsW ( 8 , ( u > > 24 ) & 0xff ) ; bsW ( 8 , ( u > > 16 ) & 0xff ) ; bsW ( 8 , ( u > > 8 ) & 0xff ) ; bsW ( 8 , u & 0xff ) ; } private void sendMTFValues ( ) throws IOException { final byte [ ] [ ] len = this . data . sendMTFValues_len ; final int alphaSize = this . nInUse + 2 ; for ( int t = N_GROUPS ; -- t >= 0 ; ) { byte [ ] len_t = len [ t ] ; for ( int v = alphaSize ; -- v >= 0 ; ) { len_t [ v ] = GREATER_ICOST ; } } final int nGroups = ( this . nMTF < 200 ) ? 2 : ( this . nMTF < 600 ) ? 3 : ( this . nMTF < 1200 ) ? 4 : ( this . nMTF < 2400 ) ? 5 : 6 ; sendMTFValues0 ( nGroups , alphaSize ) ; final int nSelectors = sendMTFValues1 ( nGroups , alphaSize ) ; sendMTFValues2 ( nGroups , nSelectors ) ; sendMTFValues3 ( nGroups , alphaSize ) ; sendMTFValues4 ( ) ; sendMTFValues5 ( nGroups , nSelectors ) ; sendMTFValues6 ( nGroups , alphaSize ) ; sendMTFValues7 ( nSelectors ) ; } private void sendMTFValues0 ( final int nGroups , final int alphaSize ) { final byte [ ] [ ] len = this . data . sendMTFValues_len ; final int [ ] mtfFreq = this . data . mtfFreq ; int remF = this . nMTF ; int gs = 0 ; for ( int nPart = nGroups ; nPart > 0 ; nPart -- ) { final int tFreq = remF / nPart ; int ge = gs - 1 ; int aFreq = 0 ; for ( final int a = alphaSize - 1 ; ( aFreq < tFreq ) && ( ge < a ) ; ) { aFreq += mtfFreq [ ++ ge ] ; } if ( ( ge > gs ) && ( nPart != nGroups ) && ( nPart != 1 ) && ( ( ( nGroups - nPart ) & 1 ) != 0 ) ) { aFreq -= mtfFreq [ ge -- ] ; } final byte [ ] len_np = len [ nPart - 1 ] ; for ( int v = alphaSize ; -- v >= 0 ; ) { if ( ( v >= gs ) && ( v <= ge ) ) { len_np [ v ] = LESSER_ICOST ; } else { len_np [ v ] = GREATER_ICOST ; } } gs = ge + 1 ; remF -= aFreq ; } } private int sendMTFValues1 ( final int nGroups , final int alphaSize ) { final Data dataShadow = this . data ; final int [ ] [ ] rfreq = dataShadow . sendMTFValues_rfreq ; final int [ ] fave = dataShadow . sendMTFValues_fave ; final short [ ] cost = dataShadow . sendMTFValues_cost ; final char [ ] sfmap = dataShadow . sfmap ; final byte [ ] selector = dataShadow . selector ; final byte [ ] [ ] len = dataShadow . sendMTFValues_len ; final byte [ ] len_0 = len [ 0 ] ; final byte [ ] len_1 = len [ 1 ] ; final byte [ ] len_2 = len [ 2 ] ; final byte [ ] len_3 = len [ 3 ] ; final byte [ ] len_4 = len [ 4 ] ; final byte [ ] len_5 = len [ 5 ] ; final int nMTFShadow = this . nMTF ; int nSelectors = 0 ; for ( int iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( int t = nGroups ; -- t >= 0 ; ) { fave [ t ] = 0 ; int [ ] rfreqt = rfreq [ t ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { rfreqt [ i ] = 0 ; } } nSelectors = 0 ; for ( int gs = 0 ; gs < this . nMTF ; ) { final int ge = Math . min ( gs + G_SIZE - 1 , nMTFShadow - 1 ) ; if ( nGroups == N_GROUPS ) { short cost0 = 0 ; short cost1 = 0 ; short cost2 = 0 ; short cost3 = 0 ; short cost4 = 0 ; short cost5 = 0 ; for ( int i = gs ; i <= ge ; i ++ ) { final int icv = sfmap [ i ] ; cost0 += len_0 [ icv ] & 0xff ; cost1 += len_1 [ icv ] & 0xff ; cost2 += len_2 [ icv ] & 0xff ; cost3 += len_3 [ icv ] & 0xff ; cost4 += len_4 [ icv ] & 0xff ; cost5 += len_5 [ icv ] & 0xff ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( int t = nGroups ; -- t >= 0 ; ) { cost [ t ] = 0 ; } for ( int i = gs ; i <= ge ; i ++ ) { final int icv = sfmap [ i ] ; for ( int t = nGroups ; -- t >= 0 ; ) { cost [ t ] += len [ t ] [ icv ] & 0xff ; } } } int bt = - 1 ; for ( int t = nGroups , bc = 999999999 ; -- t >= 0 ; ) { final int cost_t = cost [ t ] ; if ( cost_t < bc ) { bc = cost_t ; bt = t ; } } fave [ bt ] ++ ; selector [ nSelectors ] = ( byte ) bt ; nSelectors ++ ; final int [ ] rfreq_bt = rfreq [ bt ] ; for ( int i = gs ; i <= ge ; i ++ ) { rfreq_bt [ sfmap [ i ] ] ++ ; } gs = ge + 1 ; } for ( int t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , this . data , alphaSize , 20 ) ; } } return nSelectors ; } private void sendMTFValues2 ( final int nGroups , final int nSelectors ) { final Data dataShadow = this . data ; byte [ ] pos = dataShadow . sendMTFValues2_pos ; for ( int i = nGroups ; -- i >= 0 ; ) { pos [ i ] = ( byte ) i ; } for ( int i = 0 ; i < nSelectors ; i ++ ) { final byte ll_i = dataShadow . selector [ i ] ; byte tmp = pos [ 0 ] ; int j = 0 ; while ( ll_i != tmp ) { j ++ ; byte tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; dataShadow . selectorMtf [ i ] = ( byte ) j ; } } private void sendMTFValues3 ( final int nGroups , final int alphaSize ) { int [ ] [ ] code = this . data . sendMTFValues_code ; byte [ ] [ ] len = this . data . sendMTFValues_len ; for ( int t = 0 ; t < nGroups ; t ++ ) { int minLen = 32 ; int maxLen = 0 ; final byte [ ] len_t = len [ t ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { final int l = len_t [ i ] & 0xff ; if ( l > maxLen ) { maxLen = l ; } if ( l < minLen ) { minLen = l ; } } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } } private void sendMTFValues4 ( ) throws IOException { final boolean [ ] inUse = this . data . inUse ; final boolean [ ] inUse16 = this . data . sentMTFValues4_inUse16 ; for ( int i = 16 ; -- i >= 0 ; ) { inUse16 [ i ] = false ; final int i16 = i * 16 ; for ( int j = 16 ; -- j >= 0 ; ) { if ( inUse [ i16 + j ] ) { inUse16 [ i ] = true ; } } } for ( int i = 0 ; i < 16 ; i ++ ) { bsW ( 1 , inUse16 [ i ] ? 1 : 0 ) ; } final OutputStream outShadow = this . out ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { final int i16 = i * 16 ; for ( int j = 0 ; j < 16 ; j ++ ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } if ( inUse [ i16 + j ] ) { bsBuffShadow |= 1 << ( 32 - bsLiveShadow - 1 ) ; } bsLiveShadow ++ ; } } } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void sendMTFValues5 ( final int nGroups , final int nSelectors ) throws IOException { bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; final OutputStream outShadow = this . out ; final byte [ ] selectorMtf = this . data . selectorMtf ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int i = 0 ; i < nSelectors ; i ++ ) { for ( int j = 0 , hj = selectorMtf [ i ] & 0xff ; j < hj ; j ++ ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= 1 << ( 32 - bsLiveShadow - 1 ) ; bsLiveShadow ++ ; } while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsLiveShadow ++ ; } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void sendMTFValues6 ( final int nGroups , final int alphaSize ) throws IOException { final byte [ ] [ ] len = this . data . sendMTFValues_len ; final OutputStream outShadow = this . out ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int t = 0 ; t < nGroups ; t ++ ) { byte [ ] len_t = len [ t ] ; int curr = len_t [ 0 ] & 0xff ; while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= curr << ( 32 - bsLiveShadow - 5 ) ; bsLiveShadow += 5 ; for ( int i = 0 ; i < alphaSize ; i ++ ) { int lti = len_t [ i ] & 0xff ; while ( curr < lti ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= 2 << ( 32 - bsLiveShadow - 2 ) ; bsLiveShadow += 2 ; curr ++ ; } while ( curr > lti ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= 3 << ( 32 - bsLiveShadow - 2 ) ; bsLiveShadow += 2 ; curr -- ; } while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsLiveShadow ++ ; } } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void sendMTFValues7 ( final int nSelectors ) throws IOException { final Data dataShadow = this . data ; final byte [ ] [ ] len = dataShadow . sendMTFValues_len ; final int [ ] [ ] code = dataShadow . sendMTFValues_code ; final OutputStream outShadow = this . out ; final byte [ ] selector = dataShadow . selector ; final char [ ] sfmap = dataShadow . sfmap ; final int nMTFShadow = this . nMTF ; int selCtr = 0 ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int gs = 0 ; gs < nMTFShadow ; ) { final int ge = Math . min ( gs + G_SIZE - 1 , nMTFShadow - 1 ) ; final int selector_selCtr = selector [ selCtr ] & 0xff ; final int [ ] code_selCtr = code [ selector_selCtr ] ; final byte [ ] len_selCtr = len [ selector_selCtr ] ; while ( gs <= ge ) { final int sfmap_i = sfmap [ gs ] ; while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } final int n = len_selCtr [ sfmap_i ] & 0xFF ; bsBuffShadow |= code_selCtr [ sfmap_i ] << ( 32 - bsLiveShadow - n ) ; bsLiveShadow += n ; gs ++ ; } gs = ge + 1 ; selCtr ++ ; } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void moveToFrontCodeAndSend ( ) throws IOException { bsW ( 24 , this . origPtr ) ; generateMTFValues ( ) ; sendMTFValues ( ) ; } private boolean mainSimpleSort ( final Data dataShadow , final int lo , final int hi , final int d ) { final int bigN = hi - lo + 1 ; if ( bigN < 2 ) { return this . firstAttempt && ( this . workDone > this . workLimit ) ; } int hp = 0 ; while ( INCS [ hp ] < bigN ) { hp ++ ; } final int [ ] fmap = dataShadow . fmap ; final char [ ] quadrant = dataShadow . quadrant ; final byte [ ] block = dataShadow . block ; final int lastShadow = this . last ; final int lastPlus1 = lastShadow + 1 ; final boolean firstAttemptShadow = this . firstAttempt ; final int workLimitShadow = this . workLimit ; int workDoneShadow = this . workDone ; HP : while ( -- hp >= 0 ) { final int h = INCS [ hp ] ; final int mj = lo + h - 1 ; for ( int i = lo + h ; i <= hi ; ) { for ( int k = 3 ; ( i <= hi ) && ( -- k >= 0 ) ; i ++ ) { final int v = fmap [ i ] ; final int vd = v + d ; int j = i ; boolean onceRunned = false ; int a = 0 ; HAMMER : while ( true ) { if ( onceRunned ) { fmap [ j ] = a ; if ( ( j -= h ) <= mj ) { break HAMMER ; } } else { onceRunned = true ; } a = fmap [ j - h ] ; int i1 = a + d ; int i2 = vd ; if ( block [ i1 + 1 ] == block [ i2 + 1 ] ) { if ( block [ i1 + 2 ] == block [ i2 + 2 ] ) { if ( block [ i1 + 3 ] == block [ i2 + 3 ] ) { if ( block [ i1 + 4 ] == block [ i2 + 4 ] ) { if ( block [ i1 + 5 ] == block [ i2 + 5 ] ) { if ( block [ ( i1 += 6 ) ] == block [ ( i2 += 6 ) ] ) { int x = lastShadow ; X : while ( x > 0 ) { x -= 4 ; if ( block [ i1 + 1 ] == block [ i2 + 1 ] ) { if ( quadrant [ i1 ] == quadrant [ i2 ] ) { if ( block [ i1 + 2 ] == block [ i2 + 2 ] ) { if ( quadrant [ i1 + 1 ] == quadrant [ i2 + 1 ] ) { if ( block [ i1 + 3 ] == block [ i2 + 3 ] ) { if ( quadrant [ i1 + 2 ] == quadrant [ i2 + 2 ] ) { if ( block [ i1 + 4 ] == block [ i2 + 4 ] ) { if ( quadrant [ i1 + 3 ] == quadrant [ i2 + 3 ] ) { if ( ( i1 += 4 ) >= lastPlus1 ) { i1 -= lastPlus1 ; } if ( ( i2 += 4 ) >= lastPlus1 ) { i2 -= lastPlus1 ; } workDoneShadow ++ ; continue X ; } else if ( ( quadrant [ i1 + 3 ] > quadrant [ i2 + 3 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 4 ] & 0xff ) > ( block [ i2 + 4 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( quadrant [ i1 + 2 ] > quadrant [ i2 + 2 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 3 ] & 0xff ) > ( block [ i2 + 3 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( quadrant [ i1 + 1 ] > quadrant [ i2 + 1 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 2 ] & 0xff ) > ( block [ i2 + 2 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( quadrant [ i1 ] > quadrant [ i2 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 1 ] & 0xff ) > ( block [ i2 + 1 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } break HAMMER ; } else { if ( ( block [ i1 ] & 0xff ) > ( block [ i2 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } } else if ( ( block [ i1 + 5 ] & 0xff ) > ( block [ i2 + 5 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 4 ] & 0xff ) > ( block [ i2 + 4 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 3 ] & 0xff ) > ( block [ i2 + 3 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 2 ] & 0xff ) > ( block [ i2 + 2 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 1 ] & 0xff ) > ( block [ i2 + 1 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } fmap [ j ] = v ; } if ( firstAttemptShadow && ( i <= hi ) && ( workDoneShadow > workLimitShadow ) ) { break HP ; } } } this . workDone = workDoneShadow ; return firstAttemptShadow && ( workDoneShadow > workLimitShadow ) ; } private static void vswap ( int [ ] fmap , int p1 , int p2 , int n ) { n += p1 ; while ( p1 < n ) { int t = fmap [ p1 ] ; fmap [ p1 ++ ] = fmap [ p2 ] ; fmap [ p2 ++ ] = t ; } } private static byte med3 ( byte a , byte b , byte c ) { return ( a < b ) ? ( b < c ? b : a < c ? c : a ) : ( b > c ? b : a > c ? c : a ) ; } private void blockSort ( ) { this . workLimit = WORK_FACTOR * this . last ; this . workDone = 0 ; this . blockRandomised = false ; this . firstAttempt = true ; mainSort ( ) ; if ( this . firstAttempt && ( this . workDone > this . workLimit ) ) { randomiseBlock ( ) ; this . workLimit = this . workDone = 0 ; this . firstAttempt = false ; mainSort ( ) ; } int [ ] fmap = this . data . fmap ; this . origPtr = - 1 ; for ( int i = 0 , lastShadow = this . last ; i <= lastShadow ; i ++ ) { if ( fmap [ i ] == 0 ) { this . origPtr = i ; break ; } } } private void mainQSort3 ( final Data dataShadow , final int loSt , final int hiSt , final int dSt ) { final int [ ] stack_ll = dataShadow . stack_ll ; final int [ ] stack_hh = dataShadow . stack_hh ; final int [ ] stack_dd = dataShadow . stack_dd ; final int [ ] fmap = dataShadow . fmap ; final byte [ ] block = dataShadow . block ; stack_ll [ 0 ] = loSt ; stack_hh [ 0 ] = hiSt ; stack_dd [ 0 ] = dSt ; for ( int sp = 1 ; -- sp >= 0 ; ) { final int lo = stack_ll [ sp ] ; final int hi = stack_hh [ sp ] ; final int d = stack_dd [ sp ] ; if ( ( hi - lo < SMALL_THRESH ) || ( d > DEPTH_THRESH ) ) { if ( mainSimpleSort ( dataShadow , lo , hi , d ) ) { return ; } } else { final int d1 = d + 1 ; final int med = med3 ( block [ fmap [ lo ] + d1 ] , block [ fmap [ hi ] + d1 ] , block [ fmap [ ( lo + hi ) > > 1 ] + d1 ] ) & 0xff ; int unLo = lo ; int unHi = hi ; int ltLo = lo ; int gtHi = hi ; while ( true ) { while ( unLo <= unHi ) { final int n = ( ( int ) block [ fmap [ unLo ] + d1 ] & 0xff ) - med ; if ( n == 0 ) { final int temp = fmap [ unLo ] ; fmap [ unLo ++ ] = fmap [ ltLo ] ; fmap [ ltLo ++ ] = temp ; } else if ( n < 0 ) { unLo ++ ; } else { break ; } } while ( unLo <= unHi ) { final int n = ( ( int ) block [ fmap [ unHi ] + d1 ] & 0xff ) - med ; if ( n == 0 ) { final int temp = fmap [ unHi ] ; fmap [ unHi -- ] = fmap [ gtHi ] ; fmap [ gtHi -- ] = temp ; } else if ( n > 0 ) { unHi -- ; } else { break ; } } if ( unLo <= unHi ) { final int temp = fmap [ unLo ] ; fmap [ unLo ++ ] = fmap [ unHi ] ; fmap [ unHi -- ] = temp ; } else { break ; } } if ( gtHi < ltLo ) { stack_ll [ sp ] = lo ; stack_hh [ sp ] = hi ; stack_dd [ sp ] = d1 ; sp ++ ; } else { int n = ( ( ltLo - lo ) < ( unLo - ltLo ) ) ? ( ltLo - lo ) : ( unLo - ltLo ) ; vswap ( fmap , lo , unLo - n , n ) ; int m = ( ( hi - gtHi ) < ( gtHi - unHi ) ) ? ( hi - gtHi ) : ( gtHi - unHi ) ; vswap ( fmap , unLo , hi - m + 1 , m ) ; n = lo + unLo - ltLo - 1 ; m = hi - ( gtHi - unHi ) + 1 ; stack_ll [ sp ] = lo ; stack_hh [ sp ] = n ; stack_dd [ sp ] = d ; sp ++ ; stack_ll [ sp ] = n + 1 ; stack_hh [ sp ] = m - 1 ; stack_dd [ sp ] = d1 ; sp ++ ; stack_ll [ sp ] = m ; stack_hh [ sp ] = hi ; stack_dd [ sp ] = d ; sp ++ ; } } } } private void mainSort ( ) { final Data dataShadow = this . data ; final int [ ] runningOrder = dataShadow . mainSort_runningOrder ; final int [ ] copy = dataShadow . mainSort_copy ; final boolean [ ] bigDone = dataShadow . mainSort_bigDone ; final int [ ] ftab = dataShadow . ftab ; final byte [ ] block = dataShadow . block ; final int [ ] fmap = dataShadow . fmap ; final char [ ] quadrant = dataShadow . quadrant ; final int lastShadow = this . last ; final int workLimitShadow = this . workLimit ; final boolean firstAttemptShadow = this . firstAttempt ; for ( int i = 65537 ; -- i >= 0 ; ) { ftab [ i ] = 0 ; } for ( int i = 0 ; i < NUM_OVERSHOOT_BYTES ; i ++ ) { block [ lastShadow + i + 2 ] = block [ ( i % ( lastShadow + 1 ) ) + 1 ] ; } for ( int i = lastShadow + NUM_OVERSHOOT_BYTES ; -- i >= 0 ; ) { quadrant [ i ] = 0 ; } block [ 0 ] = block [ lastShadow + 1 ] ; int c1 = block [ 0 ] & 0xff ; for ( int i = 0 ; i <= lastShadow ; i ++ ) { final int c2 = block [ i + 1 ] & 0xff ; ftab [ ( c1 << 8 ) + c2 ] ++ ; c1 = c2 ; } for ( int i = 1 ; i <= 65536 ; i ++ ) ftab [ i ] += ftab [ i - 1 ] ; c1 = block [ 1 ] & 0xff ; for ( int i = 0 ; i < lastShadow ; i ++ ) { final int c2 = block [ i + 2 ] & 0xff ; fmap [ -- ftab [ ( c1 << 8 ) + c2 ] ] = i ; c1 = c2 ; } fmap [ -- ftab [ ( ( block [ lastShadow + 1 ] & 0xff ) << 8 ) + ( block [ 1 ] & 0xff ) ] ] = lastShadow ; for ( int i = 256 ; -- i >= 0 ; ) { bigDone [ i ] = false ; runningOrder [ i ] = i ; } for ( int h = 364 ; h != 1 ; ) { h /= 3 ; for ( int i = h ; i <= 255 ; i ++ ) { final int vv = runningOrder [ i ] ; final int a = ftab [ ( vv + 1 ) << 8 ] - ftab [ vv << 8 ] ; final int b = h - 1 ; int j = i ; for ( int ro = runningOrder [ j - h ] ; ( ftab [ ( ro + 1 ) << 8 ] - ftab [ ro << 8 ] ) > a ; ro = runningOrder [ j - h ] ) { runningOrder [ j ] = ro ; j -= h ; if ( j <= b ) { break ; } } runningOrder [ j ] = vv ; } } for ( int i = 0 ; i <= 255 ; i ++ ) { final int ss = runningOrder [ i ] ; for ( int j = 0 ; j <= 255 ; j ++ ) { final int sb = ( ss << 8 ) + j ; final int ftab_sb = ftab [ sb ] ; if ( ( ftab_sb & SETMASK ) != SETMASK ) { final int lo = ftab_sb & CLEARMASK ; final int hi = ( ftab [ sb + 1 ] & CLEARMASK ) - 1 ; if ( hi > lo ) { mainQSort3 ( dataShadow , lo , hi , 2 ) ; if ( firstAttemptShadow && ( this . workDone > workLimitShadow ) ) { return ; } } ftab [ sb ] = ftab_sb | SETMASK ; } } for ( int j = 0 ; j <= 255 ; j ++ ) { copy [ j ] = ftab [ ( j << 8 ) + ss ] & CLEARMASK ; } for ( int j = ftab [ ss << 8 ] & CLEARMASK , hj = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) ; j < hj ; j ++ ) { final int fmap_j = fmap [ j ] ; c1 = block [ fmap_j ] & 0xff ; if ( ! bigDone [ c1 ] ) { fmap [ copy [ c1 ] ] = ( fmap_j == 0 ) ? lastShadow : ( fmap_j - 1 ) ; copy [ c1 ] ++ ; } } for ( int j = 256 ; -- j >= 0 ; ) ftab [ ( j << 8 ) + ss ] |= SETMASK ; bigDone [ ss ] = true ; if ( i < 255 ) { final int bbStart = ftab [ ss << 8 ] & CLEARMASK ; final int bbSize = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart ; int shifts = 0 ; while ( ( bbSize > > shifts ) > 65534 ) { shifts ++ ; } for ( int j = 0 ; j < bbSize ; j ++ ) { final int a2update = fmap [ bbStart + j ] ; final char qVal = ( char ) ( j > > shifts ) ; quadrant [ a2update ] = qVal ; if ( a2update < NUM_OVERSHOOT_BYTES ) { quadrant [ a2update + lastShadow + 1 ] = qVal ; } } } } } private void randomiseBlock ( ) { final boolean [ ] inUse = this . data . inUse ; final byte [ ] block = this . data . block ; final int lastShadow = this . last ; for ( int i = 256 ; -- i >= 0 ; ) inUse [ i ] = false ; int rNToGo = 0 ; int rTPos = 0 ; for ( int i = 0 , j = 1 ; i <= lastShadow ; i = j , j ++ ) { if ( rNToGo == 0 ) { rNToGo = ( char ) BZip2Constants . rNums [ rTPos ] ; if ( ++ rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; block [ j ] ^= ( ( rNToGo == 1 ) ? 1 : 0 ) ; inUse [ block [ j ] & 0xff ] = true ; } this . blockRandomised = true ; } private void generateMTFValues ( ) { final int lastShadow = this . last ; final Data dataShadow = this . data ; final boolean [ ] inUse = dataShadow . inUse ; final byte [ ] block = dataShadow . block ; final int [ ] fmap = dataShadow . fmap ; final char [ ] sfmap = dataShadow . sfmap ; final int [ ] mtfFreq = dataShadow . mtfFreq ; final byte [ ] unseqToSeq = dataShadow . unseqToSeq ; final byte [ ] yy = dataShadow . generateMTFValues_yy ; int nInUseShadow = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) { unseqToSeq [ i ] = ( byte ) nInUseShadow ; nInUseShadow ++ ; } } this . nInUse = nInUseShadow ; final int eob = nInUseShadow + 1 ; for ( int i = eob ; i >= 0 ; i -- ) { mtfFreq [ i ] = 0 ; } for ( int i = nInUseShadow ; -- i >= 0 ; ) { yy [ i ] = ( byte ) i ; } int wr = 0 ; int zPend = 0 ; for ( int i = 0 ; i <= lastShadow ; i ++ ) { final byte ll_i = unseqToSeq [ block [ fmap [ i ] ] & 0xff ] ; byte tmp = yy [ 0 ] ; int j = 0 ; while ( ll_i != tmp ) { j ++ ; byte tmp2 = tmp ; tmp = yy [ j ] ; yy [ j ] = tmp2 ; } yy [ 0 ] = tmp ; if ( j == 0 ) { zPend ++ ; } else { if ( zPend > 0 ) { zPend -- ; while ( true ) { if ( ( zPend & 1 ) == 0 ) { sfmap [ wr ] = RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; } else { sfmap [ wr ] = RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; } if ( zPend >= 2 ) { zPend = ( zPend - 2 ) > > 1 ; } else { break ; } } zPend = 0 ; } sfmap [ wr ] = ( char ) ( j + 1 ) ; wr ++ ; mtfFreq [ j + 1 ] ++ ; } } if ( zPend > 0 ) { zPend -- ; while ( true ) { if ( ( zPend & 1 ) == 0 ) { sfmap [ wr ] = RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; } else { sfmap [ wr ] = RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; } if ( zPend >= 2 ) { zPend = ( zPend - 2 ) > > 1 ; } else { break ; } } } sfmap [ wr ] = ( char ) eob ; mtfFreq [ eob ] ++ ; this . nMTF = wr + 1 ; } private static final class Data extends Object { final boolean [ ] inUse = new boolean [ 256 ] ; final byte [ ] unseqToSeq = new byte [ 256 ] ; final int [ ] mtfFreq = new int [ MAX_ALPHA_SIZE ] ; final byte [ ] selector = new byte [ MAX_SELECTORS ] ; final byte [ ] selectorMtf = new byte [ MAX_SELECTORS ] ; final byte [ ] generateMTFValues_yy = new byte [ 256 ] ; final byte [ ] [ ] sendMTFValues_len = new byte [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] [ ] sendMTFValues_rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] sendMTFValues_fave = new int [ N_GROUPS ] ; final short [ ] sendMTFValues_cost = new short [ N_GROUPS ] ; final int [ ] [ ] sendMTFValues_code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final byte [ ] sendMTFValues2_pos = new byte [ N_GROUPS ] ; final boolean [ ] sentMTFValues4_inUse16 = new boolean [ 16 ] ; final int [ ] stack_ll = new int [ QSORT_STACK_SIZE ] ; final int [ ] stack_hh = new int [ QSORT_STACK_SIZE ] ; final int [ ] stack_dd = new int [ QSORT_STACK_SIZE ] ; final int [ ] mainSort_runningOrder = new int [ 256 ] ; final int [ ] mainSort_copy = new int [ 256 ] ; final boolean [ ] mainSort_bigDone = new boolean [ 256 ] ; final int [ ] heap = new int [ MAX_ALPHA_SIZE + 2 ] ; final int [ ] weight = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] parent = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] ftab = new int [ 65537 ] ; final byte [ ] block ; final int [ ] fmap ; final char [ ] sfmap ; final char [ ] quadrant ; Data ( int blockSize100k ) { super ( ) ; final int n = blockSize100k * BZip2Constants . baseBlockSize ; this . block = new byte [ ( n + 1 + NUM_OVERSHOOT_BYTES ) ] ; this . fmap = new int [ n ] ; this . sfmap = new char [ 2 * n ] ; this . quadrant = this . sfmap ; } } } 	1
package org . apache . tools . ant . taskdefs . condition ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; public class Os implements Condition { private static final String OS_NAME = System . getProperty ( "os.name" ) . toLowerCase ( Locale . US ) ; private static final String OS_ARCH = System . getProperty ( "os.arch" ) . toLowerCase ( Locale . US ) ; private static final String OS_VERSION = System . getProperty ( "os.version" ) . toLowerCase ( Locale . US ) ; private static final String PATH_SEP = System . getProperty ( "path.separator" ) ; private String family ; private String name ; private String version ; private String arch ; public static final String FAMILY_WINDOWS = "windows" ; public static final String FAMILY_9X = "win9x" ; public static final String FAMILY_NT = "winnt" ; public static final String FAMILY_OS2 = "os/2" ; public static final String FAMILY_NETWARE = "netware" ; public static final String FAMILY_DOS = "dos" ; public static final String FAMILY_MAC = "mac" ; public static final String FAMILY_TANDEM = "tandem" ; public static final String FAMILY_UNIX = "unix" ; public static final String FAMILY_VMS = "openvms" ; public static final String FAMILY_ZOS = "z/os" ; public static final String FAMILY_OS400 = "os/400" ; public Os ( ) { } public Os ( String family ) { setFamily ( family ) ; } public void setFamily ( String f ) { family = f . toLowerCase ( Locale . US ) ; } public void setName ( String name ) { this . name = name . toLowerCase ( Locale . US ) ; } public void setArch ( String arch ) { this . arch = arch . toLowerCase ( Locale . US ) ; } public void setVersion ( String version ) { this . version = version . toLowerCase ( Locale . US ) ; } public boolean eval ( ) throws BuildException { return isOs ( family , name , arch , version ) ; } public static boolean isFamily ( String family ) { return isOs ( family , null , null , null ) ; } public static boolean isName ( String name ) { return isOs ( null , name , null , null ) ; } public static boolean isArch ( String arch ) { return isOs ( null , null , arch , null ) ; } public static boolean isVersion ( String version ) { return isOs ( null , null , null , version ) ; } public static boolean isOs ( String family , String name , String arch , String version ) { boolean retValue = false ; if ( family != null || name != null || arch != null || version != null ) { boolean isFamily = true ; boolean isName = true ; boolean isArch = true ; boolean isVersion = true ; if ( family != null ) { boolean isWindows = OS_NAME . indexOf ( FAMILY_WINDOWS ) > - 1 ; boolean is9x = false ; boolean isNT = false ; if ( isWindows ) { is9x = ( OS_NAME . indexOf ( "95" ) >= 0 || OS_NAME . indexOf ( "98" ) >= 0 || OS_NAME . indexOf ( "me" ) >= 0 || OS_NAME . indexOf ( "ce" ) >= 0 ) ; isNT = ! is9x ; } if ( family . equals ( FAMILY_WINDOWS ) ) { isFamily = isWindows ; } else if ( family . equals ( FAMILY_9X ) ) { isFamily = isWindows && is9x ; } else if ( family . equals ( FAMILY_NT ) ) { isFamily = isWindows && isNT ; } else if ( family . equals ( FAMILY_OS2 ) ) { isFamily = OS_NAME . indexOf ( FAMILY_OS2 ) > - 1 ; } else if ( family . equals ( FAMILY_NETWARE ) ) { isFamily = OS_NAME . indexOf ( FAMILY_NETWARE ) > - 1 ; } else if ( family . equals ( FAMILY_DOS ) ) { isFamily = PATH_SEP . equals ( ";" ) && ! isFamily ( FAMILY_NETWARE ) ; } else if ( family . equals ( FAMILY_MAC ) ) { isFamily = OS_NAME . indexOf ( FAMILY_MAC ) > - 1 ; } else if ( family . equals ( FAMILY_TANDEM ) ) { isFamily = OS_NAME . indexOf ( "nonstop_kernel" ) > - 1 ; } else if ( family . equals ( FAMILY_UNIX ) ) { isFamily = PATH_SEP . equals ( ":" ) && ! isFamily ( FAMILY_VMS ) && ( ! isFamily ( FAMILY_MAC ) || OS_NAME . endsWith ( "x" ) ) ; } else if ( family . equals ( FAMILY_ZOS ) ) { isFamily = OS_NAME . indexOf ( FAMILY_ZOS ) > - 1 || OS_NAME . indexOf ( "os/390" ) > - 1 ; } else if ( family . equals ( FAMILY_OS400 ) ) { isFamily = OS_NAME . indexOf ( FAMILY_OS400 ) > - 1 ; } else if ( family . equals ( FAMILY_VMS ) ) { isFamily = OS_NAME . indexOf ( FAMILY_VMS ) > - 1 ; } else { throw new BuildException ( "Don\'t know how to detect os family \"" + family + "\"" ) ; } } if ( name != null ) { isName = name . equals ( OS_NAME ) ; } if ( arch != null ) { isArch = arch . equals ( OS_ARCH ) ; } if ( version != null ) { isVersion = version . equals ( OS_VERSION ) ; } retValue = isFamily && isName && isArch && isVersion ; } return retValue ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Locale ; import java . util . HashMap ; import java . util . Iterator ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class MacroDef extends AntlibDefinition { private NestedSequential nestedSequential ; private String name ; private boolean backTrace = true ; private List attributes = new ArrayList ( ) ; private Map elements = new HashMap ( ) ; private String textName = null ; private Text text = null ; private boolean hasImplicitElement = false ; public void setName ( String name ) { this . name = name ; } public void addConfiguredText ( Text text ) { if ( this . text != null ) { throw new BuildException ( "Only one nested text element allowed" ) ; } if ( text . getName ( ) == null ) { throw new BuildException ( "the text nested element needed a \"name\" attribute" ) ; } for ( Iterator i = attributes . iterator ( ) ; i . hasNext ( ) ; ) { Attribute attribute = ( Attribute ) i . next ( ) ; if ( text . getName ( ) . equals ( attribute . getName ( ) ) ) { throw new BuildException ( "the name \"" + text . getName ( ) + "\" is already used as an attribute" ) ; } } this . text = text ; this . textName = text . getName ( ) ; } public Text getText ( ) { return text ; } public void setBackTrace ( boolean backTrace ) { this . backTrace = backTrace ; } public boolean getBackTrace ( ) { return backTrace ; } public NestedSequential createSequential ( ) { if ( this . nestedSequential != null ) { throw new BuildException ( "Only one sequential allowed" ) ; } this . nestedSequential = new NestedSequential ( ) ; return this . nestedSequential ; } public static class NestedSequential implements TaskContainer { private List nested = new ArrayList ( ) ; public void addTask ( Task task ) { nested . add ( task ) ; } public List getNested ( ) { return nested ; } public boolean similar ( NestedSequential other ) { if ( nested . size ( ) != other . nested . size ( ) ) { return false ; } for ( int i = 0 ; i < nested . size ( ) ; ++ i ) { UnknownElement me = ( UnknownElement ) nested . get ( i ) ; UnknownElement o = ( UnknownElement ) other . nested . get ( i ) ; if ( ! me . similar ( o ) ) { return false ; } } return true ; } } public UnknownElement getNestedTask ( ) { UnknownElement ret = new UnknownElement ( "sequential" ) ; ret . setTaskName ( "sequential" ) ; ret . setNamespace ( "" ) ; ret . setQName ( "sequential" ) ; new RuntimeConfigurable ( ret , "sequential" ) ; for ( int i = 0 ; i < nestedSequential . getNested ( ) . size ( ) ; ++ i ) { UnknownElement e = ( UnknownElement ) nestedSequential . getNested ( ) . get ( i ) ; ret . addChild ( e ) ; ret . getWrapper ( ) . addChild ( e . getWrapper ( ) ) ; } return ret ; } public List getAttributes ( ) { return attributes ; } public Map getElements ( ) { return elements ; } public static boolean isValidNameCharacter ( char c ) { return Character . isLetterOrDigit ( c ) || c == '.' || c == '-' ; } private static boolean isValidName ( String name ) { if ( name . length ( ) == 0 ) { return false ; } for ( int i = 0 ; i < name . length ( ) ; ++ i ) { if ( ! isValidNameCharacter ( name . charAt ( i ) ) ) { return false ; } } return true ; } public void addConfiguredAttribute ( Attribute attribute ) { if ( attribute . getName ( ) == null ) { throw new BuildException ( "the attribute nested element needed a \"name\" attribute" ) ; } if ( attribute . getName ( ) . equals ( textName ) ) { throw new BuildException ( "the name \"" + attribute . getName ( ) + "\" has already been used by the text element" ) ; } for ( int i = 0 ; i < attributes . size ( ) ; ++ i ) { Attribute att = ( Attribute ) attributes . get ( i ) ; if ( att . getName ( ) . equals ( attribute . getName ( ) ) ) { throw new BuildException ( "the name \"" + attribute . getName ( ) + "\" has already been used in " + "another attribute element" ) ; } } attributes . add ( attribute ) ; } public void addConfiguredElement ( TemplateElement element ) { if ( element . getName ( ) == null ) { throw new BuildException ( "the element nested element needed a \"name\" attribute" ) ; } if ( elements . get ( element . getName ( ) ) != null ) { throw new BuildException ( "the element " + element . getName ( ) + " has already been specified" ) ; } if ( hasImplicitElement || ( element . isImplicit ( ) && elements . size ( ) != 0 ) ) { throw new BuildException ( "Only one element allowed when using implicit elements" ) ; } hasImplicitElement = element . isImplicit ( ) ; elements . put ( element . getName ( ) , element ) ; } public void execute ( ) { if ( nestedSequential == null ) { throw new BuildException ( "Missing sequential element" ) ; } if ( name == null ) { throw new BuildException ( "Name not specified" ) ; } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; MyAntTypeDefinition def = new MyAntTypeDefinition ( this ) ; def . setName ( name ) ; def . setClass ( MacroInstance . class ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; helper . addDataTypeDefinition ( def ) ; log ( "creating macro  " + name , Project . MSG_VERBOSE ) ; } public static class Attribute { private String name ; private String defaultValue ; private String description ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name . toLowerCase ( Locale . US ) ; } public String getName ( ) { return name ; } public void setDefault ( String defaultValue ) { this . defaultValue = defaultValue ; } public String getDefault ( ) { return defaultValue ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } Attribute other = ( Attribute ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } if ( defaultValue == null ) { if ( other . defaultValue != null ) { return false ; } } else if ( ! defaultValue . equals ( other . defaultValue ) ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( defaultValue ) + objectHashCode ( name ) ; } } public static class Text { private String name ; private boolean optional ; private boolean trim ; private String description ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name . toLowerCase ( Locale . US ) ; } public String getName ( ) { return name ; } public void setOptional ( boolean optional ) { this . optional = optional ; } public boolean getOptional ( ) { return optional ; } public void setTrim ( boolean trim ) { this . trim = trim ; } public boolean getTrim ( ) { return trim ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } Text other = ( Text ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } if ( optional != other . optional ) { return false ; } if ( trim != other . trim ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( name ) ; } } public static class TemplateElement { private String name ; private String description ; private boolean optional = false ; private boolean implicit = false ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for macro element" ) ; } this . name = name . toLowerCase ( Locale . US ) ; } public String getName ( ) { return name ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void setOptional ( boolean optional ) { this . optional = optional ; } public boolean isOptional ( ) { return optional ; } public void setImplicit ( boolean implicit ) { this . implicit = implicit ; } public boolean isImplicit ( ) { return implicit ; } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj == null || ! obj . getClass ( ) . equals ( getClass ( ) ) ) { return false ; } TemplateElement t = ( TemplateElement ) obj ; return ( name == null ? t . name == null : name . equals ( t . name ) ) && optional == t . optional && implicit == t . implicit ; } public int hashCode ( ) { return objectHashCode ( name ) + ( optional ? 1 : 0 ) + ( implicit ? 1 : 0 ) ; } } private boolean sameOrSimilar ( Object obj , boolean same ) { if ( obj == this ) { return true ; } if ( obj == null ) { return false ; } if ( ! obj . getClass ( ) . equals ( getClass ( ) ) ) { return false ; } MacroDef other = ( MacroDef ) obj ; if ( name == null ) { return other . name == null ; } if ( ! name . equals ( other . name ) ) { return false ; } if ( other . getLocation ( ) != null && other . getLocation ( ) . equals ( getLocation ( ) ) && ! same ) { return true ; } if ( text == null ) { if ( other . text != null ) { return false ; } } else { if ( ! text . equals ( other . text ) ) { return false ; } } if ( getURI ( ) == null || getURI ( ) . equals ( "" ) || getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) { if ( ! ( other . getURI ( ) == null || other . getURI ( ) . equals ( "" ) || other . getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) ) { return false ; } } else { if ( ! getURI ( ) . equals ( other . getURI ( ) ) ) { return false ; } } if ( ! nestedSequential . similar ( other . nestedSequential ) ) { return false ; } if ( ! attributes . equals ( other . attributes ) ) { return false ; } if ( ! elements . equals ( other . elements ) ) { return false ; } return true ; } public boolean similar ( Object obj ) { return sameOrSimilar ( obj , false ) ; } public boolean sameDefinition ( Object obj ) { return sameOrSimilar ( obj , true ) ; } private static class MyAntTypeDefinition extends AntTypeDefinition { private MacroDef macroDef ; public MyAntTypeDefinition ( MacroDef macroDef ) { this . macroDef = macroDef ; } public Object create ( Project project ) { Object o = super . create ( project ) ; if ( o == null ) { return null ; } ( ( MacroInstance ) o ) . setMacroDef ( macroDef ) ; return o ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . sameDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . sameDefinition ( otherDef . macroDef ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . similarDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . similar ( otherDef . macroDef ) ; } } private static int objectHashCode ( Object o ) { if ( o == null ) { return 0 ; } else { return o . hashCode ( ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; public class TempFile extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String property ; private File destDir = null ; private String prefix ; private String suffix = "" ; private boolean deleteOnExit ; public void setProperty ( String property ) { this . property = property ; } public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void setDeleteOnExit ( boolean deleteOnExit ) { this . deleteOnExit = deleteOnExit ; } public boolean isDeleteOnExit ( ) { return deleteOnExit ; } public void execute ( ) throws BuildException { if ( property == null || property . length ( ) == 0 ) { throw new BuildException ( "no property specified" ) ; } if ( destDir == null ) { destDir = getProject ( ) . resolveFile ( "." ) ; } File tfile = FILE_UTILS . createTempFile ( prefix , suffix , destDir , deleteOnExit ) ; getProject ( ) . setNewProperty ( property , tfile . toString ( ) ) ; } } 	1
package org . apache . tools . ant ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . PrintStream ; import java . io . StringReader ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . StringUtils ; public class DefaultLogger implements BuildLogger { public static final int LEFT_COLUMN_SIZE = 12 ; protected PrintStream out ; protected PrintStream err ; protected int msgOutputLevel = Project . MSG_ERR ; private long startTime = System . currentTimeMillis ( ) ; protected static final String lSep = StringUtils . LINE_SEP ; protected boolean emacsMode = false ; public DefaultLogger ( ) { } public void setMessageOutputLevel ( int level ) { this . msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . out = new PrintStream ( output , true ) ; } public void setErrorPrintStream ( PrintStream err ) { this . err = new PrintStream ( err , true ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void buildStarted ( BuildEvent event ) { startTime = System . currentTimeMillis ( ) ; } public void buildFinished ( BuildEvent event ) { Throwable error = event . getException ( ) ; StringBuffer message = new StringBuffer ( ) ; if ( error == null ) { message . append ( StringUtils . LINE_SEP ) ; message . append ( getBuildSuccessfulMessage ( ) ) ; } else { message . append ( StringUtils . LINE_SEP ) ; message . append ( getBuildFailedMessage ( ) ) ; message . append ( StringUtils . LINE_SEP ) ; if ( Project . MSG_VERBOSE <= msgOutputLevel || ! ( error instanceof BuildException ) ) { message . append ( StringUtils . getStackTrace ( error ) ) ; } else { message . append ( error . toString ( ) ) . append ( lSep ) ; } } message . append ( StringUtils . LINE_SEP ) ; message . append ( "Total time: " ) ; message . append ( formatTime ( System . currentTimeMillis ( ) - startTime ) ) ; String msg = message . toString ( ) ; if ( error == null ) { printMessage ( msg , out , Project . MSG_VERBOSE ) ; } else { printMessage ( msg , err , Project . MSG_ERR ) ; } log ( msg ) ; } protected String getBuildFailedMessage ( ) { return "BUILD FAILED" ; } protected String getBuildSuccessfulMessage ( ) { return "BUILD SUCCESSFUL" ; } public void targetStarted ( BuildEvent event ) { if ( Project . MSG_INFO <= msgOutputLevel && ! event . getTarget ( ) . getName ( ) . equals ( "" ) ) { String msg = StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" ; printMessage ( msg , out , event . getPriority ( ) ) ; log ( msg ) ; } } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority <= msgOutputLevel ) { StringBuffer message = new StringBuffer ( ) ; if ( event . getTask ( ) != null && ! emacsMode ) { String name = event . getTask ( ) . getTaskName ( ) ; String label = "[" + name + "] " ; int size = LEFT_COLUMN_SIZE - label . length ( ) ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = 0 ; i < size ; i ++ ) { tmp . append ( " " ) ; } tmp . append ( label ) ; label = tmp . toString ( ) ; try { BufferedReader r = new BufferedReader ( new StringReader ( event . getMessage ( ) ) ) ; String line = r . readLine ( ) ; boolean first = true ; do { if ( first ) { if ( line == null ) { message . append ( label ) ; break ; } } else { message . append ( StringUtils . LINE_SEP ) ; } first = false ; message . append ( label ) . append ( line ) ; line = r . readLine ( ) ; } while ( line != null ) ; } catch ( IOException e ) { message . append ( label ) . append ( event . getMessage ( ) ) ; } } else { message . append ( event . getMessage ( ) ) ; } Throwable ex = event . getException ( ) ; if ( Project . MSG_DEBUG <= msgOutputLevel && ex != null ) { message . append ( StringUtils . getStackTrace ( ex ) ) ; } String msg = message . toString ( ) ; if ( priority != Project . MSG_ERR ) { printMessage ( msg , out , priority ) ; } else { printMessage ( msg , err , priority ) ; } log ( msg ) ; } } protected static String formatTime ( final long millis ) { return DateUtils . formatElapsedTime ( millis ) ; } protected void printMessage ( final String message , final PrintStream stream , final int priority ) { stream . println ( message ) ; } protected void log ( String message ) { } } 	1
package org . apache . tools . ant . types . resources ; import java . util . Stack ; import java . util . TreeMap ; import java . util . Iterator ; import java . util . Collection ; import java . util . Comparator ; import java . util . Collections ; import java . util . AbstractCollection ; import java . util . NoSuchElementException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; import org . apache . tools . ant . types . resources . comparators . DelegatedResourceComparator ; public class Sort extends BaseResourceCollectionWrapper { private static class SortedBag extends AbstractCollection { private class MutableInt { private int value = 0 ; } private class MyIterator implements Iterator { private Iterator keyIter = t . keySet ( ) . iterator ( ) ; private Object current ; private int occurrence ; public synchronized boolean hasNext ( ) { return occurrence > 0 || keyIter . hasNext ( ) ; } public synchronized Object next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } if ( occurrence == 0 ) { current = keyIter . next ( ) ; occurrence = ( ( MutableInt ) t . get ( current ) ) . value ; } -- occurrence ; return current ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } private TreeMap t ; private int size ; SortedBag ( Comparator c ) { t = new TreeMap ( c ) ; } public synchronized Iterator iterator ( ) { return new MyIterator ( ) ; } public synchronized boolean add ( Object o ) { if ( size < Integer . MAX_VALUE ) { ++ size ; } MutableInt m = ( MutableInt ) ( t . get ( o ) ) ; if ( m == null ) { m = new MutableInt ( ) ; t . put ( o , m ) ; } m . value ++ ; return true ; } public synchronized int size ( ) { return size ; } } private DelegatedResourceComparator comp = new DelegatedResourceComparator ( ) ; protected synchronized Collection getCollection ( ) { ResourceCollection rc = getResourceCollection ( ) ; Iterator iter = rc . iterator ( ) ; if ( ! ( iter . hasNext ( ) ) ) { return Collections . EMPTY_SET ; } SortedBag b = new SortedBag ( comp ) ; while ( iter . hasNext ( ) ) { b . add ( iter . next ( ) ) ; } return b ; } public synchronized void add ( ResourceComparator c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } comp . add ( c ) ; FailFast . invalidate ( this ) ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { DataType . invokeCircularReferenceCheck ( comp , stk , p ) ; setChecked ( true ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Date ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class Expand extends Task { private File dest ; private File source ; private boolean overwrite = true ; private Mapper mapperElement = null ; private Vector patternsets = new Vector ( ) ; private Union resources = new Union ( ) ; private boolean resourcesSpecified = false ; private static final String NATIVE_ENCODING = "native-encoding" ; private String encoding = "UTF8" ; public static final String ERROR_MULTIPLE_MAPPERS = "Cannot define more than one mapper" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public void execute ( ) throws BuildException { if ( "expand" . equals ( getTaskType ( ) ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } if ( source == null && ! resourcesSpecified ) { throw new BuildException ( "src attribute and/or resources must be " + "specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( dest . exists ( ) && ! dest . isDirectory ( ) ) { throw new BuildException ( "Dest must be a directory." , getLocation ( ) ) ; } if ( source != null ) { if ( source . isDirectory ( ) ) { throw new BuildException ( "Src must not be a directory." + " Use nested filesets instead." , getLocation ( ) ) ; } else { expandFile ( FILE_UTILS , source , dest ) ; } } Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } if ( r instanceof FileResource ) { expandFile ( FILE_UTILS , ( ( FileResource ) r ) . getFile ( ) , dest ) ; } else { expandResource ( r , dest ) ; } } } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; ZipFile zf = null ; FileNameMapper mapper = getMapper ( ) ; try { zf = new ZipFile ( srcF , encoding ) ; Enumeration e = zf . getEntries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; extractFile ( fileUtils , srcF , dir , zf . getInputStream ( ze ) , ze . getName ( ) , new Date ( ze . getTime ( ) ) , ze . isDirectory ( ) , mapper ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { ZipFile . closeQuietly ( zf ) ; } } protected void expandResource ( Resource srcR , File dir ) { throw new BuildException ( "only filesystem based resources are" + " supported by this task." ) ; } protected FileNameMapper getMapper ( ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else { mapper = new IdentityMapper ( ) ; } return mapper ; } protected void extractFile ( FileUtils fileUtils , File srcF , File dir , InputStream compressedInputStream , String entryName , Date entryDate , boolean isDirectory , FileNameMapper mapper ) throws IOException { if ( patternsets != null && patternsets . size ( ) > 0 ) { String name = entryName . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; boolean included = false ; Set includePatterns = new HashSet ( ) ; Set excludePatterns = new HashSet ( ) ; for ( int v = 0 , size = patternsets . size ( ) ; v < size ; v ++ ) { PatternSet p = ( PatternSet ) patternsets . elementAt ( v ) ; String [ ] incls = p . getIncludePatterns ( getProject ( ) ) ; if ( incls == null || incls . length == 0 ) { incls = new String [ ] { "**" } ; } for ( int w = 0 ; w < incls . length ; w ++ ) { String pattern = incls [ w ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } includePatterns . add ( pattern ) ; } String [ ] excls = p . getExcludePatterns ( getProject ( ) ) ; if ( excls != null ) { for ( int w = 0 ; w < excls . length ; w ++ ) { String pattern = excls [ w ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } excludePatterns . add ( pattern ) ; } } } for ( Iterator iter = includePatterns . iterator ( ) ; ! included && iter . hasNext ( ) ; ) { String pattern = ( String ) iter . next ( ) ; included = SelectorUtils . matchPath ( pattern , name ) ; } for ( Iterator iter = excludePatterns . iterator ( ) ; included && iter . hasNext ( ) ; ) { String pattern = ( String ) iter . next ( ) ; included = ! SelectorUtils . matchPath ( pattern , name ) ; } if ( ! included ) { return ; } } String [ ] mappedNames = mapper . mapFileName ( entryName ) ; if ( mappedNames == null || mappedNames . length == 0 ) { mappedNames = new String [ ] { entryName } ; } File f = fileUtils . resolveFile ( dir , mappedNames [ 0 ] ) ; try { if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= entryDate . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; return ; } log ( "expanding " + entryName + " to " + f , Project . MSG_VERBOSE ) ; File dirF = f . getParentFile ( ) ; if ( dirF != null ) { dirF . mkdirs ( ) ; } if ( isDirectory ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; while ( ( length = compressedInputStream . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; fos = null ; } finally { FileUtils . close ( fos ) ; } } fileUtils . setFileLastModified ( f , entryDate . getTime ( ) ) ; } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } public void addPatternset ( PatternSet set ) { patternsets . addElement ( set ) ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { resourcesSpecified = true ; resources . add ( rc ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( ERROR_MULTIPLE_MAPPERS , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public void setEncoding ( String encoding ) { if ( NATIVE_ENCODING . equals ( encoding ) ) { encoding = null ; } this . encoding = encoding ; } } 	1
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class BaseSelectorContainer extends BaseSelector implements SelectorContainer { private Vector selectorsList = new Vector ( ) ; public BaseSelectorContainer ( ) { } public boolean hasSelectors ( ) { return ! ( selectorsList . isEmpty ( ) ) ; } public int selectorCount ( ) { return selectorsList . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { FileSelector [ ] result = new FileSelector [ selectorsList . size ( ) ] ; selectorsList . copyInto ( result ) ; return result ; } public Enumeration selectorElements ( ) { return selectorsList . elements ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = selectorElements ( ) ; if ( e . hasMoreElements ( ) ) { while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) . toString ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } } return buf . toString ( ) ; } public void appendSelector ( FileSelector selector ) { selectorsList . addElement ( selector ) ; } public void validate ( ) { verifySettings ( ) ; String errmsg = getError ( ) ; if ( errmsg != null ) { throw new BuildException ( errmsg ) ; } Enumeration e = selectorElements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof BaseSelector ) { ( ( BaseSelector ) o ) . validate ( ) ; } } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { appendSelector ( selector ) ; } public void addType ( TypeSelector selector ) { appendSelector ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { appendSelector ( selector ) ; } public void addModified ( ModifiedSelector selector ) { appendSelector ( selector ) ; } public void add ( FileSelector selector ) { appendSelector ( selector ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . OutputStream ; import java . io . FileOutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . XMLFragment ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Node ; import org . w3c . dom . Element ; public class EchoXML extends XMLFragment { private File file ; private boolean append ; private static final String ERROR_NO_XML = "No nested XML specified" ; public void setFile ( File f ) { file = f ; } public void setAppend ( boolean b ) { append = b ; } public void execute ( ) { DOMElementWriter writer = new DOMElementWriter ( ! append ) ; OutputStream os = null ; try { if ( file != null ) { os = new FileOutputStream ( file . getAbsolutePath ( ) , append ) ; } else { os = new LogOutputStream ( this , Project . MSG_INFO ) ; } Node n = getFragment ( ) . getFirstChild ( ) ; if ( n == null ) { throw new BuildException ( ERROR_NO_XML ) ; } writer . write ( ( Element ) n , os ) ; } catch ( BuildException e ) { throw e ; } catch ( Exception e ) { throw new BuildException ( e ) ; } finally { FileUtils . close ( os ) ; } } } 	1
package org . apache . tools . ant ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . List ; import java . util . StringTokenizer ; import org . apache . tools . ant . util . CollectionUtils ; public class Target implements TaskContainer { private String name ; private String ifCondition = "" ; private String unlessCondition = "" ; private List dependencies = null ; private List children = new ArrayList ( ) ; private Location location = Location . UNKNOWN_LOCATION ; private Project project ; private String description = null ; public Target ( ) { } public Target ( Target other ) { this . name = other . name ; this . ifCondition = other . ifCondition ; this . unlessCondition = other . unlessCondition ; this . dependencies = other . dependencies ; this . location = other . location ; this . project = other . project ; this . description = other . description ; this . children = other . children ; } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void setDepends ( String depS ) { if ( depS . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depS , "," , true ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; if ( "" . equals ( token ) || "," . equals ( token ) ) { throw new BuildException ( "Syntax Error: depends " + "attribute of target \"" + getName ( ) + "\" has an empty string as dependency." ) ; } addDependency ( token ) ; if ( tok . hasMoreTokens ( ) ) { token = tok . nextToken ( ) ; if ( ! tok . hasMoreTokens ( ) || ! "," . equals ( token ) ) { throw new BuildException ( "Syntax Error: Depend " + "attribute for target \"" + getName ( ) + "\" ends with a , character" ) ; } } } } } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void addTask ( Task task ) { children . add ( task ) ; } public void addDataType ( RuntimeConfigurable r ) { children . add ( r ) ; } public Task [ ] getTasks ( ) { List tasks = new ArrayList ( children . size ( ) ) ; Iterator it = children . iterator ( ) ; while ( it . hasNext ( ) ) { Object o = it . next ( ) ; if ( o instanceof Task ) { tasks . add ( o ) ; } } return ( Task [ ] ) tasks . toArray ( new Task [ tasks . size ( ) ] ) ; } public void addDependency ( String dependency ) { if ( dependencies == null ) { dependencies = new ArrayList ( 2 ) ; } dependencies . add ( dependency ) ; } public Enumeration getDependencies ( ) { return ( dependencies != null ? Collections . enumeration ( dependencies ) : new CollectionUtils . EmptyEnumeration ( ) ) ; } public boolean dependsOn ( String other ) { Project p = getProject ( ) ; Hashtable t = ( p == null ) ? null : p . getTargets ( ) ; return ( p != null && p . topoSort ( getName ( ) , t , false ) . contains ( t . get ( other ) ) ) ; } public void setIf ( String property ) { ifCondition = ( property == null ) ? "" : property ; } public String getIf ( ) { return ( "" . equals ( ifCondition ) ? null : ifCondition ) ; } public void setUnless ( String property ) { unlessCondition = ( property == null ) ? "" : property ; } public String getUnless ( ) { return ( "" . equals ( unlessCondition ) ? null : unlessCondition ) ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public String toString ( ) { return name ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { for ( int taskPosition = 0 ; taskPosition < children . size ( ) ; ++ taskPosition ) { Object o = children . get ( taskPosition ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . perform ( ) ; } else { RuntimeConfigurable r = ( RuntimeConfigurable ) o ; r . maybeConfigure ( project ) ; } } } else if ( ! testIfCondition ( ) ) { project . log ( this , "Skipped because property '" + project . replaceProperties ( ifCondition ) + "' not set." , Project . MSG_VERBOSE ) ; } else { project . log ( this , "Skipped because property '" + project . replaceProperties ( unlessCondition ) + "' set." , Project . MSG_VERBOSE ) ; } } public final void performTasks ( ) { RuntimeException thrown = null ; project . fireTargetStarted ( this ) ; try { execute ( ) ; } catch ( RuntimeException exc ) { thrown = exc ; throw exc ; } finally { project . fireTargetFinished ( this , thrown ) ; } } void replaceChild ( Task el , RuntimeConfigurable o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . set ( index , o ) ; } } void replaceChild ( Task el , Task o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . set ( index , o ) ; } } private boolean testIfCondition ( ) { if ( "" . equals ( ifCondition ) ) { return true ; } String test = project . replaceProperties ( ifCondition ) ; return project . getProperty ( test ) != null ; } private boolean testUnlessCondition ( ) { if ( "" . equals ( unlessCondition ) ) { return true ; } String test = project . replaceProperties ( unlessCondition ) ; return project . getProperty ( test ) == null ; } } 	1
package org . apache . tools . tar ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; import java . util . Arrays ; public class TarBuffer { public static final int DEFAULT_RCDSIZE = ( 512 ) ; public static final int DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 ) ; private InputStream inStream ; private OutputStream outStream ; private byte [ ] blockBuffer ; private int currBlkIdx ; private int currRecIdx ; private int blockSize ; private int recordSize ; private int recsPerBlock ; private boolean debug ; public TarBuffer ( InputStream inStream ) { this ( inStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize ) { this ( inStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize , int recordSize ) { this . inStream = inStream ; this . outStream = null ; this . initialize ( blockSize , recordSize ) ; } public TarBuffer ( OutputStream outStream ) { this ( outStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize ) { this ( outStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize , int recordSize ) { this . inStream = null ; this . outStream = outStream ; this . initialize ( blockSize , recordSize ) ; } private void initialize ( int blockSize , int recordSize ) { this . debug = false ; this . blockSize = blockSize ; this . recordSize = recordSize ; this . recsPerBlock = ( this . blockSize / this . recordSize ) ; this . blockBuffer = new byte [ this . blockSize ] ; if ( this . inStream != null ) { this . currBlkIdx = - 1 ; this . currRecIdx = this . recsPerBlock ; } else { this . currBlkIdx = 0 ; this . currRecIdx = 0 ; } } public int getBlockSize ( ) { return this . blockSize ; } public int getRecordSize ( ) { return this . recordSize ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean isEOFRecord ( byte [ ] record ) { for ( int i = 0 , sz = this . getRecordSize ( ) ; i < sz ; ++ i ) { if ( record [ i ] != 0 ) { return false ; } } return true ; } public void skipRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "SkipRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading (via skip) from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return ; } } this . currRecIdx ++ ; } public byte [ ] readRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ this . recordSize ] ; System . arraycopy ( this . blockBuffer , ( this . currRecIdx * this . recordSize ) , result , 0 , this . recordSize ) ; this . currRecIdx ++ ; return result ; } private boolean readBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } this . currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = this . blockSize ; while ( bytesNeeded > 0 ) { long numBytes = this . inStream . read ( this . blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { if ( offset == 0 ) { return false ; } Arrays . fill ( blockBuffer , offset , offset + bytesNeeded , ( byte ) 0 ) ; break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != this . blockSize ) { if ( this . debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + this . blockSize + " bytes read." ) ; } } } this . currBlkIdx ++ ; return true ; } public int getCurrentBlockNum ( ) { return this . currBlkIdx ; } public int getCurrentRecordNum ( ) { return this . currRecIdx - 1 ; } public void writeRecord ( byte [ ] record ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( record . length != this . recordSize ) { throw new IOException ( "record to write has length '" + record . length + "' which is not the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( record , 0 , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( ( offset + this . recordSize ) > buf . length ) { throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( buf , offset , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } private void writeBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "WriteBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } this . outStream . write ( this . blockBuffer , 0 , this . blockSize ) ; this . outStream . flush ( ) ; this . currRecIdx = 0 ; this . currBlkIdx ++ ; } private void flushBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.flushBlock() called." ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( this . currRecIdx > 0 ) { this . writeBlock ( ) ; } } public void close ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.closeBuffer()." ) ; } if ( this . outStream != null ) { this . flushBlock ( ) ; if ( this . outStream != System . out && this . outStream != System . err ) { this . outStream . close ( ) ; this . outStream = null ; } } else if ( this . inStream != null ) { if ( this . inStream != System . in ) { this . inStream . close ( ) ; this . inStream = null ; } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . TimeComparison ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Sort ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . Not ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . resources . comparators . Reverse ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; public class DependSet extends MatchingTask { private static final ResourceSelector NOT_EXISTS = new Not ( new Exists ( ) ) ; private static final ResourceComparator DATE_ASC = new org . apache . tools . ant . types . resources . comparators . Date ( ) ; private static final ResourceComparator DATE_DESC = new Reverse ( DATE_ASC ) ; private static class NonExistent extends Restrict { private NonExistent ( ResourceCollection rc ) { super . add ( rc ) ; super . add ( NOT_EXISTS ) ; } } private static class Xest extends Sort { private Xest ( ResourceCollection rc , ResourceComparator c ) { super . add ( c ) ; super . add ( rc ) ; } } private static class Oldest extends Xest { private Oldest ( ResourceCollection rc ) { super ( rc , DATE_ASC ) ; } } private static class Newest extends Xest { private Newest ( ResourceCollection rc ) { super ( rc , DATE_DESC ) ; } } private static class HideMissingBasedir implements ResourceCollection { private FileSet fs ; private HideMissingBasedir ( FileSet fs ) { this . fs = fs ; } public Iterator iterator ( ) { return basedirExists ( ) ? fs . iterator ( ) : Resources . EMPTY_ITERATOR ; } public int size ( ) { return basedirExists ( ) ? fs . size ( ) : 0 ; } public boolean isFilesystemOnly ( ) { return true ; } private boolean basedirExists ( ) { File basedir = fs . getDir ( ) ; return basedir == null || basedir . exists ( ) ; } } private Union sources = null ; private Path targets = null ; public synchronized Union createSources ( ) { sources = ( sources == null ) ? new Union ( ) : sources ; return sources ; } public void addSrcfileset ( FileSet fs ) { createSources ( ) . add ( fs ) ; } public void addSrcfilelist ( FileList fl ) { createSources ( ) . add ( fl ) ; } public synchronized Path createTargets ( ) { targets = ( targets == null ) ? new Path ( getProject ( ) ) : targets ; return targets ; } public void addTargetfileset ( FileSet fs ) { createTargets ( ) . add ( new HideMissingBasedir ( fs ) ) ; } public void addTargetfilelist ( FileList fl ) { createTargets ( ) . add ( fl ) ; } public void execute ( ) throws BuildException { if ( sources == null ) { throw new BuildException ( "At least one set of source resources must be specified" ) ; } if ( targets == null ) { throw new BuildException ( "At least one set of target files must be specified" ) ; } if ( sources . size ( ) > 0 && targets . size ( ) > 0 && ! uptodate ( sources , targets ) ) { log ( "Deleting all target files." , Project . MSG_VERBOSE ) ; Delete delete = new Delete ( ) ; delete . bindToOwner ( this ) ; delete . add ( targets ) ; delete . perform ( ) ; } } private boolean uptodate ( ResourceCollection src , ResourceCollection target ) { org . apache . tools . ant . types . resources . selectors . Date datesel = new org . apache . tools . ant . types . resources . selectors . Date ( ) ; datesel . setMillis ( System . currentTimeMillis ( ) ) ; datesel . setWhen ( TimeComparison . AFTER ) ; logFuture ( targets , datesel ) ; int neTargets = new NonExistent ( targets ) . size ( ) ; if ( neTargets > 0 ) { log ( neTargets + " nonexistent targets" , Project . MSG_VERBOSE ) ; return false ; } FileResource oldestTarget = ( FileResource ) ( new Oldest ( targets ) . iterator ( ) . next ( ) ) ; log ( oldestTarget + " is oldest target file" , Project . MSG_VERBOSE ) ; logFuture ( sources , datesel ) ; int neSources = new NonExistent ( sources ) . size ( ) ; if ( neSources > 0 ) { log ( neSources + " nonexistent sources" , Project . MSG_VERBOSE ) ; return false ; } Resource newestSource = ( Resource ) ( new Newest ( sources ) . iterator ( ) . next ( ) ) ; log ( newestSource . toLongString ( ) + " is newest source" , Project . MSG_VERBOSE ) ; return oldestTarget . getLastModified ( ) >= newestSource . getLastModified ( ) ; } private void logFuture ( ResourceCollection rc , ResourceSelector rsel ) { Restrict r = new Restrict ( ) ; r . add ( rsel ) ; r . add ( rc ) ; for ( Iterator i = r . iterator ( ) ; i . hasNext ( ) ; ) { log ( "Warning: " + i . next ( ) + " modified in the future." , Project . MSG_WARN ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Vector ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . ResourceUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . FlatFileNameMapper ; public class Copy extends Task { static final File NULL_FILE_PLACEHOLDER = new File ( "/NULL_FILE" ) ; static final String LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector rcs = new Vector ( ) ; private boolean enableMultipleMappings = false ; protected boolean filtering = false ; protected boolean preserveLastModified = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; protected boolean failonerror = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; protected Hashtable completeDirMap = new Hashtable ( ) ; protected Mapper mapperElement = null ; protected FileUtils fileUtils ; private Vector filterChains = new Vector ( ) ; private Vector filterSets = new Vector ( ) ; private String inputEncoding = null ; private String outputEncoding = null ; private long granularity = 0 ; public Copy ( ) { fileUtils = FileUtils . getFileUtils ( ) ; granularity = fileUtils . getFileTimestampGranularity ( ) ; } protected FileUtils getFileUtils ( ) { return fileUtils ; } public void setFile ( File file ) { this . file = file ; } public void setTofile ( File destFile ) { this . destFile = destFile ; } public void setTodir ( File destDir ) { this . destDir = destDir ; } public FilterChain createFilterChain ( ) { FilterChain filterChain = new FilterChain ( ) ; filterChains . addElement ( filterChain ) ; return filterChain ; } public FilterSet createFilterSet ( ) { FilterSet filterSet = new FilterSet ( ) ; filterSets . addElement ( filterSet ) ; return filterSet ; } public void setPreserveLastModified ( String preserve ) { setPreserveLastModified ( Project . toBoolean ( preserve ) ) ; } public void setPreserveLastModified ( boolean preserve ) { preserveLastModified = preserve ; } public boolean getPreserveLastModified ( ) { return preserveLastModified ; } protected Vector getFilterSets ( ) { return filterSets ; } protected Vector getFilterChains ( ) { return filterChains ; } public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } public void setOverwrite ( boolean overwrite ) { this . forceOverwrite = overwrite ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setVerbose ( boolean verbose ) { this . verbosity = verbose ? Project . MSG_INFO : Project . MSG_VERBOSE ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void setEnableMultipleMappings ( boolean enableMultipleMappings ) { this . enableMultipleMappings = enableMultipleMappings ; } public boolean isEnableMultipleMapping ( ) { return enableMultipleMappings ; } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection res ) { rcs . add ( res ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public void setEncoding ( String encoding ) { this . inputEncoding = encoding ; if ( outputEncoding == null ) { outputEncoding = encoding ; } } public String getEncoding ( ) { return inputEncoding ; } public void setOutputEncoding ( String encoding ) { this . outputEncoding = encoding ; } public String getOutputEncoding ( ) { return outputEncoding ; } public void setGranularity ( long granularity ) { this . granularity = granularity ; } public void execute ( ) throws BuildException { File savedFile = file ; File savedDestFile = destFile ; File savedDestDir = destDir ; ResourceCollection savedRc = null ; if ( file == null && destFile != null && rcs . size ( ) == 1 ) { savedRc = ( ResourceCollection ) rcs . elementAt ( 0 ) ; } validateAttributes ( ) ; try { if ( file != null ) { if ( file . exists ( ) ) { if ( destFile == null ) { destFile = new File ( destDir , file . getName ( ) ) ; } if ( forceOverwrite || ! destFile . exists ( ) || ( file . lastModified ( ) - granularity > destFile . lastModified ( ) ) ) { fileCopyMap . put ( file . getAbsolutePath ( ) , new String [ ] { destFile . getAbsolutePath ( ) } ) ; } else { log ( file + " omitted as " + destFile + " is up to date." , Project . MSG_VERBOSE ) ; } } else { String message = "Warning: Could not find file " + file . getAbsolutePath ( ) + " to copy." ; if ( ! failonerror ) { log ( message , Project . MSG_ERR ) ; } else { throw new BuildException ( message ) ; } } } HashMap filesByBasedir = new HashMap ( ) ; HashMap dirsByBasedir = new HashMap ( ) ; HashSet baseDirs = new HashSet ( ) ; ArrayList nonFileResources = new ArrayList ( ) ; for ( int i = 0 ; i < rcs . size ( ) ; i ++ ) { ResourceCollection rc = ( ResourceCollection ) rcs . elementAt ( i ) ; if ( rc instanceof FileSet && rc . isFilesystemOnly ( ) ) { FileSet fs = ( FileSet ) rc ; DirectoryScanner ds = null ; try { ds = fs . getDirectoryScanner ( getProject ( ) ) ; } catch ( BuildException e ) { if ( failonerror || ! getMessage ( e ) . endsWith ( " not found." ) ) { throw e ; } else { log ( "Warning: " + getMessage ( e ) , Project . MSG_ERR ) ; continue ; } } File fromDir = fs . getDir ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; if ( ! flatten && mapperElement == null && ds . isEverythingIncluded ( ) && ! fs . hasPatterns ( ) ) { completeDirMap . put ( fromDir , destDir ) ; } add ( fromDir , srcFiles , filesByBasedir ) ; add ( fromDir , srcDirs , dirsByBasedir ) ; baseDirs . add ( fromDir ) ; } else { if ( ! rc . isFilesystemOnly ( ) && ! supportsNonFileResources ( ) ) { throw new BuildException ( "Only FileSystem resources are supported." ) ; } Iterator resources = rc . iterator ( ) ; while ( resources . hasNext ( ) ) { Resource r = ( Resource ) resources . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } File baseDir = NULL_FILE_PLACEHOLDER ; String name = r . getName ( ) ; if ( r instanceof FileResource ) { FileResource fr = ( FileResource ) r ; baseDir = getKeyFile ( fr . getBaseDir ( ) ) ; if ( fr . getBaseDir ( ) == null ) { name = fr . getFile ( ) . getAbsolutePath ( ) ; } } if ( r . isDirectory ( ) || r instanceof FileResource ) { add ( baseDir , name , r . isDirectory ( ) ? dirsByBasedir : filesByBasedir ) ; baseDirs . add ( baseDir ) ; } else { nonFileResources . add ( r ) ; } } } } Iterator iter = baseDirs . iterator ( ) ; while ( iter . hasNext ( ) ) { File f = ( File ) iter . next ( ) ; List files = ( List ) filesByBasedir . get ( f ) ; List dirs = ( List ) dirsByBasedir . get ( f ) ; String [ ] srcFiles = new String [ 0 ] ; if ( files != null ) { srcFiles = ( String [ ] ) files . toArray ( srcFiles ) ; } String [ ] srcDirs = new String [ 0 ] ; if ( dirs != null ) { srcDirs = ( String [ ] ) dirs . toArray ( srcDirs ) ; } scan ( f == NULL_FILE_PLACEHOLDER ? null : f , destDir , srcFiles , srcDirs ) ; } try { doFileOperations ( ) ; } catch ( BuildException e ) { if ( ! failonerror ) { log ( "Warning: " + getMessage ( e ) , Project . MSG_ERR ) ; } else { throw e ; } } if ( nonFileResources . size ( ) > 0 ) { Resource [ ] nonFiles = ( Resource [ ] ) nonFileResources . toArray ( new Resource [ nonFileResources . size ( ) ] ) ; Map map = scan ( nonFiles , destDir ) ; try { doResourceOperations ( map ) ; } catch ( BuildException e ) { if ( ! failonerror ) { log ( "Warning: " + getMessage ( e ) , Project . MSG_ERR ) ; } else { throw e ; } } } } finally { file = savedFile ; destFile = savedDestFile ; destDir = savedDestDir ; if ( savedRc != null ) { rcs . insertElementAt ( savedRc , 0 ) ; } fileCopyMap . clear ( ) ; dirCopyMap . clear ( ) ; completeDirMap . clear ( ) ; } } protected void validateAttributes ( ) throws BuildException { if ( file == null && rcs . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source--a file or a resource collection." ) ; } if ( destFile != null && destDir != null ) { throw new BuildException ( "Only one of tofile and todir may be set." ) ; } if ( destFile == null && destDir == null ) { throw new BuildException ( "One of tofile or todir must be set." ) ; } if ( file != null && file . isDirectory ( ) ) { throw new BuildException ( "Use a resource collection to copy directories." ) ; } if ( destFile != null && rcs . size ( ) > 0 ) { if ( rcs . size ( ) > 1 ) { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } else { ResourceCollection rc = ( ResourceCollection ) rcs . elementAt ( 0 ) ; if ( ! rc . isFilesystemOnly ( ) ) { throw new BuildException ( "Only FileSystem resources are" + " supported when concatenating" + " files." ) ; } if ( rc . size ( ) == 0 ) { throw new BuildException ( "Cannot perform operation from directory to file." ) ; } else if ( rc . size ( ) == 1 ) { FileResource r = ( FileResource ) rc . iterator ( ) . next ( ) ; if ( file == null ) { file = r . getFile ( ) ; rcs . removeElementAt ( 0 ) ; } else { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } } else { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } } } if ( destFile != null ) { destDir = destFile . getParentFile ( ) ; } } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { FileNameMapper mapper = getMapper ( ) ; buildMap ( fromDir , toDir , files , mapper , fileCopyMap ) ; if ( includeEmpty ) { buildMap ( fromDir , toDir , dirs , mapper , dirCopyMap ) ; } } protected Map scan ( Resource [ ] fromResources , File toDir ) { return buildMap ( fromResources , toDir , getMapper ( ) ) ; } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( mapper . mapFileName ( names [ i ] ) != null ) { v . addElement ( names [ i ] ) ; } } toCopy = new String [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { SourceFileScanner ds = new SourceFileScanner ( this ) ; toCopy = ds . restrict ( names , fromDir , toDir , mapper , granularity ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; String [ ] mappedFiles = mapper . mapFileName ( toCopy [ i ] ) ; if ( ! enableMultipleMappings ) { map . put ( src . getAbsolutePath ( ) , new String [ ] { new File ( toDir , mappedFiles [ 0 ] ) . getAbsolutePath ( ) } ) ; } else { for ( int k = 0 ; k < mappedFiles . length ; k ++ ) { mappedFiles [ k ] = new File ( toDir , mappedFiles [ k ] ) . getAbsolutePath ( ) ; } map . put ( src . getAbsolutePath ( ) , mappedFiles ) ; } } } protected Map buildMap ( Resource [ ] fromResources , final File toDir , FileNameMapper mapper ) { HashMap map = new HashMap ( ) ; Resource [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < fromResources . length ; i ++ ) { if ( mapper . mapFileName ( fromResources [ i ] . getName ( ) ) != null ) { v . addElement ( fromResources [ i ] ) ; } } toCopy = new Resource [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { toCopy = ResourceUtils . selectOutOfDateSources ( this , fromResources , mapper , new ResourceFactory ( ) { public Resource getResource ( String name ) { return new FileResource ( toDir , name ) ; } } , granularity ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { String [ ] mappedFiles = mapper . mapFileName ( toCopy [ i ] . getName ( ) ) ; if ( ! enableMultipleMappings ) { map . put ( toCopy [ i ] , new String [ ] { new File ( toDir , mappedFiles [ 0 ] ) . getAbsolutePath ( ) } ) ; } else { for ( int k = 0 ; k < mappedFiles . length ; k ++ ) { mappedFiles [ k ] = new File ( toDir , mappedFiles [ k ] ) . getAbsolutePath ( ) ; } map . put ( toCopy [ i ] , mappedFiles ) ; } } return map ; } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Copying " + fileCopyMap . size ( ) + " file" + ( fileCopyMap . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String [ ] toFiles = ( String [ ] ) fileCopyMap . get ( fromFile ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = toFiles [ i ] ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-copy of " + fromFile , verbosity ) ; continue ; } try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } fileUtils . copyFile ( fromFile , toFile , executionFilters , filterChains , forceOverwrite , preserveLastModified , inputEncoding , outputEncoding , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + getDueTo ( ioe ) ; File targetFile = new File ( toFile ) ; if ( targetFile . exists ( ) && ! targetFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + toFile ; } if ( failonerror ) { throw new BuildException ( msg , ioe , getLocation ( ) ) ; } log ( msg , Project . MSG_ERR ) ; } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int createCount = 0 ; while ( e . hasMoreElements ( ) ) { String [ ] dirs = ( String [ ] ) e . nextElement ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File d = new File ( dirs [ i ] ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { createCount ++ ; } } } } if ( createCount > 0 ) { log ( "Copied " + dirCopyMap . size ( ) + " empty director" + ( dirCopyMap . size ( ) == 1 ? "y" : "ies" ) + " to " + createCount + " empty director" + ( createCount == 1 ? "y" : "ies" ) + " under " + destDir . getAbsolutePath ( ) ) ; } } } protected void doResourceOperations ( Map map ) { if ( map . size ( ) > 0 ) { log ( "Copying " + map . size ( ) + " resource" + ( map . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Iterator iter = map . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource fromResource = ( Resource ) iter . next ( ) ; String [ ] toFiles = ( String [ ] ) map . get ( fromResource ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = toFiles [ i ] ; try { log ( "Copying " + fromResource + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } ResourceUtils . copyResource ( fromResource , new FileResource ( destDir , toFile ) , executionFilters , filterChains , forceOverwrite , preserveLastModified , inputEncoding , outputEncoding , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromResource + " to " + toFile + " due to " + getDueTo ( ioe ) ; File targetFile = new File ( toFile ) ; if ( targetFile . exists ( ) && ! targetFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + toFile ; } if ( failonerror ) { throw new BuildException ( msg , ioe , getLocation ( ) ) ; } log ( msg , Project . MSG_ERR ) ; } } } } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( Copy . class ) ; } private static void add ( File baseDir , String [ ] names , Map m ) { if ( names != null ) { baseDir = getKeyFile ( baseDir ) ; List l = ( List ) m . get ( baseDir ) ; if ( l == null ) { l = new ArrayList ( names . length ) ; m . put ( baseDir , l ) ; } l . addAll ( java . util . Arrays . asList ( names ) ) ; } } private static void add ( File baseDir , String name , Map m ) { if ( name != null ) { add ( baseDir , new String [ ] { name } , m ) ; } } private static File getKeyFile ( File f ) { return f == null ? NULL_FILE_PLACEHOLDER : f ; } private FileNameMapper getMapper ( ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else if ( flatten ) { mapper = new FlatFileNameMapper ( ) ; } else { mapper = new IdentityMapper ( ) ; } return mapper ; } private String getMessage ( Exception ex ) { return ex . getMessage ( ) == null ? ex . toString ( ) : ex . getMessage ( ) ; } private String getDueTo ( Exception ex ) { boolean baseIOException = ex . getClass ( ) == IOException . class ; StringBuffer message = new StringBuffer ( ) ; if ( ! baseIOException || ex . getMessage ( ) == null ) { message . append ( ex . getClass ( ) . getName ( ) ) ; } if ( ex . getMessage ( ) != null ) { if ( ! baseIOException ) { message . append ( " " ) ; } message . append ( ex . getMessage ( ) ) ; } if ( ex . getClass ( ) . getName ( ) . indexOf ( "MalformedInput" ) != - 1 ) { message . append ( LINE_SEPARATOR ) ; message . append ( "This is normally due to the input file containing invalid" ) ; message . append ( LINE_SEPARATOR ) ; message . append ( "bytes for the character encoding used : " ) ; message . append ( ( inputEncoding == null ? fileUtils . getDefaultEncoding ( ) : inputEncoding ) ) ; message . append ( LINE_SEPARATOR ) ; } return message . toString ( ) ; } } 	1
package org . apache . tools . ant . util ; import java . util . Vector ; import java . util . Iterator ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class CollectionUtils { public static boolean equals ( Vector v1 , Vector v2 ) { if ( v1 == v2 ) { return true ; } if ( v1 == null || v2 == null ) { return false ; } return v1 . equals ( v2 ) ; } public static boolean equals ( Dictionary d1 , Dictionary d2 ) { if ( d1 == d2 ) { return true ; } if ( d1 == null || d2 == null ) { return false ; } if ( d1 . size ( ) != d2 . size ( ) ) { return false ; } Enumeration e1 = d1 . keys ( ) ; while ( e1 . hasMoreElements ( ) ) { Object key = e1 . nextElement ( ) ; Object value1 = d1 . get ( key ) ; Object value2 = d2 . get ( key ) ; if ( value2 == null || ! value1 . equals ( value2 ) ) { return false ; } } return true ; } public static void putAll ( Dictionary m1 , Dictionary m2 ) { for ( Enumeration it = m2 . keys ( ) ; it . hasMoreElements ( ) ; ) { Object key = it . nextElement ( ) ; m1 . put ( key , m2 . get ( key ) ) ; } } public static final class EmptyEnumeration implements Enumeration { public EmptyEnumeration ( ) { } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) throws NoSuchElementException { throw new NoSuchElementException ( ) ; } } public static Enumeration append ( Enumeration e1 , Enumeration e2 ) { return new CompoundEnumeration ( e1 , e2 ) ; } public static Enumeration asEnumeration ( final Iterator iter ) { return new Enumeration ( ) { public boolean hasMoreElements ( ) { return iter . hasNext ( ) ; } public Object nextElement ( ) { return iter . next ( ) ; } } ; } public static Iterator asIterator ( final Enumeration e ) { return new Iterator ( ) { public boolean hasNext ( ) { return e . hasMoreElements ( ) ; } public Object next ( ) { return e . nextElement ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } private static final class CompoundEnumeration implements Enumeration { private final Enumeration e1 , e2 ; public CompoundEnumeration ( Enumeration e1 , Enumeration e2 ) { this . e1 = e1 ; this . e2 = e2 ; } public boolean hasMoreElements ( ) { return e1 . hasMoreElements ( ) || e2 . hasMoreElements ( ) ; } public Object nextElement ( ) throws NoSuchElementException { if ( e1 . hasMoreElements ( ) ) { return e1 . nextElement ( ) ; } else { return e2 . nextElement ( ) ; } } } } 	1
package org . apache . tools . ant ; import java . io . File ; import java . io . IOException ; import java . io . EOFException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import java . util . Set ; import java . util . HashSet ; import java . util . HashMap ; import java . util . Map ; import java . util . WeakHashMap ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . helper . DefaultExecutor ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Description ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . StringUtils ; public class Project implements ResourceFactory { private static final String LINE_SEP = System . getProperty ( "line.separator" ) ; public static final int MSG_ERR = 0 ; public static final int MSG_WARN = 1 ; public static final int MSG_INFO = 2 ; public static final int MSG_VERBOSE = 3 ; public static final int MSG_DEBUG = 4 ; private static final String VISITING = "VISITING" ; private static final String VISITED = "VISITED" ; public static final String JAVA_1_0 = JavaEnvUtils . JAVA_1_0 ; public static final String JAVA_1_1 = JavaEnvUtils . JAVA_1_1 ; public static final String JAVA_1_2 = JavaEnvUtils . JAVA_1_2 ; public static final String JAVA_1_3 = JavaEnvUtils . JAVA_1_3 ; public static final String JAVA_1_4 = JavaEnvUtils . JAVA_1_4 ; public static final String TOKEN_START = FilterSet . DEFAULT_TOKEN_START ; public static final String TOKEN_END = FilterSet . DEFAULT_TOKEN_END ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String name ; private String description ; private Hashtable references = new AntRefTable ( ) ; private HashMap idReferences = new HashMap ( ) ; private Project parentIdProject = null ; private String defaultTarget ; private Hashtable targets = new Hashtable ( ) ; private FilterSet globalFilterSet = new FilterSet ( ) ; { globalFilterSet . setProject ( this ) ; } private FilterSetCollection globalFilters = new FilterSetCollection ( globalFilterSet ) ; private File baseDir ; private Vector listeners = new Vector ( ) ; private ClassLoader coreLoader = null ; private Map threadTasks = Collections . synchronizedMap ( new WeakHashMap ( ) ) ; private Map threadGroupTasks = Collections . synchronizedMap ( new WeakHashMap ( ) ) ; private InputHandler inputHandler = null ; private InputStream defaultInputStream = null ; private boolean keepGoingMode = false ; private boolean loggingMessage = false ; public void setInputHandler ( InputHandler handler ) { inputHandler = handler ; } public void setDefaultInputStream ( InputStream defaultInputStream ) { this . defaultInputStream = defaultInputStream ; } public InputStream getDefaultInputStream ( ) { return defaultInputStream ; } public InputHandler getInputHandler ( ) { return inputHandler ; } public Project ( ) { inputHandler = new DefaultInputHandler ( ) ; } public Project createSubProject ( ) { Project subProject = null ; try { subProject = ( Project ) ( getClass ( ) . newInstance ( ) ) ; } catch ( Exception e ) { subProject = new Project ( ) ; } initSubProject ( subProject ) ; return subProject ; } public void initSubProject ( Project subProject ) { ComponentHelper . getComponentHelper ( subProject ) . initSubProject ( ComponentHelper . getComponentHelper ( this ) ) ; subProject . setDefaultInputStream ( getDefaultInputStream ( ) ) ; subProject . setKeepGoingMode ( this . isKeepGoingMode ( ) ) ; subProject . setExecutor ( getExecutor ( ) . getSubProjectExecutor ( ) ) ; } public void init ( ) throws BuildException { initProperties ( ) ; ComponentHelper . getComponentHelper ( this ) . initDefaultDefinitions ( ) ; } public void initProperties ( ) throws BuildException { setJavaVersionProperty ( ) ; setSystemProperties ( ) ; setPropertyInternal ( MagicNames . ANT_VERSION , Main . getAntVersion ( ) ) ; setAntLib ( ) ; } private void setAntLib ( ) { File antlib = org . apache . tools . ant . launch . Locator . getClassSource ( Project . class ) ; if ( antlib != null ) { setPropertyInternal ( MagicNames . ANT_LIB , antlib . getAbsolutePath ( ) ) ; } } public AntClassLoader createClassLoader ( Path path ) { return new AntClassLoader ( getClass ( ) . getClassLoader ( ) , this , path ) ; } public AntClassLoader createClassLoader ( ClassLoader parent , Path path ) { return new AntClassLoader ( parent , this , path ) ; } public void setCoreLoader ( ClassLoader coreLoader ) { this . coreLoader = coreLoader ; } public ClassLoader getCoreLoader ( ) { return coreLoader ; } public synchronized void addBuildListener ( BuildListener listener ) { if ( listeners . contains ( listener ) ) { return ; } Vector newListeners = getBuildListeners ( ) ; newListeners . addElement ( listener ) ; listeners = newListeners ; } public synchronized void removeBuildListener ( BuildListener listener ) { Vector newListeners = getBuildListeners ( ) ; newListeners . removeElement ( listener ) ; listeners = newListeners ; } public Vector getBuildListeners ( ) { return ( Vector ) listeners . clone ( ) ; } public void log ( String message ) { log ( message , MSG_INFO ) ; } public void log ( String message , int msgLevel ) { log ( message , null , msgLevel ) ; } public void log ( String message , Throwable throwable , int msgLevel ) { fireMessageLogged ( this , message , throwable , msgLevel ) ; } public void log ( Task task , String message , int msgLevel ) { fireMessageLogged ( task , message , null , msgLevel ) ; } public void log ( Task task , String message , Throwable throwable , int msgLevel ) { fireMessageLogged ( task , message , throwable , msgLevel ) ; } public void log ( Target target , String message , int msgLevel ) { log ( target , message , null , msgLevel ) ; } public void log ( Target target , String message , Throwable throwable , int msgLevel ) { fireMessageLogged ( target , message , throwable , msgLevel ) ; } public FilterSet getGlobalFilterSet ( ) { return globalFilterSet ; } public void setProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setProperty ( null , name , value , true ) ; } public void setNewProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setNewProperty ( null , name , value ) ; } public void setUserProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setUserProperty ( null , name , value ) ; } public void setInheritedProperty ( String name , String value ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . setInheritedProperty ( null , name , value ) ; } private void setPropertyInternal ( String name , String value ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . setProperty ( null , name , value , false ) ; } public String getProperty ( String propertyName ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ( String ) ph . getProperty ( null , propertyName ) ; } public String replaceProperties ( String value ) throws BuildException { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . replaceProperties ( null , value , null ) ; } public String getUserProperty ( String propertyName ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ( String ) ph . getUserProperty ( null , propertyName ) ; } public Hashtable getProperties ( ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . getProperties ( ) ; } public Hashtable getUserProperties ( ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . getUserProperties ( ) ; } public void copyUserProperties ( Project other ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . copyUserProperties ( other ) ; } public void copyInheritedProperties ( Project other ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . copyInheritedProperties ( other ) ; } public void setDefaultTarget ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public String getDefaultTarget ( ) { return defaultTarget ; } public void setDefault ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public void setName ( String name ) { setUserProperty ( "ant.project.name" , name ) ; this . name = name ; } public String getName ( ) { return name ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { if ( description == null ) { description = Description . getDescription ( this ) ; } return description ; } public void addFilter ( String token , String value ) { if ( token == null ) { return ; } globalFilterSet . addFilter ( new FilterSet . Filter ( token , value ) ) ; } public Hashtable getFilters ( ) { return globalFilterSet . getFilterHash ( ) ; } public void setBasedir ( String baseD ) throws BuildException { setBaseDir ( new File ( baseD ) ) ; } public void setBaseDir ( File baseDir ) throws BuildException { baseDir = FILE_UTILS . normalize ( baseDir . getAbsolutePath ( ) ) ; if ( ! baseDir . exists ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " does not exist" ) ; } if ( ! baseDir . isDirectory ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " is not a directory" ) ; } this . baseDir = baseDir ; setPropertyInternal ( MagicNames . PROJECT_BASEDIR , this . baseDir . getPath ( ) ) ; String msg = "Project base dir set to: " + this . baseDir ; log ( msg , MSG_VERBOSE ) ; } public File getBaseDir ( ) { if ( baseDir == null ) { try { setBasedir ( "." ) ; } catch ( BuildException ex ) { ex . printStackTrace ( ) ; } } return baseDir ; } public void setKeepGoingMode ( boolean keepGoingMode ) { this . keepGoingMode = keepGoingMode ; } public boolean isKeepGoingMode ( ) { return this . keepGoingMode ; } public static String getJavaVersion ( ) { return JavaEnvUtils . getJavaVersion ( ) ; } public void setJavaVersionProperty ( ) throws BuildException { String javaVersion = JavaEnvUtils . getJavaVersion ( ) ; setPropertyInternal ( MagicNames . ANT_JAVA_VERSION , javaVersion ) ; if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) || JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { throw new BuildException ( "Ant cannot work on Java 1.0 / 1.1" ) ; } log ( "Detected Java version: " + javaVersion + " in: " + System . getProperty ( "java.home" ) , MSG_VERBOSE ) ; log ( "Detected OS: " + System . getProperty ( "os.name" ) , MSG_VERBOSE ) ; } public void setSystemProperties ( ) { Properties systemP = System . getProperties ( ) ; Enumeration e = systemP . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String propertyName = ( String ) e . nextElement ( ) ; String value = systemP . getProperty ( propertyName ) ; this . setPropertyInternal ( propertyName , value ) ; } } public void addTaskDefinition ( String taskName , Class taskClass ) throws BuildException { ComponentHelper . getComponentHelper ( this ) . addTaskDefinition ( taskName , taskClass ) ; } public void checkTaskClass ( final Class taskClass ) throws BuildException { ComponentHelper . getComponentHelper ( this ) . checkTaskClass ( taskClass ) ; if ( ! Modifier . isPublic ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is not public" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( Modifier . isAbstract ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is abstract" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } try { taskClass . getConstructor ( ( Class [ ] ) null ) ; } catch ( NoSuchMethodException e ) { final String message = "No public no-arg constructor in " + taskClass ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } catch ( LinkageError e ) { String message = "Could not load " + taskClass + ": " + e ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message , e ) ; } if ( ! Task . class . isAssignableFrom ( taskClass ) ) { TaskAdapter . checkTaskClass ( taskClass , this ) ; } } public Hashtable getTaskDefinitions ( ) { return ComponentHelper . getComponentHelper ( this ) . getTaskDefinitions ( ) ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { ComponentHelper . getComponentHelper ( this ) . addDataTypeDefinition ( typeName , typeClass ) ; } public Hashtable getDataTypeDefinitions ( ) { return ComponentHelper . getComponentHelper ( this ) . getDataTypeDefinitions ( ) ; } public void addTarget ( Target target ) throws BuildException { addTarget ( target . getName ( ) , target ) ; } public void addTarget ( String targetName , Target target ) throws BuildException { if ( targets . get ( targetName ) != null ) { throw new BuildException ( "Duplicate target: `" + targetName + "'" ) ; } addOrReplaceTarget ( targetName , target ) ; } public void addOrReplaceTarget ( Target target ) { addOrReplaceTarget ( target . getName ( ) , target ) ; } public void addOrReplaceTarget ( String targetName , Target target ) { String msg = " +Target: " + targetName ; log ( msg , MSG_DEBUG ) ; target . setProject ( this ) ; targets . put ( targetName , target ) ; } public Hashtable getTargets ( ) { return targets ; } public Task createTask ( String taskType ) throws BuildException { return ComponentHelper . getComponentHelper ( this ) . createTask ( taskType ) ; } public Object createDataType ( String typeName ) throws BuildException { return ComponentHelper . getComponentHelper ( this ) . createDataType ( typeName ) ; } public void setExecutor ( Executor e ) { addReference ( MagicNames . ANT_EXECUTOR_REFERENCE , e ) ; } public Executor getExecutor ( ) { Object o = getReference ( MagicNames . ANT_EXECUTOR_REFERENCE ) ; if ( o == null ) { String classname = getProperty ( MagicNames . ANT_EXECUTOR_CLASSNAME ) ; if ( classname == null ) { classname = DefaultExecutor . class . getName ( ) ; } log ( "Attempting to create object of type " + classname , MSG_DEBUG ) ; try { o = Class . forName ( classname , true , coreLoader ) . newInstance ( ) ; } catch ( ClassNotFoundException seaEnEfEx ) { try { o = Class . forName ( classname ) . newInstance ( ) ; } catch ( Exception ex ) { log ( ex . toString ( ) , MSG_ERR ) ; } } catch ( Exception ex ) { log ( ex . toString ( ) , MSG_ERR ) ; } if ( o == null ) { throw new BuildException ( "Unable to obtain a Target Executor instance." ) ; } setExecutor ( ( Executor ) o ) ; } return ( Executor ) o ; } public void executeTargets ( Vector names ) throws BuildException { getExecutor ( ) . executeTargets ( this , ( String [ ] ) ( names . toArray ( new String [ names . size ( ) ] ) ) ) ; } public void demuxOutput ( String output , boolean isWarning ) { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { log ( output , isWarning ? MSG_WARN : MSG_INFO ) ; } else { if ( isWarning ) { task . handleErrorOutput ( output ) ; } else { task . handleOutput ( output ) ; } } } public int defaultInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( defaultInputStream != null ) { System . out . flush ( ) ; return defaultInputStream . read ( buffer , offset , length ) ; } else { throw new EOFException ( "No input provided for project" ) ; } } public int demuxInput ( byte [ ] buffer , int offset , int length ) throws IOException { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { return defaultInput ( buffer , offset , length ) ; } else { return task . handleInput ( buffer , offset , length ) ; } } public void demuxFlush ( String output , boolean isError ) { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { fireMessageLogged ( this , output , isError ? MSG_ERR : MSG_INFO ) ; } else { if ( isError ) { task . handleErrorFlush ( output ) ; } else { task . handleFlush ( output ) ; } } } public void executeTarget ( String targetName ) throws BuildException { if ( targetName == null ) { String msg = "No target specified" ; throw new BuildException ( msg ) ; } executeSortedTargets ( topoSort ( targetName , targets , false ) ) ; } public void executeSortedTargets ( Vector sortedTargets ) throws BuildException { Set succeededTargets = new HashSet ( ) ; BuildException buildException = null ; for ( Enumeration iter = sortedTargets . elements ( ) ; iter . hasMoreElements ( ) ; ) { Target curtarget = ( Target ) iter . nextElement ( ) ; boolean canExecute = true ; for ( Enumeration depIter = curtarget . getDependencies ( ) ; depIter . hasMoreElements ( ) ; ) { String dependencyName = ( ( String ) depIter . nextElement ( ) ) ; if ( ! succeededTargets . contains ( dependencyName ) ) { canExecute = false ; log ( curtarget , "Cannot execute '" + curtarget . getName ( ) + "' - '" + dependencyName + "' failed or was not executed." , MSG_ERR ) ; break ; } } if ( canExecute ) { Throwable thrownException = null ; try { curtarget . performTasks ( ) ; succeededTargets . add ( curtarget . getName ( ) ) ; } catch ( RuntimeException ex ) { if ( ! ( keepGoingMode ) ) { throw ex ; } thrownException = ex ; } catch ( Throwable ex ) { if ( ! ( keepGoingMode ) ) { throw new BuildException ( ex ) ; } thrownException = ex ; } if ( thrownException != null ) { if ( thrownException instanceof BuildException ) { log ( curtarget , "Target '" + curtarget . getName ( ) + "' failed with message '" + thrownException . getMessage ( ) + "'." , MSG_ERR ) ; if ( buildException == null ) { buildException = ( BuildException ) thrownException ; } } else { log ( curtarget , "Target '" + curtarget . getName ( ) + "' failed with message '" + thrownException . getMessage ( ) + "'." , MSG_ERR ) ; thrownException . printStackTrace ( System . err ) ; if ( buildException == null ) { buildException = new BuildException ( thrownException ) ; } } } } } if ( buildException != null ) { throw buildException ; } } public File resolveFile ( String fileName , File rootDir ) { return FILE_UTILS . resolveFile ( rootDir , fileName ) ; } public File resolveFile ( String fileName ) { return FILE_UTILS . resolveFile ( baseDir , fileName ) ; } public static String translatePath ( String toProcess ) { return FileUtils . translatePath ( toProcess ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void setFileLastModified ( File file , long time ) throws BuildException { FILE_UTILS . setFileLastModified ( file , time ) ; log ( "Setting modification time for " + file , MSG_VERBOSE ) ; } public static boolean toBoolean ( String s ) { return ( "on" . equalsIgnoreCase ( s ) || "true" . equalsIgnoreCase ( s ) || "yes" . equalsIgnoreCase ( s ) ) ; } public final Vector topoSort ( String root , Hashtable targetTable ) throws BuildException { return topoSort ( new String [ ] { root } , targetTable , true ) ; } public final Vector topoSort ( String root , Hashtable targetTable , boolean returnAll ) throws BuildException { return topoSort ( new String [ ] { root } , targetTable , returnAll ) ; } public final Vector topoSort ( String [ ] root , Hashtable targetTable , boolean returnAll ) throws BuildException { Vector ret = new Vector ( ) ; Hashtable state = new Hashtable ( ) ; Stack visiting = new Stack ( ) ; for ( int i = 0 ; i < root . length ; i ++ ) { String st = ( String ) ( state . get ( root [ i ] ) ) ; if ( st == null ) { tsort ( root [ i ] , targetTable , state , visiting , ret ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + root [ i ] ) ; } } StringBuffer buf = new StringBuffer ( "Build sequence for target(s)" ) ; for ( int j = 0 ; j < root . length ; j ++ ) { buf . append ( ( j == 0 ) ? " `" : ", `" ) . append ( root [ j ] ) . append ( '\'' ) ; } buf . append ( " is " + ret ) ; log ( buf . toString ( ) , MSG_VERBOSE ) ; Vector complete = ( returnAll ) ? ret : new Vector ( ret ) ; for ( Enumeration en = targetTable . keys ( ) ; en . hasMoreElements ( ) ; ) { String curTarget = ( String ) en . nextElement ( ) ; String st = ( String ) state . get ( curTarget ) ; if ( st == null ) { tsort ( curTarget , targetTable , state , visiting , complete ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + curTarget ) ; } } log ( "Complete build sequence is " + complete , MSG_VERBOSE ) ; return ret ; } private void tsort ( String root , Hashtable targetTable , Hashtable state , Stack visiting , Vector ret ) throws BuildException { state . put ( root , VISITING ) ; visiting . push ( root ) ; Target target = ( Target ) targetTable . get ( root ) ; if ( target == null ) { StringBuffer sb = new StringBuffer ( "Target \"" ) ; sb . append ( root ) ; sb . append ( "\" does not exist in the project \"" ) ; sb . append ( name ) ; sb . append ( "\". " ) ; visiting . pop ( ) ; if ( ! visiting . empty ( ) ) { String parent = ( String ) visiting . peek ( ) ; sb . append ( "It is used from target \"" ) ; sb . append ( parent ) ; sb . append ( "\"." ) ; } throw new BuildException ( new String ( sb ) ) ; } for ( Enumeration en = target . getDependencies ( ) ; en . hasMoreElements ( ) ; ) { String cur = ( String ) en . nextElement ( ) ; String m = ( String ) state . get ( cur ) ; if ( m == null ) { tsort ( cur , targetTable , state , visiting , ret ) ; } else if ( m == VISITING ) { throw makeCircularException ( cur , visiting ) ; } } String p = ( String ) visiting . pop ( ) ; if ( root != p ) { throw new RuntimeException ( "Unexpected internal error: expected to " + "pop " + root + " but got " + p ) ; } state . put ( root , VISITED ) ; ret . addElement ( target ) ; } private static BuildException makeCircularException ( String end , Stack stk ) { StringBuffer sb = new StringBuffer ( "Circular dependency: " ) ; sb . append ( end ) ; String c ; do { c = ( String ) stk . pop ( ) ; sb . append ( " <- " ) ; sb . append ( c ) ; } while ( ! c . equals ( end ) ) ; return new BuildException ( new String ( sb ) ) ; } public void inheritIDReferences ( Project parent ) { parentIdProject = parent ; } private Object resolveIdReference ( String key , Project callerProject ) { UnknownElement origUE = ( UnknownElement ) idReferences . get ( key ) ; if ( origUE == null ) { return parentIdProject == null ? null : parentIdProject . resolveIdReference ( key , callerProject ) ; } callerProject . log ( "Warning: Reference " + key + " has not been set at runtime," + " but was found during" + LINE_SEP + "build file parsing, attempting to resolve." + " Future versions of Ant may support" + LINE_SEP + " referencing ids defined in non-executed targets." , MSG_WARN ) ; UnknownElement copyUE = origUE . copy ( callerProject ) ; copyUE . maybeConfigure ( ) ; return copyUE . getRealThing ( ) ; } public void addIdReference ( String id , Object value ) { idReferences . put ( id , value ) ; } public void addReference ( String referenceName , Object value ) { synchronized ( references ) { Object old = ( ( AntRefTable ) references ) . getReal ( referenceName ) ; if ( old == value ) { return ; } if ( old != null && ! ( old instanceof UnknownElement ) ) { log ( "Overriding previous definition of reference to " + referenceName , MSG_VERBOSE ) ; } log ( "Adding reference: " + referenceName , MSG_DEBUG ) ; references . put ( referenceName , value ) ; } } public Hashtable getReferences ( ) { return references ; } public Object getReference ( String key ) { Object ret = references . get ( key ) ; if ( ret != null ) { return ret ; } ret = resolveIdReference ( key , this ) ; if ( ret == null && ! key . equals ( MagicNames . REFID_PROPERTY_HELPER ) ) { Vector p = new Vector ( ) ; PropertyHelper . getPropertyHelper ( this ) . parsePropertyString ( key , new Vector ( ) , p ) ; if ( p . size ( ) == 1 ) { log ( "Unresolvable reference " + key + " might be a misuse of property expansion syntax." , MSG_WARN ) ; } } return ret ; } public String getElementName ( Object element ) { return ComponentHelper . getComponentHelper ( this ) . getElementName ( element ) ; } public void fireBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . buildStarted ( event ) ; } } public void fireBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . buildFinished ( event ) ; } IntrospectionHelper . clearCache ( ) ; } public void fireSubBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { Object listener = iter . next ( ) ; if ( listener instanceof SubBuildListener ) { ( ( SubBuildListener ) listener ) . subBuildStarted ( event ) ; } } } public void fireSubBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { Object listener = iter . next ( ) ; if ( listener instanceof SubBuildListener ) { ( ( SubBuildListener ) listener ) . subBuildFinished ( event ) ; } } } protected void fireTargetStarted ( Target target ) { BuildEvent event = new BuildEvent ( target ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . targetStarted ( event ) ; } } protected void fireTargetFinished ( Target target , Throwable exception ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . targetFinished ( event ) ; } } protected void fireTaskStarted ( Task task ) { registerThreadTask ( Thread . currentThread ( ) , task ) ; BuildEvent event = new BuildEvent ( task ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . taskStarted ( event ) ; } } protected void fireTaskFinished ( Task task , Throwable exception ) { registerThreadTask ( Thread . currentThread ( ) , null ) ; System . out . flush ( ) ; System . err . flush ( ) ; BuildEvent event = new BuildEvent ( task ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . taskFinished ( event ) ; } } private void fireMessageLoggedEvent ( BuildEvent event , String message , int priority ) { if ( message . endsWith ( StringUtils . LINE_SEP ) ) { int endIndex = message . length ( ) - StringUtils . LINE_SEP . length ( ) ; event . setMessage ( message . substring ( 0 , endIndex ) , priority ) ; } else { event . setMessage ( message , priority ) ; } synchronized ( this ) { if ( loggingMessage ) { return ; } try { loggingMessage = true ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . messageLogged ( event ) ; } } finally { loggingMessage = false ; } } } protected void fireMessageLogged ( Project project , String message , int priority ) { fireMessageLogged ( project , message , null , priority ) ; } protected void fireMessageLogged ( Project project , String message , Throwable throwable , int priority ) { BuildEvent event = new BuildEvent ( project ) ; event . setException ( throwable ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Target target , String message , int priority ) { fireMessageLogged ( target , message , null , priority ) ; } protected void fireMessageLogged ( Target target , String message , Throwable throwable , int priority ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( throwable ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Task task , String message , int priority ) { fireMessageLogged ( task , message , null , priority ) ; } protected void fireMessageLogged ( Task task , String message , Throwable throwable , int priority ) { BuildEvent event = new BuildEvent ( task ) ; event . setException ( throwable ) ; fireMessageLoggedEvent ( event , message , priority ) ; } public synchronized void registerThreadTask ( Thread thread , Task task ) { if ( task != null ) { threadTasks . put ( thread , task ) ; threadGroupTasks . put ( thread . getThreadGroup ( ) , task ) ; } else { threadTasks . remove ( thread ) ; threadGroupTasks . remove ( thread . getThreadGroup ( ) ) ; } } public Task getThreadTask ( Thread thread ) { Task task = ( Task ) threadTasks . get ( thread ) ; if ( task == null ) { ThreadGroup group = thread . getThreadGroup ( ) ; while ( task == null && group != null ) { task = ( Task ) threadGroupTasks . get ( group ) ; group = group . getParent ( ) ; } } return task ; } private static class AntRefTable extends Hashtable { AntRefTable ( ) { super ( ) ; } private Object getReal ( Object key ) { return super . get ( key ) ; } public Object get ( Object key ) { Object o = getReal ( key ) ; if ( o instanceof UnknownElement ) { UnknownElement ue = ( UnknownElement ) o ; ue . maybeConfigure ( ) ; o = ue . getRealThing ( ) ; } return o ; } } public final void setProjectReference ( final Object obj ) { if ( obj instanceof ProjectComponent ) { ( ( ProjectComponent ) obj ) . setProject ( this ) ; return ; } try { Method method = obj . getClass ( ) . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( method != null ) { method . invoke ( obj , new Object [ ] { this } ) ; } } catch ( Throwable e ) { } } public Resource getResource ( String name ) { return new FileResource ( getBaseDir ( ) , name ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Replace extends MatchingTask { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File src = null ; private NestedString token = null ; private NestedString value = new NestedString ( ) ; private File propertyFile = null ; private File replaceFilterFile = null ; private Properties properties = null ; private Vector replacefilters = new Vector ( ) ; private File dir = null ; private int fileCount ; private int replaceCount ; private boolean summary = false ; private String encoding = null ; public class NestedString { private StringBuffer buf = new StringBuffer ( ) ; public void addText ( String val ) { buf . append ( val ) ; } public String getText ( ) { return buf . toString ( ) ; } } public class Replacefilter { private String token ; private String value ; private String replaceValue ; private String property ; private StringBuffer inputBuffer ; private StringBuffer outputBuffer = new StringBuffer ( ) ; public void validate ( ) throws BuildException { if ( token == null ) { String message = "token is a mandatory attribute " + "of replacefilter." ; throw new BuildException ( message ) ; } if ( "" . equals ( token ) ) { String message = "The token attribute must not be an empty " + "string." ; throw new BuildException ( message ) ; } if ( ( value != null ) && ( property != null ) ) { String message = "Either value or property " + "can be specified, but a replacefilter " + "element cannot have both." ; throw new BuildException ( message ) ; } if ( ( property != null ) ) { if ( propertyFile == null ) { String message = "The replacefilter's property attribute " + "can only be used with the replacetask's " + "propertyFile attribute." ; throw new BuildException ( message ) ; } if ( properties == null || properties . getProperty ( property ) == null ) { String message = "property \"" + property + "\" was not found in " + propertyFile . getPath ( ) ; throw new BuildException ( message ) ; } } replaceValue = getReplaceValue ( ) ; } public String getReplaceValue ( ) { if ( property != null ) { return properties . getProperty ( property ) ; } else if ( value != null ) { return value ; } else if ( Replace . this . value != null ) { return Replace . this . value . getText ( ) ; } else { return "" ; } } public void setToken ( String token ) { this . token = token ; } public String getToken ( ) { return token ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setProperty ( String property ) { this . property = property ; } public String getProperty ( ) { return property ; } StringBuffer getOutputBuffer ( ) { return outputBuffer ; } void setInputBuffer ( StringBuffer input ) { inputBuffer = input ; } boolean process ( ) { if ( inputBuffer . length ( ) > token . length ( ) ) { int pos = replace ( ) ; pos = Math . max ( ( inputBuffer . length ( ) - token . length ( ) ) , pos ) ; outputBuffer . append ( inputBuffer . substring ( 0 , pos ) ) ; inputBuffer . delete ( 0 , pos ) ; return true ; } return false ; } void flush ( ) { replace ( ) ; outputBuffer . append ( inputBuffer . toString ( ) ) ; inputBuffer . delete ( 0 , inputBuffer . length ( ) ) ; } private int replace ( ) { int found = inputBuffer . toString ( ) . indexOf ( token ) ; int pos = - 1 ; while ( found >= 0 ) { inputBuffer . replace ( found , found + token . length ( ) , replaceValue ) ; pos = found + replaceValue . length ( ) ; found = inputBuffer . toString ( ) . indexOf ( token , pos ) ; ++ replaceCount ; } return pos ; } } private class FileInput { private StringBuffer outputBuffer ; private Reader reader ; private char [ ] buffer ; private static final int BUFF_SIZE = 4096 ; FileInput ( File source ) throws IOException { outputBuffer = new StringBuffer ( ) ; buffer = new char [ BUFF_SIZE ] ; if ( encoding == null ) { reader = new BufferedReader ( new FileReader ( source ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( source ) , encoding ) ) ; } } StringBuffer getOutputBuffer ( ) { return outputBuffer ; } boolean readChunk ( ) throws IOException { int bufferLength = 0 ; bufferLength = reader . read ( buffer ) ; if ( bufferLength < 0 ) { return false ; } outputBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; return true ; } void close ( ) throws IOException { reader . close ( ) ; } void closeQuietly ( ) { FileUtils . close ( reader ) ; } } private class FileOutput { private StringBuffer inputBuffer ; private Writer writer ; FileOutput ( File out ) throws IOException { if ( encoding == null ) { writer = new BufferedWriter ( new FileWriter ( out ) ) ; } else { writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( out ) , encoding ) ) ; } } void setInputBuffer ( StringBuffer input ) { inputBuffer = input ; } boolean process ( ) throws IOException { writer . write ( inputBuffer . toString ( ) ) ; inputBuffer . delete ( 0 , inputBuffer . length ( ) ) ; return false ; } void flush ( ) throws IOException { process ( ) ; writer . flush ( ) ; } void close ( ) throws IOException { writer . close ( ) ; } void closeQuietly ( ) { FileUtils . close ( writer ) ; } } public void execute ( ) throws BuildException { Vector savedFilters = ( Vector ) replacefilters . clone ( ) ; Properties savedProperties = properties == null ? null : ( Properties ) properties . clone ( ) ; if ( token != null ) { StringBuffer val = new StringBuffer ( value . getText ( ) ) ; stringReplace ( val , "\r\n" , "\n" ) ; stringReplace ( val , "\n" , StringUtils . LINE_SEP ) ; StringBuffer tok = new StringBuffer ( token . getText ( ) ) ; stringReplace ( tok , "\r\n" , "\n" ) ; stringReplace ( tok , "\n" , StringUtils . LINE_SEP ) ; Replacefilter firstFilter = createPrimaryfilter ( ) ; firstFilter . setToken ( tok . toString ( ) ) ; firstFilter . setValue ( val . toString ( ) ) ; } try { if ( replaceFilterFile != null ) { Properties props = getProperties ( replaceFilterFile ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String tok = e . nextElement ( ) . toString ( ) ; Replacefilter replaceFilter = createReplacefilter ( ) ; replaceFilter . setToken ( tok ) ; replaceFilter . setValue ( props . getProperty ( tok ) ) ; } } validateAttributes ( ) ; if ( propertyFile != null ) { properties = getProperties ( propertyFile ) ; } validateReplacefilters ( ) ; fileCount = 0 ; replaceCount = 0 ; if ( src != null ) { processFile ( src ) ; } if ( dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] srcs = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < srcs . length ; i ++ ) { File file = new File ( dir , srcs [ i ] ) ; processFile ( file ) ; } } if ( summary ) { log ( "Replaced " + replaceCount + " occurrences in " + fileCount + " files." , Project . MSG_INFO ) ; } } finally { replacefilters = savedFilters ; properties = savedProperties ; } } public void validateAttributes ( ) throws BuildException { if ( src == null && dir == null ) { String message = "Either the file or the dir attribute " + "must be specified" ; throw new BuildException ( message , getLocation ( ) ) ; } if ( propertyFile != null && ! propertyFile . exists ( ) ) { String message = "Property file " + propertyFile . getPath ( ) + " does not exist." ; throw new BuildException ( message , getLocation ( ) ) ; } if ( token == null && replacefilters . size ( ) == 0 ) { String message = "Either token or a nested replacefilter " + "must be specified" ; throw new BuildException ( message , getLocation ( ) ) ; } if ( token != null && "" . equals ( token . getText ( ) ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message , getLocation ( ) ) ; } } public void validateReplacefilters ( ) throws BuildException { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter element = ( Replacefilter ) replacefilters . elementAt ( i ) ; element . validate ( ) ; } } public Properties getProperties ( File propertyFile ) throws BuildException { Properties props = new Properties ( ) ; FileInputStream in = null ; try { in = new FileInputStream ( propertyFile ) ; props . load ( in ) ; } catch ( FileNotFoundException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") not found." ; throw new BuildException ( message ) ; } catch ( IOException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") cannot be loaded." ; throw new BuildException ( message ) ; } finally { FileUtils . close ( in ) ; } return props ; } private void processFile ( File src ) throws BuildException { if ( ! src . exists ( ) ) { throw new BuildException ( "Replace: source file " + src . getPath ( ) + " doesn't exist" , getLocation ( ) ) ; } File temp = null ; FileInput in = null ; FileOutput out = null ; try { in = new FileInput ( src ) ; temp = FILE_UTILS . createTempFile ( "rep" , ".tmp" , src . getParentFile ( ) ) ; out = new FileOutput ( temp ) ; int repCountStart = replaceCount ; logFilterChain ( src . getPath ( ) ) ; out . setInputBuffer ( buildFilterChain ( in . getOutputBuffer ( ) ) ) ; while ( in . readChunk ( ) ) { if ( processFilterChain ( ) ) { out . process ( ) ; } } flushFilterChain ( ) ; out . flush ( ) ; in . close ( ) ; in = null ; out . close ( ) ; out = null ; boolean changes = ( replaceCount != repCountStart ) ; if ( changes ) { FILE_UTILS . rename ( temp , src ) ; temp = null ; } } catch ( IOException ioe ) { throw new BuildException ( "IOException in " + src + " - " + ioe . getClass ( ) . getName ( ) + ":" + ioe . getMessage ( ) , ioe , getLocation ( ) ) ; } finally { if ( null != in ) { in . closeQuietly ( ) ; } if ( null != out ) { out . closeQuietly ( ) ; } if ( temp != null ) { if ( ! temp . delete ( ) ) { temp . deleteOnExit ( ) ; } } } } private void flushFilterChain ( ) { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; filter . flush ( ) ; } } private boolean processFilterChain ( ) { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; if ( ! filter . process ( ) ) { return false ; } } return true ; } private StringBuffer buildFilterChain ( StringBuffer inputBuffer ) { StringBuffer buf = inputBuffer ; for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; filter . setInputBuffer ( buf ) ; buf = filter . getOutputBuffer ( ) ; } return buf ; } private void logFilterChain ( String filename ) { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; log ( "Replacing in " + filename + ": " + filter . getToken ( ) + " --> " + filter . getReplaceValue ( ) , Project . MSG_VERBOSE ) ; } } public void setFile ( File file ) { this . src = file ; } public void setSummary ( boolean summary ) { this . summary = summary ; } public void setReplaceFilterFile ( File replaceFilterFile ) { this . replaceFilterFile = replaceFilterFile ; } public void setDir ( File dir ) { this . dir = dir ; } public void setToken ( String token ) { createReplaceToken ( ) . addText ( token ) ; } public void setValue ( String value ) { createReplaceValue ( ) . addText ( value ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public NestedString createReplaceToken ( ) { if ( token == null ) { token = new NestedString ( ) ; } return token ; } public NestedString createReplaceValue ( ) { return value ; } public void setPropertyFile ( File propertyFile ) { this . propertyFile = propertyFile ; } public Replacefilter createReplacefilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . addElement ( filter ) ; return filter ; } private Replacefilter createPrimaryfilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . insertElementAt ( filter , 0 ) ; return filter ; } private void stringReplace ( StringBuffer str , String str1 , String str2 ) { int found = str . toString ( ) . indexOf ( str1 ) ; while ( found >= 0 ) { str . replace ( found , found + str1 . length ( ) , str2 ) ; found = str . toString ( ) . indexOf ( str1 , found + str2 . length ( ) ) ; } } } 	1
package org . apache . tools . zip ; public class UnrecognizedExtraField implements ZipExtraField { private ZipShort headerId ; public void setHeaderId ( ZipShort headerId ) { this . headerId = headerId ; } public ZipShort getHeaderId ( ) { return headerId ; } private byte [ ] localData ; public void setLocalFileDataData ( byte [ ] data ) { localData = data ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( localData . length ) ; } public byte [ ] getLocalFileDataData ( ) { return localData ; } private byte [ ] centralData ; public void setCentralDirectoryData ( byte [ ] data ) { centralData = data ; } public ZipShort getCentralDirectoryLength ( ) { if ( centralData != null ) { return new ZipShort ( centralData . length ) ; } return getLocalFileDataLength ( ) ; } public byte [ ] getCentralDirectoryData ( ) { if ( centralData != null ) { return centralData ; } return getLocalFileDataData ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) { byte [ ] tmp = new byte [ length ] ; System . arraycopy ( data , offset , tmp , 0 , length ) ; setLocalFileDataData ( tmp ) ; } } 	1
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Collections ; import java . util . Iterator ; import java . util . Locale ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . PathTokenizer ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . FileResourceIterator ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Path extends DataType implements Cloneable , ResourceCollection { public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public static Path systemBootClasspath = new Path ( null , System . getProperty ( "sun.boot.class.path" ) ) ; private static final Iterator EMPTY_ITERATOR = Collections . EMPTY_SET . iterator ( ) ; public class PathElement implements ResourceCollection { private String [ ] parts ; public void setLocation ( File loc ) { parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } public void setPath ( String path ) { parts = Path . translatePath ( getProject ( ) , path ) ; } public String [ ] getParts ( ) { return parts ; } public Iterator iterator ( ) { return new FileResourceIterator ( null , parts ) ; } public boolean isFilesystemOnly ( ) { return true ; } public int size ( ) { return parts == null ? 0 : parts . length ; } } private Union union = null ; public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { setProject ( project ) ; } public void setLocation ( File location ) throws BuildException { checkAttributesAllowed ( ) ; createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { checkAttributesAllowed ( ) ; createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( union != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; add ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( fs . getProject ( ) == null ) { fs . setProject ( getProject ( ) ) ; } add ( fs ) ; } public void addFilelist ( FileList fl ) throws BuildException { if ( fl . getProject ( ) == null ) { fl . setProject ( getProject ( ) ) ; } add ( fl ) ; } public void addDirset ( DirSet dset ) throws BuildException { if ( dset . getProject ( ) == null ) { dset . setProject ( getProject ( ) ) ; } add ( dset ) ; } public void add ( Path path ) throws BuildException { if ( path == this ) { throw circularReference ( ) ; } if ( path . getProject ( ) == null ) { path . setProject ( getProject ( ) ) ; } add ( ( ResourceCollection ) path ) ; } public void add ( ResourceCollection c ) { checkChildrenAllowed ( ) ; if ( c == null ) { return ; } if ( union == null ) { union = new Union ( ) ; union . setProject ( getProject ( ) ) ; union . setCache ( false ) ; } union . add ( c ) ; setChecked ( false ) ; } public Path createPath ( ) throws BuildException { Path p = new Path ( getProject ( ) ) ; add ( p ) ; return p ; } public void append ( Path other ) { if ( other == null ) { return ; } add ( other ) ; } public void addExisting ( Path source ) { addExisting ( source , false ) ; } public void addExisting ( Path source , boolean tryUserDir ) { String [ ] list = source . list ( ) ; File userDir = ( tryUserDir ) ? new File ( System . getProperty ( "user.dir" ) ) : null ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = resolveFile ( getProject ( ) , list [ i ] ) ; if ( tryUserDir && ! f . exists ( ) ) { f = new File ( userDir , list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } else { log ( "dropping " + f + " from path as it doesn't exist" , Project . MSG_VERBOSE ) ; } } } public String [ ] list ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . list ( ) ; } return assertFilesystemOnly ( union ) == null ? new String [ 0 ] : union . list ( ) ; } public String toString ( ) { return isReference ( ) ? getCheckedRef ( ) . toString ( ) : union == null ? "" : union . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) { return new String [ 0 ] ; } PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String pathElement = tok . nextToken ( ) ; try { element . append ( resolveFile ( project , pathElement ) . getPath ( ) ) ; } catch ( BuildException e ) { project . log ( "Dropping path element " + pathElement + " as it is not valid relative to the project" , Project . MSG_VERBOSE ) ; } for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; element = new StringBuffer ( ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) { return "" ; } final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public synchronized int size ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . size ( ) ; } dieOnCircularReference ( ) ; return union == null ? 0 : assertFilesystemOnly ( union ) . size ( ) ; } public Object clone ( ) { try { Path result = ( Path ) super . clone ( ) ; result . union = union == null ? union : ( Union ) union . clone ( ) ; return result ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( union != null ) { stk . push ( union ) ; invokeCircularReferenceCheck ( union , stk , p ) ; stk . pop ( ) ; } setChecked ( true ) ; } } private static File resolveFile ( Project project , String relativeName ) { return FileUtils . getFileUtils ( ) . resolveFile ( ( project == null ) ? null : project . getBaseDir ( ) , relativeName ) ; } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { return concatSpecialPath ( defValue , Path . systemClasspath ) ; } public Path concatSystemBootClasspath ( String defValue ) { return concatSpecialPath ( defValue , Path . systemBootClasspath ) ; } private Path concatSpecialPath ( String defValue , Path p ) { Path result = new Path ( getProject ( ) ) ; String order = defValue ; if ( getProject ( ) != null ) { String o = getProject ( ) . getProperty ( "build.sysclasspath" ) ; if ( o != null ) { order = o ; } } if ( order . equals ( "only" ) ) { result . addExisting ( p , true ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( p , true ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( p , true ) ; } return result ; } public void addJavaRuntime ( ) { if ( JavaEnvUtils . isKaffe ( ) ) { File kaffeShare = new File ( System . getProperty ( "java.home" ) + File . separator + "share" + File . separator + "kaffe" ) ; if ( kaffeShare . isDirectory ( ) ) { FileSet kaffeJarFiles = new FileSet ( ) ; kaffeJarFiles . setDir ( kaffeShare ) ; kaffeJarFiles . setIncludes ( "*.jar" ) ; addFileset ( kaffeJarFiles ) ; } } else if ( "GNU libgcj" . equals ( System . getProperty ( "java.vm.name" ) ) ) { addExisting ( systemBootClasspath ) ; } if ( System . getProperty ( "java.vendor" ) . toLowerCase ( Locale . US ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; addFileset ( msZipFiles ) ; } else { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; String [ ] secJars = { "jce" , "jsse" } ; for ( int i = 0 ; i < secJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + secJars [ i ] + ".jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + secJars [ i ] + ".jar" ) ) ; } String [ ] ibmJars = { "core" , "graphics" , "security" , "server" , "xml" } ; for ( int i = 0 ; i < ibmJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + ibmJars [ i ] + ".jar" ) ) ; } addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } public void addExtdirs ( Path extdirs ) { if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( getProject ( ) , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File dir = resolveFile ( getProject ( ) , dirs [ i ] ) ; if ( dir . exists ( ) && dir . isDirectory ( ) ) { FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; addFileset ( fs ) ; } } } public final synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . iterator ( ) ; } dieOnCircularReference ( ) ; return union == null ? EMPTY_ITERATOR : assertFilesystemOnly ( union ) . iterator ( ) ; } public synchronized boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } dieOnCircularReference ( ) ; assertFilesystemOnly ( union ) ; return true ; } protected ResourceCollection assertFilesystemOnly ( ResourceCollection rc ) { if ( rc != null && ! ( rc . isFilesystemOnly ( ) ) ) { throw new BuildException ( getDataTypeName ( ) + " allows only filesystem resources." ) ; } return rc ; } } 	1
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . rmic . DefaultRmicAdapter ; import org . apache . tools . ant . taskdefs . rmic . WLRmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . depend . DependencyAnalyzer ; public class Depend extends MatchingTask { private static class ClassFileInfo { private File absoluteFile ; private String className ; private File sourceFile ; private boolean isUserWarned = false ; } private Path srcPath ; private Path destPath ; private File cache ; private String [ ] srcPathList ; private Hashtable affectedClassMap ; private Hashtable classFileInfoMap ; private Hashtable classpathDependencies ; private Hashtable outOfDateClasses ; private boolean closure = false ; private boolean warnOnRmiStubs = true ; private boolean dump = false ; private Path dependClasspath ; private static final String CACHE_FILE_NAME = "dependencies.txt" ; private static final String CLASSNAME_PREPEND = "||:" ; public void setClasspath ( Path classpath ) { if ( dependClasspath == null ) { dependClasspath = classpath ; } else { dependClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return dependClasspath ; } public Path createClasspath ( ) { if ( dependClasspath == null ) { dependClasspath = new Path ( getProject ( ) ) ; } return dependClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setWarnOnRmiStubs ( boolean warnOnRmiStubs ) { this . warnOnRmiStubs = warnOnRmiStubs ; } private Hashtable readCachedDependencies ( File depFile ) throws IOException { Hashtable dependencyMap = new Hashtable ( ) ; BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( depFile ) ) ; String line = null ; Vector dependencyList = null ; String className = null ; int prependLength = CLASSNAME_PREPEND . length ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( CLASSNAME_PREPEND ) ) { dependencyList = new Vector ( ) ; className = line . substring ( prependLength ) ; dependencyMap . put ( className , dependencyList ) ; } else { dependencyList . addElement ( line ) ; } } } finally { if ( in != null ) { in . close ( ) ; } } return dependencyMap ; } private void writeCachedDependencies ( Hashtable dependencyMap ) throws IOException { if ( cache != null ) { PrintWriter pw = null ; try { cache . mkdirs ( ) ; File depFile = new File ( cache , CACHE_FILE_NAME ) ; pw = new PrintWriter ( new FileWriter ( depFile ) ) ; Enumeration e = dependencyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String className = ( String ) e . nextElement ( ) ; pw . println ( CLASSNAME_PREPEND + className ) ; Vector dependencyList = ( Vector ) dependencyMap . get ( className ) ; int size = dependencyList . size ( ) ; for ( int x = 0 ; x < size ; x ++ ) { pw . println ( dependencyList . elementAt ( x ) ) ; } } } finally { if ( pw != null ) { pw . close ( ) ; } } } } private Path getCheckClassPath ( ) { if ( dependClasspath == null ) { return null ; } String [ ] destPathElements = destPath . list ( ) ; String [ ] classpathElements = dependClasspath . list ( ) ; String checkPath = "" ; for ( int i = 0 ; i < classpathElements . length ; ++ i ) { String element = classpathElements [ i ] ; boolean inDestPath = false ; for ( int j = 0 ; j < destPathElements . length && ! inDestPath ; ++ j ) { inDestPath = destPathElements [ j ] . equals ( element ) ; } if ( ! inDestPath ) { if ( checkPath . length ( ) == 0 ) { checkPath = element ; } else { checkPath += ":" + element ; } } } if ( checkPath . length ( ) == 0 ) { return null ; } return new Path ( getProject ( ) , checkPath ) ; } private void determineDependencies ( ) throws IOException { affectedClassMap = new Hashtable ( ) ; classFileInfoMap = new Hashtable ( ) ; boolean cacheDirty = false ; Hashtable dependencyMap = new Hashtable ( ) ; File cacheFile = null ; boolean cacheFileExists = true ; long cacheLastModified = Long . MAX_VALUE ; if ( cache != null ) { cacheFile = new File ( cache , CACHE_FILE_NAME ) ; cacheFileExists = cacheFile . exists ( ) ; cacheLastModified = cacheFile . lastModified ( ) ; if ( cacheFileExists ) { dependencyMap = readCachedDependencies ( cacheFile ) ; } } Enumeration classfileEnum = getClassFiles ( destPath ) . elements ( ) ; while ( classfileEnum . hasMoreElements ( ) ) { ClassFileInfo info = ( ClassFileInfo ) classfileEnum . nextElement ( ) ; log ( "Adding class info for " + info . className , Project . MSG_DEBUG ) ; classFileInfoMap . put ( info . className , info ) ; Vector dependencyList = null ; if ( cache != null ) { if ( cacheFileExists && cacheLastModified > info . absoluteFile . lastModified ( ) ) { dependencyList = ( Vector ) dependencyMap . get ( info . className ) ; } } if ( dependencyList == null ) { DependencyAnalyzer analyzer = new AntAnalyzer ( ) ; analyzer . addRootClass ( info . className ) ; analyzer . addClassPath ( destPath ) ; analyzer . setClosure ( false ) ; dependencyList = new Vector ( ) ; Enumeration depEnum = analyzer . getClassDependencies ( ) ; while ( depEnum . hasMoreElements ( ) ) { dependencyList . addElement ( depEnum . nextElement ( ) ) ; } cacheDirty = true ; dependencyMap . put ( info . className , dependencyList ) ; } Enumeration depEnum = dependencyList . elements ( ) ; while ( depEnum . hasMoreElements ( ) ) { String dependentClass = ( String ) depEnum . nextElement ( ) ; Hashtable affectedClasses = ( Hashtable ) affectedClassMap . get ( dependentClass ) ; if ( affectedClasses == null ) { affectedClasses = new Hashtable ( ) ; affectedClassMap . put ( dependentClass , affectedClasses ) ; } affectedClasses . put ( info . className , info ) ; } } classpathDependencies = null ; Path checkPath = getCheckClassPath ( ) ; if ( checkPath != null ) { classpathDependencies = new Hashtable ( ) ; AntClassLoader loader = getProject ( ) . createClassLoader ( checkPath ) ; Hashtable classpathFileCache = new Hashtable ( ) ; Object nullFileMarker = new Object ( ) ; for ( Enumeration e = dependencyMap . keys ( ) ; e . hasMoreElements ( ) ; ) { String className = ( String ) e . nextElement ( ) ; Vector dependencyList = ( Vector ) dependencyMap . get ( className ) ; Hashtable dependencies = new Hashtable ( ) ; classpathDependencies . put ( className , dependencies ) ; Enumeration e2 = dependencyList . elements ( ) ; while ( e2 . hasMoreElements ( ) ) { String dependency = ( String ) e2 . nextElement ( ) ; Object classpathFileObject = classpathFileCache . get ( dependency ) ; if ( classpathFileObject == null ) { classpathFileObject = nullFileMarker ; if ( ! dependency . startsWith ( "java." ) && ! dependency . startsWith ( "javax." ) ) { URL classURL = loader . getResource ( dependency . replace ( '.' , '/' ) + ".class" ) ; if ( classURL != null ) { if ( classURL . getProtocol ( ) . equals ( "jar" ) ) { String jarFilePath = classURL . getFile ( ) ; int classMarker = jarFilePath . indexOf ( '!' ) ; jarFilePath = jarFilePath . substring ( 0 , classMarker ) ; if ( jarFilePath . startsWith ( "file:" ) ) { classpathFileObject = new File ( FileUtils . getFileUtils ( ) . fromURI ( jarFilePath ) ) ; } else { throw new IOException ( "Bizarre nested path in jar: protocol: " + jarFilePath ) ; } } else if ( classURL . getProtocol ( ) . equals ( "file" ) ) { classpathFileObject = new File ( FileUtils . getFileUtils ( ) . fromURI ( classURL . toExternalForm ( ) ) ) ; } log ( "Class " + className + " depends on " + classpathFileObject + " due to " + dependency , Project . MSG_DEBUG ) ; } } classpathFileCache . put ( dependency , classpathFileObject ) ; } if ( classpathFileObject != null && classpathFileObject != nullFileMarker ) { File jarFile = ( File ) classpathFileObject ; dependencies . put ( jarFile , jarFile ) ; } } } } if ( cache != null && cacheDirty ) { writeCachedDependencies ( dependencyMap ) ; } } private int deleteAllAffectedFiles ( ) { int count = 0 ; for ( Enumeration e = outOfDateClasses . elements ( ) ; e . hasMoreElements ( ) ; ) { String className = ( String ) e . nextElement ( ) ; count += deleteAffectedFiles ( className ) ; ClassFileInfo classInfo = ( ClassFileInfo ) classFileInfoMap . get ( className ) ; if ( classInfo != null && classInfo . absoluteFile . exists ( ) ) { classInfo . absoluteFile . delete ( ) ; count ++ ; } } return count ; } private int deleteAffectedFiles ( String className ) { int count = 0 ; Hashtable affectedClasses = ( Hashtable ) affectedClassMap . get ( className ) ; if ( affectedClasses == null ) { return count ; } for ( Enumeration e = affectedClasses . keys ( ) ; e . hasMoreElements ( ) ; ) { String affectedClass = ( String ) e . nextElement ( ) ; ClassFileInfo affectedClassInfo = ( ClassFileInfo ) affectedClasses . get ( affectedClass ) ; if ( ! affectedClassInfo . absoluteFile . exists ( ) ) { continue ; } if ( affectedClassInfo . sourceFile == null ) { warnOutOfDateButNotDeleted ( affectedClassInfo , affectedClass , className ) ; continue ; } log ( "Deleting file " + affectedClassInfo . absoluteFile . getPath ( ) + " since " + className + " out of date" , Project . MSG_VERBOSE ) ; affectedClassInfo . absoluteFile . delete ( ) ; count ++ ; if ( closure ) { count += deleteAffectedFiles ( affectedClass ) ; } else { if ( affectedClass . indexOf ( "$" ) == - 1 ) { continue ; } String topLevelClassName = affectedClass . substring ( 0 , affectedClass . indexOf ( "$" ) ) ; log ( "Top level class = " + topLevelClassName , Project . MSG_VERBOSE ) ; ClassFileInfo topLevelClassInfo = ( ClassFileInfo ) classFileInfoMap . get ( topLevelClassName ) ; if ( topLevelClassInfo != null && topLevelClassInfo . absoluteFile . exists ( ) ) { log ( "Deleting file " + topLevelClassInfo . absoluteFile . getPath ( ) + " since one of its inner classes was removed" , Project . MSG_VERBOSE ) ; topLevelClassInfo . absoluteFile . delete ( ) ; count ++ ; if ( closure ) { count += deleteAffectedFiles ( topLevelClassName ) ; } } } } return count ; } private void warnOutOfDateButNotDeleted ( ClassFileInfo affectedClassInfo , String affectedClass , String className ) { if ( affectedClassInfo . isUserWarned ) { return ; } int level = Project . MSG_WARN ; if ( ! warnOnRmiStubs ) { if ( isRmiStub ( affectedClass , className ) ) { level = Project . MSG_VERBOSE ; } } log ( "The class " + affectedClass + " in file " + affectedClassInfo . absoluteFile . getPath ( ) + " is out of date due to " + className + " but has not been deleted because its source file" + " could not be determined" , level ) ; affectedClassInfo . isUserWarned = true ; } private boolean isRmiStub ( String affectedClass , String className ) { return isStub ( affectedClass , className , DefaultRmicAdapter . RMI_STUB_SUFFIX ) || isStub ( affectedClass , className , DefaultRmicAdapter . RMI_SKEL_SUFFIX ) || isStub ( affectedClass , className , WLRmic . RMI_STUB_SUFFIX ) || isStub ( affectedClass , className , WLRmic . RMI_SKEL_SUFFIX ) ; } private boolean isStub ( String affectedClass , String baseClass , String suffix ) { return ( baseClass + suffix ) . equals ( affectedClass ) ; } private void dumpDependencies ( ) { log ( "Reverse Dependency Dump for " + affectedClassMap . size ( ) + " classes:" , Project . MSG_DEBUG ) ; Enumeration classEnum = affectedClassMap . keys ( ) ; while ( classEnum . hasMoreElements ( ) ) { String className = ( String ) classEnum . nextElement ( ) ; log ( " Class " + className + " affects:" , Project . MSG_DEBUG ) ; Hashtable affectedClasses = ( Hashtable ) affectedClassMap . get ( className ) ; Enumeration affectedClassEnum = affectedClasses . keys ( ) ; while ( affectedClassEnum . hasMoreElements ( ) ) { String affectedClass = ( String ) affectedClassEnum . nextElement ( ) ; ClassFileInfo info = ( ClassFileInfo ) affectedClasses . get ( affectedClass ) ; log ( "    " + affectedClass + " in " + info . absoluteFile . getPath ( ) , Project . MSG_DEBUG ) ; } } if ( classpathDependencies != null ) { log ( "Classpath file dependencies (Forward):" , Project . MSG_DEBUG ) ; Enumeration classpathEnum = classpathDependencies . keys ( ) ; while ( classpathEnum . hasMoreElements ( ) ) { String className = ( String ) classpathEnum . nextElement ( ) ; log ( " Class " + className + " depends on:" , Project . MSG_DEBUG ) ; Hashtable dependencies = ( Hashtable ) classpathDependencies . get ( className ) ; Enumeration classpathFileEnum = dependencies . elements ( ) ; while ( classpathFileEnum . hasMoreElements ( ) ) { File classpathFile = ( File ) classpathFileEnum . nextElement ( ) ; log ( "    " + classpathFile . getPath ( ) , Project . MSG_DEBUG ) ; } } } } private void determineOutOfDateClasses ( ) { outOfDateClasses = new Hashtable ( ) ; for ( int i = 0 ; i < srcPathList . length ; i ++ ) { File srcDir = getProject ( ) . resolveFile ( srcPathList [ i ] ) ; if ( srcDir . exists ( ) ) { DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , files ) ; } } if ( classpathDependencies == null ) { return ; } Enumeration classpathDepsEnum = classpathDependencies . keys ( ) ; while ( classpathDepsEnum . hasMoreElements ( ) ) { String className = ( String ) classpathDepsEnum . nextElement ( ) ; if ( outOfDateClasses . containsKey ( className ) ) { continue ; } ClassFileInfo info = ( ClassFileInfo ) classFileInfoMap . get ( className ) ; if ( info != null ) { Hashtable dependencies = ( Hashtable ) classpathDependencies . get ( className ) ; for ( Enumeration e2 = dependencies . elements ( ) ; e2 . hasMoreElements ( ) ; ) { File classpathFile = ( File ) e2 . nextElement ( ) ; if ( classpathFile . lastModified ( ) > info . absoluteFile . lastModified ( ) ) { log ( "Class " + className + " is out of date with respect to " + classpathFile , Project . MSG_DEBUG ) ; outOfDateClasses . put ( className , className ) ; break ; } } } } } public void execute ( ) throws BuildException { try { long start = System . currentTimeMillis ( ) ; if ( srcPath == null ) { throw new BuildException ( "srcdir attribute must be set" , getLocation ( ) ) ; } srcPathList = srcPath . list ( ) ; if ( srcPathList . length == 0 ) { throw new BuildException ( "srcdir attribute must be non-empty" , getLocation ( ) ) ; } if ( destPath == null ) { destPath = srcPath ; } if ( cache != null && cache . exists ( ) && ! cache . isDirectory ( ) ) { throw new BuildException ( "The cache, if specified, must " + "point to a directory" ) ; } if ( cache != null && ! cache . exists ( ) ) { cache . mkdirs ( ) ; } determineDependencies ( ) ; if ( dump ) { dumpDependencies ( ) ; } determineOutOfDateClasses ( ) ; int count = deleteAllAffectedFiles ( ) ; long duration = ( System . currentTimeMillis ( ) - start ) / 1000 ; final int summaryLogLevel ; if ( count > 0 ) { summaryLogLevel = Project . MSG_INFO ; } else { summaryLogLevel = Project . MSG_DEBUG ; } log ( "Deleted " + count + " out of date files in " + duration + " seconds" , summaryLogLevel ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } protected void scanDir ( File srcDir , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { File srcFile = new File ( srcDir , files [ i ] ) ; if ( files [ i ] . endsWith ( ".java" ) ) { String filePath = srcFile . getPath ( ) ; String className = filePath . substring ( srcDir . getPath ( ) . length ( ) + 1 , filePath . length ( ) - ".java" . length ( ) ) ; className = ClassFileUtils . convertSlashName ( className ) ; ClassFileInfo info = ( ClassFileInfo ) classFileInfoMap . get ( className ) ; if ( info == null ) { outOfDateClasses . put ( className , className ) ; } else { if ( srcFile . lastModified ( ) > info . absoluteFile . lastModified ( ) ) { outOfDateClasses . put ( className , className ) ; } } } } } private Vector getClassFiles ( Path classLocations ) { String [ ] classLocationsList = classLocations . list ( ) ; Vector classFileList = new Vector ( ) ; for ( int i = 0 ; i < classLocationsList . length ; ++ i ) { File dir = new File ( classLocationsList [ i ] ) ; if ( dir . isDirectory ( ) ) { addClassFiles ( classFileList , dir , dir ) ; } } return classFileList ; } private File findSourceFile ( String classname ) { String sourceFilename = classname + ".java" ; int innerIndex = classname . indexOf ( "$" ) ; if ( innerIndex != - 1 ) { sourceFilename = classname . substring ( 0 , innerIndex ) + ".java" ; } for ( int i = 0 ; i < srcPathList . length ; ++ i ) { File sourceFile = new File ( srcPathList [ i ] , sourceFilename ) ; if ( sourceFile . exists ( ) ) { return sourceFile ; } } return null ; } private void addClassFiles ( Vector classFileList , File dir , File root ) { String [ ] filesInDir = dir . list ( ) ; if ( filesInDir == null ) { return ; } int length = filesInDir . length ; int rootLength = root . getPath ( ) . length ( ) ; for ( int i = 0 ; i < length ; ++ i ) { File file = new File ( dir , filesInDir [ i ] ) ; if ( file . isDirectory ( ) ) { addClassFiles ( classFileList , file , root ) ; } else if ( file . getName ( ) . endsWith ( ".class" ) ) { ClassFileInfo info = new ClassFileInfo ( ) ; info . absoluteFile = file ; String relativeName = file . getPath ( ) . substring ( rootLength + 1 , file . getPath ( ) . length ( ) - 6 ) ; info . className = ClassFileUtils . convertSlashName ( relativeName ) ; info . sourceFile = findSourceFile ( relativeName ) ; classFileList . addElement ( info ) ; } } } public void setSrcdir ( Path srcPath ) { this . srcPath = srcPath ; } public void setDestDir ( Path destPath ) { this . destPath = destPath ; } public void setCache ( File cache ) { this . cache = cache ; } public void setClosure ( boolean closure ) { this . closure = closure ; } public void setDump ( boolean dump ) { this . dump = dump ; } } 	1
package org . apache . tools . tar ; import java . io . FilterOutputStream ; import java . io . OutputStream ; import java . io . IOException ; public class TarOutputStream extends FilterOutputStream { public static final int LONGFILE_ERROR = 0 ; public static final int LONGFILE_TRUNCATE = 1 ; public static final int LONGFILE_GNU = 2 ; protected boolean debug ; protected long currSize ; protected String currName ; protected long currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; private boolean closed = false ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { if ( ! closed ) { this . finish ( ) ; this . buffer . close ( ) ; out . close ( ) ; closed = true ; } } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = entry . getSize ( ) ; } currName = entry . getName ( ) ; } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry '" + currName + "' closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes for entry '" + currName + "'" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . ssh ; import java . io . File ; import java . io . IOException ; import java . io . EOFException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . FileOutputStream ; import java . io . ByteArrayOutputStream ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . Channel ; public class ScpFromMessage extends AbstractSshMessage { private static final byte LINE_FEED = 0x0a ; private static final int BUFFER_SIZE = 1024 ; private String remoteFile ; private File localFile ; private boolean isRecursive = false ; public ScpFromMessage ( Session session ) { super ( session ) ; } public ScpFromMessage ( boolean verbose , Session session ) { super ( verbose , session ) ; } public ScpFromMessage ( boolean verbose , Session session , String aRemoteFile , File aLocalFile , boolean recursive ) { super ( verbose , session ) ; this . remoteFile = aRemoteFile ; this . localFile = aLocalFile ; this . isRecursive = recursive ; } public ScpFromMessage ( Session session , String aRemoteFile , File aLocalFile , boolean recursive ) { this ( false , session , aRemoteFile , aLocalFile , recursive ) ; } public void execute ( ) throws IOException , JSchException { String command = "scp -f " ; if ( isRecursive ) { command += "-r " ; } command += remoteFile ; Channel channel = openExecChannel ( command ) ; try { OutputStream out = channel . getOutputStream ( ) ; InputStream in = channel . getInputStream ( ) ; channel . connect ( ) ; sendAck ( out ) ; startRemoteCpProtocol ( in , out , localFile ) ; } finally { if ( channel != null ) { channel . disconnect ( ) ; } } log ( "done\n" ) ; } private void startRemoteCpProtocol ( InputStream in , OutputStream out , File localFile ) throws IOException { File startFile = localFile ; while ( true ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; while ( true ) { int read = in . read ( ) ; if ( read < 0 ) { return ; } if ( ( byte ) read == LINE_FEED ) { break ; } stream . write ( read ) ; } String serverResponse = stream . toString ( "UTF-8" ) ; if ( serverResponse . charAt ( 0 ) == 'C' ) { parseAndFetchFile ( serverResponse , startFile , out , in ) ; } else if ( serverResponse . charAt ( 0 ) == 'D' ) { startFile = parseAndCreateDirectory ( serverResponse , startFile ) ; sendAck ( out ) ; } else if ( serverResponse . charAt ( 0 ) == 'E' ) { startFile = startFile . getParentFile ( ) ; sendAck ( out ) ; } else if ( serverResponse . charAt ( 0 ) == '\01' || serverResponse . charAt ( 0 ) == '\02' ) { throw new IOException ( serverResponse . substring ( 1 ) ) ; } } } private File parseAndCreateDirectory ( String serverResponse , File localFile ) { int start = serverResponse . indexOf ( " " ) ; start = serverResponse . indexOf ( " " , start + 1 ) ; String directoryName = serverResponse . substring ( start + 1 ) ; if ( localFile . isDirectory ( ) ) { File dir = new File ( localFile , directoryName ) ; dir . mkdir ( ) ; log ( "Creating: " + dir ) ; return dir ; } return null ; } private void parseAndFetchFile ( String serverResponse , File localFile , OutputStream out , InputStream in ) throws IOException { int start = 0 ; int end = serverResponse . indexOf ( " " , start + 1 ) ; start = end + 1 ; end = serverResponse . indexOf ( " " , start + 1 ) ; long filesize = Long . parseLong ( serverResponse . substring ( start , end ) ) ; String filename = serverResponse . substring ( end + 1 ) ; log ( "Receiving: " + filename + " : " + filesize ) ; File transferFile = ( localFile . isDirectory ( ) ) ? new File ( localFile , filename ) : localFile ; fetchFile ( transferFile , filesize , out , in ) ; waitForAck ( in ) ; sendAck ( out ) ; } private void fetchFile ( File localFile , long filesize , OutputStream out , InputStream in ) throws IOException { byte [ ] buf = new byte [ BUFFER_SIZE ] ; sendAck ( out ) ; FileOutputStream fos = new FileOutputStream ( localFile ) ; int length ; long totalLength = 0 ; long startTime = System . currentTimeMillis ( ) ; boolean trackProgress = getVerbose ( ) && filesize > 102400 ; long initFilesize = filesize ; int percentTransmitted = 0 ; try { while ( true ) { length = in . read ( buf , 0 , ( BUFFER_SIZE < filesize ) ? BUFFER_SIZE : ( int ) filesize ) ; if ( length < 0 ) { throw new EOFException ( "Unexpected end of stream." ) ; } fos . write ( buf , 0 , length ) ; filesize -= length ; totalLength += length ; if ( filesize == 0 ) { break ; } if ( trackProgress ) { percentTransmitted = trackProgress ( initFilesize , totalLength , percentTransmitted ) ; } } } finally { long endTime = System . currentTimeMillis ( ) ; logStats ( startTime , endTime , totalLength ) ; fos . flush ( ) ; fos . close ( ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class Ear extends Jar { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File deploymentDescriptor ; private boolean descriptorAdded ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { setDestFile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "appxml attribute is required" , getLocation ( ) ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/application.xml" ) ) { if ( deploymentDescriptor == null || ! FILE_UTILS . fileNameEquals ( deploymentDescriptor , file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will" + " be ignored (please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath , mode ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . rmi . Remote ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapter ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapterFactory ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; public class Rmic extends MatchingTask { public static final String ERROR_RMIC_FAILED = "Rmic failed; see the compiler error output for details." ; private File baseDir ; private String classname ; private File sourceBase ; private String stubVersion ; private Path compileClasspath ; private Path extDirs ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private String iiopOpts ; private boolean idl = false ; private String idlOpts ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; private FacadeTaskHelper facade ; public static final String ERROR_UNABLE_TO_VERIFY_CLASS = "Unable to verify class " ; public static final String ERROR_NOT_FOUND = ". It could not be found." ; public static final String ERROR_NOT_DEFINED = ". It is not defined." ; public static final String ERROR_LOADING_CAUSED_EXCEPTION = ". Loading caused Exception: " ; public static final String ERROR_NO_BASE_EXISTS = "base does not exist: " ; public static final String ERROR_NOT_A_DIR = "base is not a directory:" ; public static final String ERROR_BASE_NOT_SET = "base attribute must be set!" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public Rmic ( ) { facade = new FacadeTaskHelper ( RmicAdapterFactory . DEFAULT_COMPILER ) ; } public void setBase ( File base ) { this . baseDir = base ; } public File getBase ( ) { return this . baseDir ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setSourceBase ( File sourceBase ) { this . sourceBase = sourceBase ; } public File getSourceBase ( ) { return sourceBase ; } public void setStubVersion ( String stubVersion ) { this . stubVersion = stubVersion ; } public String getStubVersion ( ) { return stubVersion ; } public void setFiltering ( boolean filter ) { this . filtering = filter ; } public boolean getFiltering ( ) { return filtering ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference pathRef ) { createClasspath ( ) . setRefid ( pathRef ) ; } public Path getClasspath ( ) { return compileClasspath ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public boolean getVerify ( ) { return verify ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public boolean getIiop ( ) { return iiop ; } public void setIiopopts ( String iiopOpts ) { this . iiopOpts = iiopOpts ; } public String getIiopopts ( ) { return iiopOpts ; } public void setIdl ( boolean idl ) { this . idl = idl ; } public boolean getIdl ( ) { return idl ; } public void setIdlopts ( String idlOpts ) { this . idlOpts = idlOpts ; } public String getIdlopts ( ) { return idlOpts ; } public Vector getFileList ( ) { return compileList ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setExtdirs ( Path extDirs ) { if ( this . extDirs == null ) { this . extDirs = extDirs ; } else { this . extDirs . append ( extDirs ) ; } } public Path createExtdirs ( ) { if ( extDirs == null ) { extDirs = new Path ( getProject ( ) ) ; } return extDirs . createPath ( ) ; } public Path getExtdirs ( ) { return extDirs ; } public Vector getCompileList ( ) { return compileList ; } public void setCompiler ( String compiler ) { if ( compiler . length ( ) > 0 ) { facade . setImplementation ( compiler ) ; } } public String getCompiler ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.rmic" ) ) ; return facade . getImplementation ( ) ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { getCompiler ( ) ; return facade . getArgs ( ) ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( ERROR_BASE_NOT_SET , getLocation ( ) ) ; } if ( ! baseDir . exists ( ) ) { throw new BuildException ( ERROR_NO_BASE_EXISTS + baseDir , getLocation ( ) ) ; } if ( ! baseDir . isDirectory ( ) ) { throw new BuildException ( ERROR_NOT_A_DIR + baseDir , getLocation ( ) ) ; } if ( verify ) { log ( "Verify has been turned on." , Project . MSG_VERBOSE ) ; } RmicAdapter adapter = RmicAdapterFactory . getRmic ( getCompiler ( ) , this ) ; adapter . setRmic ( this ) ; Path classpath = adapter . getClasspath ( ) ; loader = getProject ( ) . createClassLoader ( classpath ) ; try { if ( classname == null ) { DirectoryScanner ds = this . getDirectoryScanner ( baseDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( baseDir , files , adapter . getMapper ( ) ) ; } else { scanDir ( baseDir , new String [ ] { classname . replace ( '.' , File . separatorChar ) + ".class" } , adapter . getMapper ( ) ) ; } int fileCount = compileList . size ( ) ; if ( fileCount > 0 ) { log ( "RMI Compiling " + fileCount + " class" + ( fileCount > 1 ? "es" : "" ) + " to " + baseDir , Project . MSG_INFO ) ; if ( ! adapter . execute ( ) ) { throw new BuildException ( ERROR_RMIC_FAILED , getLocation ( ) ) ; } } if ( null != sourceBase && ! baseDir . equals ( sourceBase ) && fileCount > 0 ) { if ( idl ) { log ( "Cannot determine sourcefiles in idl mode, " , Project . MSG_WARN ) ; log ( "sourcebase attribute will be ignored." , Project . MSG_WARN ) ; } else { for ( int j = 0 ; j < fileCount ; j ++ ) { moveGeneratedFile ( baseDir , sourceBase , ( String ) compileList . elementAt ( j ) , adapter ) ; } } } } finally { compileList . removeAllElements ( ) ; } } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws BuildException { String classFileName = classname . replace ( '.' , File . separatorChar ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < generatedFiles . length ; i ++ ) { final String generatedFile = generatedFiles [ i ] ; if ( ! generatedFile . endsWith ( ".class" ) ) { continue ; } final int pos = generatedFile . length ( ) - ".class" . length ( ) ; String sourceFileName = generatedFile . substring ( 0 , pos ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; if ( ! oldFile . exists ( ) ) { continue ; } File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { if ( filtering ) { FILE_UTILS . copyFile ( oldFile , newFile , new FilterSetCollection ( getProject ( ) . getGlobalFilterSet ( ) ) ) ; } else { FILE_UTILS . copyFile ( oldFile , newFile ) ; } oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldFile + " to " + newFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } protected void scanDir ( File baseDir , String [ ] files , FileNameMapper mapper ) { String [ ] newFiles = files ; if ( idl ) { log ( "will leave uptodate test to rmic implementation in idl mode." , Project . MSG_VERBOSE ) ; } else if ( iiop && iiopOpts != null && iiopOpts . indexOf ( "-always" ) > - 1 ) { log ( "no uptodate test as -always option has been specified" , Project . MSG_VERBOSE ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; newFiles = sfs . restrict ( files , baseDir , baseDir , mapper ) ; } for ( int i = 0 ; i < newFiles . length ; i ++ ) { String name = newFiles [ i ] . replace ( File . separatorChar , '.' ) ; name = name . substring ( 0 , name . lastIndexOf ( ".class" ) ) ; compileList . addElement ( name ) ; } } public boolean isValidRmiRemote ( String classname ) { try { Class testClass = loader . loadClass ( classname ) ; if ( testClass . isInterface ( ) && ! iiop && ! idl ) { return false ; } return isValidRmiRemote ( testClass ) ; } catch ( ClassNotFoundException e ) { log ( ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_NOT_FOUND , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { log ( ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_NOT_DEFINED , Project . MSG_WARN ) ; } catch ( Throwable t ) { log ( ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_LOADING_CAUSED_EXCEPTION + t . getMessage ( ) , Project . MSG_WARN ) ; } return false ; } public Class getRemoteInterface ( Class testClass ) { if ( Remote . class . isAssignableFrom ( testClass ) ) { Class [ ] interfaces = testClass . getInterfaces ( ) ; if ( interfaces != null ) { for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( Remote . class . isAssignableFrom ( interfaces [ i ] ) ) { return interfaces [ i ] ; } } } } return null ; } private boolean isValidRmiRemote ( Class testClass ) { return getRemoteInterface ( testClass ) != null ; } public ClassLoader getLoader ( ) { return loader ; } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	1
package org . apache . tools . ant . util ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; public class RegexpPatternMapper implements FileNameMapper { protected RegexpMatcher reg = null ; protected char [ ] to = null ; protected StringBuffer result = new StringBuffer ( ) ; public RegexpPatternMapper ( ) throws BuildException { reg = ( new RegexpMatcherFactory ( ) ) . newRegexpMatcher ( ) ; } private boolean handleDirSep = false ; private int regexpOptions = 0 ; public void setHandleDirSep ( boolean handleDirSep ) { this . handleDirSep = handleDirSep ; } public void setCaseSensitive ( boolean caseSensitive ) { if ( ! caseSensitive ) { regexpOptions = RegexpMatcher . MATCH_CASE_INSENSITIVE ; } else { regexpOptions = 0 ; } } public void setFrom ( String from ) throws BuildException { try { reg . setPattern ( from ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Cannot load regular expression matcher" , e ) ; } } public void setTo ( String to ) { this . to = to . toCharArray ( ) ; } public String [ ] mapFileName ( String sourceFileName ) { if ( handleDirSep ) { if ( sourceFileName . indexOf ( "\\" ) != - 1 ) { sourceFileName = sourceFileName . replace ( '\\' , '/' ) ; } } if ( reg == null || to == null || ! reg . matches ( sourceFileName , regexpOptions ) ) { return null ; } return new String [ ] { replaceReferences ( sourceFileName ) } ; } protected String replaceReferences ( String source ) { Vector v = reg . getGroups ( source , regexpOptions ) ; result . setLength ( 0 ) ; for ( int i = 0 ; i < to . length ; i ++ ) { if ( to [ i ] == '\\' ) { if ( ++ i < to . length ) { int value = Character . digit ( to [ i ] , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( to [ i ] ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( to [ i ] ) ; } } return result . substring ( 0 ) ; } } 	1
package org . apache . tools . ant . filters . util ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . BaseFilterReader ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . types . AntFilterReader ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public final class ChainReaderHelper { private static final int DEFAULT_BUFFER_SIZE = 8192 ; public Reader primaryReader ; public int bufferSize = DEFAULT_BUFFER_SIZE ; public Vector filterChains = new Vector ( ) ; private Project project = null ; public void setPrimaryReader ( Reader rdr ) { primaryReader = rdr ; } public void setProject ( final Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setBufferSize ( int size ) { bufferSize = size ; } public void setFilterChains ( Vector fchain ) { filterChains = fchain ; } public Reader getAssembledReader ( ) throws BuildException { if ( primaryReader == null ) { throw new BuildException ( "primaryReader must not be null." ) ; } Reader instream = primaryReader ; final int filterReadersCount = filterChains . size ( ) ; final Vector finalFilters = new Vector ( ) ; for ( int i = 0 ; i < filterReadersCount ; i ++ ) { final FilterChain filterchain = ( FilterChain ) filterChains . elementAt ( i ) ; final Vector filterReaders = filterchain . getFilterReaders ( ) ; final int readerCount = filterReaders . size ( ) ; for ( int j = 0 ; j < readerCount ; j ++ ) { finalFilters . addElement ( filterReaders . elementAt ( j ) ) ; } } final int filtersCount = finalFilters . size ( ) ; if ( filtersCount > 0 ) { for ( int i = 0 ; i < filtersCount ; i ++ ) { Object o = finalFilters . elementAt ( i ) ; if ( o instanceof AntFilterReader ) { final AntFilterReader filter = ( AntFilterReader ) finalFilters . elementAt ( i ) ; final String className = filter . getClassName ( ) ; final Path classpath = filter . getClasspath ( ) ; final Project pro = filter . getProject ( ) ; if ( className != null ) { try { Class clazz = null ; if ( classpath == null ) { clazz = Class . forName ( className ) ; } else { AntClassLoader al = pro . createClassLoader ( classpath ) ; clazz = Class . forName ( className , true , al ) ; } if ( clazz != null ) { if ( ! FilterReader . class . isAssignableFrom ( clazz ) ) { throw new BuildException ( className + " does not extend java.io.FilterReader" ) ; } final Constructor [ ] constructors = clazz . getConstructors ( ) ; int j = 0 ; boolean consPresent = false ; for ( ; j < constructors . length ; j ++ ) { Class [ ] types = constructors [ j ] . getParameterTypes ( ) ; if ( types . length == 1 && types [ 0 ] . isAssignableFrom ( Reader . class ) ) { consPresent = true ; break ; } } if ( ! consPresent ) { throw new BuildException ( className + " does not define a public constructor" + " that takes in a Reader as its " + "single argument." ) ; } final Reader [ ] rdr = { instream } ; instream = ( Reader ) constructors [ j ] . newInstance ( ( Object [ ] ) rdr ) ; setProjectOnObject ( instream ) ; if ( Parameterizable . class . isAssignableFrom ( clazz ) ) { final Parameter [ ] params = filter . getParams ( ) ; ( ( Parameterizable ) instream ) . setParameters ( params ) ; } } } catch ( final ClassNotFoundException cnfe ) { throw new BuildException ( cnfe ) ; } catch ( final InstantiationException ie ) { throw new BuildException ( ie ) ; } catch ( final IllegalAccessException iae ) { throw new BuildException ( iae ) ; } catch ( final InvocationTargetException ite ) { throw new BuildException ( ite ) ; } } } else if ( o instanceof ChainableReader ) { setProjectOnObject ( o ) ; instream = ( ( ChainableReader ) o ) . chain ( instream ) ; setProjectOnObject ( instream ) ; } } } return instream ; } private void setProjectOnObject ( Object obj ) { if ( project == null ) { return ; } if ( obj instanceof BaseFilterReader ) { ( ( BaseFilterReader ) obj ) . setProject ( project ) ; return ; } project . setProjectReference ( obj ) ; } public String readFully ( Reader rdr ) throws IOException { return FileUtils . readFully ( rdr , bufferSize ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . taskdefs . Ant . TargetElement ; public class SubAnt extends Task { private Path buildpath ; private Ant ant = null ; private String subTarget = null ; private String antfile = "build.xml" ; private File genericantfile = null ; private boolean verbose = false ; private boolean inheritAll = false ; private boolean inheritRefs = false ; private boolean failOnError = true ; private String output = null ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Vector propertySets = new Vector ( ) ; private Vector targets = new Vector ( ) ; public void handleOutput ( String output ) { if ( ant != null ) { ant . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( ant != null ) { return ant . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } public void handleFlush ( String output ) { if ( ant != null ) { ant . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( ant != null ) { ant . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( ant != null ) { ant . handleErrorFlush ( output ) ; } else { super . handleErrorFlush ( output ) ; } } public void execute ( ) { if ( buildpath == null ) { throw new BuildException ( "No buildpath specified" ) ; } final String [ ] filenames = buildpath . list ( ) ; final int count = filenames . length ; if ( count < 1 ) { log ( "No sub-builds to iterate on" , Project . MSG_WARN ) ; return ; } BuildException buildException = null ; for ( int i = 0 ; i < count ; ++ i ) { File file = null ; String subdirPath = null ; Throwable thrownException = null ; try { File directory = null ; file = new File ( filenames [ i ] ) ; if ( file . isDirectory ( ) ) { if ( verbose ) { subdirPath = file . getPath ( ) ; log ( "Entering directory: " + subdirPath + "\n" , Project . MSG_INFO ) ; } if ( genericantfile != null ) { directory = file ; file = genericantfile ; } else { file = new File ( file , antfile ) ; } } execute ( file , directory ) ; if ( verbose && subdirPath != null ) { log ( "Leaving directory: " + subdirPath + "\n" , Project . MSG_INFO ) ; } } catch ( RuntimeException ex ) { if ( ! ( getProject ( ) . isKeepGoingMode ( ) ) ) { if ( verbose && subdirPath != null ) { log ( "Leaving directory: " + subdirPath + "\n" , Project . MSG_INFO ) ; } throw ex ; } thrownException = ex ; } catch ( Throwable ex ) { if ( ! ( getProject ( ) . isKeepGoingMode ( ) ) ) { if ( verbose && subdirPath != null ) { log ( "Leaving directory: " + subdirPath + "\n" , Project . MSG_INFO ) ; } throw new BuildException ( ex ) ; } thrownException = ex ; } if ( thrownException != null ) { if ( thrownException instanceof BuildException ) { log ( "File '" + file + "' failed with message '" + thrownException . getMessage ( ) + "'." , Project . MSG_ERR ) ; if ( buildException == null ) { buildException = ( BuildException ) thrownException ; } } else { log ( "Target '" + file + "' failed with message '" + thrownException . getMessage ( ) + "'." , Project . MSG_ERR ) ; thrownException . printStackTrace ( System . err ) ; if ( buildException == null ) { buildException = new BuildException ( thrownException ) ; } } if ( verbose && subdirPath != null ) { log ( "Leaving directory: " + subdirPath + "\n" , Project . MSG_INFO ) ; } } } if ( buildException != null ) { throw buildException ; } } private void execute ( File file , File directory ) throws BuildException { if ( ! file . exists ( ) || file . isDirectory ( ) || ! file . canRead ( ) ) { String msg = "Invalid file: " + file ; if ( failOnError ) { throw new BuildException ( msg ) ; } log ( msg , Project . MSG_WARN ) ; return ; } ant = createAntTask ( directory ) ; String antfilename = file . getAbsolutePath ( ) ; ant . setAntfile ( antfilename ) ; for ( int i = 0 ; i < targets . size ( ) ; i ++ ) { TargetElement targetElement = ( TargetElement ) targets . get ( i ) ; ant . addConfiguredTarget ( targetElement ) ; } try { ant . execute ( ) ; } catch ( BuildException e ) { if ( failOnError ) { throw e ; } log ( "Failure for target '" + subTarget + "' of: " + antfilename + "\n" + e . getMessage ( ) , Project . MSG_WARN ) ; } catch ( Throwable e ) { if ( failOnError ) { throw new BuildException ( e ) ; } log ( "Failure for target '" + subTarget + "' of: " + antfilename + "\n" + e . toString ( ) , Project . MSG_WARN ) ; } finally { ant = null ; } } public void setAntfile ( String antfile ) { this . antfile = antfile ; } public void setGenericAntfile ( File afile ) { this . genericantfile = afile ; } public void setFailonerror ( boolean failOnError ) { this . failOnError = failOnError ; } public void setTarget ( String target ) { this . subTarget = target ; } public void addConfiguredTarget ( TargetElement t ) { String name = t . getName ( ) ; if ( "" . equals ( name ) ) { throw new BuildException ( "target name must not be empty" ) ; } targets . add ( t ) ; } public void setVerbose ( boolean on ) { this . verbose = on ; } public void setOutput ( String s ) { this . output = s ; } public void setInheritall ( boolean b ) { this . inheritAll = b ; } public void setInheritrefs ( boolean b ) { this . inheritRefs = b ; } public void addProperty ( Property p ) { properties . addElement ( p ) ; } public void addReference ( Ant . Reference r ) { references . addElement ( r ) ; } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void addDirset ( DirSet set ) { add ( set ) ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void addFilelist ( FileList list ) { add ( list ) ; } public void add ( ResourceCollection rc ) { getBuildpath ( ) . add ( rc ) ; } public void setBuildpath ( Path s ) { getBuildpath ( ) . append ( s ) ; } public Path createBuildpath ( ) { return getBuildpath ( ) . createPath ( ) ; } public Path . PathElement createBuildpathElement ( ) { return getBuildpath ( ) . createPathElement ( ) ; } private Path getBuildpath ( ) { if ( buildpath == null ) { buildpath = new Path ( getProject ( ) ) ; } return buildpath ; } public void setBuildpathRef ( Reference r ) { createBuildpath ( ) . setRefid ( r ) ; } private Ant createAntTask ( File directory ) { Ant antTask = new Ant ( this ) ; antTask . init ( ) ; if ( subTarget != null && subTarget . length ( ) > 0 ) { antTask . setTarget ( subTarget ) ; } if ( output != null ) { antTask . setOutput ( output ) ; } if ( directory != null ) { antTask . setDir ( directory ) ; } antTask . setInheritAll ( inheritAll ) ; for ( Enumeration i = properties . elements ( ) ; i . hasMoreElements ( ) ; ) { copyProperty ( antTask . createProperty ( ) , ( Property ) i . nextElement ( ) ) ; } for ( Enumeration i = propertySets . elements ( ) ; i . hasMoreElements ( ) ; ) { antTask . addPropertyset ( ( PropertySet ) i . nextElement ( ) ) ; } antTask . setInheritRefs ( inheritRefs ) ; for ( Enumeration i = references . elements ( ) ; i . hasMoreElements ( ) ; ) { antTask . addReference ( ( Ant . Reference ) i . nextElement ( ) ) ; } return antTask ; } private static void copyProperty ( Property to , Property from ) { to . setName ( from . getName ( ) ) ; if ( from . getValue ( ) != null ) { to . setValue ( from . getValue ( ) ) ; } if ( from . getFile ( ) != null ) { to . setFile ( from . getFile ( ) ) ; } if ( from . getResource ( ) != null ) { to . setResource ( from . getResource ( ) ) ; } if ( from . getPrefix ( ) != null ) { to . setPrefix ( from . getPrefix ( ) ) ; } if ( from . getRefid ( ) != null ) { to . setRefid ( from . getRefid ( ) ) ; } if ( from . getEnvironment ( ) != null ) { to . setEnvironment ( from . getEnvironment ( ) ) ; } if ( from . getClasspath ( ) != null ) { to . setClasspath ( from . getClasspath ( ) ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Vector ; import java . util . Set ; import java . util . HashSet ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Main ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . util . FileUtils ; public class Ant extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File dir = null ; private String antFile = null ; private String output = null ; private boolean inheritAll = true ; private boolean inheritRefs = false ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Project newProject ; private PrintStream out = null ; private Vector propertySets = new Vector ( ) ; private Vector targets = new Vector ( ) ; private boolean targetAttributeSet = false ; public Ant ( ) { } public Ant ( Task owner ) { bindToOwner ( owner ) ; } public void setInheritAll ( boolean value ) { inheritAll = value ; } public void setInheritRefs ( boolean value ) { inheritRefs = value ; } public void init ( ) { newProject = getProject ( ) . createSubProject ( ) ; newProject . setJavaVersionProperty ( ) ; } private void reinit ( ) { init ( ) ; } private void initializeProject ( ) { newProject . setInputHandler ( getProject ( ) . getInputHandler ( ) ) ; Iterator iter = getBuildListeners ( ) ; while ( iter . hasNext ( ) ) { newProject . addBuildListener ( ( BuildListener ) iter . next ( ) ) ; } if ( output != null ) { File outfile = null ; if ( dir != null ) { outfile = FILE_UTILS . resolveFile ( dir , output ) ; } else { outfile = getProject ( ) . resolveFile ( output ) ; } try { out = new PrintStream ( new FileOutputStream ( outfile ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; newProject . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } getProject ( ) . copyUserProperties ( newProject ) ; if ( ! inheritAll ) { newProject . setSystemProperties ( ) ; } else { addAlmostAll ( getProject ( ) . getProperties ( ) ) ; } Enumeration e = propertySets . elements ( ) ; while ( e . hasMoreElements ( ) ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; addAlmostAll ( ps . getProperties ( ) ) ; } } public void handleOutput ( String outputToHandle ) { if ( newProject != null ) { newProject . demuxOutput ( outputToHandle , false ) ; } else { super . handleOutput ( outputToHandle ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( newProject != null ) { return newProject . demuxInput ( buffer , offset , length ) ; } return super . handleInput ( buffer , offset , length ) ; } public void handleFlush ( String toFlush ) { if ( newProject != null ) { newProject . demuxFlush ( toFlush , false ) ; } else { super . handleFlush ( toFlush ) ; } } public void handleErrorOutput ( String errorOutputToHandle ) { if ( newProject != null ) { newProject . demuxOutput ( errorOutputToHandle , true ) ; } else { super . handleErrorOutput ( errorOutputToHandle ) ; } } public void handleErrorFlush ( String errorOutputToFlush ) { if ( newProject != null ) { newProject . demuxFlush ( errorOutputToFlush , true ) ; } else { super . handleErrorFlush ( errorOutputToFlush ) ; } } public void execute ( ) throws BuildException { File savedDir = dir ; String savedAntFile = antFile ; Vector locals = new Vector ( targets ) ; try { getNewProject ( ) ; if ( dir == null && inheritAll ) { dir = getProject ( ) . getBaseDir ( ) ; } initializeProject ( ) ; if ( dir != null ) { newProject . setBaseDir ( dir ) ; if ( savedDir != null ) { newProject . setInheritedProperty ( MagicNames . PROJECT_BASEDIR , dir . getAbsolutePath ( ) ) ; } } else { dir = getProject ( ) . getBaseDir ( ) ; } overrideProperties ( ) ; if ( antFile == null ) { antFile = Main . DEFAULT_BUILD_FILENAME ; } File file = FILE_UTILS . resolveFile ( dir , antFile ) ; antFile = file . getAbsolutePath ( ) ; log ( "calling target(s) " + ( ( locals . size ( ) > 0 ) ? locals . toString ( ) : "[default]" ) + " in build file " + antFile , Project . MSG_VERBOSE ) ; newProject . setUserProperty ( MagicNames . ANT_FILE , antFile ) ; String thisAntFile = getProject ( ) . getProperty ( MagicNames . ANT_FILE ) ; if ( thisAntFile != null && file . equals ( getProject ( ) . resolveFile ( thisAntFile ) ) && getOwningTarget ( ) != null ) { if ( getOwningTarget ( ) . getName ( ) . equals ( "" ) ) { if ( getTaskName ( ) . equals ( "antcall" ) ) { throw new BuildException ( "antcall must not be used at" + " the top level." ) ; } throw new BuildException ( getTaskName ( ) + " task at the" + " top level must not invoke" + " its own build file." ) ; } } try { ProjectHelper . configureProject ( newProject , file ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } if ( locals . size ( ) == 0 ) { String defaultTarget = newProject . getDefaultTarget ( ) ; if ( defaultTarget != null ) { locals . add ( defaultTarget ) ; } } if ( newProject . getProperty ( MagicNames . ANT_FILE ) . equals ( getProject ( ) . getProperty ( MagicNames . ANT_FILE ) ) && getOwningTarget ( ) != null ) { String owningTargetName = getOwningTarget ( ) . getName ( ) ; if ( locals . contains ( owningTargetName ) ) { throw new BuildException ( getTaskName ( ) + " task calling " + "its own parent target." ) ; } boolean circular = false ; for ( Iterator it = locals . iterator ( ) ; ! circular && it . hasNext ( ) ; ) { Target other = ( Target ) ( getProject ( ) . getTargets ( ) . get ( it . next ( ) ) ) ; circular |= ( other != null && other . dependsOn ( owningTargetName ) ) ; } if ( circular ) { throw new BuildException ( getTaskName ( ) + " task calling a target" + " that depends on" + " its parent target \'" + owningTargetName + "\'." ) ; } } addReferences ( ) ; if ( locals . size ( ) > 0 && ! ( locals . size ( ) == 1 && "" . equals ( locals . get ( 0 ) ) ) ) { BuildException be = null ; try { log ( "Entering " + antFile + "..." , Project . MSG_VERBOSE ) ; newProject . fireSubBuildStarted ( ) ; newProject . executeTargets ( locals ) ; } catch ( BuildException ex ) { be = ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; throw be ; } finally { log ( "Exiting " + antFile + "." , Project . MSG_VERBOSE ) ; newProject . fireSubBuildFinished ( be ) ; } } } finally { newProject = null ; Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( null ) ; } if ( output != null && out != null ) { try { out . close ( ) ; } catch ( final Exception ex ) { } } dir = savedDir ; antFile = savedAntFile ; } } private void overrideProperties ( ) throws BuildException { Set set = new HashSet ( ) ; for ( int i = properties . size ( ) - 1 ; i >= 0 ; -- i ) { Property p = ( Property ) properties . get ( i ) ; if ( p . getName ( ) != null && ! p . getName ( ) . equals ( "" ) ) { if ( set . contains ( p . getName ( ) ) ) { properties . remove ( i ) ; } else { set . add ( p . getName ( ) ) ; } } } Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( newProject ) ; p . execute ( ) ; } getProject ( ) . copyInheritedProperties ( newProject ) ; } private void addReferences ( ) throws BuildException { Hashtable thisReferences = ( Hashtable ) getProject ( ) . getReferences ( ) . clone ( ) ; Hashtable newReferences = newProject . getReferences ( ) ; Enumeration e ; if ( references . size ( ) > 0 ) { for ( e = references . elements ( ) ; e . hasMoreElements ( ) ; ) { Reference ref = ( Reference ) e . nextElement ( ) ; String refid = ref . getRefId ( ) ; if ( refid == null ) { throw new BuildException ( "the refid attribute is required" + " for reference elements" ) ; } if ( ! thisReferences . containsKey ( refid ) ) { log ( "Parent project doesn't contain any reference '" + refid + "'" , Project . MSG_WARN ) ; continue ; } thisReferences . remove ( refid ) ; String toRefid = ref . getToRefid ( ) ; if ( toRefid == null ) { toRefid = refid ; } copyReference ( refid , toRefid ) ; } } if ( inheritRefs ) { for ( e = thisReferences . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( newReferences . containsKey ( key ) ) { continue ; } copyReference ( key , key ) ; newProject . inheritIDReferences ( getProject ( ) ) ; } } } private void copyReference ( String oldKey , String newKey ) { Object orig = getProject ( ) . getReference ( oldKey ) ; if ( orig == null ) { log ( "No object referenced by " + oldKey + ". Can't copy to " + newKey , Project . MSG_WARN ) ; return ; } Class c = orig . getClass ( ) ; Object copy = orig ; try { Method cloneM = c . getMethod ( "clone" , new Class [ 0 ] ) ; if ( cloneM != null ) { copy = cloneM . invoke ( orig , new Object [ 0 ] ) ; log ( "Adding clone of reference " + oldKey , Project . MSG_DEBUG ) ; } } catch ( Exception e ) { } if ( copy instanceof ProjectComponent ) { ( ( ProjectComponent ) copy ) . setProject ( newProject ) ; } else { try { Method setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( copy , new Object [ ] { newProject } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception e2 ) { String msg = "Error setting new project instance for " + "reference with id " + oldKey ; throw new BuildException ( msg , e2 , getLocation ( ) ) ; } } newProject . addReference ( newKey , copy ) ; } private void addAlmostAll ( Hashtable props ) { Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = e . nextElement ( ) . toString ( ) ; if ( MagicNames . PROJECT_BASEDIR . equals ( key ) || MagicNames . ANT_FILE . equals ( key ) ) { continue ; } String value = props . get ( key ) . toString ( ) ; if ( newProject . getProperty ( key ) == null ) { newProject . setNewProperty ( key , value ) ; } } } public void setDir ( File dir ) { this . dir = dir ; } public void setAntfile ( String antFile ) { this . antFile = antFile ; } public void setTarget ( String targetToAdd ) { if ( targetToAdd . equals ( "" ) ) { throw new BuildException ( "target attribute must not be empty" ) ; } targets . add ( targetToAdd ) ; targetAttributeSet = true ; } public void setOutput ( String outputFile ) { this . output = outputFile ; } public Property createProperty ( ) { Property p = new Property ( true , getProject ( ) ) ; p . setProject ( getNewProject ( ) ) ; p . setTaskName ( "property" ) ; properties . addElement ( p ) ; return p ; } public void addReference ( Reference ref ) { references . addElement ( ref ) ; } public void addConfiguredTarget ( TargetElement t ) { if ( targetAttributeSet ) { throw new BuildException ( "nested target is incompatible with the target attribute" ) ; } String name = t . getName ( ) ; if ( name . equals ( "" ) ) { throw new BuildException ( "target name must not be empty" ) ; } targets . add ( name ) ; } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } protected Project getNewProject ( ) { if ( newProject == null ) { reinit ( ) ; } return newProject ; } private Iterator getBuildListeners ( ) { return getProject ( ) . getBuildListeners ( ) . iterator ( ) ; } public static class Reference extends org . apache . tools . ant . types . Reference { public Reference ( ) { super ( ) ; } private String targetid = null ; public void setToRefid ( String targetid ) { this . targetid = targetid ; } public String getToRefid ( ) { return targetid ; } } public static class TargetElement { private String name ; public TargetElement ( ) { } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } } 	1
package org . apache . tools . ant . util ; import java . text . ChoiceFormat ; import java . text . DateFormat ; import java . text . MessageFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Locale ; import java . util . TimeZone ; public final class DateUtils { public static final String ISO8601_DATETIME_PATTERN = "yyyy-MM-dd'T'HH:mm:ss" ; public static final String ISO8601_DATE_PATTERN = "yyyy-MM-dd" ; public static final String ISO8601_TIME_PATTERN = "HH:mm:ss" ; public static final DateFormat DATE_HEADER_FORMAT = new SimpleDateFormat ( "EEE, dd MMM yyyy HH:mm:ss " , Locale . US ) ; private static final MessageFormat MINUTE_SECONDS = new MessageFormat ( "{0}{1}" ) ; private static final double [ ] LIMITS = { 0 , 1 , 2 } ; private static final String [ ] MINUTES_PART = { "" , "1 minute " , "{0,number} minutes " } ; private static final String [ ] SECONDS_PART = { "0 seconds" , "1 second" , "{1,number} seconds" } ; private static final ChoiceFormat MINUTES_FORMAT = new ChoiceFormat ( LIMITS , MINUTES_PART ) ; private static final ChoiceFormat SECONDS_FORMAT = new ChoiceFormat ( LIMITS , SECONDS_PART ) ; static { MINUTE_SECONDS . setFormat ( 0 , MINUTES_FORMAT ) ; MINUTE_SECONDS . setFormat ( 1 , SECONDS_FORMAT ) ; } private DateUtils ( ) { } public static String format ( long date , String pattern ) { return format ( new Date ( date ) , pattern ) ; } public static String format ( Date date , String pattern ) { DateFormat df = createDateFormat ( pattern ) ; return df . format ( date ) ; } public static String formatElapsedTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; Object [ ] args = { new Long ( minutes ) , new Long ( seconds % 60 ) } ; return MINUTE_SECONDS . format ( args ) ; } private static DateFormat createDateFormat ( String pattern ) { SimpleDateFormat sdf = new SimpleDateFormat ( pattern ) ; TimeZone gmt = TimeZone . getTimeZone ( "GMT" ) ; sdf . setTimeZone ( gmt ) ; sdf . setLenient ( true ) ; return sdf ; } public static int getPhaseOfMoon ( Calendar cal ) { int dayOfTheYear = cal . get ( Calendar . DAY_OF_YEAR ) ; int yearInMetonicCycle = ( ( cal . get ( Calendar . YEAR ) - 1900 ) % 19 ) + 1 ; int epact = ( 11 * yearInMetonicCycle + 18 ) % 30 ; if ( ( epact == 25 && yearInMetonicCycle > 11 ) || epact == 24 ) { epact ++ ; } return ( ( ( ( ( dayOfTheYear + epact ) * 6 ) + 11 ) % 177 ) / 22 ) & 7 ; } public static String getDateForHeader ( ) { Calendar cal = Calendar . getInstance ( ) ; TimeZone tz = cal . getTimeZone ( ) ; int offset = tz . getOffset ( cal . get ( Calendar . ERA ) , cal . get ( Calendar . YEAR ) , cal . get ( Calendar . MONTH ) , cal . get ( Calendar . DAY_OF_MONTH ) , cal . get ( Calendar . DAY_OF_WEEK ) , cal . get ( Calendar . MILLISECOND ) ) ; StringBuffer tzMarker = new StringBuffer ( offset < 0 ? "-" : "+" ) ; offset = Math . abs ( offset ) ; int hours = offset / ( 60 * 60 * 1000 ) ; int minutes = offset / ( 60 * 1000 ) - 60 * hours ; if ( hours < 10 ) { tzMarker . append ( "0" ) ; } tzMarker . append ( hours ) ; if ( minutes < 10 ) { tzMarker . append ( "0" ) ; } tzMarker . append ( minutes ) ; return DATE_HEADER_FORMAT . format ( cal . getTime ( ) ) + tzMarker . toString ( ) ; } public static Date parseIso8601DateTime ( String datestr ) throws ParseException { return new SimpleDateFormat ( ISO8601_DATETIME_PATTERN ) . parse ( datestr ) ; } public static Date parseIso8601Date ( String datestr ) throws ParseException { return new SimpleDateFormat ( ISO8601_DATE_PATTERN ) . parse ( datestr ) ; } public static Date parseIso8601DateTimeOrDate ( String datestr ) throws ParseException { try { return parseIso8601DateTime ( datestr ) ; } catch ( ParseException px ) { return parseIso8601Date ( datestr ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamPumper implements Runnable { private InputStream is ; private OutputStream os ; private volatile boolean finish ; private volatile boolean finished ; private boolean closeWhenExhausted ; private boolean autoflush = false ; private Exception exception = null ; private int bufferSize = 128 ; private boolean started = false ; public StreamPumper ( InputStream is , OutputStream os , boolean closeWhenExhausted ) { this . is = is ; this . os = os ; this . closeWhenExhausted = closeWhenExhausted ; } public StreamPumper ( InputStream is , OutputStream os ) { this ( is , os , false ) ; } void setAutoflush ( boolean autoflush ) { this . autoflush = autoflush ; } public void run ( ) { synchronized ( this ) { started = true ; } finished = false ; finish = false ; final byte [ ] buf = new byte [ bufferSize ] ; int length ; try { while ( ( length = is . read ( buf ) ) > 0 && ! finish ) { os . write ( buf , 0 , length ) ; if ( autoflush ) { os . flush ( ) ; } } os . flush ( ) ; } catch ( Exception e ) { synchronized ( this ) { exception = e ; } } finally { if ( closeWhenExhausted ) { try { os . close ( ) ; } catch ( IOException e ) { } } finished = true ; synchronized ( this ) { notifyAll ( ) ; } } } public boolean isFinished ( ) { return finished ; } public synchronized void waitFor ( ) throws InterruptedException { while ( ! isFinished ( ) ) { wait ( ) ; } } public synchronized void setBufferSize ( int bufferSize ) { if ( started ) { throw new IllegalStateException ( "Cannot set buffer size on a running StreamPumper" ) ; } this . bufferSize = bufferSize ; } public synchronized int getBufferSize ( ) { return bufferSize ; } public synchronized Exception getException ( ) { return exception ; } synchronized void stop ( ) { finish = true ; notifyAll ( ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . Driver ; import java . sql . SQLException ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Locale ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public abstract class JDBCTask extends Task { private static Hashtable loaderMap = new Hashtable ( 3 ) ; private boolean caching = true ; private Path classpath ; private AntClassLoader loader ; private boolean autocommit = false ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private String rdbms = null ; private String version = null ; public void setClasspath ( Path classpath ) { this . classpath = classpath ; } public void setCaching ( boolean enable ) { caching = enable ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setDriver ( String driver ) { this . driver = driver . trim ( ) ; } public void setUrl ( String url ) { this . url = url ; } public void setPassword ( String password ) { this . password = password ; } public void setAutocommit ( boolean autocommit ) { this . autocommit = autocommit ; } public void setRdbms ( String rdbms ) { this . rdbms = rdbms ; } public void setVersion ( String version ) { this . version = version ; } protected boolean isValidRdbms ( Connection conn ) { if ( rdbms == null && version == null ) { return true ; } try { DatabaseMetaData dmd = conn . getMetaData ( ) ; if ( rdbms != null ) { String theVendor = dmd . getDatabaseProductName ( ) . toLowerCase ( ) ; log ( "RDBMS = " + theVendor , Project . MSG_VERBOSE ) ; if ( theVendor == null || theVendor . indexOf ( rdbms ) < 0 ) { log ( "Not the required RDBMS: " + rdbms , Project . MSG_VERBOSE ) ; return false ; } } if ( version != null ) { String theVersion = dmd . getDatabaseProductVersion ( ) . toLowerCase ( Locale . ENGLISH ) ; log ( "Version = " + theVersion , Project . MSG_VERBOSE ) ; if ( theVersion == null || ! ( theVersion . startsWith ( version ) || theVersion . indexOf ( " " + version ) >= 0 ) ) { log ( "Not the required version: \"" + version + "\"" , Project . MSG_VERBOSE ) ; return false ; } } } catch ( SQLException e ) { log ( "Failed to obtain required RDBMS information" , Project . MSG_ERR ) ; return false ; } return true ; } protected static Hashtable getLoaderMap ( ) { return loaderMap ; } protected AntClassLoader getLoader ( ) { return loader ; } protected Connection getConnection ( ) throws BuildException { if ( userId == null ) { throw new BuildException ( "UserId attribute must be set!" , getLocation ( ) ) ; } if ( password == null ) { throw new BuildException ( "Password attribute must be set!" , getLocation ( ) ) ; } if ( url == null ) { throw new BuildException ( "Url attribute must be set!" , getLocation ( ) ) ; } try { log ( "connecting to " + getUrl ( ) , Project . MSG_VERBOSE ) ; Properties info = new Properties ( ) ; info . put ( "user" , getUserId ( ) ) ; info . put ( "password" , getPassword ( ) ) ; Connection conn = getDriver ( ) . connect ( getUrl ( ) , info ) ; if ( conn == null ) { throw new SQLException ( "No suitable Driver for " + url ) ; } conn . setAutoCommit ( autocommit ) ; return conn ; } catch ( SQLException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private Driver getDriver ( ) throws BuildException { if ( driver == null ) { throw new BuildException ( "Driver attribute must be set!" , getLocation ( ) ) ; } Driver driverInstance = null ; try { Class dc ; if ( classpath != null ) { synchronized ( loaderMap ) { if ( caching ) { loader = ( AntClassLoader ) loaderMap . get ( driver ) ; } if ( loader == null ) { log ( "Loading " + driver + " using AntClassLoader with classpath " + classpath , Project . MSG_VERBOSE ) ; loader = getProject ( ) . createClassLoader ( classpath ) ; if ( caching ) { loaderMap . put ( driver , loader ) ; } } else { log ( "Loading " + driver + " using a cached AntClassLoader." , Project . MSG_VERBOSE ) ; } } dc = loader . loadClass ( driver ) ; } else { log ( "Loading " + driver + " using system loader." , Project . MSG_VERBOSE ) ; dc = Class . forName ( driver ) ; } driverInstance = ( Driver ) dc . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class Not Found: JDBC driver " + driver + " could not be loaded" , e , getLocation ( ) ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Illegal Access: JDBC driver " + driver + " could not be loaded" , e , getLocation ( ) ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Instantiation Exception: JDBC driver " + driver + " could not be loaded" , e , getLocation ( ) ) ; } return driverInstance ; } public void isCaching ( boolean value ) { caching = value ; } public Path getClasspath ( ) { return classpath ; } public boolean isAutocommit ( ) { return autocommit ; } public String getUrl ( ) { return url ; } public String getUserId ( ) { return userId ; } public void setUserid ( String userId ) { this . userId = userId ; } public String getPassword ( ) { return password ; } public String getRdbms ( ) { return rdbms ; } public String getVersion ( ) { return version ; } } 	1
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . util . Iterator ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . ClasspathUtils ; public class EmailTask extends Task { public static final String AUTO = "auto" ; public static final String MIME = "mime" ; public static final String UU = "uu" ; public static final String PLAIN = "plain" ; public static class Encoding extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { AUTO , MIME , UU , PLAIN } ; } } private String encoding = AUTO ; private String host = "localhost" ; private int port = 25 ; private String subject = null ; private Message message = null ; private boolean failOnError = true ; private boolean includeFileNames = false ; private String messageMimeType = null ; private EmailAddress from = null ; private Vector replyToList = new Vector ( ) ; private Vector toList = new Vector ( ) ; private Vector ccList = new Vector ( ) ; private Vector bccList = new Vector ( ) ; private Vector headers = new Vector ( ) ; private Path attachments = null ; private String charset = null ; private String user = null ; private String password = null ; private boolean ssl = false ; public void setUser ( String user ) { this . user = user ; } public void setPassword ( String password ) { this . password = password ; } public void setSSL ( boolean ssl ) { this . ssl = ssl ; } public void setEncoding ( Encoding encoding ) { this . encoding = encoding . getValue ( ) ; } public void setMailport ( int port ) { this . port = port ; } public void setMailhost ( String host ) { this . host = host ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setMessage ( String message ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( message ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageFile ( File file ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( file ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageMimeType ( String type ) { this . messageMimeType = type ; } public void addMessage ( Message message ) throws BuildException { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an email" ) ; } this . message = message ; } public void addFrom ( EmailAddress address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = address ; } public void setFrom ( String address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = new EmailAddress ( address ) ; } public void addReplyTo ( EmailAddress address ) { this . replyToList . add ( address ) ; } public void setReplyTo ( String address ) { this . replyToList . add ( new EmailAddress ( address ) ) ; } public void addTo ( EmailAddress address ) { toList . addElement ( address ) ; } public void setToList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { toList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addCc ( EmailAddress address ) { ccList . addElement ( address ) ; } public void setCcList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { ccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addBcc ( EmailAddress address ) { bccList . addElement ( address ) ; } public void setBccList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { bccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setFiles ( String filenames ) { StringTokenizer t = new StringTokenizer ( filenames , ", " ) ; while ( t . hasMoreTokens ( ) ) { createAttachments ( ) . add ( new FileResource ( getProject ( ) . resolveFile ( t . nextToken ( ) ) ) ) ; } } public void addFileset ( FileSet fs ) { createAttachments ( ) . add ( fs ) ; } public Path createAttachments ( ) { if ( attachments == null ) { attachments = new Path ( getProject ( ) ) ; } return attachments . createPath ( ) ; } public Header createHeader ( ) { Header h = new Header ( ) ; headers . add ( h ) ; return h ; } public void setIncludefilenames ( boolean includeFileNames ) { this . includeFileNames = includeFileNames ; } public boolean getIncludeFileNames ( ) { return includeFileNames ; } public void execute ( ) { Message savedMessage = message ; try { Mailer mailer = null ; boolean autoFound = false ; if ( encoding . equals ( MIME ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) ClasspathUtils . newInstance ( "org.apache.tools.ant.taskdefs.email.MimeMailer" , EmailTask . class . getClassLoader ( ) , Mailer . class ) ; autoFound = true ; log ( "Using MIME mail" , Project . MSG_VERBOSE ) ; } catch ( BuildException e ) { Throwable t = e . getCause ( ) == null ? e : e . getCause ( ) ; log ( "Failed to initialise MIME mail: " + t . getMessage ( ) , Project . MSG_WARN ) ; return ; } } if ( ! autoFound && ( ( user != null ) || ( password != null ) ) && ( encoding . equals ( UU ) || encoding . equals ( PLAIN ) ) ) { throw new BuildException ( "SMTP auth only possible with MIME mail" ) ; } if ( ! autoFound && ( ssl ) && ( encoding . equals ( UU ) || encoding . equals ( PLAIN ) ) ) { throw new BuildException ( "SSL only possible with MIME mail" ) ; } if ( encoding . equals ( UU ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) ClasspathUtils . newInstance ( "org.apache.tools.ant.taskdefs.email.UUMailer" , EmailTask . class . getClassLoader ( ) , Mailer . class ) ; autoFound = true ; log ( "Using UU mail" , Project . MSG_VERBOSE ) ; } catch ( BuildException e ) { Throwable t = e . getCause ( ) == null ? e : e . getCause ( ) ; log ( "Failed to initialise UU mail: " + t . getMessage ( ) , Project . MSG_WARN ) ; return ; } } if ( encoding . equals ( PLAIN ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { mailer = new PlainMailer ( ) ; autoFound = true ; log ( "Using plain mail" , Project . MSG_VERBOSE ) ; } if ( mailer == null ) { throw new BuildException ( "Failed to initialise encoding: " + encoding ) ; } if ( message == null ) { message = new Message ( ) ; message . setProject ( getProject ( ) ) ; } if ( from == null || from . getAddress ( ) == null ) { throw new BuildException ( "A from element is required" ) ; } if ( toList . isEmpty ( ) && ccList . isEmpty ( ) && bccList . isEmpty ( ) ) { throw new BuildException ( "At least one of to, cc or bcc must " + "be supplied" ) ; } if ( messageMimeType != null ) { if ( message . isMimeTypeSpecified ( ) ) { throw new BuildException ( "The mime type can only be " + "specified in one location" ) ; } message . setMimeType ( messageMimeType ) ; } if ( charset != null ) { if ( message . getCharset ( ) != null ) { throw new BuildException ( "The charset can only be " + "specified in one location" ) ; } message . setCharset ( charset ) ; } Vector files = new Vector ( ) ; if ( attachments != null ) { Iterator iter = attachments . iterator ( ) ; while ( iter . hasNext ( ) ) { FileResource fr = ( FileResource ) iter . next ( ) ; files . addElement ( fr . getFile ( ) ) ; } } log ( "Sending email: " + subject , Project . MSG_INFO ) ; log ( "From " + from , Project . MSG_VERBOSE ) ; log ( "ReplyTo " + replyToList , Project . MSG_VERBOSE ) ; log ( "To " + toList , Project . MSG_VERBOSE ) ; log ( "Cc " + ccList , Project . MSG_VERBOSE ) ; log ( "Bcc " + bccList , Project . MSG_VERBOSE ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setUser ( user ) ; mailer . setPassword ( password ) ; mailer . setSSL ( ssl ) ; mailer . setMessage ( message ) ; mailer . setFrom ( from ) ; mailer . setReplyToList ( replyToList ) ; mailer . setToList ( toList ) ; mailer . setCcList ( ccList ) ; mailer . setBccList ( bccList ) ; mailer . setFiles ( files ) ; mailer . setSubject ( subject ) ; mailer . setTask ( this ) ; mailer . setIncludeFileNames ( includeFileNames ) ; mailer . setHeaders ( headers ) ; mailer . send ( ) ; int count = files . size ( ) ; log ( "Sent email with " + count + " attachment" + ( count == 1 ? "" : "s" ) , Project . MSG_INFO ) ; } catch ( BuildException e ) { Throwable t = e . getCause ( ) == null ? e : e . getCause ( ) ; log ( "Failed to send email: " + t . getMessage ( ) , Project . MSG_WARN ) ; if ( failOnError ) { throw e ; } } catch ( Exception e ) { log ( "Failed to send email: " + e . getMessage ( ) , Project . MSG_WARN ) ; if ( failOnError ) { throw new BuildException ( e ) ; } } finally { message = savedMessage ; } } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } 	1
package org . apache . tools . ant ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Enumeration ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; public class XmlLogger implements BuildLogger { private int msgOutputLevel = Project . MSG_DEBUG ; private PrintStream outStream ; private static DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private static final String STACKTRACE_TAG = "stacktrace" ; private Document doc = builder . newDocument ( ) ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private TimedElement buildElement = null ; private static class TimedElement { private long startTime ; private Element element ; public String toString ( ) { return element . getTagName ( ) + ":" + element . getAttribute ( "name" ) ; } } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildElement = new TimedElement ( ) ; buildElement . startTime = System . currentTimeMillis ( ) ; buildElement . element = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildElement . startTime ; buildElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . element . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; Throwable t = event . getException ( ) ; Text errText = doc . createCDATASection ( StringUtils . getStackTrace ( t ) ) ; Element stacktrace = doc . createElement ( STACKTRACE_TAG ) ; stacktrace . appendChild ( errText ) ; buildElement . element . appendChild ( stacktrace ) ; } String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } String xslUri = event . getProject ( ) . getProperty ( "ant.XmlLogger.stylesheet.uri" ) ; if ( xslUri == null ) { xslUri = "log.xsl" ; } Writer out = null ; try { OutputStream stream = outStream ; if ( stream == null ) { stream = new FileOutputStream ( outFilename ) ; } out = new OutputStreamWriter ( stream , "UTF8" ) ; out . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; if ( xslUri . length ( ) > 0 ) { out . write ( "<?xml-stylesheet type=\"text/xsl\" href=\"" + xslUri + "\"?>\n\n" ) ; } ( new DOMElementWriter ( ) ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to write log file" , exc ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { } } } buildElement = null ; } private Stack getStack ( ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack == null ) { threadStack = new Stack ( ) ; threadStacks . put ( Thread . currentThread ( ) , threadStack ) ; } return threadStack ; } public void targetStarted ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = new TimedElement ( ) ; targetElement . startTime = System . currentTimeMillis ( ) ; targetElement . element = doc . createElement ( TARGET_TAG ) ; targetElement . element . setAttribute ( NAME_ATTR , target . getName ( ) ) ; targets . put ( target , targetElement ) ; getStack ( ) . push ( targetElement ) ; } public void targetFinished ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement != null ) { long totalTime = System . currentTimeMillis ( ) - targetElement . startTime ; targetElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; TimedElement parentElement = null ; Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != targetElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack + " finished target element = " + targetElement ) ; } if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } if ( parentElement == null ) { buildElement . element . appendChild ( targetElement . element ) ; } else { parentElement . element . appendChild ( targetElement . element ) ; } } targets . remove ( target ) ; } public void taskStarted ( BuildEvent event ) { TimedElement taskElement = new TimedElement ( ) ; taskElement . startTime = System . currentTimeMillis ( ) ; taskElement . element = doc . createElement ( TASK_TAG ) ; Task task = event . getTask ( ) ; String name = event . getTask ( ) . getTaskName ( ) ; if ( name == null ) { name = "" ; } taskElement . element . setAttribute ( NAME_ATTR , name ) ; taskElement . element . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; tasks . put ( task , taskElement ) ; getStack ( ) . push ( taskElement ) ; } public void taskFinished ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = ( TimedElement ) tasks . get ( task ) ; if ( taskElement != null ) { long totalTime = System . currentTimeMillis ( ) - taskElement . startTime ; taskElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; Target target = task . getOwningTarget ( ) ; TimedElement targetElement = null ; if ( target != null ) { targetElement = ( TimedElement ) targets . get ( target ) ; } if ( targetElement == null ) { buildElement . element . appendChild ( taskElement . element ) ; } else { targetElement . element . appendChild ( taskElement . element ) ; } Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != taskElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack + " finished task element = " + taskElement ) ; } } tasks . remove ( task ) ; } else { throw new RuntimeException ( "Unknown task " + task + " not in " + tasks ) ; } } private TimedElement getTaskElement ( Task task ) { TimedElement element = ( TimedElement ) tasks . get ( task ) ; if ( element != null ) { return element ; } for ( Enumeration e = tasks . keys ( ) ; e . hasMoreElements ( ) ; ) { Task key = ( Task ) e . nextElement ( ) ; if ( key instanceof UnknownElement ) { if ( ( ( UnknownElement ) key ) . getTask ( ) == task ) { return ( TimedElement ) tasks . get ( key ) ; } } } return null ; } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority > msgOutputLevel ) { return ; } Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Throwable ex = event . getException ( ) ; if ( Project . MSG_DEBUG <= msgOutputLevel && ex != null ) { Text errText = doc . createCDATASection ( StringUtils . getStackTrace ( ex ) ) ; Element stacktrace = doc . createElement ( STACKTRACE_TAG ) ; stacktrace . appendChild ( errText ) ; buildElement . element . appendChild ( stacktrace ) ; } Text messageText = doc . createCDATASection ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; TimedElement parentElement = null ; Task task = event . getTask ( ) ; Target target = event . getTarget ( ) ; if ( task != null ) { parentElement = getTaskElement ( task ) ; } if ( parentElement == null && target != null ) { parentElement = ( TimedElement ) targets . get ( target ) ; } if ( parentElement != null ) { parentElement . element . appendChild ( messageElement ) ; } else { buildElement . element . appendChild ( messageElement ) ; } } public void setMessageOutputLevel ( int level ) { msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . outStream = new PrintStream ( output , true ) ; } public void setEmacsMode ( boolean emacsMode ) { } public void setErrorPrintStream ( PrintStream err ) { } } 	1
package org . apache . tools . ant . taskdefs . rmic ; import java . io . File ; import java . util . Random ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; public abstract class DefaultRmicAdapter implements RmicAdapter { private Rmic attributes ; private FileNameMapper mapper ; private static final Random RAND = new Random ( ) ; public static final String RMI_STUB_SUFFIX = "_Stub" ; public static final String RMI_SKEL_SUFFIX = "_Skel" ; public static final String RMI_TIE_SUFFIX = "_Tie" ; public static final String STUB_COMPAT = "-vcompat" ; public static final String STUB_1_1 = "-v1.1" ; public static final String STUB_1_2 = "-v1.2" ; public DefaultRmicAdapter ( ) { } public void setRmic ( final Rmic attributes ) { this . attributes = attributes ; mapper = new RmicFileNameMapper ( ) ; } public Rmic getRmic ( ) { return attributes ; } protected String getStubClassSuffix ( ) { return RMI_STUB_SUFFIX ; } protected String getSkelClassSuffix ( ) { return RMI_SKEL_SUFFIX ; } protected String getTieClassSuffix ( ) { return RMI_TIE_SUFFIX ; } public FileNameMapper getMapper ( ) { return mapper ; } public Path getClasspath ( ) { return getCompileClasspath ( ) ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( attributes . getProject ( ) ) ; classpath . setLocation ( attributes . getBase ( ) ) ; Path cp = attributes . getClasspath ( ) ; if ( cp == null ) { cp = new Path ( attributes . getProject ( ) ) ; } if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( cp . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( cp . concatSystemClasspath ( "ignore" ) ) ; } if ( attributes . getIncludejavaruntime ( ) ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupRmicCommand ( ) { return setupRmicCommand ( null ) ; } protected Commandline setupRmicCommand ( String [ ] options ) { Commandline cmd = new Commandline ( ) ; if ( options != null ) { for ( int i = 0 ; i < options . length ; i ++ ) { cmd . createArgument ( ) . setValue ( options [ i ] ) ; } } Path classpath = getCompileClasspath ( ) ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( attributes . getBase ( ) ) ; if ( attributes . getExtdirs ( ) != null ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( attributes . getExtdirs ( ) ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; String stubVersion = attributes . getStubVersion ( ) ; String stubOption = null ; if ( null != stubVersion ) { if ( "1.1" . equals ( stubVersion ) ) { stubOption = STUB_1_1 ; } else if ( "1.2" . equals ( stubVersion ) ) { stubOption = STUB_1_2 ; } else if ( "compat" . equals ( stubVersion ) ) { stubOption = STUB_COMPAT ; } else { attributes . log ( "Unknown stub option " + stubVersion ) ; } } if ( stubOption == null && ! attributes . getIiop ( ) && ! attributes . getIdl ( ) ) { stubOption = STUB_COMPAT ; } if ( stubOption != null ) { cmd . createArgument ( ) . setValue ( stubOption ) ; } if ( null != attributes . getSourceBase ( ) ) { cmd . createArgument ( ) . setValue ( "-keepgenerated" ) ; } if ( attributes . getIiop ( ) ) { attributes . log ( "IIOP has been turned on." , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( "-iiop" ) ; if ( attributes . getIiopopts ( ) != null ) { attributes . log ( "IIOP Options: " + attributes . getIiopopts ( ) , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( attributes . getIiopopts ( ) ) ; } } if ( attributes . getIdl ( ) ) { cmd . createArgument ( ) . setValue ( "-idl" ) ; attributes . log ( "IDL has been turned on." , Project . MSG_INFO ) ; if ( attributes . getIdlopts ( ) != null ) { cmd . createArgument ( ) . setValue ( attributes . getIdlopts ( ) ) ; attributes . log ( "IDL Options: " + attributes . getIdlopts ( ) , Project . MSG_INFO ) ; } } if ( attributes . getDebug ( ) ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } cmd . addArguments ( attributes . getCurrentCompilerArgs ( ) ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { Vector compileList = attributes . getCompileList ( ) ; attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; int cListSize = compileList . size ( ) ; if ( cListSize != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; for ( int i = 0 ; i < cListSize ; i ++ ) { String arg = ( String ) compileList . elementAt ( i ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " ) ; niceSourceList . append ( arg ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } private class RmicFileNameMapper implements FileNameMapper { RmicFileNameMapper ( ) { } public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String name ) { if ( name == null || ! name . endsWith ( ".class" ) || name . endsWith ( getStubClassSuffix ( ) + ".class" ) || name . endsWith ( getSkelClassSuffix ( ) + ".class" ) || name . endsWith ( getTieClassSuffix ( ) + ".class" ) ) { return null ; } String base = name . substring ( 0 , name . length ( ) - 6 ) ; String classname = base . replace ( File . separatorChar , '.' ) ; if ( attributes . getVerify ( ) && ! attributes . isValidRmiRemote ( classname ) ) { return null ; } String [ ] target = new String [ ] { name + ".tmp." + RAND . nextLong ( ) } ; if ( ! attributes . getIiop ( ) && ! attributes . getIdl ( ) ) { if ( "1.2" . equals ( attributes . getStubVersion ( ) ) ) { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" } ; } else { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" , base + getSkelClassSuffix ( ) + ".class" , } ; } } else if ( ! attributes . getIdl ( ) ) { int lastSlash = base . lastIndexOf ( File . separatorChar ) ; String dirname = "" ; int index = - 1 ; if ( lastSlash == - 1 ) { index = 0 ; } else { index = lastSlash + 1 ; dirname = base . substring ( 0 , index ) ; } String filename = base . substring ( index ) ; try { Class c = attributes . getLoader ( ) . loadClass ( classname ) ; if ( c . isInterface ( ) ) { target = new String [ ] { dirname + "_" + filename + getStubClassSuffix ( ) + ".class" } ; } else { Class interf = attributes . getRemoteInterface ( c ) ; String iName = interf . getName ( ) ; String iDir = "" ; int iIndex = - 1 ; int lastDot = iName . lastIndexOf ( "." ) ; if ( lastDot == - 1 ) { iIndex = 0 ; } else { iIndex = lastDot + 1 ; iDir = iName . substring ( 0 , iIndex ) ; iDir = iDir . replace ( '.' , File . separatorChar ) ; } target = new String [ ] { dirname + "_" + filename + getTieClassSuffix ( ) + ".class" , iDir + "_" + iName . substring ( iIndex ) + getStubClassSuffix ( ) + ".class" } ; } } catch ( ClassNotFoundException e ) { attributes . log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { attributes . log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { attributes . log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } return target ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Arrays ; import java . util . Vector ; import java . util . Iterator ; import java . util . Comparator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Sort ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . FileResourceIterator ; import org . apache . tools . ant . types . resources . comparators . Reverse ; import org . apache . tools . ant . types . resources . comparators . FileSystem ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public class Delete extends MatchingTask { private static final int DELETE_RETRY_SLEEP_MILLIS = 10 ; private static final ResourceComparator REVERSE_FILESYSTEM = new Reverse ( new FileSystem ( ) ) ; private static final ResourceSelector EXISTS = new Exists ( ) ; private static class ReverseDirs implements ResourceCollection { static final Comparator REVERSE = new Comparator ( ) { public int compare ( Object foo , Object bar ) { return ( ( Comparable ) foo ) . compareTo ( bar ) * - 1 ; } } ; private File basedir ; private String [ ] dirs ; ReverseDirs ( File basedir , String [ ] dirs ) { this . basedir = basedir ; this . dirs = dirs ; Arrays . sort ( this . dirs , REVERSE ) ; } public Iterator iterator ( ) { return new FileResourceIterator ( basedir , dirs ) ; } public boolean isFilesystemOnly ( ) { return true ; } public int size ( ) { return dirs . length ; } } protected File file = null ; protected File dir = null ; protected Vector filesets = new Vector ( ) ; protected boolean usedMatchingTask = false ; protected boolean includeEmpty = false ; private int verbosity = Project . MSG_VERBOSE ; private boolean quiet = false ; private boolean failonerror = true ; private boolean deleteOnExit = false ; private Resources rcs = null ; public void setFile ( File file ) { this . file = file ; } public void setDir ( File dir ) { this . dir = dir ; getImplicitFileSet ( ) . setDir ( dir ) ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . failonerror = false ; } } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void setDeleteOnExit ( boolean deleteOnExit ) { this . deleteOnExit = deleteOnExit ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void add ( ResourceCollection rc ) { if ( rc == null ) { return ; } rcs = ( rcs == null ) ? new Resources ( ) : rcs ; rcs . add ( rc ) ; } public PatternSet . NameEntry createInclude ( ) { usedMatchingTask = true ; return super . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { usedMatchingTask = true ; return super . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { usedMatchingTask = true ; return super . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { usedMatchingTask = true ; return super . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { usedMatchingTask = true ; return super . createPatternSet ( ) ; } public void setIncludes ( String includes ) { usedMatchingTask = true ; super . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { usedMatchingTask = true ; super . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { usedMatchingTask = true ; super . setDefaultexcludes ( useDefaultExcludes ) ; } public void setIncludesfile ( File includesfile ) { usedMatchingTask = true ; super . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { usedMatchingTask = true ; super . setExcludesfile ( excludesfile ) ; } public void setCaseSensitive ( boolean isCaseSensitive ) { usedMatchingTask = true ; super . setCaseSensitive ( isCaseSensitive ) ; } public void setFollowSymlinks ( boolean followSymlinks ) { usedMatchingTask = true ; super . setFollowSymlinks ( followSymlinks ) ; } public void addSelector ( SelectSelector selector ) { usedMatchingTask = true ; super . addSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { usedMatchingTask = true ; super . addAnd ( selector ) ; } public void addOr ( OrSelector selector ) { usedMatchingTask = true ; super . addOr ( selector ) ; } public void addNot ( NotSelector selector ) { usedMatchingTask = true ; super . addNot ( selector ) ; } public void addNone ( NoneSelector selector ) { usedMatchingTask = true ; super . addNone ( selector ) ; } public void addMajority ( MajoritySelector selector ) { usedMatchingTask = true ; super . addMajority ( selector ) ; } public void addDate ( DateSelector selector ) { usedMatchingTask = true ; super . addDate ( selector ) ; } public void addSize ( SizeSelector selector ) { usedMatchingTask = true ; super . addSize ( selector ) ; } public void addFilename ( FilenameSelector selector ) { usedMatchingTask = true ; super . addFilename ( selector ) ; } public void addCustom ( ExtendSelector selector ) { usedMatchingTask = true ; super . addCustom ( selector ) ; } public void addContains ( ContainsSelector selector ) { usedMatchingTask = true ; super . addContains ( selector ) ; } public void addPresent ( PresentSelector selector ) { usedMatchingTask = true ; super . addPresent ( selector ) ; } public void addDepth ( DepthSelector selector ) { usedMatchingTask = true ; super . addDepth ( selector ) ; } public void addDepend ( DependSelector selector ) { usedMatchingTask = true ; super . addDepend ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { usedMatchingTask = true ; super . addContainsRegexp ( selector ) ; } public void addModified ( ModifiedSelector selector ) { usedMatchingTask = true ; super . addModified ( selector ) ; } public void add ( FileSelector selector ) { usedMatchingTask = true ; super . add ( selector ) ; } public void execute ( ) throws BuildException { if ( usedMatchingTask ) { log ( "DEPRECATED - Use of the implicit FileSet is deprecated.  " + "Use a nested fileset element instead." , quiet ? Project . MSG_VERBOSE : verbosity ) ; } if ( file == null && dir == null && filesets . size ( ) == 0 && rcs == null ) { throw new BuildException ( "At least one of the file or dir " + "attributes, or a nested resource collection, " + "must be set." ) ; } if ( quiet && failonerror ) { throw new BuildException ( "quiet and failonerror cannot both be " + "set to true" , getLocation ( ) ) ; } if ( file != null ) { if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { log ( "Directory " + file . getAbsolutePath ( ) + " cannot be removed using the file attribute.  " + "Use dir instead." , quiet ? Project . MSG_VERBOSE : verbosity ) ; } else { log ( "Deleting: " + file . getAbsolutePath ( ) ) ; if ( ! delete ( file ) ) { handle ( "Unable to delete file " + file . getAbsolutePath ( ) ) ; } } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to delete." , quiet ? Project . MSG_VERBOSE : verbosity ) ; } } if ( dir != null && dir . exists ( ) && dir . isDirectory ( ) && ! usedMatchingTask ) { if ( verbosity == Project . MSG_VERBOSE ) { log ( "Deleting directory " + dir . getAbsolutePath ( ) ) ; } removeDir ( dir ) ; } Resources resourcesToDelete = new Resources ( ) ; resourcesToDelete . setProject ( getProject ( ) ) ; Resources filesetDirs = new Resources ( ) ; filesetDirs . setProject ( getProject ( ) ) ; FileSet implicit = null ; if ( usedMatchingTask && dir != null && dir . isDirectory ( ) ) { implicit = getImplicitFileSet ( ) ; implicit . setProject ( getProject ( ) ) ; filesets . add ( implicit ) ; } for ( int i = 0 , size = filesets . size ( ) ; i < size ; i ++ ) { FileSet fs = ( FileSet ) filesets . get ( i ) ; if ( fs . getProject ( ) == null ) { log ( "Deleting fileset with no project specified;" + " assuming executing project" , Project . MSG_VERBOSE ) ; fs = ( FileSet ) fs . clone ( ) ; fs . setProject ( getProject ( ) ) ; } if ( ! fs . getDir ( ) . isDirectory ( ) ) { handle ( "Directory does not exist:" + fs . getDir ( ) ) ; } else { resourcesToDelete . add ( fs ) ; if ( includeEmpty ) { filesetDirs . add ( new ReverseDirs ( fs . getDir ( ) , fs . getDirectoryScanner ( ) . getIncludedDirectories ( ) ) ) ; } } } resourcesToDelete . add ( filesetDirs ) ; if ( rcs != null ) { Restrict exists = new Restrict ( ) ; exists . add ( EXISTS ) ; exists . add ( rcs ) ; Sort s = new Sort ( ) ; s . add ( REVERSE_FILESYSTEM ) ; s . add ( exists ) ; resourcesToDelete . add ( s ) ; } try { if ( resourcesToDelete . isFilesystemOnly ( ) ) { for ( Iterator iter = resourcesToDelete . iterator ( ) ; iter . hasNext ( ) ; ) { FileResource r = ( FileResource ) iter . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } if ( ! ( r . isDirectory ( ) ) || r . getFile ( ) . list ( ) . length == 0 ) { log ( "Deleting " + r , verbosity ) ; if ( ! delete ( r . getFile ( ) ) && failonerror ) { handle ( "Unable to delete " + ( r . isDirectory ( ) ? "directory " : "file " ) + r ) ; } } } } else { handle ( getTaskName ( ) + " handles only filesystem resources" ) ; } } catch ( Exception e ) { handle ( e ) ; } finally { if ( implicit != null ) { filesets . remove ( implicit ) ; } } } private void handle ( String msg ) { handle ( new BuildException ( msg ) ) ; } private void handle ( Exception e ) { if ( failonerror ) { throw ( e instanceof BuildException ) ? ( BuildException ) e : new BuildException ( e ) ; } log ( e , quiet ? Project . MSG_VERBOSE : verbosity ) ; } private boolean delete ( File f ) { if ( ! f . delete ( ) ) { if ( Os . isFamily ( "windows" ) ) { System . gc ( ) ; } try { Thread . sleep ( DELETE_RETRY_SLEEP_MILLIS ) ; } catch ( InterruptedException ex ) { } if ( ! f . delete ( ) ) { if ( deleteOnExit ) { int level = quiet ? Project . MSG_VERBOSE : Project . MSG_INFO ; log ( "Failed to delete " + f + ", calling deleteOnExit." + " This attempts to delete the file when the Ant jvm" + " has exited and might not succeed." , level ) ; f . deleteOnExit ( ) ; return true ; } return false ; } } return true ; } protected void removeDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { list = new String [ 0 ] ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { log ( "Deleting " + f . getAbsolutePath ( ) , quiet ? Project . MSG_VERBOSE : verbosity ) ; if ( ! delete ( f ) ) { handle ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! delete ( d ) ) { handle ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } protected void removeFiles ( File d , String [ ] files , String [ ] dirs ) { if ( files . length > 0 ) { log ( "Deleting " + files . length + " files from " + d . getAbsolutePath ( ) , quiet ? Project . MSG_VERBOSE : verbosity ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( d , files [ j ] ) ; log ( "Deleting " + f . getAbsolutePath ( ) , quiet ? Project . MSG_VERBOSE : verbosity ) ; if ( ! delete ( f ) ) { handle ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( dirs . length > 0 && includeEmpty ) { int dirCount = 0 ; for ( int j = dirs . length - 1 ; j >= 0 ; j -- ) { File currDir = new File ( d , dirs [ j ] ) ; String [ ] dirFiles = currDir . list ( ) ; if ( dirFiles == null || dirFiles . length == 0 ) { log ( "Deleting " + currDir . getAbsolutePath ( ) , quiet ? Project . MSG_VERBOSE : verbosity ) ; if ( ! delete ( currDir ) ) { handle ( "Unable to delete directory " + currDir . getAbsolutePath ( ) ) ; } else { dirCount ++ ; } } } if ( dirCount > 0 ) { log ( "Deleted " + dirCount + " director" + ( dirCount == 1 ? "y" : "ies" ) + " form " + d . getAbsolutePath ( ) , quiet ? Project . MSG_VERBOSE : verbosity ) ; } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import org . xml . sax . EntityResolver ; public class XmlProperty extends org . apache . tools . ant . Task { private Resource src ; private String prefix = "" ; private boolean keepRoot = true ; private boolean validate = false ; private boolean collapseAttributes = false ; private boolean semanticAttributes = false ; private boolean includeSemanticAttribute = false ; private File rootDirectory = null ; private Hashtable addedAttributes = new Hashtable ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; private static final String ID = "id" ; private static final String REF_ID = "refid" ; private static final String LOCATION = "location" ; private static final String VALUE = "value" ; private static final String PATH = "path" ; private static final String PATHID = "pathid" ; private static final String [ ] ATTRIBUTES = new String [ ] { ID , REF_ID , LOCATION , VALUE , PATH , PATHID } ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public XmlProperty ( ) { super ( ) ; } public void init ( ) { super . init ( ) ; xmlCatalog . setProject ( getProject ( ) ) ; } protected EntityResolver getEntityResolver ( ) { return xmlCatalog ; } public void execute ( ) throws BuildException { Resource r = getResource ( ) ; if ( r == null ) { String msg = "XmlProperty task requires a source resource" ; throw new BuildException ( msg ) ; } try { log ( "Loading " + src , Project . MSG_VERBOSE ) ; if ( r . isExists ( ) ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setValidating ( validate ) ; factory . setNamespaceAware ( false ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; builder . setEntityResolver ( getEntityResolver ( ) ) ; Document document = null ; if ( src instanceof FileResource ) { document = builder . parse ( ( ( FileResource ) src ) . getFile ( ) ) ; } else { document = builder . parse ( src . getInputStream ( ) ) ; } Element topElement = document . getDocumentElement ( ) ; addedAttributes = new Hashtable ( ) ; if ( keepRoot ) { addNodeRecursively ( topElement , prefix , null ) ; } else { NodeList topChildren = topElement . getChildNodes ( ) ; int numChildren = topChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( topChildren . item ( i ) , prefix , null ) ; } } } else { log ( "Unable to find property resource: " + r , Project . MSG_VERBOSE ) ; } } catch ( SAXException sxe ) { Exception x = sxe ; if ( sxe . getException ( ) != null ) { x = sxe . getException ( ) ; } throw new BuildException ( "Failed to load " + src , x ) ; } catch ( ParserConfigurationException pce ) { throw new BuildException ( pce ) ; } catch ( IOException ioe ) { throw new BuildException ( "Failed to load " + src , ioe ) ; } } private void addNodeRecursively ( Node node , String prefix , Object container ) { String nodePrefix = prefix ; if ( node . getNodeType ( ) != Node . TEXT_NODE ) { if ( prefix . trim ( ) . length ( ) > 0 ) { nodePrefix += "." ; } nodePrefix += node . getNodeName ( ) ; } Object nodeObject = processNode ( node , nodePrefix , container ) ; if ( node . hasChildNodes ( ) ) { NodeList nodeChildren = node . getChildNodes ( ) ; int numChildren = nodeChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( nodeChildren . item ( i ) , nodePrefix , nodeObject ) ; } } } void addNodeRecursively ( org . w3c . dom . Node node , String prefix ) { addNodeRecursively ( node , prefix , null ) ; } public Object processNode ( Node node , String prefix , Object container ) { Object addedPath = null ; String id = null ; if ( node . hasAttributes ( ) ) { NamedNodeMap nodeAttributes = node . getAttributes ( ) ; Node idNode = nodeAttributes . getNamedItem ( ID ) ; id = ( semanticAttributes && idNode != null ? idNode . getNodeValue ( ) : null ) ; for ( int i = 0 ; i < nodeAttributes . getLength ( ) ; i ++ ) { Node attributeNode = nodeAttributes . item ( i ) ; if ( ! semanticAttributes ) { String attributeName = getAttributeName ( attributeNode ) ; String attributeValue = getAttributeValue ( attributeNode ) ; addProperty ( prefix + attributeName , attributeValue , null ) ; } else { String nodeName = attributeNode . getNodeName ( ) ; String attributeValue = getAttributeValue ( attributeNode ) ; Path containingPath = ( container != null && container instanceof Path ? ( Path ) container : null ) ; if ( nodeName . equals ( ID ) ) { continue ; } else if ( containingPath != null && nodeName . equals ( PATH ) ) { containingPath . setPath ( attributeValue ) ; } else if ( container instanceof Path && nodeName . equals ( REF_ID ) ) { containingPath . setPath ( attributeValue ) ; } else if ( container instanceof Path && nodeName . equals ( LOCATION ) ) { containingPath . setLocation ( resolveFile ( attributeValue ) ) ; } else if ( nodeName . equals ( PATHID ) ) { if ( container != null ) { throw new BuildException ( "XmlProperty does not " + "support nested paths" ) ; } addedPath = new Path ( getProject ( ) ) ; getProject ( ) . addReference ( attributeValue , addedPath ) ; } else { String attributeName = getAttributeName ( attributeNode ) ; addProperty ( prefix + attributeName , attributeValue , id ) ; } } } } String nodeText = null ; boolean emptyNode = false ; boolean semanticEmptyOverride = false ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE && semanticAttributes && node . hasAttributes ( ) && ( node . getAttributes ( ) . getNamedItem ( VALUE ) != null || node . getAttributes ( ) . getNamedItem ( LOCATION ) != null || node . getAttributes ( ) . getNamedItem ( REF_ID ) != null || node . getAttributes ( ) . getNamedItem ( PATH ) != null || node . getAttributes ( ) . getNamedItem ( PATHID ) != null ) ) { semanticEmptyOverride = true ; } if ( node . getNodeType ( ) == Node . TEXT_NODE ) { nodeText = getAttributeValue ( node ) ; } else if ( ( node . getNodeType ( ) == Node . ELEMENT_NODE ) && ( node . getChildNodes ( ) . getLength ( ) == 1 ) && ( node . getFirstChild ( ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) ) { nodeText = node . getFirstChild ( ) . getNodeValue ( ) ; if ( "" . equals ( nodeText ) && ! semanticEmptyOverride ) { emptyNode = true ; } } else if ( ( node . getNodeType ( ) == Node . ELEMENT_NODE ) && ( node . getChildNodes ( ) . getLength ( ) == 0 ) && ! semanticEmptyOverride ) { nodeText = "" ; emptyNode = true ; } else if ( ( node . getNodeType ( ) == Node . ELEMENT_NODE ) && ( node . getChildNodes ( ) . getLength ( ) == 1 ) && ( node . getFirstChild ( ) . getNodeType ( ) == Node . TEXT_NODE ) && ( "" . equals ( node . getFirstChild ( ) . getNodeValue ( ) ) ) && ! semanticEmptyOverride ) { nodeText = "" ; emptyNode = true ; } if ( nodeText != null ) { if ( semanticAttributes && id == null && container instanceof String ) { id = ( String ) container ; } if ( nodeText . trim ( ) . length ( ) != 0 || emptyNode ) { addProperty ( prefix , nodeText , id ) ; } } return ( addedPath != null ? addedPath : id ) ; } private void addProperty ( String name , String value , String id ) { String msg = name + ":" + value ; if ( id != null ) { msg += ( "(id=" + id + ")" ) ; } log ( msg , Project . MSG_DEBUG ) ; if ( addedAttributes . containsKey ( name ) ) { value = ( String ) addedAttributes . get ( name ) + "," + value ; getProject ( ) . setProperty ( name , value ) ; addedAttributes . put ( name , value ) ; } else if ( getProject ( ) . getProperty ( name ) == null ) { getProject ( ) . setNewProperty ( name , value ) ; addedAttributes . put ( name , value ) ; } else { log ( "Override ignored for property " + name , Project . MSG_VERBOSE ) ; } if ( id != null ) { getProject ( ) . addReference ( id , value ) ; } } private String getAttributeName ( Node attributeNode ) { String attributeName = attributeNode . getNodeName ( ) ; if ( semanticAttributes ) { if ( attributeName . equals ( REF_ID ) ) { return "" ; } else if ( ! isSemanticAttribute ( attributeName ) || includeSemanticAttribute ) { return "." + attributeName ; } else { return "" ; } } else if ( collapseAttributes ) { return "." + attributeName ; } else { return "(" + attributeName + ")" ; } } private static boolean isSemanticAttribute ( String attributeName ) { for ( int i = 0 ; i < ATTRIBUTES . length ; i ++ ) { if ( attributeName . equals ( ATTRIBUTES [ i ] ) ) { return true ; } } return false ; } private String getAttributeValue ( Node attributeNode ) { String nodeValue = attributeNode . getNodeValue ( ) . trim ( ) ; if ( semanticAttributes ) { String attributeName = attributeNode . getNodeName ( ) ; nodeValue = getProject ( ) . replaceProperties ( nodeValue ) ; if ( attributeName . equals ( LOCATION ) ) { File f = resolveFile ( nodeValue ) ; return f . getPath ( ) ; } else if ( attributeName . equals ( REF_ID ) ) { Object ref = getProject ( ) . getReference ( nodeValue ) ; if ( ref != null ) { return ref . toString ( ) ; } } } return nodeValue ; } public void setFile ( File src ) { setSrcResource ( new FileResource ( src ) ) ; } public void setSrcResource ( Resource src ) { if ( src . isDirectory ( ) ) { throw new BuildException ( "the source can't be a directory" ) ; } if ( src instanceof FileResource && ! supportsNonFileResources ( ) ) { throw new BuildException ( "Only FileSystem resources are" + " supported." ) ; } this . src = src ; } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } public void setPrefix ( String prefix ) { this . prefix = prefix . trim ( ) ; } public void setKeeproot ( boolean keepRoot ) { this . keepRoot = keepRoot ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public void setCollapseAttributes ( boolean collapseAttributes ) { this . collapseAttributes = collapseAttributes ; } public void setSemanticAttributes ( boolean semanticAttributes ) { this . semanticAttributes = semanticAttributes ; } public void setRootDirectory ( File rootDirectory ) { this . rootDirectory = rootDirectory ; } public void setIncludeSemanticAttribute ( boolean includeSemanticAttribute ) { this . includeSemanticAttribute = includeSemanticAttribute ; } public void addConfiguredXMLCatalog ( XMLCatalog catalog ) { xmlCatalog . addConfiguredXMLCatalog ( catalog ) ; } protected File getFile ( ) { if ( src instanceof FileResource ) { return ( ( FileResource ) src ) . getFile ( ) ; } else { return null ; } } protected Resource getResource ( ) { File f = getFile ( ) ; if ( f != null ) { return new FileResource ( f ) ; } else { return src ; } } protected String getPrefix ( ) { return this . prefix ; } protected boolean getKeeproot ( ) { return this . keepRoot ; } protected boolean getValidate ( ) { return this . validate ; } protected boolean getCollapseAttributes ( ) { return this . collapseAttributes ; } protected boolean getSemanticAttributes ( ) { return this . semanticAttributes ; } protected File getRootDirectory ( ) { return this . rootDirectory ; } protected boolean getIncludeSementicAttribute ( ) { return this . includeSemanticAttribute ; } private File resolveFile ( String fileName ) { if ( rootDirectory == null ) { return FILE_UTILS . resolveFile ( getProject ( ) . getBaseDir ( ) , fileName ) ; } return FILE_UTILS . resolveFile ( rootDirectory , fileName ) ; } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( XmlProperty . class ) ; } } 	1
package org . apache . tools . ant ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import java . util . HashMap ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . launch . AntMain ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . ProxySetup ; public class Main implements AntMain { public static final String DEFAULT_BUILD_FILENAME = "build.xml" ; private int msgOutputLevel = Project . MSG_INFO ; private File buildFile ; private static PrintStream out = System . out ; private static PrintStream err = System . err ; private Vector targets = new Vector ( ) ; private Properties definedProps = new Properties ( ) ; private Vector listeners = new Vector ( 1 ) ; private Vector propertyFiles = new Vector ( 1 ) ; private boolean allowInput = true ; private boolean keepGoingMode = false ; private String loggerClassname = null ; private String inputHandlerClassname = null ; private boolean emacsMode = false ; private boolean readyToRun = false ; private boolean projectHelp = false ; private static boolean isLogFileUsed = false ; private Integer threadPriority = null ; private boolean proxy = false ; private static void printMessage ( Throwable t ) { String message = t . getMessage ( ) ; if ( message != null ) { System . err . println ( message ) ; } } public static void start ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { Main m = new Main ( ) ; m . startAnt ( args , additionalUserProperties , coreLoader ) ; } public void startAnt ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { try { Diagnostics . validateVersion ( ) ; processArgs ( args ) ; } catch ( Throwable exc ) { handleLogfile ( ) ; printMessage ( exc ) ; exit ( 1 ) ; return ; } if ( additionalUserProperties != null ) { for ( Enumeration e = additionalUserProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String property = additionalUserProperties . getProperty ( key ) ; definedProps . put ( key , property ) ; } } int exitCode = 1 ; try { try { runBuild ( coreLoader ) ; exitCode = 0 ; } catch ( ExitStatusException ese ) { exitCode = ese . getStatus ( ) ; if ( exitCode != 0 ) { throw ese ; } } } catch ( BuildException be ) { if ( err != System . err ) { printMessage ( be ) ; } } catch ( Throwable exc ) { exc . printStackTrace ( ) ; printMessage ( exc ) ; } finally { handleLogfile ( ) ; } exit ( exitCode ) ; } protected void exit ( int exitCode ) { System . exit ( exitCode ) ; } private static void handleLogfile ( ) { if ( isLogFileUsed ) { FileUtils . close ( out ) ; FileUtils . close ( err ) ; } } public static void main ( String [ ] args ) { start ( args , null , null ) ; } public Main ( ) { } protected Main ( String [ ] args ) throws BuildException { processArgs ( args ) ; } private void processArgs ( String [ ] args ) { String searchForThis = null ; PrintStream logTo = null ; HashMap launchCommands = new HashMap ( ) ; launchCommands . put ( "-lib" , "" ) ; launchCommands . put ( "-cp" , "" ) ; launchCommands . put ( "-noclasspath" , "" ) ; launchCommands . put ( "--noclasspath" , "" ) ; launchCommands . put ( "-nouserlib" , "" ) ; launchCommands . put ( "--nouserlib" , "" ) ; launchCommands . put ( "-main" , "" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( "-help" ) || arg . equals ( "-h" ) ) { printUsage ( ) ; return ; } else if ( arg . equals ( "-version" ) ) { printVersion ( ) ; return ; } else if ( arg . equals ( "-diagnostics" ) ) { Diagnostics . doReport ( System . out ) ; return ; } else if ( arg . equals ( "-quiet" ) || arg . equals ( "-q" ) ) { msgOutputLevel = Project . MSG_WARN ; } else if ( arg . equals ( "-verbose" ) || arg . equals ( "-v" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_VERBOSE ; } else if ( arg . equals ( "-debug" ) || arg . equals ( "-d" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_DEBUG ; } else if ( arg . equals ( "-noinput" ) ) { allowInput = false ; } else if ( arg . equals ( "-logfile" ) || arg . equals ( "-l" ) ) { try { File logFile = new File ( args [ i + 1 ] ) ; i ++ ; logTo = new PrintStream ( new FileOutputStream ( logFile ) ) ; isLogFileUsed = true ; } catch ( IOException ioe ) { String msg = "Cannot write on the specified log file. " + "Make sure the path exists and you have write " + "permissions." ; throw new BuildException ( msg ) ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a log file when " + "using the -log argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-buildfile" ) || arg . equals ( "-file" ) || arg . equals ( "-f" ) ) { try { buildFile = new File ( args [ i + 1 ] . replace ( '/' , File . separatorChar ) ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a buildfile when " + "using the -buildfile argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-listener" ) ) { try { listeners . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a classname when " + "using the -listener argument" ; throw new BuildException ( msg ) ; } } else if ( arg . startsWith ( "-D" ) ) { String name = arg . substring ( 2 , arg . length ( ) ) ; String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( posEq + 1 ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < args . length - 1 ) { value = args [ ++ i ] ; } else { throw new BuildException ( "Missing value for property " + name ) ; } definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( loggerClassname != null ) { throw new BuildException ( "Only one logger class may " + " be specified." ) ; } try { loggerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( "You must specify a classname when" + " using the -logger argument" ) ; } } else if ( arg . equals ( "-inputhandler" ) ) { if ( inputHandlerClassname != null ) { throw new BuildException ( "Only one input handler class may " + "be specified." ) ; } try { inputHandlerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( "You must specify a classname when" + " using the -inputhandler" + " argument" ) ; } } else if ( arg . equals ( "-emacs" ) || arg . equals ( "-e" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) || arg . equals ( "-p" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) || arg . equals ( "-s" ) ) { if ( i < args . length - 1 ) { searchForThis = args [ ++ i ] ; } else { searchForThis = DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-propertyfile" ) ) { try { propertyFiles . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a property filename when " + "using the -propertyfile argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-k" ) || arg . equals ( "-keep-going" ) ) { keepGoingMode = true ; } else if ( arg . equals ( "-nice" ) ) { try { threadPriority = Integer . decode ( args [ i + 1 ] ) ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( "You must supply a niceness value (1-10)" + " after the -nice option" ) ; } catch ( NumberFormatException e ) { throw new BuildException ( "Unrecognized niceness value: " + args [ i + 1 ] ) ; } i ++ ; if ( threadPriority . intValue ( ) < Thread . MIN_PRIORITY || threadPriority . intValue ( ) > Thread . MAX_PRIORITY ) { throw new BuildException ( "Niceness value is out of the range 1-10" ) ; } } else if ( launchCommands . get ( arg ) != null ) { String msg = "Ant's Main method is being handed " + "an option " + arg + " that is only for the launcher class." + "\nThis can be caused by a version mismatch between " + "the ant script/.bat file and Ant itself." ; throw new BuildException ( msg ) ; } else if ( arg . equals ( "-autoproxy" ) ) { proxy = false ; } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown argument: " + arg ; System . err . println ( msg ) ; printUsage ( ) ; throw new BuildException ( "" ) ; } else { targets . addElement ( arg ) ; } } if ( buildFile == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( System . getProperty ( "user.dir" ) , searchForThis ) ; } else { buildFile = new File ( DEFAULT_BUILD_FILENAME ) ; } } if ( ! buildFile . exists ( ) ) { System . out . println ( "Buildfile: " + buildFile + " does not exist!" ) ; throw new BuildException ( "Build failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( "What? Buildfile: " + buildFile + " is a dir!" ) ; throw new BuildException ( "Build failed" ) ; } for ( int propertyFileIndex = 0 ; propertyFileIndex < propertyFiles . size ( ) ; propertyFileIndex ++ ) { String filename = ( String ) propertyFiles . elementAt ( propertyFileIndex ) ; Properties props = new Properties ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( filename ) ; props . load ( fis ) ; } catch ( IOException e ) { System . out . println ( "Could not load property file " + filename + ": " + e . getMessage ( ) ) ; } finally { FileUtils . close ( fis ) ; } Enumeration propertyNames = props . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String name = ( String ) propertyNames . nextElement ( ) ; if ( definedProps . getProperty ( name ) == null ) { definedProps . put ( name , props . getProperty ( name ) ) ; } } } if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Buildfile: " + buildFile ) ; } if ( logTo != null ) { out = logTo ; err = logTo ; System . setOut ( out ) ; System . setErr ( err ) ; } readyToRun = true ; } private File getParentFile ( File file ) { File parent = file . getParentFile ( ) ; if ( parent != null && msgOutputLevel >= Project . MSG_VERBOSE ) { System . out . println ( "Searching in " + parent . getAbsolutePath ( ) ) ; } return parent ; } private File findBuildFile ( String start , String suffix ) throws BuildException { if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Searching for " + suffix + " ..." ) ; } File parent = new File ( new File ( start ) . getAbsolutePath ( ) ) ; File file = new File ( parent , suffix ) ; while ( ! file . exists ( ) ) { parent = getParentFile ( parent ) ; if ( parent == null ) { throw new BuildException ( "Could not locate a build file!" ) ; } file = new File ( parent , suffix ) ; } return file ; } private void runBuild ( ClassLoader coreLoader ) throws BuildException { if ( ! readyToRun ) { return ; } final Project project = new Project ( ) ; project . setCoreLoader ( coreLoader ) ; Throwable error = null ; try { addBuildListeners ( project ) ; addInputHandler ( project ) ; PrintStream savedErr = System . err ; PrintStream savedOut = System . out ; InputStream savedIn = System . in ; SecurityManager oldsm = null ; oldsm = System . getSecurityManager ( ) ; try { if ( allowInput ) { project . setDefaultInputStream ( System . in ) ; } System . setIn ( new DemuxInputStream ( project ) ) ; System . setOut ( new PrintStream ( new DemuxOutputStream ( project , false ) ) ) ; System . setErr ( new PrintStream ( new DemuxOutputStream ( project , true ) ) ) ; if ( ! projectHelp ) { project . fireBuildStarted ( ) ; } if ( threadPriority != null ) { try { project . log ( "Setting Ant's thread priority to " + threadPriority , Project . MSG_VERBOSE ) ; Thread . currentThread ( ) . setPriority ( threadPriority . intValue ( ) ) ; } catch ( SecurityException swallowed ) { project . log ( "A security manager refused to set the -nice value" ) ; } } project . init ( ) ; Enumeration e = definedProps . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) definedProps . get ( arg ) ; project . setUserProperty ( arg , value ) ; } project . setUserProperty ( MagicNames . ANT_FILE , buildFile . getAbsolutePath ( ) ) ; project . setKeepGoingMode ( keepGoingMode ) ; if ( proxy ) { ProxySetup proxySetup = new ProxySetup ( project ) ; proxySetup . enableProxies ( ) ; } ProjectHelper . configureProject ( project , buildFile ) ; if ( projectHelp ) { printDescription ( project ) ; printTargets ( project , msgOutputLevel > Project . MSG_INFO ) ; return ; } if ( targets . size ( ) == 0 ) { if ( project . getDefaultTarget ( ) != null ) { targets . addElement ( project . getDefaultTarget ( ) ) ; } } project . executeTargets ( targets ) ; } finally { if ( oldsm != null ) { System . setSecurityManager ( oldsm ) ; } System . setOut ( savedOut ) ; System . setErr ( savedErr ) ; System . setIn ( savedIn ) ; } } catch ( RuntimeException exc ) { error = exc ; throw exc ; } catch ( Error e ) { error = e ; throw e ; } finally { if ( ! projectHelp ) { project . fireBuildFinished ( error ) ; } else if ( error != null ) { project . log ( error . toString ( ) , Project . MSG_ERR ) ; } } } protected void addBuildListeners ( Project project ) { project . addBuildListener ( createLogger ( ) ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { String className = ( String ) listeners . elementAt ( i ) ; BuildListener listener = ( BuildListener ) ClasspathUtils . newInstance ( className , Main . class . getClassLoader ( ) , BuildListener . class ) ; if ( project != null ) { project . setProjectReference ( listener ) ; } project . addBuildListener ( listener ) ; } } private void addInputHandler ( Project project ) throws BuildException { InputHandler handler = null ; if ( inputHandlerClassname == null ) { handler = new DefaultInputHandler ( ) ; } else { handler = ( InputHandler ) ClasspathUtils . newInstance ( inputHandlerClassname , Main . class . getClassLoader ( ) , InputHandler . class ) ; if ( project != null ) { project . setProjectReference ( handler ) ; } } project . setInputHandler ( handler ) ; } private BuildLogger createLogger ( ) { BuildLogger logger = null ; if ( loggerClassname != null ) { try { logger = ( BuildLogger ) ClasspathUtils . newInstance ( loggerClassname , Main . class . getClassLoader ( ) , BuildLogger . class ) ; } catch ( BuildException e ) { System . err . println ( "The specified logger class " + loggerClassname + " could not be used because " + e . getMessage ( ) ) ; throw new RuntimeException ( ) ; } } else { logger = new DefaultLogger ( ) ; } logger . setMessageOutputLevel ( msgOutputLevel ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( err ) ; logger . setEmacsMode ( emacsMode ) ; return logger ; } private static void printUsage ( ) { String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "ant [options] [target [target2 [target3] ...]]" + lSep ) ; msg . append ( "Options: " + lSep ) ; msg . append ( "  -help, -h              print this message" + lSep ) ; msg . append ( "  -projecthelp, -p       print project help information" + lSep ) ; msg . append ( "  -version               print the version information and exit" + lSep ) ; msg . append ( "  -diagnostics           print information that might be helpful to" + lSep ) ; msg . append ( "                         diagnose or report problems." + lSep ) ; msg . append ( "  -quiet, -q             be extra quiet" + lSep ) ; msg . append ( "  -verbose, -v           be extra verbose" + lSep ) ; msg . append ( "  -debug, -d             print debugging information" + lSep ) ; msg . append ( "  -emacs, -e             produce logging information without adornments" + lSep ) ; msg . append ( "  -lib <path>            specifies a path to search for jars and classes" + lSep ) ; msg . append ( "  -logfile <file>        use given file for log" + lSep ) ; msg . append ( "    -l     <file>                ''" + lSep ) ; msg . append ( "  -logger <classname>    the class which is to perform logging" + lSep ) ; msg . append ( "  -listener <classname>  add an instance of class as a project listener" + lSep ) ; msg . append ( "  -noinput               do not allow interactive input" + lSep ) ; msg . append ( "  -buildfile <file>      use given buildfile" + lSep ) ; msg . append ( "    -file    <file>              ''" + lSep ) ; msg . append ( "    -f       <file>              ''" + lSep ) ; msg . append ( "  -D<property>=<value>   use value for given property" + lSep ) ; msg . append ( "  -keep-going, -k        execute all targets that do not depend" + lSep ) ; msg . append ( "                         on failed target(s)" + lSep ) ; msg . append ( "  -propertyfile <name>   load all properties from file with -D" + lSep ) ; msg . append ( "                         properties taking precedence" + lSep ) ; msg . append ( "  -inputhandler <class>  the class which will handle input requests" + lSep ) ; msg . append ( "  -find <file>           (s)earch for buildfile towards the root of" + lSep ) ; msg . append ( "    -s  <file>           the filesystem and use it" + lSep ) ; msg . append ( "  -nice  number          A niceness value for the main thread:" + lSep + "                         1 (lowest) to 10 (highest); 5 is the default" + lSep ) ; msg . append ( "  -nouserlib             Run ant without using the jar files from" + lSep + "                         ${user.home}/.ant/lib" + lSep ) ; msg . append ( "  -noclasspath           Run ant without using CLASSPATH" + lSep ) ; msg . append ( "  -autoproxy             Java1.5+: use the OS proxy settings" + lSep ) ; msg . append ( "  -main <class>          override Ant's normal entry point" ) ; System . out . println ( msg . toString ( ) ) ; } private static void printVersion ( ) throws BuildException { System . out . println ( getAntVersion ( ) ) ; } private static String antVersion = null ; public static synchronized String getAntVersion ( ) throws BuildException { if ( antVersion == null ) { try { Properties props = new Properties ( ) ; InputStream in = Main . class . getResourceAsStream ( "/org/apache/tools/ant/version.txt" ) ; props . load ( in ) ; in . close ( ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "Apache Ant version " ) ; msg . append ( props . getProperty ( "VERSION" ) ) ; msg . append ( " compiled on " ) ; msg . append ( props . getProperty ( "DATE" ) ) ; antVersion = msg . toString ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not load the version information:" + ioe . getMessage ( ) ) ; } catch ( NullPointerException npe ) { throw new BuildException ( "Could not load the version information." ) ; } } return antVersion ; } private static void printDescription ( Project project ) { if ( project . getDescription ( ) != null ) { project . log ( project . getDescription ( ) ) ; } } private static void printTargets ( Project project , boolean printSubTargets ) { int maxLength = 0 ; Enumeration ptargets = project . getTargets ( ) . elements ( ) ; String targetName ; String targetDescription ; Target currentTarget ; Vector topNames = new Vector ( ) ; Vector topDescriptions = new Vector ( ) ; Vector subNames = new Vector ( ) ; while ( ptargets . hasMoreElements ( ) ) { currentTarget = ( Target ) ptargets . nextElement ( ) ; targetName = currentTarget . getName ( ) ; if ( targetName . equals ( "" ) ) { continue ; } targetDescription = currentTarget . getDescription ( ) ; if ( targetDescription == null ) { int pos = findTargetPosition ( subNames , targetName ) ; subNames . insertElementAt ( targetName , pos ) ; } else { int pos = findTargetPosition ( topNames , targetName ) ; topNames . insertElementAt ( targetName , pos ) ; topDescriptions . insertElementAt ( targetDescription , pos ) ; if ( targetName . length ( ) > maxLength ) { maxLength = targetName . length ( ) ; } } } printTargets ( project , topNames , topDescriptions , "Main targets:" , maxLength ) ; if ( topNames . size ( ) == 0 ) { printSubTargets = true ; } if ( printSubTargets ) { printTargets ( project , subNames , null , "Other targets:" , 0 ) ; } String defaultTarget = project . getDefaultTarget ( ) ; if ( defaultTarget != null && ! "" . equals ( defaultTarget ) ) { project . log ( "Default target: " + defaultTarget ) ; } } private static int findTargetPosition ( Vector names , String name ) { int res = names . size ( ) ; for ( int i = 0 ; i < names . size ( ) && res == names . size ( ) ; i ++ ) { if ( name . compareTo ( ( String ) names . elementAt ( i ) ) < 0 ) { res = i ; } } return res ; } private static void printTargets ( Project project , Vector names , Vector descriptions , String heading , int maxlen ) { String lSep = System . getProperty ( "line.separator" ) ; String spaces = "    " ; while ( spaces . length ( ) <= maxlen ) { spaces += spaces ; } StringBuffer msg = new StringBuffer ( ) ; msg . append ( heading + lSep + lSep ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { msg . append ( " " ) ; msg . append ( names . elementAt ( i ) ) ; if ( descriptions != null ) { msg . append ( spaces . substring ( 0 , maxlen - ( ( String ) names . elementAt ( i ) ) . length ( ) + 2 ) ) ; msg . append ( descriptions . elementAt ( i ) ) ; } msg . append ( lSep ) ; } project . log ( msg . toString ( ) , Project . MSG_WARN ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . lang . reflect . Constructor ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteWatchdog ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; import org . apache . tools . ant . types . Assertions ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Permissions ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . LoaderUtils ; public class JUnitTask extends Task { private static final String CLASSPATH = "CLASSPATH=" ; private CommandlineJava commandline ; private Vector tests = new Vector ( ) ; private Vector batchTests = new Vector ( ) ; private Vector formatters = new Vector ( ) ; private File dir = null ; private Integer timeout = null ; private boolean summary = false ; private boolean reloading = true ; private String summaryValue = "" ; private JUnitTaskMirror . JUnitTestRunnerMirror runner = null ; private boolean newEnvironment = false ; private Environment env = new Environment ( ) ; private boolean includeAntRuntime = true ; private Path antRuntimeClasses = null ; private boolean showOutput = false ; private boolean outputToFormatters = true ; private File tmpDir ; private AntClassLoader classLoader = null ; private Permissions perm = null ; private ForkMode forkMode = new ForkMode ( "perTest" ) ; private boolean splitJunit = false ; private JUnitTaskMirror delegate ; private boolean haltOnError = false ; private boolean haltOnFail = false ; private boolean filterTrace = true ; private boolean fork = false ; private String failureProperty ; private String errorProperty ; private static final int STRING_BUFFER_SIZE = 128 ; public static final String TESTLISTENER_PREFIX = "junit.framework.TestListener: " ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public void setReloading ( boolean value ) { reloading = value ; } public void setFiltertrace ( boolean value ) { this . filterTrace = value ; } public void setHaltonerror ( boolean value ) { this . haltOnError = value ; } public void setErrorProperty ( String propertyName ) { this . errorProperty = propertyName ; } public void setHaltonfailure ( boolean value ) { this . haltOnFail = value ; } public void setFailureProperty ( String propertyName ) { this . failureProperty = propertyName ; } public void setFork ( boolean value ) { this . fork = value ; } public void setForkMode ( ForkMode mode ) { this . forkMode = mode ; } public void setPrintsummary ( SummaryAttribute value ) { summaryValue = value . getValue ( ) ; summary = value . asBoolean ( ) ; } public static class SummaryAttribute extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "true" , "yes" , "false" , "no" , "on" , "off" , "withOutAndErr" } ; } public boolean asBoolean ( ) { String v = getValue ( ) ; return "true" . equals ( v ) || "on" . equals ( v ) || "yes" . equals ( v ) || "withOutAndErr" . equals ( v ) ; } } public void setTimeout ( Integer value ) { timeout = value ; } public void setMaxmemory ( String max ) { getCommandline ( ) . setMaxmemory ( max ) ; } public void setJvm ( String value ) { getCommandline ( ) . setVm ( value ) ; } public Commandline . Argument createJvmarg ( ) { return getCommandline ( ) . createVmArgument ( ) ; } public void setDir ( File dir ) { this . dir = dir ; } public void addSysproperty ( Environment . Variable sysp ) { getCommandline ( ) . addSysproperty ( sysp ) ; } public void addConfiguredSysproperty ( Environment . Variable sysp ) { String testString = sysp . getContent ( ) ; getProject ( ) . log ( "sysproperty added : " + testString , Project . MSG_DEBUG ) ; getCommandline ( ) . addSysproperty ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { getCommandline ( ) . addSyspropertyset ( sysp ) ; } public Path createClasspath ( ) { return getCommandline ( ) . createClasspath ( getProject ( ) ) . createPath ( ) ; } public Path createBootclasspath ( ) { return getCommandline ( ) . createBootclasspath ( getProject ( ) ) . createPath ( ) ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } private void preConfigure ( BaseTest test ) { test . setFiltertrace ( filterTrace ) ; test . setHaltonerror ( haltOnError ) ; if ( errorProperty != null ) { test . setErrorProperty ( errorProperty ) ; } test . setHaltonfailure ( haltOnFail ) ; if ( failureProperty != null ) { test . setFailureProperty ( failureProperty ) ; } test . setFork ( fork ) ; } public void addTest ( JUnitTest test ) { tests . addElement ( test ) ; preConfigure ( test ) ; } public BatchTest createBatchTest ( ) { BatchTest test = new BatchTest ( getProject ( ) ) ; batchTests . addElement ( test ) ; preConfigure ( test ) ; return test ; } public void addFormatter ( FormatterElement fe ) { formatters . addElement ( fe ) ; } public void setIncludeantruntime ( boolean b ) { includeAntRuntime = b ; } public void setShowOutput ( boolean showOutput ) { this . showOutput = showOutput ; } public void setOutputToFormatters ( boolean outputToFormatters ) { this . outputToFormatters = outputToFormatters ; } public void addAssertions ( Assertions asserts ) { if ( getCommandline ( ) . getAssertions ( ) != null ) { throw new BuildException ( "Only one assertion declaration is allowed" ) ; } getCommandline ( ) . setAssertions ( asserts ) ; } public Permissions createPermissions ( ) { if ( perm == null ) { perm = new Permissions ( ) ; } return perm ; } public void setCloneVm ( boolean cloneVm ) { getCommandline ( ) . setCloneVm ( cloneVm ) ; } public JUnitTask ( ) throws Exception { getCommandline ( ) . setClassname ( "org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner" ) ; } public void setTempdir ( File tmpDir ) { if ( tmpDir != null ) { if ( ! tmpDir . exists ( ) || ! tmpDir . isDirectory ( ) ) { throw new BuildException ( tmpDir . toString ( ) + " is not a valid temp directory" ) ; } } this . tmpDir = tmpDir ; } public void init ( ) { antRuntimeClasses = new Path ( getProject ( ) ) ; splitJunit = ! addClasspathEntry ( "/junit/framework/TestCase.class" ) ; addClasspathEntry ( "/org/apache/tools/ant/launch/AntMain.class" ) ; addClasspathEntry ( "/org/apache/tools/ant/Task.class" ) ; addClasspathEntry ( "/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.class" ) ; } private static JUnitTaskMirror createMirror ( JUnitTask task , ClassLoader loader ) { try { loader . loadClass ( "junit.framework.Test" ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "The <classpath> for <junit> must include junit.jar " + "if not in Ant's own classpath" , e , task . getLocation ( ) ) ; } try { Class c = loader . loadClass ( JUnitTaskMirror . class . getName ( ) + "Impl" ) ; if ( c . getClassLoader ( ) != loader ) { throw new BuildException ( "Overdelegating loader" , task . getLocation ( ) ) ; } Constructor cons = c . getConstructor ( new Class [ ] { JUnitTask . class } ) ; return ( JUnitTaskMirror ) cons . newInstance ( new Object [ ] { task } ) ; } catch ( Exception e ) { throw new BuildException ( e , task . getLocation ( ) ) ; } } private final class SplitLoader extends AntClassLoader { public SplitLoader ( ClassLoader parent , Path path ) { super ( parent , getProject ( ) , path , true ) ; } protected synchronized Class loadClass ( String classname , boolean resolve ) throws ClassNotFoundException { Class theClass = findLoadedClass ( classname ) ; if ( theClass != null ) { return theClass ; } if ( isSplit ( classname ) ) { theClass = findClass ( classname ) ; if ( resolve ) { resolveClass ( theClass ) ; } return theClass ; } else { return super . loadClass ( classname , resolve ) ; } } private final String [ ] splitClasses = { "BriefJUnitResultFormatter" , "JUnitResultFormatter" , "JUnitTaskMirrorImpl" , "JUnitTestRunner" , "JUnitVersionHelper" , "OutErrSummaryJUnitResultFormatter" , "PlainJUnitResultFormatter" , "SummaryJUnitResultFormatter" , "XMLJUnitResultFormatter" , } ; private boolean isSplit ( String classname ) { String simplename = classname . substring ( classname . lastIndexOf ( '.' ) + 1 ) ; for ( int i = 0 ; i < splitClasses . length ; i ++ ) { if ( simplename . equals ( splitClasses [ i ] ) || simplename . startsWith ( splitClasses [ i ] + '$' ) ) { return true ; } } return false ; } } public void execute ( ) throws BuildException { ClassLoader myLoader = JUnitTask . class . getClassLoader ( ) ; ClassLoader mirrorLoader ; if ( splitJunit ) { Path path = new Path ( getProject ( ) ) ; path . add ( antRuntimeClasses ) ; path . add ( getCommandline ( ) . getClasspath ( ) ) ; mirrorLoader = new SplitLoader ( myLoader , path ) ; } else { mirrorLoader = myLoader ; } delegate = createMirror ( this , mirrorLoader ) ; List testLists = new ArrayList ( ) ; boolean forkPerTest = forkMode . getValue ( ) . equals ( ForkMode . PER_TEST ) ; if ( forkPerTest || forkMode . getValue ( ) . equals ( ForkMode . ONCE ) ) { testLists . addAll ( executeOrQueue ( getIndividualTests ( ) , forkPerTest ) ) ; } else { final int count = batchTests . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { BatchTest batchtest = ( BatchTest ) batchTests . elementAt ( i ) ; testLists . addAll ( executeOrQueue ( batchtest . elements ( ) , false ) ) ; } testLists . addAll ( executeOrQueue ( tests . elements ( ) , forkPerTest ) ) ; } try { Iterator iter = testLists . iterator ( ) ; while ( iter . hasNext ( ) ) { List l = ( List ) iter . next ( ) ; if ( l . size ( ) == 1 ) { execute ( ( JUnitTest ) l . get ( 0 ) ) ; } else { execute ( l ) ; } } } finally { deleteClassLoader ( ) ; if ( mirrorLoader instanceof SplitLoader ) { ( ( SplitLoader ) mirrorLoader ) . cleanup ( ) ; } delegate = null ; } } protected void execute ( JUnitTest arg ) throws BuildException { JUnitTest test = ( JUnitTest ) arg . clone ( ) ; if ( test . getTodir ( ) == null ) { test . setTodir ( getProject ( ) . resolveFile ( "." ) ) ; } if ( test . getOutfile ( ) == null ) { test . setOutfile ( "TEST-" + test . getName ( ) ) ; } TestResultHolder result = null ; if ( ! test . getFork ( ) ) { result = executeInVM ( test ) ; } else { ExecuteWatchdog watchdog = createWatchdog ( ) ; result = executeAsForked ( test , watchdog , null ) ; } actOnTestResult ( result , test , "Test " + test . getName ( ) ) ; } protected void execute ( List tests ) throws BuildException { JUnitTest test = null ; File casesFile = createTempPropertiesFile ( "junittestcases" ) ; PrintWriter writer = null ; try { writer = new PrintWriter ( new BufferedWriter ( new FileWriter ( casesFile ) ) ) ; Iterator iter = tests . iterator ( ) ; while ( iter . hasNext ( ) ) { test = ( JUnitTest ) iter . next ( ) ; writer . print ( test . getName ( ) ) ; if ( test . getTodir ( ) == null ) { writer . print ( "," + getProject ( ) . resolveFile ( "." ) ) ; } else { writer . print ( "," + test . getTodir ( ) ) ; } if ( test . getOutfile ( ) == null ) { writer . println ( "," + "TEST-" + test . getName ( ) ) ; } else { writer . println ( "," + test . getOutfile ( ) ) ; } } writer . flush ( ) ; writer . close ( ) ; writer = null ; ExecuteWatchdog watchdog = createWatchdog ( ) ; TestResultHolder result = executeAsForked ( test , watchdog , casesFile ) ; actOnTestResult ( result , test , "Tests" ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; throw new BuildException ( e ) ; } finally { if ( writer != null ) { writer . close ( ) ; } try { casesFile . delete ( ) ; } catch ( Exception e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; } } } private TestResultHolder executeAsForked ( JUnitTest test , ExecuteWatchdog watchdog , File casesFile ) throws BuildException { if ( perm != null ) { log ( "Permissions ignored when running in forked mode!" , Project . MSG_WARN ) ; } CommandlineJava cmd = null ; try { cmd = ( CommandlineJava ) ( getCommandline ( ) . clone ( ) ) ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( "This shouldn't happen" , e , getLocation ( ) ) ; } cmd . setClassname ( "org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner" ) ; if ( casesFile == null ) { cmd . createArgument ( ) . setValue ( test . getName ( ) ) ; } else { log ( "Running multiple tests in the same VM" , Project . MSG_VERBOSE ) ; cmd . createArgument ( ) . setValue ( Constants . TESTSFILE + casesFile ) ; } cmd . createArgument ( ) . setValue ( Constants . FILTERTRACE + test . getFiltertrace ( ) ) ; cmd . createArgument ( ) . setValue ( Constants . HALT_ON_ERROR + test . getHaltonerror ( ) ) ; cmd . createArgument ( ) . setValue ( Constants . HALT_ON_FAILURE + test . getHaltonfailure ( ) ) ; if ( includeAntRuntime ) { Vector v = Execute . getProcEnvironment ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { String s = ( String ) e . nextElement ( ) ; if ( s . startsWith ( CLASSPATH ) ) { cmd . createClasspath ( getProject ( ) ) . createPath ( ) . append ( new Path ( getProject ( ) , s . substring ( CLASSPATH . length ( ) ) ) ) ; } } log ( "Implicitly adding " + antRuntimeClasses + " to CLASSPATH" , Project . MSG_VERBOSE ) ; cmd . createClasspath ( getProject ( ) ) . createPath ( ) . append ( antRuntimeClasses ) ; } if ( summary ) { String prefix = "" ; if ( "withoutanderr" . equalsIgnoreCase ( summaryValue ) ) { prefix = "OutErr" ; } cmd . createArgument ( ) . setValue ( Constants . FORMATTER + "org.apache.tools.ant.taskdefs.optional.junit." + prefix + "SummaryJUnitResultFormatter" ) ; } cmd . createArgument ( ) . setValue ( Constants . SHOWOUTPUT + String . valueOf ( showOutput ) ) ; cmd . createArgument ( ) . setValue ( Constants . OUTPUT_TO_FORMATTERS + String . valueOf ( outputToFormatters ) ) ; cmd . createArgument ( ) . setValue ( Constants . LOGTESTLISTENEREVENTS + "true" ) ; StringBuffer formatterArg = new StringBuffer ( STRING_BUFFER_SIZE ) ; final FormatterElement [ ] feArray = mergeFormatters ( test ) ; for ( int i = 0 ; i < feArray . length ; i ++ ) { FormatterElement fe = feArray [ i ] ; if ( fe . shouldUse ( this ) ) { formatterArg . append ( Constants . FORMATTER ) ; formatterArg . append ( fe . getClassname ( ) ) ; File outFile = getOutput ( fe , test ) ; if ( outFile != null ) { formatterArg . append ( "," ) ; formatterArg . append ( outFile ) ; } cmd . createArgument ( ) . setValue ( formatterArg . toString ( ) ) ; formatterArg = new StringBuffer ( ) ; } } File vmWatcher = createTempPropertiesFile ( "junitvmwatcher" ) ; cmd . createArgument ( ) . setValue ( Constants . CRASHFILE + vmWatcher . getAbsolutePath ( ) ) ; File propsFile = createTempPropertiesFile ( "junit" ) ; cmd . createArgument ( ) . setValue ( Constants . PROPSFILE + propsFile . getAbsolutePath ( ) ) ; Hashtable p = getProject ( ) . getProperties ( ) ; Properties props = new Properties ( ) ; for ( Enumeration e = p . keys ( ) ; e . hasMoreElements ( ) ; ) { Object key = e . nextElement ( ) ; props . put ( key , p . get ( key ) ) ; } try { FileOutputStream outstream = new FileOutputStream ( propsFile ) ; props . store ( outstream , "Ant JUnitTask generated properties file" ) ; outstream . close ( ) ; } catch ( java . io . IOException e ) { propsFile . delete ( ) ; throw new BuildException ( "Error creating temporary properties " + "file." , e , getLocation ( ) ) ; } Execute execute = new Execute ( new JUnitLogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , watchdog ) ; execute . setCommandline ( cmd . getCommandline ( ) ) ; execute . setAntRun ( getProject ( ) ) ; if ( dir != null ) { execute . setWorkingDirectory ( dir ) ; } String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } execute . setNewenvironment ( newEnvironment ) ; execute . setEnvironment ( environment ) ; log ( cmd . describeCommand ( ) , Project . MSG_VERBOSE ) ; TestResultHolder result = new TestResultHolder ( ) ; try { result . exitCode = execute . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Process fork failed." , e , getLocation ( ) ) ; } finally { String vmCrashString = "unknown" ; BufferedReader br = null ; try { br = new BufferedReader ( new FileReader ( vmWatcher ) ) ; vmCrashString = br . readLine ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { FileUtils . close ( br ) ; } if ( watchdog != null && watchdog . killedProcess ( ) ) { result . timedOut = true ; logTimeout ( feArray , test , vmCrashString ) ; } else if ( ! Constants . TERMINATED_SUCCESSFULLY . equals ( vmCrashString ) ) { result . crashed = true ; logVmCrash ( feArray , test , vmCrashString ) ; } vmWatcher . delete ( ) ; if ( ! propsFile . delete ( ) ) { throw new BuildException ( "Could not delete temporary " + "properties file." ) ; } } return result ; } private File createTempPropertiesFile ( String prefix ) { File propsFile = FILE_UTILS . createTempFile ( prefix , ".properties" , tmpDir != null ? tmpDir : getProject ( ) . getBaseDir ( ) , true ) ; return propsFile ; } protected void handleOutput ( String output ) { if ( output . startsWith ( TESTLISTENER_PREFIX ) ) { log ( output , Project . MSG_VERBOSE ) ; } else if ( runner != null ) { if ( outputToFormatters ) { runner . handleOutput ( output ) ; } if ( showOutput ) { super . handleOutput ( output ) ; } } else { super . handleOutput ( output ) ; } } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( runner != null ) { return runner . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( runner != null ) { runner . handleFlush ( output ) ; if ( showOutput ) { super . handleFlush ( output ) ; } } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( runner != null ) { runner . handleErrorOutput ( output ) ; if ( showOutput ) { super . handleErrorOutput ( output ) ; } } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( runner != null ) { runner . handleErrorFlush ( output ) ; if ( showOutput ) { super . handleErrorFlush ( output ) ; } } else { super . handleErrorFlush ( output ) ; } } private TestResultHolder executeInVM ( JUnitTest arg ) throws BuildException { JUnitTest test = ( JUnitTest ) arg . clone ( ) ; test . setProperties ( getProject ( ) . getProperties ( ) ) ; if ( dir != null ) { log ( "dir attribute ignored if running in the same VM" , Project . MSG_WARN ) ; } if ( newEnvironment || null != env . getVariables ( ) ) { log ( "Changes to environment variables are ignored if running in " + "the same VM." , Project . MSG_WARN ) ; } if ( getCommandline ( ) . getBootclasspath ( ) != null ) { log ( "bootclasspath is ignored if running in the same VM." , Project . MSG_WARN ) ; } CommandlineJava . SysProperties sysProperties = getCommandline ( ) . getSystemProperties ( ) ; if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } try { log ( "Using System properties " + System . getProperties ( ) , Project . MSG_VERBOSE ) ; if ( splitJunit ) { classLoader = ( AntClassLoader ) delegate . getClass ( ) . getClassLoader ( ) ; } else { createClassLoader ( ) ; } if ( classLoader != null ) { classLoader . setThreadContextLoader ( ) ; } runner = delegate . newJUnitTestRunner ( test , test . getHaltonerror ( ) , test . getFiltertrace ( ) , test . getHaltonfailure ( ) , false , true , classLoader ) ; if ( summary ) { JUnitTaskMirror . SummaryJUnitResultFormatterMirror f = delegate . newSummaryJUnitResultFormatter ( ) ; f . setWithOutAndErr ( "withoutanderr" . equalsIgnoreCase ( summaryValue ) ) ; f . setOutput ( getDefaultOutput ( ) ) ; runner . addFormatter ( f ) ; } runner . setPermissions ( perm ) ; final FormatterElement [ ] feArray = mergeFormatters ( test ) ; for ( int i = 0 ; i < feArray . length ; i ++ ) { FormatterElement fe = feArray [ i ] ; if ( fe . shouldUse ( this ) ) { File outFile = getOutput ( fe , test ) ; if ( outFile != null ) { fe . setOutfile ( outFile ) ; } else { fe . setOutput ( getDefaultOutput ( ) ) ; } runner . addFormatter ( fe . createFormatter ( classLoader ) ) ; } } runner . run ( ) ; TestResultHolder result = new TestResultHolder ( ) ; result . exitCode = runner . getRetCode ( ) ; return result ; } finally { if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } if ( classLoader != null ) { classLoader . resetThreadContextLoader ( ) ; } } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( ( long ) timeout . intValue ( ) ) ; } protected OutputStream getDefaultOutput ( ) { return new LogOutputStream ( this , Project . MSG_INFO ) ; } protected Enumeration getIndividualTests ( ) { final int count = batchTests . size ( ) ; final Enumeration [ ] enums = new Enumeration [ count + 1 ] ; for ( int i = 0 ; i < count ; i ++ ) { BatchTest batchtest = ( BatchTest ) batchTests . elementAt ( i ) ; enums [ i ] = batchtest . elements ( ) ; } enums [ enums . length - 1 ] = tests . elements ( ) ; return Enumerations . fromCompound ( enums ) ; } protected Enumeration allTests ( ) { Enumeration [ ] enums = { tests . elements ( ) , batchTests . elements ( ) } ; return Enumerations . fromCompound ( enums ) ; } private FormatterElement [ ] mergeFormatters ( JUnitTest test ) { Vector feVector = ( Vector ) formatters . clone ( ) ; test . addFormattersTo ( feVector ) ; FormatterElement [ ] feArray = new FormatterElement [ feVector . size ( ) ] ; feVector . copyInto ( feArray ) ; return feArray ; } protected File getOutput ( FormatterElement fe , JUnitTest test ) { if ( fe . getUseFile ( ) ) { String base = test . getOutfile ( ) ; if ( base == null ) { base = JUnitTaskMirror . JUnitTestRunnerMirror . IGNORED_FILE_NAME ; } String filename = base + fe . getExtension ( ) ; File destFile = new File ( test . getTodir ( ) , filename ) ; String absFilename = destFile . getAbsolutePath ( ) ; return getProject ( ) . resolveFile ( absFilename ) ; } return null ; } protected boolean addClasspathEntry ( String resource ) { if ( resource . startsWith ( "/" ) ) { resource = resource . substring ( 1 ) ; } else { resource = "org/apache/tools/ant/taskdefs/optional/junit/" + resource ; } File f = LoaderUtils . getResourceSource ( getClass ( ) . getClassLoader ( ) , resource ) ; if ( f != null ) { log ( "Found " + f . getAbsolutePath ( ) , Project . MSG_DEBUG ) ; antRuntimeClasses . createPath ( ) . setLocation ( f ) ; return true ; } else { log ( "Couldn\'t find " + resource , Project . MSG_DEBUG ) ; return false ; } } private void logTimeout ( FormatterElement [ ] feArray , JUnitTest test , String testCase ) { logVmExit ( feArray , test , "Timeout occurred. Please note the time in the report does" + " not reflect the time until the timeout." , testCase ) ; } private void logVmCrash ( FormatterElement [ ] feArray , JUnitTest test , String testCase ) { logVmExit ( feArray , test , "Forked Java VM exited abnormally. Please note the time in the report" + " does not reflect the time until the VM exit." , testCase ) ; } private void logVmExit ( FormatterElement [ ] feArray , JUnitTest test , String message , String testCase ) { try { log ( "Using System properties " + System . getProperties ( ) , Project . MSG_VERBOSE ) ; if ( splitJunit ) { classLoader = ( AntClassLoader ) delegate . getClass ( ) . getClassLoader ( ) ; } else { createClassLoader ( ) ; } if ( classLoader != null ) { classLoader . setThreadContextLoader ( ) ; } test . setCounts ( 1 , 0 , 1 ) ; test . setProperties ( getProject ( ) . getProperties ( ) ) ; for ( int i = 0 ; i < feArray . length ; i ++ ) { FormatterElement fe = feArray [ i ] ; File outFile = getOutput ( fe , test ) ; JUnitTaskMirror . JUnitResultFormatterMirror formatter = fe . createFormatter ( classLoader ) ; if ( outFile != null && formatter != null ) { try { OutputStream out = new FileOutputStream ( outFile ) ; delegate . addVmExit ( test , formatter , out , message , testCase ) ; } catch ( IOException e ) { } } } if ( summary ) { JUnitTaskMirror . SummaryJUnitResultFormatterMirror f = delegate . newSummaryJUnitResultFormatter ( ) ; f . setWithOutAndErr ( "withoutanderr" . equalsIgnoreCase ( summaryValue ) ) ; delegate . addVmExit ( test , f , getDefaultOutput ( ) , message , testCase ) ; } } finally { if ( classLoader != null ) { classLoader . resetThreadContextLoader ( ) ; } } } private void createClassLoader ( ) { Path userClasspath = getCommandline ( ) . getClasspath ( ) ; if ( userClasspath != null ) { if ( reloading || classLoader == null ) { deleteClassLoader ( ) ; Path classpath = ( Path ) userClasspath . clone ( ) ; if ( includeAntRuntime ) { log ( "Implicitly adding " + antRuntimeClasses + " to CLASSPATH" , Project . MSG_VERBOSE ) ; classpath . append ( antRuntimeClasses ) ; } classLoader = getProject ( ) . createClassLoader ( classpath ) ; if ( getClass ( ) . getClassLoader ( ) != null && getClass ( ) . getClassLoader ( ) != Project . class . getClassLoader ( ) ) { classLoader . setParent ( getClass ( ) . getClassLoader ( ) ) ; } classLoader . setParentFirst ( false ) ; classLoader . addJavaLibraries ( ) ; log ( "Using CLASSPATH " + classLoader . getClasspath ( ) , Project . MSG_VERBOSE ) ; classLoader . addSystemPackageRoot ( "junit" ) ; classLoader . addSystemPackageRoot ( "org.junit" ) ; classLoader . addSystemPackageRoot ( "org.apache.tools.ant" ) ; } } } private void deleteClassLoader ( ) { if ( classLoader != null ) { classLoader . cleanup ( ) ; classLoader = null ; } } protected CommandlineJava getCommandline ( ) { if ( commandline == null ) { commandline = new CommandlineJava ( ) ; } return commandline ; } private static final class ForkedTestConfiguration { private boolean filterTrace ; private boolean haltOnError ; private boolean haltOnFailure ; private String errorProperty ; private String failureProperty ; ForkedTestConfiguration ( boolean filterTrace , boolean haltOnError , boolean haltOnFailure , String errorProperty , String failureProperty ) { this . filterTrace = filterTrace ; this . haltOnError = haltOnError ; this . haltOnFailure = haltOnFailure ; this . errorProperty = errorProperty ; this . failureProperty = failureProperty ; } ForkedTestConfiguration ( JUnitTest test ) { this ( test . getFiltertrace ( ) , test . getHaltonerror ( ) , test . getHaltonfailure ( ) , test . getErrorProperty ( ) , test . getFailureProperty ( ) ) ; } public boolean equals ( Object other ) { if ( other == null || other . getClass ( ) != ForkedTestConfiguration . class ) { return false ; } ForkedTestConfiguration o = ( ForkedTestConfiguration ) other ; return filterTrace == o . filterTrace && haltOnError == o . haltOnError && haltOnFailure == o . haltOnFailure && ( ( errorProperty == null && o . errorProperty == null ) || ( errorProperty != null && errorProperty . equals ( o . errorProperty ) ) ) && ( ( failureProperty == null && o . failureProperty == null ) || ( failureProperty != null && failureProperty . equals ( o . failureProperty ) ) ) ; } public int hashCode ( ) { return ( filterTrace ? 1 : 0 ) + ( haltOnError ? 2 : 0 ) + ( haltOnFailure ? 4 : 0 ) ; } } public static final class ForkMode extends EnumeratedAttribute { public static final String ONCE = "once" ; public static final String PER_TEST = "perTest" ; public static final String PER_BATCH = "perBatch" ; public ForkMode ( ) { super ( ) ; } public ForkMode ( String value ) { super ( ) ; setValue ( value ) ; } public String [ ] getValues ( ) { return new String [ ] { ONCE , PER_TEST , PER_BATCH } ; } } protected Collection executeOrQueue ( Enumeration testList , boolean runIndividual ) { Map testConfigurations = new HashMap ( ) ; while ( testList . hasMoreElements ( ) ) { JUnitTest test = ( JUnitTest ) testList . nextElement ( ) ; if ( test . shouldRun ( getProject ( ) ) ) { if ( runIndividual || ! test . getFork ( ) ) { execute ( test ) ; } else { ForkedTestConfiguration c = new ForkedTestConfiguration ( test ) ; List l = ( List ) testConfigurations . get ( c ) ; if ( l == null ) { l = new ArrayList ( ) ; testConfigurations . put ( c , l ) ; } l . add ( test ) ; } } } return testConfigurations . values ( ) ; } protected void actOnTestResult ( int exitValue , boolean wasKilled , JUnitTest test , String name ) { TestResultHolder t = new TestResultHolder ( ) ; t . exitCode = exitValue ; t . timedOut = wasKilled ; actOnTestResult ( t , test , name ) ; } protected void actOnTestResult ( TestResultHolder result , JUnitTest test , String name ) { boolean fatal = result . timedOut || result . crashed ; boolean errorOccurredHere = result . exitCode == JUnitTaskMirror . JUnitTestRunnerMirror . ERRORS || fatal ; boolean failureOccurredHere = result . exitCode != JUnitTaskMirror . JUnitTestRunnerMirror . SUCCESS || fatal ; if ( errorOccurredHere || failureOccurredHere ) { if ( ( errorOccurredHere && test . getHaltonerror ( ) ) || ( failureOccurredHere && test . getHaltonfailure ( ) ) ) { throw new BuildException ( name + " failed" + ( result . timedOut ? " (timeout)" : "" ) + ( result . crashed ? " (crashed)" : "" ) , getLocation ( ) ) ; } else { log ( name + " FAILED" + ( result . timedOut ? " (timeout)" : "" ) + ( result . crashed ? " (crashed)" : "" ) , Project . MSG_ERR ) ; if ( errorOccurredHere && test . getErrorProperty ( ) != null ) { getProject ( ) . setNewProperty ( test . getErrorProperty ( ) , "true" ) ; } if ( failureOccurredHere && test . getFailureProperty ( ) != null ) { getProject ( ) . setNewProperty ( test . getFailureProperty ( ) , "true" ) ; } } } } protected class TestResultHolder { public int exitCode = JUnitTaskMirror . JUnitTestRunnerMirror . ERRORS ; public boolean timedOut = false ; public boolean crashed = false ; } protected static class JUnitLogOutputStream extends LogOutputStream { private Task task ; public JUnitLogOutputStream ( Task task , int level ) { super ( task , level ) ; this . task = task ; } protected void processLine ( String line , int level ) { if ( line . startsWith ( TESTLISTENER_PREFIX ) ) { task . log ( line , Project . MSG_VERBOSE ) ; } else { super . processLine ( line , level ) ; } } } protected static class JUnitLogStreamHandler extends PumpStreamHandler { public JUnitLogStreamHandler ( Task task , int outlevel , int errlevel ) { super ( new JUnitLogOutputStream ( task , outlevel ) , new LogOutputStream ( task , errlevel ) ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . ExitStatusException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Assertions ; import org . apache . tools . ant . types . Permissions ; import org . apache . tools . ant . types . RedirectorElement ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . util . KeepAliveInputStream ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private Environment env = new Environment ( ) ; private boolean fork = false ; private boolean newEnvironment = false ; private File dir = null ; private boolean failOnError = false ; private Long timeout = null ; private String inputString ; private File input ; private File output ; private File error ; protected Redirector redirector = new Redirector ( this ) ; protected RedirectorElement redirectorElement ; private String resultProperty ; private Permissions perm = null ; private boolean spawn = false ; private boolean incompatibleWithSpawn = false ; public Java ( ) { } public Java ( Task owner ) { bindToOwner ( owner ) ; } public void execute ( ) throws BuildException { File savedDir = dir ; Permissions savedPermissions = perm ; int err = - 1 ; try { err = executeJava ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new ExitStatusException ( "Java returned: " + err , err , getLocation ( ) ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } maybeSetResultPropertyValue ( err ) ; } finally { dir = savedDir ; perm = savedPermissions ; } } public int executeJava ( ) throws BuildException { String classname = getCommandLine ( ) . getClassname ( ) ; if ( classname == null && getCommandLine ( ) . getJar ( ) == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( ! fork && getCommandLine ( ) . getJar ( ) != null ) { throw new BuildException ( "Cannot execute a jar in non-forked mode." + " Please set fork='true'. " ) ; } if ( spawn && ! fork ) { throw new BuildException ( "Cannot spawn a java process in non-forked mode." + " Please set fork='true'. " ) ; } if ( getCommandLine ( ) . getClasspath ( ) != null && getCommandLine ( ) . getJar ( ) != null ) { log ( "When using 'jar' attribute classpath-settings are ignored. " + "See the manual for more information." , Project . MSG_VERBOSE ) ; } if ( spawn && incompatibleWithSpawn ) { getProject ( ) . log ( "spawn does not allow attributes related to input, " + "output, error, result" , Project . MSG_ERR ) ; getProject ( ) . log ( "spawn also does not allow timeout" , Project . MSG_ERR ) ; getProject ( ) . log ( "finally, spawn is not compatible " + "with a nested I/O <redirector>" , Project . MSG_ERR ) ; throw new BuildException ( "You have used an attribute " + "or nested element which is not compatible with spawn" ) ; } if ( getCommandLine ( ) . getAssertions ( ) != null && ! fork ) { log ( "Assertion statements are currently ignored in non-forked mode" ) ; } if ( fork ) { if ( perm != null ) { log ( "Permissions can not be set this way in forked mode." , Project . MSG_WARN ) ; } log ( getCommandLine ( ) . describeCommand ( ) , Project . MSG_VERBOSE ) ; } else { if ( getCommandLine ( ) . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( newEnvironment || null != env . getVariables ( ) ) { log ( "Changes to environment variables are ignored when same " + "JVM is used." , Project . MSG_WARN ) ; } if ( getCommandLine ( ) . getBootclasspath ( ) != null ) { log ( "bootclasspath ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( perm == null ) { perm = new Permissions ( true ) ; log ( "running " + this . getCommandLine ( ) . getClassname ( ) + " with default permissions (exit forbidden)" , Project . MSG_VERBOSE ) ; } log ( "Running in same VM " + getCommandLine ( ) . describeJavaCommand ( ) , Project . MSG_VERBOSE ) ; } setupRedirector ( ) ; try { if ( fork ) { if ( ! spawn ) { return fork ( getCommandLine ( ) . getCommandline ( ) ) ; } else { spawn ( getCommandLine ( ) . getCommandline ( ) ) ; return 0 ; } } else { try { run ( getCommandLine ( ) ) ; return 0 ; } catch ( ExitException ex ) { return ex . getStatus ( ) ; } } } catch ( BuildException e ) { if ( e . getLocation ( ) == null && getLocation ( ) != null ) { e . setLocation ( getLocation ( ) ) ; } if ( failOnError ) { throw e ; } else { log ( e ) ; return 0 ; } } catch ( ThreadDeath t ) { throw t ; } catch ( Throwable t ) { if ( failOnError ) { throw new BuildException ( t , getLocation ( ) ) ; } else { log ( t ) ; return 0 ; } } } public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return getCommandLine ( ) . createClasspath ( getProject ( ) ) . createPath ( ) ; } public Path createBootclasspath ( ) { return getCommandLine ( ) . createBootclasspath ( getProject ( ) ) . createPath ( ) ; } public Permissions createPermissions ( ) { perm = ( perm == null ) ? new Permissions ( ) : perm ; return perm ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setJar ( File jarfile ) throws BuildException { if ( getCommandLine ( ) . getClassname ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command." ) ; } getCommandLine ( ) . setJar ( jarfile . getAbsolutePath ( ) ) ; } public void setClassname ( String s ) throws BuildException { if ( getCommandLine ( ) . getJar ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command" ) ; } getCommandLine ( ) . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; getCommandLine ( ) . createArgument ( ) . setLine ( s ) ; } public void setCloneVm ( boolean cloneVm ) { getCommandLine ( ) . setCloneVm ( cloneVm ) ; } public Commandline . Argument createArg ( ) { return getCommandLine ( ) . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; incompatibleWithSpawn = true ; } protected void maybeSetResultPropertyValue ( int result ) { String res = Integer . toString ( result ) ; if ( resultProperty != null ) { getProject ( ) . setNewProperty ( resultProperty , res ) ; } } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; getCommandLine ( ) . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return getCommandLine ( ) . createVmArgument ( ) ; } public void setJvm ( String s ) { getCommandLine ( ) . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { getCommandLine ( ) . addSysproperty ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { getCommandLine ( ) . addSyspropertyset ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; incompatibleWithSpawn |= fail ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { this . output = out ; incompatibleWithSpawn = true ; } public void setInput ( File input ) { if ( inputString != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } this . input = input ; incompatibleWithSpawn = true ; } public void setInputString ( String inputString ) { if ( input != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } this . inputString = inputString ; incompatibleWithSpawn = true ; } public void setLogError ( boolean logError ) { redirector . setLogError ( logError ) ; incompatibleWithSpawn |= logError ; } public void setError ( File error ) { this . error = error ; incompatibleWithSpawn = true ; } public void setOutputproperty ( String outputProp ) { redirector . setOutputProperty ( outputProp ) ; incompatibleWithSpawn = true ; } public void setErrorProperty ( String errorProperty ) { redirector . setErrorProperty ( errorProperty ) ; incompatibleWithSpawn = true ; } public void setMaxmemory ( String max ) { getCommandLine ( ) . setMaxmemory ( max ) ; } public void setJVMVersion ( String value ) { getCommandLine ( ) . setVmversion ( value ) ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setAppend ( boolean append ) { redirector . setAppend ( append ) ; incompatibleWithSpawn = true ; } public void setTimeout ( Long value ) { timeout = value ; incompatibleWithSpawn |= timeout != null ; } public void addAssertions ( Assertions asserts ) { if ( getCommandLine ( ) . getAssertions ( ) != null ) { throw new BuildException ( "Only one assertion declaration is allowed" ) ; } getCommandLine ( ) . setAssertions ( asserts ) ; } public void addConfiguredRedirector ( RedirectorElement redirectorElement ) { if ( this . redirectorElement != null ) { throw new BuildException ( "cannot have > 1 nested redirectors" ) ; } this . redirectorElement = redirectorElement ; incompatibleWithSpawn = true ; } protected void handleOutput ( String output ) { if ( redirector . getOutputStream ( ) != null ) { redirector . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { return redirector . handleInput ( buffer , offset , length ) ; } protected void handleFlush ( String output ) { if ( redirector . getOutputStream ( ) != null ) { redirector . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } protected void handleErrorOutput ( String output ) { if ( redirector . getErrorStream ( ) != null ) { redirector . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void handleErrorFlush ( String output ) { if ( redirector . getErrorStream ( ) != null ) { redirector . handleErrorFlush ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void setupRedirector ( ) { redirector . setInput ( input ) ; redirector . setInputString ( inputString ) ; redirector . setOutput ( output ) ; redirector . setError ( error ) ; if ( redirectorElement != null ) { redirectorElement . configure ( redirector ) ; } if ( ! spawn && input == null && inputString == null ) { redirector . setInputStream ( new KeepAliveInputStream ( getProject ( ) . getDefaultInputStream ( ) ) ) ; } } private void run ( CommandlineJava command ) throws BuildException { try { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; exe . setPermissions ( perm ) ; exe . setTimeout ( timeout ) ; redirector . createStreams ( ) ; exe . execute ( getProject ( ) ) ; redirector . complete ( ) ; if ( exe . killedProcess ( ) ) { throw new BuildException ( "Timeout: killed the sub-process" ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } } private int fork ( String [ ] command ) throws BuildException { Execute exe = new Execute ( redirector . createHandler ( ) , createWatchdog ( ) ) ; setupExecutable ( exe , command ) ; try { int rc = exe . execute ( ) ; redirector . complete ( ) ; if ( exe . killedProcess ( ) ) { throw new BuildException ( "Timeout: killed the sub-process" ) ; } return rc ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private void spawn ( String [ ] command ) throws BuildException { Execute exe = new Execute ( ) ; setupExecutable ( exe , command ) ; try { exe . spawn ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private void setupExecutable ( Execute exe , String [ ] command ) { exe . setAntRun ( getProject ( ) ) ; setupWorkingDir ( exe ) ; setupEnvironment ( exe ) ; setupCommandLine ( exe , command ) ; } private void setupEnvironment ( Execute exe ) { String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; } private void setupWorkingDir ( Execute exe ) { if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , getLocation ( ) ) ; } exe . setWorkingDirectory ( dir ) ; } private void setupCommandLine ( Execute exe , String [ ] command ) { if ( Os . isFamily ( "openvms" ) ) { setupCommandLineForVMS ( exe , command ) ; } else { exe . setCommandline ( command ) ; } } private void setupCommandLineForVMS ( Execute exe , String [ ] command ) { ExecuteJava . setupCommandLineForVMS ( exe , command ) ; } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { getCommandLine ( ) . clearJavaArgs ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } private void log ( Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter w = new PrintWriter ( sw ) ; t . printStackTrace ( w ) ; w . close ( ) ; log ( sw . toString ( ) , Project . MSG_ERR ) ; } public CommandlineJava getCommandLine ( ) { return cmdl ; } public CommandlineJava . SysProperties getSysProperties ( ) { return getCommandLine ( ) . getSystemProperties ( ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . ssh ; import java . io . File ; import java . io . IOException ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . SftpException ; import com . jcraft . jsch . SftpATTRS ; import com . jcraft . jsch . SftpProgressMonitor ; public class ScpFromMessageBySftp extends ScpFromMessage { private String remoteFile ; private File localFile ; private boolean isRecursive = false ; private boolean verbose = false ; public ScpFromMessageBySftp ( boolean verbose , Session session , String aRemoteFile , File aLocalFile , boolean recursive ) { super ( verbose , session ) ; this . verbose = verbose ; this . remoteFile = aRemoteFile ; this . localFile = aLocalFile ; this . isRecursive = recursive ; } public ScpFromMessageBySftp ( Session session , String aRemoteFile , File aLocalFile , boolean recursive ) { this ( false , session , aRemoteFile , aLocalFile , recursive ) ; } public void execute ( ) throws IOException , JSchException { ChannelSftp channel = openSftpChannel ( ) ; try { channel . connect ( ) ; try { SftpATTRS attrs = channel . stat ( remoteFile ) ; if ( attrs . isDir ( ) && ! remoteFile . endsWith ( "/" ) ) { remoteFile = remoteFile + "/" ; } } catch ( SftpException ee ) { } getDir ( channel , remoteFile , localFile ) ; } catch ( SftpException e ) { throw new JSchException ( e . toString ( ) ) ; } finally { if ( channel != null ) { channel . disconnect ( ) ; } } log ( "done\n" ) ; } private void getDir ( ChannelSftp channel , String remoteFile , File localFile ) throws IOException , SftpException { String pwd = remoteFile ; if ( remoteFile . lastIndexOf ( '/' ) != - 1 ) { if ( remoteFile . length ( ) > 1 ) { pwd = remoteFile . substring ( 0 , remoteFile . lastIndexOf ( '/' ) ) ; } } channel . cd ( pwd ) ; if ( ! localFile . exists ( ) ) { localFile . mkdirs ( ) ; } java . util . Vector files = channel . ls ( remoteFile ) ; for ( int i = 0 ; i < files . size ( ) ; i ++ ) { ChannelSftp . LsEntry le = ( ChannelSftp . LsEntry ) files . elementAt ( i ) ; String name = le . getFilename ( ) ; if ( le . getAttrs ( ) . isDir ( ) ) { if ( name . equals ( "." ) || name . equals ( ".." ) ) { continue ; } getDir ( channel , channel . pwd ( ) + "/" + name + "/" , new File ( localFile , le . getFilename ( ) ) ) ; } else { getFile ( channel , le , localFile ) ; } } channel . cd ( ".." ) ; } private void getFile ( ChannelSftp channel , ChannelSftp . LsEntry le , File localFile ) throws IOException , SftpException { String remoteFile = le . getFilename ( ) ; if ( ! localFile . exists ( ) ) { String path = localFile . getAbsolutePath ( ) ; int i = 0 ; if ( ( i = path . lastIndexOf ( File . pathSeparator ) ) != - 1 ) { if ( path . length ( ) > File . pathSeparator . length ( ) ) { new File ( path . substring ( 0 , i ) ) . mkdirs ( ) ; } } } if ( localFile . isDirectory ( ) ) { localFile = new File ( localFile , remoteFile ) ; } long startTime = System . currentTimeMillis ( ) ; long totalLength = le . getAttrs ( ) . getSize ( ) ; SftpProgressMonitor monitor = null ; boolean trackProgress = getVerbose ( ) && totalLength > 102400 ; if ( trackProgress ) { monitor = getProgressMonitor ( ) ; } try { log ( "Receiving: " + remoteFile + " : " + le . getAttrs ( ) . getSize ( ) ) ; channel . get ( remoteFile , localFile . getAbsolutePath ( ) , monitor ) ; } finally { long endTime = System . currentTimeMillis ( ) ; logStats ( startTime , endTime , ( int ) totalLength ) ; } } } 	1
package org . apache . tools . ant ; import org . apache . tools . ant . util . StringUtils ; public class NoBannerLogger extends DefaultLogger { protected String targetName ; public NoBannerLogger ( ) { } public void targetStarted ( BuildEvent event ) { targetName = event . getTarget ( ) . getName ( ) ; } public void targetFinished ( BuildEvent event ) { targetName = null ; } public void messageLogged ( BuildEvent event ) { if ( event . getPriority ( ) > msgOutputLevel || null == event . getMessage ( ) || "" . equals ( event . getMessage ( ) . trim ( ) ) ) { return ; } if ( null != targetName ) { out . println ( StringUtils . LINE_SEP + targetName + ":" ) ; targetName = null ; } super . messageLogged ( event ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . net . URL ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . helper . ProjectHelper2 ; import org . apache . tools . ant . UnknownElement ; public class Antlib extends Task implements TaskContainer { public static final String TAG = "antlib" ; public static Antlib createAntlib ( Project project , URL antlibUrl , String uri ) { try { antlibUrl . openConnection ( ) . connect ( ) ; } catch ( IOException ex ) { throw new BuildException ( "Unable to find " + antlibUrl , ex ) ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; helper . enterAntLib ( uri ) ; try { ProjectHelper2 parser = new ProjectHelper2 ( ) ; UnknownElement ue = parser . parseUnknownElement ( project , antlibUrl ) ; if ( ! ( ue . getTag ( ) . equals ( TAG ) ) ) { throw new BuildException ( "Unexpected tag " + ue . getTag ( ) + " expecting " + TAG , ue . getLocation ( ) ) ; } Antlib antlib = new Antlib ( ) ; antlib . setProject ( project ) ; antlib . setLocation ( ue . getLocation ( ) ) ; antlib . setTaskName ( "antlib" ) ; antlib . init ( ) ; ue . configure ( antlib ) ; return antlib ; } finally { helper . exitAntLib ( ) ; } } private ClassLoader classLoader ; private String uri = "" ; private List tasks = new ArrayList ( ) ; protected void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } protected void setURI ( String uri ) { this . uri = uri ; } private ClassLoader getClassLoader ( ) { if ( classLoader == null ) { classLoader = Antlib . class . getClassLoader ( ) ; } return classLoader ; } public void addTask ( Task nestedTask ) { tasks . add ( nestedTask ) ; } public void execute ( ) { for ( Iterator i = tasks . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement ue = ( UnknownElement ) i . next ( ) ; setLocation ( ue . getLocation ( ) ) ; ue . maybeConfigure ( ) ; Object configuredObject = ue . getRealThing ( ) ; if ( configuredObject == null ) { continue ; } if ( ! ( configuredObject instanceof AntlibDefinition ) ) { throw new BuildException ( "Invalid task in antlib " + ue . getTag ( ) + " " + configuredObject . getClass ( ) + " does not " + "extend org.apache.tools.ant.taskdefs.AntlibDefinition" ) ; } AntlibDefinition def = ( AntlibDefinition ) configuredObject ; def . setURI ( uri ) ; def . setAntlibClassLoader ( getClassLoader ( ) ) ; def . init ( ) ; def . execute ( ) ; } } } 	1
package org . apache . tools . ant ; import org . apache . tools . ant . launch . Launcher ; public final class MagicNames { private MagicNames ( ) { } public static final String ANTLIB_PREFIX = "antlib:" ; public static final String ANT_VERSION = "ant.version" ; public static final String BUILD_SYSCLASSPATH = "build.sysclasspath" ; public static final String SCRIPT_REPOSITORY = "org.apache.ant.scriptrepo" ; public static final String SYSTEM_LOADER_REF = "ant.coreLoader" ; public static final String REPOSITORY_DIR_PROPERTY = "ant.maven.repository.dir" ; public static final String REPOSITORY_URL_PROPERTY = "ant.maven.repository.url" ; public static final String TASKDEF_PROPERTIES_RESOURCE = "/org/apache/tools/ant/taskdefs/defaults.properties" ; public static final String TYPEDEFS_PROPERTIES_RESOURCE = "/org/apache/tools/ant/types/defaults.properties" ; public static final String ANT_EXECUTOR_REFERENCE = "ant.executor" ; public static final String ANT_EXECUTOR_CLASSNAME = "ant.executor.class" ; public static final String PROJECT_BASEDIR = "basedir" ; public static final String ANT_FILE = "ant.file" ; public static final String ANT_JAVA_VERSION = "ant.java.version" ; public static final String ANT_HOME = Launcher . ANTHOME_PROPERTY ; public static final String ANT_LIB = "ant.core.lib" ; public static final String REGEXP_IMPL = "ant.regexp.regexpimpl" ; public static final String BUILD_JAVAC_SOURCE = "ant.build.javac.source" ; public static final String BUILD_JAVAC_TARGET = "ant.build.javac.target" ; public static final String REFID_CLASSPATH_REUSE_LOADER = "ant.reuse.loader" ; public static final String REFID_CLASSPATH_LOADER_PREFIX = "ant.loader." ; public static final String REFID_PROPERTY_HELPER = "ant.PropertyHelper" ; } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Path ; import java . io . File ; public class Classloader extends Task { public static final String SYSTEM_LOADER_REF = MagicNames . SYSTEM_LOADER_REF ; private String name = null ; private Path classpath ; private boolean reset = false ; private boolean parentFirst = true ; private String parentName = null ; public Classloader ( ) { } public void setName ( String name ) { this . name = name ; } public void setReset ( boolean b ) { this . reset = b ; } public void setReverse ( boolean b ) { this . parentFirst = ! b ; } public void setParentFirst ( boolean b ) { this . parentFirst = b ; } public void setParentName ( String name ) { this . parentName = name ; } public void setClasspathRef ( Reference pathRef ) throws BuildException { classpath = ( Path ) pathRef . getReferencedObject ( getProject ( ) ) ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( null ) ; } return this . classpath . createPath ( ) ; } public void execute ( ) { try { if ( "only" . equals ( getProject ( ) . getProperty ( "build.sysclasspath" ) ) && ( name == null || SYSTEM_LOADER_REF . equals ( name ) ) ) { log ( "Changing the system loader is disabled " + "by build.sysclasspath=only" , Project . MSG_WARN ) ; return ; } String loaderName = ( name == null ) ? SYSTEM_LOADER_REF : name ; Object obj = getProject ( ) . getReference ( loaderName ) ; if ( reset ) { obj = null ; } if ( obj != null && ! ( obj instanceof AntClassLoader ) ) { log ( "Referenced object is not an AntClassLoader" , Project . MSG_ERR ) ; return ; } AntClassLoader acl = ( AntClassLoader ) obj ; if ( acl == null ) { Object parent = null ; if ( parentName != null ) { parent = getProject ( ) . getReference ( parentName ) ; if ( ! ( parent instanceof ClassLoader ) ) { parent = null ; } } if ( parent == null ) { parent = this . getClass ( ) . getClassLoader ( ) ; } if ( name == null ) { } getProject ( ) . log ( "Setting parent loader " + name + " " + parent + " " + parentFirst , Project . MSG_DEBUG ) ; acl = new AntClassLoader ( ( ClassLoader ) parent , getProject ( ) , classpath , parentFirst ) ; getProject ( ) . addReference ( loaderName , acl ) ; if ( name == null ) { acl . addLoaderPackageRoot ( "org.apache.tools.ant.taskdefs.optional" ) ; getProject ( ) . setCoreLoader ( acl ) ; } } if ( classpath != null ) { String [ ] list = classpath . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = new File ( list [ i ] ) ; if ( f . exists ( ) ) { acl . addPathElement ( f . getAbsolutePath ( ) ) ; log ( "Adding to class loader " + acl + " " + f . getAbsolutePath ( ) , Project . MSG_DEBUG ) ; } } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Vector ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ArchiveFileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . ArchiveResource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . types . resources . TarResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . bzip2 . CBZip2OutputStream ; import org . apache . tools . tar . TarConstants ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarOutputStream ; public class Tar extends MatchingTask { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; File tarFile ; File baseDir ; private TarLongFileMode longFileMode = new TarLongFileMode ( ) ; Vector filesets = new Vector ( ) ; private Vector resourceCollections = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; private TarCompressionMethod compression = new TarCompressionMethod ( ) ; public TarFileSet createTarFileSet ( ) { TarFileSet fs = new TarFileSet ( ) ; fs . setProject ( getProject ( ) ) ; filesets . addElement ( fs ) ; return fs ; } public void add ( ResourceCollection res ) { resourceCollections . add ( res ) ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setDestFile ( File destFile ) { this . tarFile = destFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { log ( "DEPRECATED - The setLongfile(String) method has been deprecated." + " Use setLongfile(Tar.TarLongFileMode) instead." ) ; this . longFileMode = new TarLongFileMode ( ) ; longFileMode . setValue ( mode ) ; } public void setLongfile ( TarLongFileMode mode ) { this . longFileMode = mode ; } public void setCompression ( TarCompressionMethod mode ) { this . compression = mode ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , getLocation ( ) ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , getLocation ( ) ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , getLocation ( ) ) ; } Vector savedFileSets = ( Vector ) filesets . clone ( ) ; try { if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , getLocation ( ) ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 && resourceCollections . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basedir " + "attribute or some nested resource" + " collections." , getLocation ( ) ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { upToDate &= check ( ( TarFileSet ) e . nextElement ( ) ) ; } for ( Enumeration e = resourceCollections . elements ( ) ; e . hasMoreElements ( ) ; ) { upToDate &= check ( ( ResourceCollection ) e . nextElement ( ) ) ; } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( compression . compress ( new BufferedOutputStream ( new FileOutputStream ( tarFile ) ) ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . isTruncateMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . isFailMode ( ) || longFileMode . isOmitMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { tar ( ( TarFileSet ) e . nextElement ( ) , tOut ) ; } for ( Enumeration e = resourceCollections . elements ( ) ; e . hasMoreElements ( ) ; ) { tar ( ( ResourceCollection ) e . nextElement ( ) , tOut ) ; } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( tOut ) ; } } finally { filesets = savedFileSets ; } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { if ( file . equals ( tarFile ) ) { return ; } tarResource ( new FileResource ( file ) , tOut , vPath , tarFileSet ) ; } protected void tarResource ( Resource r , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { if ( ! r . isExists ( ) ) { return ; } if ( tarFileSet != null ) { String fullpath = tarFileSet . getFullpath ( this . getProject ( ) ) ; if ( fullpath . length ( ) > 0 ) { vPath = fullpath ; } else { if ( vPath . length ( ) <= 0 ) { return ; } String prefix = tarFileSet . getPrefix ( this . getProject ( ) ) ; if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) ) { prefix = prefix + "/" ; } vPath = prefix + vPath ; } if ( vPath . startsWith ( "/" ) && ! tarFileSet . getPreserveLeadingSlashes ( ) ) { int l = vPath . length ( ) ; if ( l <= 1 ) { return ; } vPath = vPath . substring ( 1 , l ) ; } } if ( r . isDirectory ( ) && ! vPath . endsWith ( "/" ) ) { vPath += "/" ; } if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . isOmitMode ( ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . isWarnMode ( ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed " + "successfully by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . isFailMode ( ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , getLocation ( ) ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setModTime ( r . getLastModified ( ) ) ; if ( r instanceof ArchiveResource ) { ArchiveResource ar = ( ArchiveResource ) r ; te . setMode ( ar . getMode ( ) ) ; if ( r instanceof TarResource ) { TarResource tr = ( TarResource ) r ; te . setUserName ( tr . getUserName ( ) ) ; te . setUserId ( tr . getUid ( ) ) ; te . setGroupName ( tr . getGroup ( ) ) ; te . setGroupId ( tr . getGid ( ) ) ; } } if ( ! r . isDirectory ( ) ) { if ( r . size ( ) > TarConstants . MAXSIZE ) { throw new BuildException ( "Resource: " + r + " larger than " + TarConstants . MAXSIZE + " bytes." ) ; } te . setSize ( r . getSize ( ) ) ; if ( tarFileSet != null && tarFileSet . hasFileModeBeenSet ( ) ) { te . setMode ( tarFileSet . getMode ( ) ) ; } } else if ( tarFileSet != null && tarFileSet . hasDirModeBeenSet ( ) ) { te . setMode ( tarFileSet . getDirMode ( this . getProject ( ) ) ) ; } if ( tarFileSet != null ) { if ( tarFileSet . hasUserNameBeenSet ( ) ) { te . setUserName ( tarFileSet . getUserName ( ) ) ; } if ( tarFileSet . hasGroupBeenSet ( ) ) { te . setGroupName ( tarFileSet . getGroup ( ) ) ; } if ( tarFileSet . hasUserIdBeenSet ( ) ) { te . setUserId ( tarFileSet . getUid ( ) ) ; } if ( tarFileSet . hasGroupIdBeenSet ( ) ) { te . setGroupId ( tarFileSet . getGid ( ) ) ; } } InputStream in = null ; try { tOut . putNextEntry ( te ) ; if ( ! r . isDirectory ( ) ) { in = r . getInputStream ( ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } tOut . closeEntry ( ) ; } finally { FileUtils . close ( in ) ; } } protected boolean archiveIsUpToDate ( String [ ] files ) { return archiveIsUpToDate ( files , baseDir ) ; } protected boolean archiveIsUpToDate ( String [ ] files , File dir ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , dir , null , mm ) . length == 0 ; } protected boolean archiveIsUpToDate ( Resource r ) { return SelectorUtils . isOutOfDate ( new FileResource ( tarFile ) , r , FileUtils . getFileUtils ( ) . getFileTimestampGranularity ( ) ) ; } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( Tar . class ) ; } protected boolean check ( ResourceCollection rc ) { boolean upToDate = true ; if ( isFileFileSet ( rc ) ) { FileSet fs = ( FileSet ) rc ; upToDate = check ( fs . getDir ( getProject ( ) ) , getFileNames ( fs ) ) ; } else if ( ! rc . isFilesystemOnly ( ) && ! supportsNonFileResources ( ) ) { throw new BuildException ( "only filesystem resources are supported" ) ; } else if ( rc . isFilesystemOnly ( ) ) { HashSet basedirs = new HashSet ( ) ; HashMap basedirToFilesMap = new HashMap ( ) ; Iterator iter = rc . iterator ( ) ; while ( iter . hasNext ( ) ) { FileResource r = ( FileResource ) iter . next ( ) ; File base = r . getBaseDir ( ) ; if ( base == null ) { base = Copy . NULL_FILE_PLACEHOLDER ; } basedirs . add ( base ) ; Vector files = ( Vector ) basedirToFilesMap . get ( base ) ; if ( files == null ) { files = new Vector ( ) ; basedirToFilesMap . put ( base , new Vector ( ) ) ; } files . add ( r . getName ( ) ) ; } iter = basedirs . iterator ( ) ; while ( iter . hasNext ( ) ) { File base = ( File ) iter . next ( ) ; Vector f = ( Vector ) basedirToFilesMap . get ( base ) ; String [ ] files = ( String [ ] ) f . toArray ( new String [ f . size ( ) ] ) ; upToDate &= check ( base == Copy . NULL_FILE_PLACEHOLDER ? null : base , files ) ; } } else { Iterator iter = rc . iterator ( ) ; while ( upToDate && iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; upToDate &= archiveIsUpToDate ( r ) ; } } return upToDate ; } protected boolean check ( File basedir , String [ ] files ) { boolean upToDate = true ; if ( ! archiveIsUpToDate ( files , basedir ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( basedir , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include " + "itself" , getLocation ( ) ) ; } } return upToDate ; } protected void tar ( ResourceCollection rc , TarOutputStream tOut ) throws IOException { ArchiveFileSet afs = null ; if ( rc instanceof ArchiveFileSet ) { afs = ( ArchiveFileSet ) rc ; } if ( afs != null && afs . size ( ) > 1 && afs . getFullpath ( this . getProject ( ) ) . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only " + "be specified for " + "filesets that specify a " + "single file." ) ; } TarFileSet tfs = asTarFileSet ( afs ) ; if ( isFileFileSet ( rc ) ) { FileSet fs = ( FileSet ) rc ; String [ ] files = getFileNames ( fs ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( fs . getDir ( getProject ( ) ) , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , tfs ) ; } } else if ( rc . isFilesystemOnly ( ) ) { Iterator iter = rc . iterator ( ) ; while ( iter . hasNext ( ) ) { FileResource r = ( FileResource ) iter . next ( ) ; File f = r . getFile ( ) ; if ( f == null ) { f = new File ( r . getBaseDir ( ) , r . getName ( ) ) ; } tarFile ( f , tOut , f . getName ( ) , tfs ) ; } } else { Iterator iter = rc . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; tarResource ( r , tOut , r . getName ( ) , tfs ) ; } } } protected static final boolean isFileFileSet ( ResourceCollection rc ) { return rc instanceof FileSet && rc . isFilesystemOnly ( ) ; } protected static final String [ ] getFileNames ( FileSet fs ) { DirectoryScanner ds = fs . getDirectoryScanner ( fs . getProject ( ) ) ; String [ ] directories = ds . getIncludedDirectories ( ) ; String [ ] filesPerSe = ds . getIncludedFiles ( ) ; String [ ] files = new String [ directories . length + filesPerSe . length ] ; System . arraycopy ( directories , 0 , files , 0 , directories . length ) ; System . arraycopy ( filesPerSe , 0 , files , directories . length , filesPerSe . length ) ; return files ; } protected TarFileSet asTarFileSet ( ArchiveFileSet archiveFileSet ) { TarFileSet tfs = null ; if ( archiveFileSet != null && archiveFileSet instanceof TarFileSet ) { tfs = ( TarFileSet ) archiveFileSet ; } else { tfs = new TarFileSet ( ) ; tfs . setProject ( getProject ( ) ) ; if ( archiveFileSet != null ) { tfs . setPrefix ( archiveFileSet . getPrefix ( getProject ( ) ) ) ; tfs . setFullpath ( archiveFileSet . getFullpath ( getProject ( ) ) ) ; if ( archiveFileSet . hasFileModeBeenSet ( ) ) { tfs . integerSetFileMode ( archiveFileSet . getFileMode ( getProject ( ) ) ) ; } if ( archiveFileSet . hasDirModeBeenSet ( ) ) { tfs . integerSetDirMode ( archiveFileSet . getDirMode ( getProject ( ) ) ) ; } if ( archiveFileSet instanceof org . apache . tools . ant . types . TarFileSet ) { org . apache . tools . ant . types . TarFileSet t = ( org . apache . tools . ant . types . TarFileSet ) archiveFileSet ; if ( t . hasUserNameBeenSet ( ) ) { tfs . setUserName ( t . getUserName ( ) ) ; } if ( t . hasGroupBeenSet ( ) ) { tfs . setGroup ( t . getGroup ( ) ) ; } if ( t . hasUserIdBeenSet ( ) ) { tfs . setUid ( t . getUid ( ) ) ; } if ( t . hasGroupIdBeenSet ( ) ) { tfs . setGid ( t . getGid ( ) ) ; } } } } return tfs ; } public static class TarFileSet extends org . apache . tools . ant . types . TarFileSet { private String [ ] files = null ; private boolean preserveLeadingSlashes = false ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { files = getFileNames ( this ) ; } return files ; } public void setMode ( String octalString ) { setFileMode ( octalString ) ; } public int getMode ( ) { return getFileMode ( this . getProject ( ) ) ; } public void setPreserveLeadingSlashes ( boolean b ) { this . preserveLeadingSlashes = b ; } public boolean getPreserveLeadingSlashes ( ) { return preserveLeadingSlashes ; } } public static class TarLongFileMode extends EnumeratedAttribute { public static final String WARN = "warn" , FAIL = "fail" , TRUNCATE = "truncate" , GNU = "gnu" , OMIT = "omit" ; private final String [ ] validModes = { WARN , FAIL , TRUNCATE , GNU , OMIT } ; public TarLongFileMode ( ) { super ( ) ; setValue ( WARN ) ; } public String [ ] getValues ( ) { return validModes ; } public boolean isTruncateMode ( ) { return TRUNCATE . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isWarnMode ( ) { return WARN . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isGnuMode ( ) { return GNU . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFailMode ( ) { return FAIL . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isOmitMode ( ) { return OMIT . equalsIgnoreCase ( getValue ( ) ) ; } } public static final class TarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public TarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } private OutputStream compress ( final OutputStream ostream ) throws IOException { final String v = getValue ( ) ; if ( GZIP . equals ( v ) ) { return new GZIPOutputStream ( ostream ) ; } else { if ( BZIP2 . equals ( v ) ) { ostream . write ( 'B' ) ; ostream . write ( 'Z' ) ; return new CBZip2OutputStream ( ostream ) ; } } return ostream ; } } } 	1
package org . apache . tools . ant . taskdefs . rmic ; import java . lang . reflect . Method ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class WLRmic extends DefaultRmicAdapter { public static final String WLRMIC_CLASSNAME = "weblogic.rmic" ; public static final String COMPILER_NAME = "weblogic" ; public static final String ERROR_NO_WLRMIC_ON_CLASSPATH = "Cannot use WebLogic rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "CLASSPATH." ; public static final String ERROR_WLRMIC_FAILED = "Error starting WebLogic rmic: " ; public static final String WL_RMI_STUB_SUFFIX = "_WLStub" ; public static final String WL_RMI_SKEL_SUFFIX = "_WLSkel" ; public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using WebLogic rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( new String [ ] { "-noexit" } ) ; AntClassLoader loader = null ; try { Class c = null ; if ( getRmic ( ) . getClasspath ( ) == null ) { c = Class . forName ( WLRMIC_CLASSNAME ) ; } else { loader = getRmic ( ) . getProject ( ) . createClassLoader ( getRmic ( ) . getClasspath ( ) ) ; c = Class . forName ( WLRMIC_CLASSNAME , true , loader ) ; } Method doRmic = c . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; doRmic . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return true ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( ERROR_NO_WLRMIC_ON_CLASSPATH , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( ERROR_WLRMIC_FAILED , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { if ( loader != null ) { loader . cleanup ( ) ; } } } public String getStubClassSuffix ( ) { return WL_RMI_STUB_SUFFIX ; } public String getSkelClassSuffix ( ) { return WL_RMI_SKEL_SUFFIX ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . IsSigned ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . FileNameMapper ; public class SignJar extends AbstractJarSignerTask { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected String sigfile ; protected File signedjar ; protected boolean internalsf ; protected boolean sectionsonly ; private boolean preserveLastModified ; protected boolean lazy ; protected File destDir ; private FileNameMapper mapper ; protected String tsaurl ; protected String tsacert ; public static final String ERROR_TODIR_AND_SIGNEDJAR = "'destdir' and 'signedjar' cannot both be set" ; public static final String ERROR_TOO_MANY_MAPPERS = "Too many mappers" ; public static final String ERROR_SIGNEDJAR_AND_PATHS = "You cannot specify the signed JAR when using paths or filesets" ; public static final String ERROR_BAD_MAP = "Cannot map source file to anything sensible: " ; public static final String ERROR_MAPPER_WITHOUT_DEST = "The destDir attribute is required if a mapper is set" ; public static final String ERROR_NO_ALIAS = "alias attribute must be set" ; public static final String ERROR_NO_STOREPASS = "storepass attribute must be set" ; public void setSigfile ( final String sigfile ) { this . sigfile = sigfile ; } public void setSignedjar ( final File signedjar ) { this . signedjar = signedjar ; } public void setInternalsf ( final boolean internalsf ) { this . internalsf = internalsf ; } public void setSectionsonly ( final boolean sectionsonly ) { this . sectionsonly = sectionsonly ; } public void setLazy ( final boolean lazy ) { this . lazy = lazy ; } public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void add ( FileNameMapper newMapper ) { if ( mapper != null ) { throw new BuildException ( ERROR_TOO_MANY_MAPPERS ) ; } mapper = newMapper ; } public FileNameMapper getMapper ( ) { return mapper ; } public String getTsaurl ( ) { return tsaurl ; } public void setTsaurl ( String tsaurl ) { this . tsaurl = tsaurl ; } public String getTsacert ( ) { return tsacert ; } public void setTsacert ( String tsacert ) { this . tsacert = tsacert ; } public void execute ( ) throws BuildException { final boolean hasJar = jar != null ; final boolean hasSignedJar = signedjar != null ; final boolean hasDestDir = destDir != null ; final boolean hasMapper = mapper != null ; if ( ! hasJar && ! hasResources ( ) ) { throw new BuildException ( ERROR_NO_SOURCE ) ; } if ( null == alias ) { throw new BuildException ( ERROR_NO_ALIAS ) ; } if ( null == storepass ) { throw new BuildException ( ERROR_NO_STOREPASS ) ; } if ( hasDestDir && hasSignedJar ) { throw new BuildException ( ERROR_TODIR_AND_SIGNEDJAR ) ; } if ( hasResources ( ) && hasSignedJar ) { throw new BuildException ( ERROR_SIGNEDJAR_AND_PATHS ) ; } if ( ! hasDestDir && hasMapper ) { throw new BuildException ( ERROR_MAPPER_WITHOUT_DEST ) ; } beginExecution ( ) ; try { if ( hasJar && hasSignedJar ) { signOneJar ( jar , signedjar ) ; return ; } Path sources = createUnifiedSourcePath ( ) ; FileNameMapper destMapper ; if ( hasMapper ) { destMapper = mapper ; } else { destMapper = new IdentityMapper ( ) ; } Iterator iter = sources . iterator ( ) ; while ( iter . hasNext ( ) ) { FileResource fr = ( FileResource ) iter . next ( ) ; File toDir = hasDestDir ? destDir : fr . getBaseDir ( ) ; String [ ] destFilenames = destMapper . mapFileName ( fr . getName ( ) ) ; if ( destFilenames == null || destFilenames . length != 1 ) { throw new BuildException ( ERROR_BAD_MAP + fr . getFile ( ) ) ; } File destFile = new File ( toDir , destFilenames [ 0 ] ) ; signOneJar ( fr . getFile ( ) , destFile ) ; } } finally { endExecution ( ) ; } } private void signOneJar ( File jarSource , File jarTarget ) throws BuildException { File targetFile = jarTarget ; if ( targetFile == null ) { targetFile = jarSource ; } if ( isUpToDate ( jarSource , targetFile ) ) { return ; } long lastModified = jarSource . lastModified ( ) ; final ExecTask cmd = createJarSigner ( ) ; setCommonOptions ( cmd ) ; bindToKeystore ( cmd ) ; if ( null != sigfile ) { addValue ( cmd , "-sigfile" ) ; String value = this . sigfile ; addValue ( cmd , value ) ; } if ( null != targetFile && ! jarSource . equals ( targetFile ) ) { addValue ( cmd , "-signedjar" ) ; addValue ( cmd , targetFile . getPath ( ) ) ; } if ( internalsf ) { addValue ( cmd , "-internalsf" ) ; } if ( sectionsonly ) { addValue ( cmd , "-sectionsonly" ) ; } addTimestampAuthorityCommands ( cmd ) ; addValue ( cmd , jarSource . getPath ( ) ) ; addValue ( cmd , alias ) ; log ( "Signing JAR: " + jarSource . getAbsolutePath ( ) + " to " + targetFile . getAbsolutePath ( ) + " as " + alias ) ; cmd . execute ( ) ; if ( preserveLastModified ) { targetFile . setLastModified ( lastModified ) ; } } private void addTimestampAuthorityCommands ( final ExecTask cmd ) { if ( tsaurl != null ) { addValue ( cmd , "-tsa" ) ; addValue ( cmd , tsaurl ) ; } if ( tsacert != null ) { addValue ( cmd , "-tsacert" ) ; addValue ( cmd , tsacert ) ; } } protected boolean isUpToDate ( File jarFile , File signedjarFile ) { if ( null == jarFile || ! jarFile . exists ( ) ) { return false ; } File destFile = signedjarFile ; if ( destFile == null ) { destFile = jarFile ; } if ( jarFile . equals ( destFile ) ) { if ( lazy ) { return isSigned ( jarFile ) ; } return false ; } return FILE_UTILS . isUpToDate ( jarFile , destFile ) ; } protected boolean isSigned ( File file ) { try { return IsSigned . isSigned ( file , alias ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } } public void setPreserveLastModified ( boolean preserveLastModified ) { this . preserveLastModified = preserveLastModified ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Map ; import java . util . HashMap ; import java . util . Enumeration ; import java . util . Locale ; import java . util . NoSuchElementException ; import java . util . Properties ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; public abstract class Definer extends DefBase { private static final String ANTLIB_XML = "/antlib.xml" ; private static class ResourceStack extends ThreadLocal { public Object initialValue ( ) { return new HashMap ( ) ; } Map getStack ( ) { return ( Map ) get ( ) ; } } private static ResourceStack resourceStack = new ResourceStack ( ) ; private String name ; private String classname ; private File file ; private String resource ; private int format = Format . PROPERTIES ; private boolean definerSet = false ; private int onError = OnError . FAIL ; private String adapter ; private String adaptTo ; private Class adapterClass ; private Class adaptToClass ; public static class OnError extends EnumeratedAttribute { public static final int FAIL = 0 , REPORT = 1 , IGNORE = 2 , FAIL_ALL = 3 ; public static final String POLICY_FAIL = "fail" ; public static final String POLICY_REPORT = "report" ; public static final String POLICY_IGNORE = "ignore" ; public static final String POLICY_FAILALL = "failall" ; public OnError ( ) { super ( ) ; } public OnError ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return new String [ ] { POLICY_FAIL , POLICY_REPORT , POLICY_IGNORE , POLICY_FAILALL } ; } } public static class Format extends EnumeratedAttribute { public static final int PROPERTIES = 0 , XML = 1 ; public String [ ] getValues ( ) { return new String [ ] { "properties" , "xml" } ; } } public void setOnError ( OnError onError ) { this . onError = onError . getIndex ( ) ; } public void setFormat ( Format format ) { this . format = format . getIndex ( ) ; } public String getName ( ) { return name ; } public File getFile ( ) { return file ; } public String getResource ( ) { return resource ; } public void execute ( ) throws BuildException { ClassLoader al = createLoader ( ) ; if ( ! definerSet ) { if ( getURI ( ) == null ) { throw new BuildException ( "name, file or resource attribute of " + getTaskName ( ) + " is undefined" , getLocation ( ) ) ; } if ( getURI ( ) . startsWith ( MagicNames . ANTLIB_PREFIX ) ) { String uri1 = getURI ( ) ; setResource ( makeResourceFromURI ( uri1 ) ) ; } else { throw new BuildException ( "Only antlib URIs can be located from the URI alone," + "not the URI " + getURI ( ) ) ; } } if ( name != null ) { if ( classname == null ) { throw new BuildException ( "classname attribute of " + getTaskName ( ) + " element " + "is undefined" , getLocation ( ) ) ; } addDefinition ( al , name , classname ) ; } else { if ( classname != null ) { String msg = "You must not specify classname " + "together with file or resource." ; throw new BuildException ( msg , getLocation ( ) ) ; } Enumeration urls = null ; if ( file != null ) { final URL url = fileToURL ( ) ; if ( url == null ) { return ; } urls = new Enumeration ( ) { private boolean more = true ; public boolean hasMoreElements ( ) { return more ; } public Object nextElement ( ) throws NoSuchElementException { if ( more ) { more = false ; return url ; } else { throw new NoSuchElementException ( ) ; } } } ; } else { urls = resourceToURLs ( al ) ; } while ( urls . hasMoreElements ( ) ) { URL url = ( URL ) urls . nextElement ( ) ; int fmt = this . format ; if ( url . toString ( ) . toLowerCase ( Locale . US ) . endsWith ( ".xml" ) ) { fmt = Format . XML ; } if ( fmt == Format . PROPERTIES ) { loadProperties ( al , url ) ; break ; } else { if ( resourceStack . getStack ( ) . get ( url ) != null ) { log ( "Warning: Recursive loading of " + url + " ignored" + " at " + getLocation ( ) + " originally loaded at " + resourceStack . getStack ( ) . get ( url ) , Project . MSG_WARN ) ; } else { try { resourceStack . getStack ( ) . put ( url , getLocation ( ) ) ; loadAntlib ( al , url ) ; } finally { resourceStack . getStack ( ) . remove ( url ) ; } } } } } } public static String makeResourceFromURI ( String uri ) { String path = uri . substring ( MagicNames . ANTLIB_PREFIX . length ( ) ) ; String resource ; if ( path . startsWith ( "//" ) ) { resource = path . substring ( "//" . length ( ) ) ; if ( ! resource . endsWith ( ".xml" ) ) { resource = resource + ANTLIB_XML ; } } else { resource = path . replace ( '.' , '/' ) + ANTLIB_XML ; } return resource ; } private URL fileToURL ( ) { String message = null ; if ( ! ( file . exists ( ) ) ) { message = "File " + file + " does not exist" ; } if ( message == null && ! ( file . isFile ( ) ) ) { message = "File " + file + " is not a file" ; } try { if ( message == null ) { return file . toURL ( ) ; } } catch ( Exception ex ) { message = "File " + file + " cannot use as URL: " + ex . toString ( ) ; } switch ( onError ) { case OnError . FAIL_ALL : throw new BuildException ( message ) ; case OnError . FAIL : case OnError . REPORT : log ( message , Project . MSG_WARN ) ; break ; case OnError . IGNORE : log ( message , Project . MSG_VERBOSE ) ; break ; default : break ; } return null ; } private Enumeration resourceToURLs ( ClassLoader classLoader ) { Enumeration ret ; try { ret = classLoader . getResources ( resource ) ; } catch ( IOException e ) { throw new BuildException ( "Could not fetch resources named " + resource , e , getLocation ( ) ) ; } if ( ! ret . hasMoreElements ( ) ) { String message = "Could not load definitions from resource " + resource + ". It could not be found." ; switch ( onError ) { case OnError . FAIL_ALL : throw new BuildException ( message ) ; case OnError . FAIL : case OnError . REPORT : log ( message , Project . MSG_WARN ) ; break ; case OnError . IGNORE : log ( message , Project . MSG_VERBOSE ) ; break ; default : break ; } } return ret ; } protected void loadProperties ( ClassLoader al , URL url ) { InputStream is = null ; try { is = url . openStream ( ) ; if ( is == null ) { log ( "Could not load definitions from " + url , Project . MSG_WARN ) ; return ; } Properties props = new Properties ( ) ; props . load ( is ) ; Enumeration keys = props . keys ( ) ; while ( keys . hasMoreElements ( ) ) { name = ( ( String ) keys . nextElement ( ) ) ; classname = props . getProperty ( name ) ; addDefinition ( al , name , classname ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } finally { FileUtils . close ( is ) ; } } private void loadAntlib ( ClassLoader classLoader , URL url ) { try { Antlib antlib = Antlib . createAntlib ( getProject ( ) , url , getURI ( ) ) ; antlib . setClassLoader ( classLoader ) ; antlib . setURI ( getURI ( ) ) ; antlib . execute ( ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } } public void setFile ( File file ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . file = file ; } public void setResource ( String res ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . resource = res ; } public void setAntlib ( String antlib ) { if ( definerSet ) { tooManyDefinitions ( ) ; } if ( ! antlib . startsWith ( "antlib:" ) ) { throw new BuildException ( "Invalid antlib attribute - it must start with antlib:" ) ; } setURI ( antlib ) ; this . resource = antlib . substring ( "antlib:" . length ( ) ) . replace ( '.' , '/' ) + "/antlib.xml" ; definerSet = true ; } public void setName ( String name ) { if ( definerSet ) { tooManyDefinitions ( ) ; } definerSet = true ; this . name = name ; } public String getClassname ( ) { return classname ; } public void setClassname ( String classname ) { this . classname = classname ; } public void setAdapter ( String adapter ) { this . adapter = adapter ; } protected void setAdapterClass ( Class adapterClass ) { this . adapterClass = adapterClass ; } public void setAdaptTo ( String adaptTo ) { this . adaptTo = adaptTo ; } protected void setAdaptToClass ( Class adaptToClass ) { this . adaptToClass = adaptToClass ; } protected void addDefinition ( ClassLoader al , String name , String classname ) throws BuildException { Class cl = null ; try { try { name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; if ( onError != OnError . IGNORE ) { cl = Class . forName ( classname , true , al ) ; } if ( adapter != null ) { adapterClass = Class . forName ( adapter , true , al ) ; } if ( adaptTo != null ) { adaptToClass = Class . forName ( adaptTo , true , al ) ; } AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( classname ) ; def . setClass ( cl ) ; def . setAdapterClass ( adapterClass ) ; def . setAdaptToClass ( adaptToClass ) ; def . setClassLoader ( al ) ; if ( cl != null ) { def . checkClass ( getProject ( ) ) ; } ComponentHelper . getComponentHelper ( getProject ( ) ) . addDataTypeDefinition ( def ) ; } catch ( ClassNotFoundException cnfe ) { String msg = getTaskName ( ) + " class " + classname + " cannot be found" ; throw new BuildException ( msg , cnfe , getLocation ( ) ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = getTaskName ( ) + " A class needed by class " + classname + " cannot be found: " + ncdfe . getMessage ( ) ; throw new BuildException ( msg , ncdfe , getLocation ( ) ) ; } } catch ( BuildException ex ) { switch ( onError ) { case OnError . FAIL_ALL : case OnError . FAIL : throw ex ; case OnError . REPORT : log ( ex . getLocation ( ) + "Warning: " + ex . getMessage ( ) , Project . MSG_WARN ) ; break ; default : log ( ex . getLocation ( ) + ex . getMessage ( ) , Project . MSG_DEBUG ) ; } } } private void tooManyDefinitions ( ) { throw new BuildException ( "Only one of the attributes name, file and resource" + " can be set" , getLocation ( ) ) ; } } 	1
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Comparator ; import java . util . Vector ; import java . util . Iterator ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . selectors . BaseExtendSelector ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . ResourceUtils ; public class ModifiedSelector extends BaseExtendSelector implements BuildListener , ResourceSelector { private CacheName cacheName = null ; private String cacheClass ; private AlgorithmName algoName = null ; private String algorithmClass ; private ComparatorName compName = null ; private String comparatorClass ; private boolean update = true ; private boolean selectDirectories = true ; private boolean selectResourcesWithoutInputStream = true ; private boolean delayUpdate = true ; private Comparator comparator = null ; private Algorithm algorithm = null ; private Cache cache = null ; private int modified = 0 ; private boolean isConfigured = false ; private Vector configParameter = new Vector ( ) ; private Vector specialParameter = new Vector ( ) ; private ClassLoader myClassLoader = null ; private Path classpath = null ; public ModifiedSelector ( ) { } public void verifySettings ( ) { configure ( ) ; if ( cache == null ) { setError ( "Cache must be set." ) ; } else if ( algorithm == null ) { setError ( "Algorithm must be set." ) ; } else if ( ! cache . isValid ( ) ) { setError ( "Cache must be proper configured." ) ; } else if ( ! algorithm . isValid ( ) ) { setError ( "Algorithm must be proper configured." ) ; } } public void configure ( ) { if ( isConfigured ) { return ; } isConfigured = true ; Project p = getProject ( ) ; String filename = "cache.properties" ; File cachefile = null ; if ( p != null ) { cachefile = new File ( p . getBaseDir ( ) , filename ) ; getProject ( ) . addBuildListener ( this ) ; } else { cachefile = new File ( filename ) ; setDelayUpdate ( false ) ; } Cache defaultCache = new PropertiesfileCache ( cachefile ) ; Algorithm defaultAlgorithm = new DigestAlgorithm ( ) ; Comparator defaultComparator = new EqualComparator ( ) ; update = true ; selectDirectories = true ; for ( Iterator itConfig = configParameter . iterator ( ) ; itConfig . hasNext ( ) ; ) { Parameter par = ( Parameter ) itConfig . next ( ) ; if ( par . getName ( ) . indexOf ( "." ) > 0 ) { specialParameter . add ( par ) ; } else { useParameter ( par ) ; } } configParameter = new Vector ( ) ; if ( algoName != null ) { if ( "hashvalue" . equals ( algoName . getValue ( ) ) ) { algorithm = new HashvalueAlgorithm ( ) ; } else if ( "digest" . equals ( algoName . getValue ( ) ) ) { algorithm = new DigestAlgorithm ( ) ; } else if ( "checksum" . equals ( algoName . getValue ( ) ) ) { algorithm = new ChecksumAlgorithm ( ) ; } } else { if ( algorithmClass != null ) { algorithm = ( Algorithm ) loadClass ( algorithmClass , "is not an Algorithm." , Algorithm . class ) ; } else { algorithm = defaultAlgorithm ; } } if ( cacheName != null ) { if ( "propertyfile" . equals ( cacheName . getValue ( ) ) ) { cache = new PropertiesfileCache ( ) ; } } else { if ( cacheClass != null ) { cache = ( Cache ) loadClass ( cacheClass , "is not a Cache." , Cache . class ) ; } else { cache = defaultCache ; } } if ( compName != null ) { if ( "equal" . equals ( compName . getValue ( ) ) ) { comparator = new EqualComparator ( ) ; } else if ( "rule" . equals ( compName . getValue ( ) ) ) { throw new BuildException ( "RuleBasedCollator not yet supported." ) ; } } else { if ( comparatorClass != null ) { comparator = ( Comparator ) loadClass ( comparatorClass , "is not a Comparator." , Comparator . class ) ; } else { comparator = defaultComparator ; } } for ( Iterator itSpecial = specialParameter . iterator ( ) ; itSpecial . hasNext ( ) ; ) { Parameter par = ( Parameter ) itSpecial . next ( ) ; useParameter ( par ) ; } specialParameter = new Vector ( ) ; } protected Object loadClass ( String classname , String msg , Class type ) { try { ClassLoader cl = getClassLoader ( ) ; Class clazz = null ; if ( cl != null ) { clazz = cl . loadClass ( classname ) ; } else { clazz = Class . forName ( classname ) ; } Object rv = clazz . newInstance ( ) ; if ( ! type . isInstance ( rv ) ) { throw new BuildException ( "Specified class (" + classname + ") " + msg ) ; } return rv ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Specified class (" + classname + ") not found." ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public boolean isSelected ( Resource resource ) { if ( resource . isFilesystemOnly ( ) ) { FileResource fileResource = ( FileResource ) resource ; File file = fileResource . getFile ( ) ; String filename = fileResource . getName ( ) ; File basedir = fileResource . getBaseDir ( ) ; return isSelected ( basedir , filename , file ) ; } else { try { FileUtils fu = FileUtils . getFileUtils ( ) ; File tmpFile = fu . createTempFile ( "modified-" , ".tmp" , null ) ; Resource tmpResource = new FileResource ( tmpFile ) ; ResourceUtils . copyResource ( resource , tmpResource ) ; boolean isSelected = isSelected ( tmpFile . getParentFile ( ) , tmpFile . getName ( ) , resource . toLongString ( ) ) ; tmpFile . delete ( ) ; return isSelected ; } catch ( UnsupportedOperationException uoe ) { log ( "The resource '" + resource . getName ( ) + "' does not provide an InputStream, so it is not checked. " + "Akkording to 'selres' attribute value it is " + ( ( selectResourcesWithoutInputStream ) ? "" : " not" ) + "selected." , Project . MSG_INFO ) ; return selectResourcesWithoutInputStream ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } } public boolean isSelected ( File basedir , String filename , File file ) { return isSelected ( basedir , filename , file . getAbsolutePath ( ) ) ; } private boolean isSelected ( File basedir , String filename , String cacheKey ) { validate ( ) ; File f = new File ( basedir , filename ) ; if ( f . isDirectory ( ) ) { return selectDirectories ; } String cachedValue = String . valueOf ( cache . get ( f . getAbsolutePath ( ) ) ) ; String newValue = algorithm . getValue ( f ) ; boolean rv = ( comparator . compare ( cachedValue , newValue ) != 0 ) ; if ( update && rv ) { cache . put ( f . getAbsolutePath ( ) , newValue ) ; setModified ( getModified ( ) + 1 ) ; if ( ! getDelayUpdate ( ) ) { saveCache ( ) ; } } return rv ; } protected void saveCache ( ) { if ( getModified ( ) > 1 ) { cache . save ( ) ; setModified ( 0 ) ; } } public void setAlgorithmClass ( String classname ) { algorithmClass = classname ; } public void setComparatorClass ( String classname ) { comparatorClass = classname ; } public void setCacheClass ( String classname ) { cacheClass = classname ; } public void setUpdate ( boolean update ) { this . update = update ; } public void setSeldirs ( boolean seldirs ) { selectDirectories = seldirs ; } public void setSelres ( boolean newValue ) { this . selectResourcesWithoutInputStream = newValue ; } public int getModified ( ) { return modified ; } public void setModified ( int modified ) { this . modified = modified ; } public boolean getDelayUpdate ( ) { return delayUpdate ; } public void setDelayUpdate ( boolean delayUpdate ) { this . delayUpdate = delayUpdate ; } public void addClasspath ( Path path ) { if ( classpath != null ) { throw new BuildException ( "<classpath> can be set only once." ) ; } classpath = path ; } public ClassLoader getClassLoader ( ) { if ( myClassLoader == null ) { myClassLoader = ( classpath == null ) ? getClass ( ) . getClassLoader ( ) : getProject ( ) . createClassLoader ( classpath ) ; } return myClassLoader ; } public void setClassLoader ( ClassLoader loader ) { myClassLoader = loader ; } public void addParam ( String key , Object value ) { Parameter par = new Parameter ( ) ; par . setName ( key ) ; par . setValue ( String . valueOf ( value ) ) ; configParameter . add ( par ) ; } public void addParam ( Parameter parameter ) { configParameter . add ( parameter ) ; } public void setParameters ( Parameter [ ] parameters ) { if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { configParameter . add ( parameters [ i ] ) ; } } } public void useParameter ( Parameter parameter ) { String key = parameter . getName ( ) ; String value = parameter . getValue ( ) ; if ( "cache" . equals ( key ) ) { CacheName cn = new CacheName ( ) ; cn . setValue ( value ) ; setCache ( cn ) ; } else if ( "algorithm" . equals ( key ) ) { AlgorithmName an = new AlgorithmName ( ) ; an . setValue ( value ) ; setAlgorithm ( an ) ; } else if ( "comparator" . equals ( key ) ) { ComparatorName cn = new ComparatorName ( ) ; cn . setValue ( value ) ; setComparator ( cn ) ; } else if ( "update" . equals ( key ) ) { boolean updateValue = ( "true" . equalsIgnoreCase ( value ) ) ? true : false ; setUpdate ( updateValue ) ; } else if ( "delayupdate" . equals ( key ) ) { boolean updateValue = ( "true" . equalsIgnoreCase ( value ) ) ? true : false ; setDelayUpdate ( updateValue ) ; } else if ( "seldirs" . equals ( key ) ) { boolean sdValue = ( "true" . equalsIgnoreCase ( value ) ) ? true : false ; setSeldirs ( sdValue ) ; } else if ( key . startsWith ( "cache." ) ) { String name = key . substring ( 6 ) ; tryToSetAParameter ( cache , name , value ) ; } else if ( key . startsWith ( "algorithm." ) ) { String name = key . substring ( 10 ) ; tryToSetAParameter ( algorithm , name , value ) ; } else if ( key . startsWith ( "comparator." ) ) { String name = key . substring ( 11 ) ; tryToSetAParameter ( comparator , name , value ) ; } else { setError ( "Invalid parameter " + key ) ; } } protected void tryToSetAParameter ( Object obj , String name , String value ) { Project prj = ( getProject ( ) != null ) ? getProject ( ) : new Project ( ) ; IntrospectionHelper iHelper = IntrospectionHelper . getHelper ( prj , obj . getClass ( ) ) ; try { iHelper . setAttribute ( prj , obj , name , value ) ; } catch ( org . apache . tools . ant . BuildException e ) { } } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{modifiedselector" ) ; buf . append ( " update=" ) . append ( update ) ; buf . append ( " seldirs=" ) . append ( selectDirectories ) ; buf . append ( " cache=" ) . append ( cache ) ; buf . append ( " algorithm=" ) . append ( algorithm ) ; buf . append ( " comparator=" ) . append ( comparator ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void buildFinished ( BuildEvent event ) { if ( getDelayUpdate ( ) ) { saveCache ( ) ; } } public void targetFinished ( BuildEvent event ) { if ( getDelayUpdate ( ) ) { saveCache ( ) ; } } public void taskFinished ( BuildEvent event ) { if ( getDelayUpdate ( ) ) { saveCache ( ) ; } } public void buildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } public Cache getCache ( ) { return cache ; } public void setCache ( CacheName name ) { cacheName = name ; } public static class CacheName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "propertyfile" } ; } } public Algorithm getAlgorithm ( ) { return algorithm ; } public void setAlgorithm ( AlgorithmName name ) { algoName = name ; } public static class AlgorithmName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "hashvalue" , "digest" , "checksum" } ; } } public Comparator getComparator ( ) { return comparator ; } public void setComparator ( ComparatorName name ) { compName = name ; } public static class ComparatorName extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "equal" , "rule" } ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . util . depend . AbstractAnalyzer ; public class AntAnalyzer extends AbstractAnalyzer { public AntAnalyzer ( ) { } protected void determineDependencies ( Vector files , Vector classes ) { Hashtable dependencies = new Hashtable ( ) ; Hashtable containers = new Hashtable ( ) ; Hashtable toAnalyze = new Hashtable ( ) ; for ( Enumeration e = getRootClasses ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; toAnalyze . put ( classname , classname ) ; } int count = 0 ; int maxCount = isClosureRequired ( ) ? MAX_LOOPS : 1 ; Hashtable analyzedDeps = null ; while ( toAnalyze . size ( ) != 0 && count ++ < maxCount ) { analyzedDeps = new Hashtable ( ) ; for ( Enumeration e = toAnalyze . keys ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; dependencies . put ( classname , classname ) ; try { File container = getClassContainer ( classname ) ; if ( container == null ) { continue ; } containers . put ( container , container ) ; ZipFile zipFile = null ; InputStream inStream = null ; try { if ( container . getName ( ) . endsWith ( ".class" ) ) { inStream = new FileInputStream ( container . getPath ( ) ) ; } else { zipFile = new ZipFile ( container . getPath ( ) ) ; String entryName = classname . replace ( '.' , '/' ) + ".class" ; ZipEntry entry = new ZipEntry ( entryName ) ; inStream = zipFile . getInputStream ( entry ) ; } ClassFile classFile = new ClassFile ( ) ; classFile . read ( inStream ) ; Vector dependencyList = classFile . getClassRefs ( ) ; Enumeration depEnum = dependencyList . elements ( ) ; while ( depEnum . hasMoreElements ( ) ) { String dependency = ( String ) depEnum . nextElement ( ) ; analyzedDeps . put ( dependency , dependency ) ; } } finally { if ( inStream != null ) { inStream . close ( ) ; } if ( zipFile != null ) { zipFile . close ( ) ; } } } catch ( IOException ioe ) { } } toAnalyze . clear ( ) ; Enumeration depsEnum = analyzedDeps . elements ( ) ; while ( depsEnum . hasMoreElements ( ) ) { String className = ( String ) depsEnum . nextElement ( ) ; if ( ! dependencies . containsKey ( className ) ) { toAnalyze . put ( className , className ) ; } } } Enumeration depsEnum = analyzedDeps . elements ( ) ; while ( depsEnum . hasMoreElements ( ) ) { String className = ( String ) depsEnum . nextElement ( ) ; dependencies . put ( className , className ) ; } files . removeAllElements ( ) ; for ( Enumeration e = containers . keys ( ) ; e . hasMoreElements ( ) ; ) { files . addElement ( ( File ) e . nextElement ( ) ) ; } classes . removeAllElements ( ) ; for ( Enumeration e = dependencies . keys ( ) ; e . hasMoreElements ( ) ; ) { classes . addElement ( ( String ) e . nextElement ( ) ) ; } } protected boolean supportsFileDependencies ( ) { return true ; } } 	1
package org . apache . tools . ant . util ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import java . lang . reflect . Field ; public class ReflectUtil { private ReflectUtil ( ) { } public static Object invoke ( Object obj , String methodName ) { try { Method method ; method = obj . getClass ( ) . getMethod ( methodName , ( Class [ ] ) null ) ; return method . invoke ( obj , ( Object [ ] ) null ) ; } catch ( Exception t ) { throwBuildException ( t ) ; return null ; } } public static Object invoke ( Object obj , String methodName , Class argType , Object arg ) { try { Method method ; method = obj . getClass ( ) . getMethod ( methodName , new Class [ ] { argType } ) ; return method . invoke ( obj , new Object [ ] { arg } ) ; } catch ( Exception t ) { throwBuildException ( t ) ; return null ; } } public static Object invoke ( Object obj , String methodName , Class argType1 , Object arg1 , Class argType2 , Object arg2 ) { try { Method method ; method = obj . getClass ( ) . getMethod ( methodName , new Class [ ] { argType1 , argType2 } ) ; return method . invoke ( obj , new Object [ ] { arg1 , arg2 } ) ; } catch ( Exception t ) { throwBuildException ( t ) ; return null ; } } public static Object getField ( Object obj , String fieldName ) throws BuildException { try { Field field = obj . getClass ( ) . getDeclaredField ( fieldName ) ; field . setAccessible ( true ) ; return field . get ( obj ) ; } catch ( Exception t ) { throwBuildException ( t ) ; return null ; } } public static void throwBuildException ( Exception t ) throws BuildException { if ( t instanceof InvocationTargetException ) { Throwable t2 = ( ( InvocationTargetException ) t ) . getTargetException ( ) ; if ( t2 instanceof BuildException ) { throw ( BuildException ) t2 ; } throw new BuildException ( t2 ) ; } else { throw new BuildException ( t ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; import java . util . Date ; public class Get extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private URL source ; private File dest ; private boolean verbose = false ; private boolean useTimestamp = false ; private boolean ignoreErrors = false ; private String uname = null ; private String pword = null ; public void execute ( ) throws BuildException { int logLevel = Project . MSG_INFO ; DownloadProgress progress = null ; if ( verbose ) { progress = new VerboseProgress ( System . out ) ; } try { doGet ( logLevel , progress ) ; } catch ( IOException ioe ) { log ( "Error getting " + source + " to " + dest ) ; if ( ! ignoreErrors ) { throw new BuildException ( ioe , getLocation ( ) ) ; } } } public boolean doGet ( int logLevel , DownloadProgress progress ) throws IOException { if ( source == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( dest == null ) { throw new BuildException ( "dest attribute is required" , getLocation ( ) ) ; } if ( dest . exists ( ) && dest . isDirectory ( ) ) { throw new BuildException ( "The specified destination is a directory" , getLocation ( ) ) ; } if ( dest . exists ( ) && ! dest . canWrite ( ) ) { throw new BuildException ( "Can't write to " + dest . getAbsolutePath ( ) , getLocation ( ) ) ; } if ( progress == null ) { progress = new NullProgress ( ) ; } log ( "Getting: " + source , logLevel ) ; log ( "To: " + dest . getAbsolutePath ( ) , logLevel ) ; long timestamp = 0 ; boolean hasTimestamp = false ; if ( useTimestamp && dest . exists ( ) ) { timestamp = dest . lastModified ( ) ; if ( verbose ) { Date t = new Date ( timestamp ) ; log ( "local file date : " + t . toString ( ) , logLevel ) ; } hasTimestamp = true ; } URLConnection connection = source . openConnection ( ) ; if ( hasTimestamp ) { connection . setIfModifiedSince ( timestamp ) ; } if ( uname != null || pword != null ) { String up = uname + ":" + pword ; String encoding ; Base64Converter encoder = new Base64Converter ( ) ; encoding = encoder . encode ( up . getBytes ( ) ) ; connection . setRequestProperty ( "Authorization" , "Basic " + encoding ) ; } connection . connect ( ) ; if ( connection instanceof HttpURLConnection ) { HttpURLConnection httpConnection = ( HttpURLConnection ) connection ; long lastModified = httpConnection . getLastModified ( ) ; if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_NOT_MODIFIED || ( lastModified != 0 && hasTimestamp && timestamp >= lastModified ) ) { log ( "Not modified - so not downloaded" , logLevel ) ; return false ; } if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_UNAUTHORIZED ) { String message = "HTTP Authorization failure" ; if ( ignoreErrors ) { log ( message , logLevel ) ; return false ; } else { throw new BuildException ( message ) ; } } } InputStream is = null ; for ( int i = 0 ; i < 3 ; i ++ ) { try { is = connection . getInputStream ( ) ; break ; } catch ( IOException ex ) { log ( "Error opening connection " + ex , logLevel ) ; } } if ( is == null ) { log ( "Can't get " + source + " to " + dest , logLevel ) ; if ( ignoreErrors ) { return false ; } throw new BuildException ( "Can't get " + source + " to " + dest , getLocation ( ) ) ; } FileOutputStream fos = new FileOutputStream ( dest ) ; progress . beginDownload ( ) ; boolean finished = false ; try { byte [ ] buffer = new byte [ 100 * 1024 ] ; int length ; while ( ( length = is . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; progress . onTick ( ) ; } finished = true ; } finally { FileUtils . close ( fos ) ; FileUtils . close ( is ) ; if ( ! finished ) { dest . delete ( ) ; } } progress . endDownload ( ) ; if ( useTimestamp ) { long remoteTimestamp = connection . getLastModified ( ) ; if ( verbose ) { Date t = new Date ( remoteTimestamp ) ; log ( "last modified = " + t . toString ( ) + ( ( remoteTimestamp == 0 ) ? " - using current time instead" : "" ) , logLevel ) ; } if ( remoteTimestamp != 0 ) { FILE_UTILS . setFileLastModified ( dest , remoteTimestamp ) ; } } return true ; } public void setSrc ( URL u ) { this . source = u ; } public void setDest ( File dest ) { this . dest = dest ; } public void setVerbose ( boolean v ) { verbose = v ; } public void setIgnoreErrors ( boolean v ) { ignoreErrors = v ; } public void setUseTimestamp ( boolean v ) { useTimestamp = v ; } public void setUsername ( String u ) { this . uname = u ; } public void setPassword ( String p ) { this . pword = p ; } protected static class Base64Converter extends org . apache . tools . ant . util . Base64Converter { } public interface DownloadProgress { void beginDownload ( ) ; void onTick ( ) ; void endDownload ( ) ; } public static class NullProgress implements DownloadProgress { public void beginDownload ( ) { } public void onTick ( ) { } public void endDownload ( ) { } } public static class VerboseProgress implements DownloadProgress { private int dots = 0 ; PrintStream out ; public VerboseProgress ( PrintStream out ) { this . out = out ; } public void beginDownload ( ) { dots = 0 ; } public void onTick ( ) { out . print ( "." ) ; if ( dots ++ > 50 ) { out . flush ( ) ; dots = 0 ; } } public void endDownload ( ) { out . println ( ) ; out . flush ( ) ; } } } 	1
package org . apache . tools . zip ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; import java . io . UnsupportedEncodingException ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . zip . Inflater ; import java . util . zip . InflaterInputStream ; import java . util . zip . ZipException ; public class ZipFile { private Hashtable entries = new Hashtable ( 509 ) ; private Hashtable nameMap = new Hashtable ( 509 ) ; private static final class OffsetEntry { private long headerOffset = - 1 ; private long dataOffset = - 1 ; } private String encoding = null ; private RandomAccessFile archive ; public ZipFile ( File f ) throws IOException { this ( f , null ) ; } public ZipFile ( String name ) throws IOException { this ( new File ( name ) , null ) ; } public ZipFile ( String name , String encoding ) throws IOException { this ( new File ( name ) , encoding ) ; } public ZipFile ( File f , String encoding ) throws IOException { this . encoding = encoding ; archive = new RandomAccessFile ( f , "r" ) ; try { populateFromCentralDirectory ( ) ; resolveLocalFileHeaderData ( ) ; } catch ( IOException e ) { try { archive . close ( ) ; } catch ( IOException e2 ) { } throw e ; } } public String getEncoding ( ) { return encoding ; } public void close ( ) throws IOException { archive . close ( ) ; } public static void closeQuietly ( ZipFile zipfile ) { if ( zipfile != null ) { try { zipfile . close ( ) ; } catch ( IOException e ) { } } } public Enumeration getEntries ( ) { return entries . keys ( ) ; } public ZipEntry getEntry ( String name ) { return ( ZipEntry ) nameMap . get ( name ) ; } public InputStream getInputStream ( ZipEntry ze ) throws IOException , ZipException { OffsetEntry offsetEntry = ( OffsetEntry ) entries . get ( ze ) ; if ( offsetEntry == null ) { return null ; } long start = offsetEntry . dataOffset ; BoundedInputStream bis = new BoundedInputStream ( start , ze . getCompressedSize ( ) ) ; switch ( ze . getMethod ( ) ) { case ZipEntry . STORED : return bis ; case ZipEntry . DEFLATED : bis . addDummy ( ) ; return new InflaterInputStream ( bis , new Inflater ( true ) ) ; default : throw new ZipException ( "Found unsupported compression method " + ze . getMethod ( ) ) ; } } private static final int CFH_LEN = 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 4 + 4 ; private void populateFromCentralDirectory ( ) throws IOException { positionAtCentralDirectory ( ) ; byte [ ] cfh = new byte [ CFH_LEN ] ; byte [ ] signatureBytes = new byte [ 4 ] ; archive . readFully ( signatureBytes ) ; long sig = ZipLong . getValue ( signatureBytes ) ; final long cfhSig = ZipLong . getValue ( ZipOutputStream . CFH_SIG ) ; while ( sig == cfhSig ) { archive . readFully ( cfh ) ; int off = 0 ; ZipEntry ze = new ZipEntry ( ) ; int versionMadeBy = ZipShort . getValue ( cfh , off ) ; off += 2 ; ze . setPlatform ( ( versionMadeBy > > 8 ) & 0x0F ) ; off += 4 ; ze . setMethod ( ZipShort . getValue ( cfh , off ) ) ; off += 2 ; long time = dosToJavaTime ( ZipLong . getValue ( cfh , off ) ) ; ze . setTime ( time ) ; off += 4 ; ze . setCrc ( ZipLong . getValue ( cfh , off ) ) ; off += 4 ; ze . setCompressedSize ( ZipLong . getValue ( cfh , off ) ) ; off += 4 ; ze . setSize ( ZipLong . getValue ( cfh , off ) ) ; off += 4 ; int fileNameLen = ZipShort . getValue ( cfh , off ) ; off += 2 ; int extraLen = ZipShort . getValue ( cfh , off ) ; off += 2 ; int commentLen = ZipShort . getValue ( cfh , off ) ; off += 2 ; off += 2 ; ze . setInternalAttributes ( ZipShort . getValue ( cfh , off ) ) ; off += 2 ; ze . setExternalAttributes ( ZipLong . getValue ( cfh , off ) ) ; off += 4 ; byte [ ] fileName = new byte [ fileNameLen ] ; archive . readFully ( fileName ) ; ze . setName ( getString ( fileName ) ) ; OffsetEntry offset = new OffsetEntry ( ) ; offset . headerOffset = ZipLong . getValue ( cfh , off ) ; entries . put ( ze , offset ) ; nameMap . put ( ze . getName ( ) , ze ) ; archive . skipBytes ( extraLen ) ; byte [ ] comment = new byte [ commentLen ] ; archive . readFully ( comment ) ; ze . setComment ( getString ( comment ) ) ; archive . readFully ( signatureBytes ) ; sig = ZipLong . getValue ( signatureBytes ) ; } } private static final int MIN_EOCD_SIZE = 4 + 2 + 2 + 2 + 2 + 4 + 4 + 2 ; private static final int CFD_LOCATOR_OFFSET = 4 + 2 + 2 + 2 + 2 + 4 ; private void positionAtCentralDirectory ( ) throws IOException { boolean found = false ; long off = archive . length ( ) - MIN_EOCD_SIZE ; if ( off >= 0 ) { archive . seek ( off ) ; byte [ ] sig = ZipOutputStream . EOCD_SIG ; int curr = archive . read ( ) ; while ( curr != - 1 ) { if ( curr == sig [ 0 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 1 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 2 ] ) { curr = archive . read ( ) ; if ( curr == sig [ 3 ] ) { found = true ; break ; } } } } archive . seek ( -- off ) ; curr = archive . read ( ) ; } } if ( ! found ) { throw new ZipException ( "archive is not a ZIP archive" ) ; } archive . seek ( off + CFD_LOCATOR_OFFSET ) ; byte [ ] cfdOffset = new byte [ 4 ] ; archive . readFully ( cfdOffset ) ; archive . seek ( ZipLong . getValue ( cfdOffset ) ) ; } private static final long LFH_OFFSET_FOR_FILENAME_LENGTH = 4 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 ; private void resolveLocalFileHeaderData ( ) throws IOException { Enumeration e = getEntries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; OffsetEntry offsetEntry = ( OffsetEntry ) entries . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ 2 ] ; archive . readFully ( b ) ; int fileNameLen = ZipShort . getValue ( b ) ; archive . readFully ( b ) ; int extraFieldLen = ZipShort . getValue ( b ) ; archive . skipBytes ( fileNameLen ) ; byte [ ] localExtraData = new byte [ extraFieldLen ] ; archive . readFully ( localExtraData ) ; ze . setExtra ( localExtraData ) ; offsetEntry . dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + 2 + 2 + fileNameLen + extraFieldLen ; } } protected static Date fromDosTime ( ZipLong zipDosTime ) { long dosTime = zipDosTime . getValue ( ) ; return new Date ( dosToJavaTime ( dosTime ) ) ; } private static long dosToJavaTime ( long dosTime ) { Calendar cal = Calendar . getInstance ( ) ; cal . set ( Calendar . YEAR , ( int ) ( ( dosTime > > 25 ) & 0x7f ) + 1980 ) ; cal . set ( Calendar . MONTH , ( int ) ( ( dosTime > > 21 ) & 0x0f ) - 1 ) ; cal . set ( Calendar . DATE , ( int ) ( dosTime > > 16 ) & 0x1f ) ; cal . set ( Calendar . HOUR_OF_DAY , ( int ) ( dosTime > > 11 ) & 0x1f ) ; cal . set ( Calendar . MINUTE , ( int ) ( dosTime > > 5 ) & 0x3f ) ; cal . set ( Calendar . SECOND , ( int ) ( dosTime << 1 ) & 0x3e ) ; return cal . getTime ( ) . getTime ( ) ; } protected String getString ( byte [ ] bytes ) throws ZipException { if ( encoding == null ) { return new String ( bytes ) ; } else { try { return new String ( bytes , encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } private class BoundedInputStream extends InputStream { private long remaining ; private long loc ; private boolean addDummyByte = false ; BoundedInputStream ( long start , long remaining ) { this . remaining = remaining ; loc = start ; } public int read ( ) throws IOException { if ( remaining -- <= 0 ) { if ( addDummyByte ) { addDummyByte = false ; return 0 ; } return - 1 ; } synchronized ( archive ) { archive . seek ( loc ++ ) ; return archive . read ( ) ; } } public int read ( byte [ ] b , int off , int len ) throws IOException { if ( remaining <= 0 ) { if ( addDummyByte ) { addDummyByte = false ; b [ off ] = 0 ; return 1 ; } return - 1 ; } if ( len <= 0 ) { return 0 ; } if ( len > remaining ) { len = ( int ) remaining ; } int ret = - 1 ; synchronized ( archive ) { archive . seek ( loc ) ; ret = archive . read ( b , off , len ) ; } if ( ret > 0 ) { loc += ret ; remaining -= ret ; } return ret ; } void addDummy ( ) { addDummyByte = true ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . AbstractFileSet ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . SourceFileScanner ; public class ExecuteOn extends ExecTask { protected Vector filesets = new Vector ( ) ; private Union resources = null ; private boolean relative = false ; private boolean parallel = false ; private boolean forwardSlash = false ; protected String type = FileDirBoth . FILE ; protected Commandline . Marker srcFilePos = null ; private boolean skipEmpty = false ; protected Commandline . Marker targetFilePos = null ; protected Mapper mapperElement = null ; protected FileNameMapper mapper = null ; protected File destDir = null ; private int maxParallel = - 1 ; private boolean addSourceFile = true ; private boolean verbose = false ; private boolean ignoreMissing = true ; private boolean force = false ; protected boolean srcIsFirst = true ; public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addDirset ( DirSet set ) { filesets . addElement ( set ) ; } public void addFilelist ( FileList list ) { add ( list ) ; } public void add ( ResourceCollection rc ) { if ( resources == null ) { resources = new Union ( ) ; } resources . add ( rc ) ; } public void setRelative ( boolean relative ) { this . relative = relative ; } public void setParallel ( boolean parallel ) { this . parallel = parallel ; } public void setType ( FileDirBoth type ) { this . type = type . getValue ( ) ; } public void setSkipEmptyFilesets ( boolean skip ) { skipEmpty = skip ; } public void setDest ( File destDir ) { this . destDir = destDir ; } public void setForwardslash ( boolean forwardSlash ) { this . forwardSlash = forwardSlash ; } public void setMaxParallel ( int max ) { maxParallel = max ; } public void setAddsourcefile ( boolean b ) { addSourceFile = b ; } public void setVerbose ( boolean b ) { verbose = b ; } public void setIgnoremissing ( boolean b ) { ignoreMissing = b ; } public void setForce ( boolean b ) { force = b ; } public Commandline . Marker createSrcfile ( ) { if ( srcFilePos != null ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support multiple " + "srcfile elements." , getLocation ( ) ) ; } srcFilePos = cmdl . createMarker ( ) ; return srcFilePos ; } public Commandline . Marker createTargetfile ( ) { if ( targetFilePos != null ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support multiple " + "targetfile elements." , getLocation ( ) ) ; } targetFilePos = cmdl . createMarker ( ) ; srcIsFirst = ( srcFilePos != null ) ; return targetFilePos ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } protected void checkConfiguration ( ) { if ( "execon" . equals ( getTaskName ( ) ) ) { log ( "!! execon is deprecated. Use apply instead. !!" ) ; } super . checkConfiguration ( ) ; if ( filesets . size ( ) == 0 && resources == null ) { throw new BuildException ( "no resources specified" , getLocation ( ) ) ; } if ( targetFilePos != null && mapperElement == null ) { throw new BuildException ( "targetfile specified without mapper" , getLocation ( ) ) ; } if ( destDir != null && mapperElement == null ) { throw new BuildException ( "dest specified without mapper" , getLocation ( ) ) ; } if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { return ( redirectorElement == null ) ? super . createHandler ( ) : new PumpStreamHandler ( ) ; } protected void setupRedirector ( ) { super . setupRedirector ( ) ; redirector . setAppendProperties ( true ) ; } protected void runExec ( Execute exe ) throws BuildException { int totalFiles = 0 ; int totalDirs = 0 ; boolean haveExecuted = false ; try { Vector fileNames = new Vector ( ) ; Vector baseDirs = new Vector ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { String currentType = type ; AbstractFileSet fs = ( AbstractFileSet ) filesets . elementAt ( i ) ; if ( fs instanceof DirSet ) { if ( ! FileDirBoth . DIR . equals ( type ) ) { log ( "Found a nested dirset but type is " + type + ". " + "Temporarily switching to type=\"dir\" on the" + " assumption that you really did mean" + " <dirset> not <fileset>." , Project . MSG_DEBUG ) ; currentType = FileDirBoth . DIR ; } } File base = fs . getDir ( getProject ( ) ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; if ( ! FileDirBoth . DIR . equals ( currentType ) ) { String [ ] s = getFiles ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { totalFiles ++ ; fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( ! FileDirBoth . FILE . equals ( currentType ) ) { String [ ] s = getDirs ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { totalDirs ++ ; fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { int includedCount = ( ( ! FileDirBoth . DIR . equals ( currentType ) ) ? ds . getIncludedFilesCount ( ) : 0 ) + ( ( ! FileDirBoth . FILE . equals ( currentType ) ) ? ds . getIncludedDirsCount ( ) : 0 ) ; log ( "Skipping fileset for directory " + base + ". It is " + ( ( includedCount > 0 ) ? "up to date." : "empty." ) , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( redirectorElement != null ) { setupRedirector ( ) ; redirectorElement . configure ( redirector , s [ j ] ) ; } if ( redirectorElement != null || haveExecuted ) { exe . setStreamHandler ( redirector . createHandler ( ) ) ; } runExecute ( exe ) ; haveExecuted = true ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } if ( resources != null ) { Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource res = ( Resource ) iter . next ( ) ; if ( ! res . isExists ( ) && ignoreMissing ) { continue ; } File base = null ; String name = res . getName ( ) ; if ( res instanceof FileResource ) { FileResource fr = ( FileResource ) res ; base = fr . getBaseDir ( ) ; if ( base == null ) { name = fr . getFile ( ) . getAbsolutePath ( ) ; } } if ( restrict ( new String [ ] { name } , base ) . length == 0 ) { continue ; } if ( ( ! res . isDirectory ( ) || ! res . isExists ( ) ) && ! FileDirBoth . DIR . equals ( type ) ) { totalFiles ++ ; } else if ( res . isDirectory ( ) && ! FileDirBoth . FILE . equals ( type ) ) { totalDirs ++ ; } else { continue ; } baseDirs . add ( base ) ; fileNames . add ( name ) ; if ( ! parallel ) { String [ ] command = getCommandline ( name , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( redirectorElement != null ) { setupRedirector ( ) ; redirectorElement . configure ( redirector , name ) ; } if ( redirectorElement != null || haveExecuted ) { exe . setStreamHandler ( redirector . createHandler ( ) ) ; } runExecute ( exe ) ; haveExecuted = true ; fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } } if ( parallel && ( fileNames . size ( ) > 0 || ! skipEmpty ) ) { runParallel ( exe , fileNames , baseDirs ) ; haveExecuted = true ; } if ( haveExecuted ) { log ( "Applied " + cmdl . getExecutable ( ) + " to " + totalFiles + " file" + ( totalFiles != 1 ? "s" : "" ) + " and " + totalDirs + " director" + ( totalDirs != 1 ? "ies" : "y" ) + "." , verbose ? Project . MSG_INFO : Project . MSG_VERBOSE ) ; } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , getLocation ( ) ) ; } finally { logFlush ( ) ; redirector . setAppendProperties ( false ) ; redirector . setProperties ( ) ; } } protected String [ ] getCommandline ( String [ ] srcFiles , File [ ] baseDirs ) { final char fileSeparator = File . separatorChar ; Vector targets = new Vector ( ) ; if ( targetFilePos != null ) { Hashtable addedFiles = new Hashtable ( ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { String [ ] subTargets = mapper . mapFileName ( srcFiles [ i ] ) ; if ( subTargets != null ) { for ( int j = 0 ; j < subTargets . length ; j ++ ) { String name = null ; if ( ! relative ) { name = ( new File ( destDir , subTargets [ j ] ) ) . getAbsolutePath ( ) ; } else { name = subTargets [ j ] ; } if ( forwardSlash && fileSeparator != '/' ) { name = name . replace ( fileSeparator , '/' ) ; } if ( ! addedFiles . contains ( name ) ) { targets . addElement ( name ) ; addedFiles . put ( name , name ) ; } } } } } String [ ] targetFiles = new String [ targets . size ( ) ] ; targets . copyInto ( targetFiles ) ; if ( ! addSourceFile ) { srcFiles = new String [ 0 ] ; } String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length + targetFiles . length ] ; int srcIndex = orig . length ; if ( srcFilePos != null ) { srcIndex = srcFilePos . getPosition ( ) ; } if ( targetFilePos != null ) { int targetIndex = targetFilePos . getPosition ( ) ; if ( srcIndex < targetIndex || ( srcIndex == targetIndex && srcIsFirst ) ) { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , targetIndex - srcIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex + srcFiles . length , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + srcFiles . length + targetFiles . length , orig . length - targetIndex ) ; } else { System . arraycopy ( orig , 0 , result , 0 , targetIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + targetFiles . length , srcIndex - targetIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length + targetFiles . length , orig . length - srcIndex ) ; srcIndex += targetFiles . length ; } } else { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , orig . length - srcIndex ) ; } for ( int i = 0 ; i < srcFiles . length ; i ++ ) { if ( ! relative ) { result [ srcIndex + i ] = ( new File ( baseDirs [ i ] , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } else { result [ srcIndex + i ] = srcFiles [ i ] ; } if ( forwardSlash && fileSeparator != '/' ) { result [ srcIndex + i ] = result [ srcIndex + i ] . replace ( fileSeparator , '/' ) ; } } return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , new File [ ] { baseDir } ) ; } protected String [ ] getFiles ( File baseDir , DirectoryScanner ds ) { return restrict ( ds . getIncludedFiles ( ) , baseDir ) ; } protected String [ ] getDirs ( File baseDir , DirectoryScanner ds ) { return restrict ( ds . getIncludedDirectories ( ) , baseDir ) ; } protected String [ ] getFilesAndDirs ( FileList list ) { return restrict ( list . getFiles ( getProject ( ) ) , list . getDir ( getProject ( ) ) ) ; } private String [ ] restrict ( String [ ] s , File baseDir ) { return ( mapper == null || force ) ? s : new SourceFileScanner ( this ) . restrict ( s , baseDir , destDir , mapper ) ; } protected void runParallel ( Execute exe , Vector fileNames , Vector baseDirs ) throws IOException , BuildException { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; File [ ] b = new File [ baseDirs . size ( ) ] ; baseDirs . copyInto ( b ) ; if ( maxParallel <= 0 || s . length == 0 ) { String [ ] command = getCommandline ( s , b ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } else { int stillToDo = fileNames . size ( ) ; int currentOffset = 0 ; while ( stillToDo > 0 ) { int currentAmount = Math . min ( stillToDo , maxParallel ) ; String [ ] cs = new String [ currentAmount ] ; System . arraycopy ( s , currentOffset , cs , 0 , currentAmount ) ; File [ ] cb = new File [ currentAmount ] ; System . arraycopy ( b , currentOffset , cb , 0 , currentAmount ) ; String [ ] command = getCommandline ( cs , cb ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( redirectorElement != null ) { setupRedirector ( ) ; redirectorElement . configure ( redirector , null ) ; } if ( redirectorElement != null || currentOffset > 0 ) { exe . setStreamHandler ( redirector . createHandler ( ) ) ; } runExecute ( exe ) ; stillToDo -= currentAmount ; currentOffset += currentAmount ; } } } public static class FileDirBoth extends EnumeratedAttribute { public static final String FILE = "file" ; public static final String DIR = "dir" ; public String [ ] getValues ( ) { return new String [ ] { FILE , DIR , "both" } ; } } } 	1
package org . apache . tools . tar ; import java . io . File ; import java . util . Date ; import java . util . Locale ; public class TarEntry implements TarConstants { private StringBuffer name ; private int mode ; private int userId ; private int groupId ; private long size ; private long modTime ; private byte linkFlag ; private StringBuffer linkName ; private StringBuffer magic ; private StringBuffer userName ; private StringBuffer groupName ; private int devMajor ; private int devMinor ; private File file ; public static final int MAX_NAMELEN = 31 ; public static final int DEFAULT_DIR_MODE = 040755 ; public static final int DEFAULT_FILE_MODE = 0100644 ; public static final int MILLIS_PER_SECOND = 1000 ; private TarEntry ( ) { this . magic = new StringBuffer ( TMAGIC ) ; this . name = new StringBuffer ( ) ; this . linkName = new StringBuffer ( ) ; String user = System . getProperty ( "user.name" , "" ) ; if ( user . length ( ) > MAX_NAMELEN ) { user = user . substring ( 0 , MAX_NAMELEN ) ; } this . userId = 0 ; this . groupId = 0 ; this . userName = new StringBuffer ( user ) ; this . groupName = new StringBuffer ( "" ) ; this . file = null ; } public TarEntry ( String name ) { this ( ) ; boolean isDir = name . endsWith ( "/" ) ; this . devMajor = 0 ; this . devMinor = 0 ; this . name = new StringBuffer ( name ) ; this . mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE ; this . linkFlag = isDir ? LF_DIR : LF_NORMAL ; this . userId = 0 ; this . groupId = 0 ; this . size = 0 ; this . modTime = ( new Date ( ) ) . getTime ( ) / MILLIS_PER_SECOND ; this . linkName = new StringBuffer ( "" ) ; this . userName = new StringBuffer ( "" ) ; this . groupName = new StringBuffer ( "" ) ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( String name , byte linkFlag ) { this ( name ) ; this . linkFlag = linkFlag ; } public TarEntry ( File file ) { this ( ) ; this . file = file ; String fileName = file . getPath ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( Locale . US ) ; if ( osname != null ) { if ( osname . startsWith ( "windows" ) ) { if ( fileName . length ( ) > 2 ) { char ch1 = fileName . charAt ( 0 ) ; char ch2 = fileName . charAt ( 1 ) ; if ( ch2 == ':' && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { fileName = fileName . substring ( 2 ) ; } } } else if ( osname . indexOf ( "netware" ) > - 1 ) { int colon = fileName . indexOf ( ':' ) ; if ( colon != - 1 ) { fileName = fileName . substring ( colon + 1 ) ; } } } fileName = fileName . replace ( File . separatorChar , '/' ) ; while ( fileName . startsWith ( "/" ) ) { fileName = fileName . substring ( 1 ) ; } this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( fileName ) ; if ( file . isDirectory ( ) ) { this . mode = DEFAULT_DIR_MODE ; this . linkFlag = LF_DIR ; if ( this . name . charAt ( this . name . length ( ) - 1 ) != '/' ) { this . name . append ( "/" ) ; } } else { this . mode = DEFAULT_FILE_MODE ; this . linkFlag = LF_NORMAL ; } this . size = file . length ( ) ; this . modTime = file . lastModified ( ) / MILLIS_PER_SECOND ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( byte [ ] headerBuf ) { this ( ) ; this . parseTarHeader ( headerBuf ) ; } public boolean equals ( TarEntry it ) { return this . getName ( ) . equals ( it . getName ( ) ) ; } public boolean equals ( Object it ) { if ( it == null || getClass ( ) != it . getClass ( ) ) { return false ; } return equals ( ( TarEntry ) it ) ; } public int hashCode ( ) { return getName ( ) . hashCode ( ) ; } public boolean isDescendent ( TarEntry desc ) { return desc . getName ( ) . startsWith ( this . getName ( ) ) ; } public String getName ( ) { return this . name . toString ( ) ; } public void setName ( String name ) { this . name = new StringBuffer ( name ) ; } public void setMode ( int mode ) { this . mode = mode ; } public String getLinkName ( ) { return this . linkName . toString ( ) ; } public int getUserId ( ) { return this . userId ; } public void setUserId ( int userId ) { this . userId = userId ; } public int getGroupId ( ) { return this . groupId ; } public void setGroupId ( int groupId ) { this . groupId = groupId ; } public String getUserName ( ) { return this . userName . toString ( ) ; } public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } public String getGroupName ( ) { return this . groupName . toString ( ) ; } public void setGroupName ( String groupName ) { this . groupName = new StringBuffer ( groupName ) ; } public void setIds ( int userId , int groupId ) { this . setUserId ( userId ) ; this . setGroupId ( groupId ) ; } public void setNames ( String userName , String groupName ) { this . setUserName ( userName ) ; this . setGroupName ( groupName ) ; } public void setModTime ( long time ) { this . modTime = time / MILLIS_PER_SECOND ; } public void setModTime ( Date time ) { this . modTime = time . getTime ( ) / MILLIS_PER_SECOND ; } public Date getModTime ( ) { return new Date ( this . modTime * MILLIS_PER_SECOND ) ; } public File getFile ( ) { return this . file ; } public int getMode ( ) { return this . mode ; } public long getSize ( ) { return this . size ; } public void setSize ( long size ) { this . size = size ; } public boolean isGNULongNameEntry ( ) { return linkFlag == LF_GNUTYPE_LONGNAME && name . toString ( ) . equals ( GNU_LONGLINK ) ; } public boolean isDirectory ( ) { if ( this . file != null ) { return this . file . isDirectory ( ) ; } if ( this . linkFlag == LF_DIR ) { return true ; } if ( this . getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } public TarEntry [ ] getDirectoryEntries ( ) { if ( this . file == null || ! this . file . isDirectory ( ) ) { return new TarEntry [ 0 ] ; } String [ ] list = this . file . list ( ) ; TarEntry [ ] result = new TarEntry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++ i ) { result [ i ] = new TarEntry ( new File ( this . file , list [ i ] ) ) ; } return result ; } public void writeEntryHeader ( byte [ ] outbuf ) { int offset = 0 ; offset = TarUtils . getNameBytes ( this . name , outbuf , offset , NAMELEN ) ; offset = TarUtils . getOctalBytes ( this . mode , outbuf , offset , MODELEN ) ; offset = TarUtils . getOctalBytes ( this . userId , outbuf , offset , UIDLEN ) ; offset = TarUtils . getOctalBytes ( this . groupId , outbuf , offset , GIDLEN ) ; offset = TarUtils . getLongOctalBytes ( this . size , outbuf , offset , SIZELEN ) ; offset = TarUtils . getLongOctalBytes ( this . modTime , outbuf , offset , MODTIMELEN ) ; int csOffset = offset ; for ( int c = 0 ; c < CHKSUMLEN ; ++ c ) { outbuf [ offset ++ ] = ( byte ) ' ' ; } outbuf [ offset ++ ] = this . linkFlag ; offset = TarUtils . getNameBytes ( this . linkName , outbuf , offset , NAMELEN ) ; offset = TarUtils . getNameBytes ( this . magic , outbuf , offset , MAGICLEN ) ; offset = TarUtils . getNameBytes ( this . userName , outbuf , offset , UNAMELEN ) ; offset = TarUtils . getNameBytes ( this . groupName , outbuf , offset , GNAMELEN ) ; offset = TarUtils . getOctalBytes ( this . devMajor , outbuf , offset , DEVLEN ) ; offset = TarUtils . getOctalBytes ( this . devMinor , outbuf , offset , DEVLEN ) ; while ( offset < outbuf . length ) { outbuf [ offset ++ ] = 0 ; } long chk = TarUtils . computeCheckSum ( outbuf ) ; TarUtils . getCheckSumOctalBytes ( chk , outbuf , csOffset , CHKSUMLEN ) ; } public void parseTarHeader ( byte [ ] header ) { int offset = 0 ; this . name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; this . userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; this . groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; this . size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; this . modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; offset += CHKSUMLEN ; this . linkFlag = header [ offset ++ ] ; this . linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; this . userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; this . groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; this . devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; this . devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; } } 	1
package org . apache . tools . ant . util ; import java . util . Enumeration ; import java . util . Vector ; public class Watchdog implements Runnable { private Vector observers = new Vector ( 1 ) ; private long timeout = - 1 ; private volatile boolean stopped = false ; public static final String ERROR_INVALID_TIMEOUT = "timeout less than 1." ; public Watchdog ( long timeout ) { if ( timeout < 1 ) { throw new IllegalArgumentException ( ERROR_INVALID_TIMEOUT ) ; } this . timeout = timeout ; } public void addTimeoutObserver ( TimeoutObserver to ) { observers . addElement ( to ) ; } public void removeTimeoutObserver ( TimeoutObserver to ) { observers . removeElement ( to ) ; } protected final void fireTimeoutOccured ( ) { Enumeration e = observers . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( TimeoutObserver ) e . nextElement ( ) ) . timeoutOccured ( this ) ; } } public synchronized void start ( ) { stopped = false ; Thread t = new Thread ( this , "WATCHDOG" ) ; t . setDaemon ( true ) ; t . start ( ) ; } public synchronized void stop ( ) { stopped = true ; notifyAll ( ) ; } public synchronized void run ( ) { final long until = System . currentTimeMillis ( ) + timeout ; long now ; while ( ! stopped && until > ( now = System . currentTimeMillis ( ) ) ) { try { wait ( until - now ) ; } catch ( InterruptedException e ) { } } if ( ! stopped ) { fireTimeoutOccured ( ) ; } } } 	1
package org . apache . tools . ant . types ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . ArrayList ; import java . util . List ; import java . util . ListIterator ; import java . util . LinkedList ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . taskdefs . condition . Os ; public class Commandline implements Cloneable { private static final boolean IS_WIN_9X = Os . isFamily ( "win9x" ) ; private Vector arguments = new Vector ( ) ; private String executable = null ; protected static final String DISCLAIMER = StringUtils . LINE_SEP + "The \' characters around the executable and arguments are" + StringUtils . LINE_SEP + "not part of the command." + StringUtils . LINE_SEP ; public Commandline ( String toProcess ) { super ( ) ; String [ ] tmp = translateCommandline ( toProcess ) ; if ( tmp != null && tmp . length > 0 ) { setExecutable ( tmp [ 0 ] ) ; for ( int i = 1 ; i < tmp . length ; i ++ ) { createArgument ( ) . setValue ( tmp [ i ] ) ; } } } public Commandline ( ) { super ( ) ; } public static class Argument extends ProjectComponent { private String [ ] parts ; public void setValue ( String value ) { parts = new String [ ] { value } ; } public void setLine ( String line ) { if ( line == null ) { return ; } parts = translateCommandline ( line ) ; } public void setPath ( Path value ) { parts = new String [ ] { value . toString ( ) } ; } public void setPathref ( Reference value ) { Path p = new Path ( getProject ( ) ) ; p . setRefid ( value ) ; parts = new String [ ] { p . toString ( ) } ; } public void setFile ( File value ) { parts = new String [ ] { value . getAbsolutePath ( ) } ; } public String [ ] getParts ( ) { return parts ; } } public class Marker { private int position ; private int realPos = - 1 ; Marker ( int position ) { this . position = position ; } public int getPosition ( ) { if ( realPos == - 1 ) { realPos = ( executable == null ? 0 : 1 ) ; for ( int i = 0 ; i < position ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; realPos += arg . getParts ( ) . length ; } } return realPos ; } } public Argument createArgument ( ) { return this . createArgument ( false ) ; } public Argument createArgument ( boolean insertAtStart ) { Argument argument = new Argument ( ) ; if ( insertAtStart ) { arguments . insertElementAt ( argument , 0 ) ; } else { arguments . addElement ( argument ) ; } return argument ; } public void setExecutable ( String executable ) { if ( executable == null || executable . length ( ) == 0 ) { return ; } this . executable = executable . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } public String getExecutable ( ) { return executable ; } public void addArguments ( String [ ] line ) { for ( int i = 0 ; i < line . length ; i ++ ) { createArgument ( ) . setValue ( line [ i ] ) ; } } public String [ ] getCommandline ( ) { List commands = new LinkedList ( ) ; ListIterator list = commands . listIterator ( ) ; addCommandToList ( list ) ; final String [ ] result = new String [ commands . size ( ) ] ; return ( String [ ] ) commands . toArray ( result ) ; } public void addCommandToList ( ListIterator list ) { if ( executable != null ) { list . add ( executable ) ; } addArgumentsToList ( list ) ; } public String [ ] getArguments ( ) { List result = new ArrayList ( arguments . size ( ) * 2 ) ; addArgumentsToList ( result . listIterator ( ) ) ; String [ ] res = new String [ result . size ( ) ] ; return ( String [ ] ) result . toArray ( res ) ; } public void addArgumentsToList ( ListIterator list ) { for ( int i = 0 ; i < arguments . size ( ) ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; String [ ] s = arg . getParts ( ) ; if ( s != null ) { for ( int j = 0 ; j < s . length ; j ++ ) { list . add ( s [ j ] ) ; } } } } public String toString ( ) { return toString ( getCommandline ( ) ) ; } public static String quoteArgument ( String argument ) { if ( argument . indexOf ( "\"" ) > - 1 ) { if ( argument . indexOf ( "\'" ) > - 1 ) { throw new BuildException ( "Can\'t handle single and double" + " quotes in same argument" ) ; } else { return '\'' + argument + '\'' ; } } else if ( argument . indexOf ( "\'" ) > - 1 || argument . indexOf ( " " ) > - 1 || ( IS_WIN_9X && argument . indexOf ( ';' ) != - 1 ) ) { return '\"' + argument + '\"' ; } else { return argument ; } } public static String toString ( String [ ] line ) { if ( line == null || line . length == 0 ) { return "" ; } final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ; i ++ ) { if ( i > 0 ) { result . append ( ' ' ) ; } result . append ( quoteArgument ( line [ i ] ) ) ; } return result . toString ( ) ; } public static String [ ] translateCommandline ( String toProcess ) { if ( toProcess == null || toProcess . length ( ) == 0 ) { return new String [ 0 ] ; } final int normal = 0 ; final int inQuote = 1 ; final int inDoubleQuote = 2 ; int state = normal ; StringTokenizer tok = new StringTokenizer ( toProcess , "\"\' " , true ) ; Vector v = new Vector ( ) ; StringBuffer current = new StringBuffer ( ) ; boolean lastTokenHasBeenQuoted = false ; while ( tok . hasMoreTokens ( ) ) { String nextTok = tok . nextToken ( ) ; switch ( state ) { case inQuote : if ( "\'" . equals ( nextTok ) ) { lastTokenHasBeenQuoted = true ; state = normal ; } else { current . append ( nextTok ) ; } break ; case inDoubleQuote : if ( "\"" . equals ( nextTok ) ) { lastTokenHasBeenQuoted = true ; state = normal ; } else { current . append ( nextTok ) ; } break ; default : if ( "\'" . equals ( nextTok ) ) { state = inQuote ; } else if ( "\"" . equals ( nextTok ) ) { state = inDoubleQuote ; } else if ( " " . equals ( nextTok ) ) { if ( lastTokenHasBeenQuoted || current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; current = new StringBuffer ( ) ; } } else { current . append ( nextTok ) ; } lastTokenHasBeenQuoted = false ; break ; } } if ( lastTokenHasBeenQuoted || current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; } if ( state == inQuote || state == inDoubleQuote ) { throw new BuildException ( "unbalanced quotes in " + toProcess ) ; } String [ ] args = new String [ v . size ( ) ] ; v . copyInto ( args ) ; return args ; } public int size ( ) { return getCommandline ( ) . length ; } public Object clone ( ) { try { Commandline c = ( Commandline ) super . clone ( ) ; c . arguments = ( Vector ) arguments . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public void clear ( ) { executable = null ; arguments . removeAllElements ( ) ; } public void clearArgs ( ) { arguments . removeAllElements ( ) ; } public Marker createMarker ( ) { return new Marker ( arguments . size ( ) ) ; } public String describeCommand ( ) { return describeCommand ( this ) ; } public String describeArguments ( ) { return describeArguments ( this ) ; } public static String describeCommand ( Commandline line ) { return describeCommand ( line . getCommandline ( ) ) ; } public static String describeArguments ( Commandline line ) { return describeArguments ( line . getArguments ( ) ) ; } public static String describeCommand ( String [ ] args ) { if ( args == null || args . length == 0 ) { return "" ; } StringBuffer buf = new StringBuffer ( "Executing \'" ) ; buf . append ( args [ 0 ] ) ; buf . append ( "\'" ) ; if ( args . length > 1 ) { buf . append ( " with " ) ; buf . append ( describeArguments ( args , 1 ) ) ; } else { buf . append ( DISCLAIMER ) ; } return buf . toString ( ) ; } public static String describeArguments ( String [ ] args ) { return describeArguments ( args , 0 ) ; } protected static String describeArguments ( String [ ] args , int offset ) { if ( args == null || args . length <= offset ) { return "" ; } StringBuffer buf = new StringBuffer ( "argument" ) ; if ( args . length > offset ) { buf . append ( "s" ) ; } buf . append ( ":" ) . append ( StringUtils . LINE_SEP ) ; for ( int i = offset ; i < args . length ; i ++ ) { buf . append ( "\'" ) . append ( args [ i ] ) . append ( "\'" ) . append ( StringUtils . LINE_SEP ) ; } buf . append ( DISCLAIMER ) ; return buf . toString ( ) ; } public Iterator iterator ( ) { return arguments . iterator ( ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . util . Hashtable ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . SubBuildListener ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . LogLevel ; public class Recorder extends Task implements SubBuildListener { private String filename = null ; private Boolean append = null ; private Boolean start = null ; private int loglevel = - 1 ; private boolean emacsMode = false ; private static Hashtable recorderEntries = new Hashtable ( ) ; public void init ( ) { getProject ( ) . addBuildListener ( this ) ; } public void setName ( String fname ) { filename = fname ; } public void setAction ( ActionChoices action ) { if ( action . getValue ( ) . equalsIgnoreCase ( "start" ) ) { start = Boolean . TRUE ; } else { start = Boolean . FALSE ; } } public void setAppend ( boolean append ) { this . append = ( append ? Boolean . TRUE : Boolean . FALSE ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void setLoglevel ( VerbosityLevelChoices level ) { loglevel = level . getLevel ( ) ; } public void execute ( ) throws BuildException { if ( filename == null ) { throw new BuildException ( "No filename specified" ) ; } getProject ( ) . log ( "setting a recorder for name " + filename , Project . MSG_DEBUG ) ; RecorderEntry recorder = getRecorder ( filename , getProject ( ) ) ; recorder . setMessageOutputLevel ( loglevel ) ; recorder . setEmacsMode ( emacsMode ) ; if ( start != null ) { if ( start . booleanValue ( ) ) { recorder . reopenFile ( ) ; recorder . setRecordState ( start ) ; } else { recorder . setRecordState ( start ) ; recorder . closeFile ( ) ; } } } public static class ActionChoices extends EnumeratedAttribute { private static final String [ ] VALUES = { "start" , "stop" } ; public String [ ] getValues ( ) { return VALUES ; } } public static class VerbosityLevelChoices extends LogLevel { } protected RecorderEntry getRecorder ( String name , Project proj ) throws BuildException { Object o = recorderEntries . get ( name ) ; RecorderEntry entry ; if ( o == null ) { entry = new RecorderEntry ( name ) ; if ( append == null ) { entry . openFile ( false ) ; } else { entry . openFile ( append . booleanValue ( ) ) ; } entry . setProject ( proj ) ; recorderEntries . put ( name , entry ) ; } else { entry = ( RecorderEntry ) o ; } return entry ; } public void buildStarted ( BuildEvent event ) { } public void subBuildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { cleanup ( ) ; } public void subBuildFinished ( BuildEvent event ) { if ( event . getProject ( ) == getProject ( ) ) { cleanup ( ) ; } } private void cleanup ( ) { recorderEntries . clear ( ) ; getProject ( ) . removeBuildListener ( this ) ; } } 	1
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class AbstractSelectorContainer extends DataType implements SelectorContainer { private Vector selectorsList = new Vector ( ) ; public boolean hasSelectors ( ) { return ! ( selectorsList . isEmpty ( ) ) ; } public int selectorCount ( ) { return selectorsList . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { FileSelector [ ] result = new FileSelector [ selectorsList . size ( ) ] ; selectorsList . copyInto ( result ) ; return result ; } public Enumeration selectorElements ( ) { return selectorsList . elements ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = selectorElements ( ) ; if ( e . hasMoreElements ( ) ) { while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) . toString ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } } return buf . toString ( ) ; } public void appendSelector ( FileSelector selector ) { selectorsList . addElement ( selector ) ; } public void validate ( ) { Enumeration e = selectorElements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof BaseSelector ) { ( ( BaseSelector ) o ) . validate ( ) ; } } } public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { appendSelector ( selector ) ; } public void addType ( TypeSelector selector ) { appendSelector ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { appendSelector ( selector ) ; } public void addModified ( ModifiedSelector selector ) { appendSelector ( selector ) ; } public void add ( FileSelector selector ) { appendSelector ( selector ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . io . PrintWriter ; import java . io . StringReader ; import java . io . StringWriter ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . StringTokenizer ; import java . util . Vector ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import junit . framework . TestFailure ; import junit . framework . TestListener ; import junit . framework . TestResult ; import junit . framework . TestSuite ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Permissions ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . TeeOutputStream ; public class JUnitTestRunner implements TestListener , JUnitTaskMirror . JUnitTestRunnerMirror { private Vector formatters = new Vector ( ) ; private TestResult res ; private static boolean filtertrace = true ; private boolean showOutput = false ; private boolean outputToFormatters = true ; private Permissions perm = null ; private static final String [ ] DEFAULT_TRACE_FILTERS = new String [ ] { "junit.framework.TestCase" , "junit.framework.TestResult" , "junit.framework.TestSuite" , "junit.framework.Assert." , "junit.swingui.TestRunner" , "junit.awtui.TestRunner" , "junit.textui.TestRunner" , "java.lang.reflect.Method.invoke(" , "sun.reflect." , "org.apache.tools.ant." , "org.junit." , "junit.framework.JUnit4TestAdapter" , "Caused by: java.lang.AssertionError" , " more" , } ; private boolean haltOnError = false ; private boolean haltOnFailure = false ; private int retCode = SUCCESS ; private JUnitTest junitTest ; private PrintStream systemError ; private PrintStream systemOut ; private boolean forked = false ; private static boolean multipleTests = false ; private ClassLoader loader ; private boolean logTestListenerEvents = false ; private boolean junit4 ; private static String crashFile = null ; public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure ) { this ( test , haltOnError , filtertrace , haltOnFailure , false ) ; } public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure , boolean showOutput ) { this ( test , haltOnError , filtertrace , haltOnFailure , showOutput , false ) ; } public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure , boolean showOutput , boolean logTestListenerEvents ) { this ( test , haltOnError , filtertrace , haltOnFailure , showOutput , logTestListenerEvents , null ) ; } public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure , ClassLoader loader ) { this ( test , haltOnError , filtertrace , haltOnFailure , false , loader ) ; } public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure , boolean showOutput , ClassLoader loader ) { this ( test , haltOnError , filtertrace , haltOnFailure , showOutput , false , loader ) ; } public JUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filtertrace , boolean haltOnFailure , boolean showOutput , boolean logTestListenerEvents , ClassLoader loader ) { JUnitTestRunner . filtertrace = filtertrace ; this . junitTest = test ; this . haltOnError = haltOnError ; this . haltOnFailure = haltOnFailure ; this . showOutput = showOutput ; this . logTestListenerEvents = logTestListenerEvents ; this . loader = loader ; } private PrintStream savedOut = null ; public void run ( ) { res = new TestResult ( ) ; res . addListener ( wrapListener ( this ) ) ; for ( int i = 0 ; i < formatters . size ( ) ; i ++ ) { res . addListener ( wrapListener ( ( TestListener ) formatters . elementAt ( i ) ) ) ; } ByteArrayOutputStream errStrm = new ByteArrayOutputStream ( ) ; systemError = new PrintStream ( errStrm ) ; ByteArrayOutputStream outStrm = new ByteArrayOutputStream ( ) ; systemOut = new PrintStream ( outStrm ) ; PrintStream savedErr = null ; if ( forked ) { if ( ! outputToFormatters ) { if ( ! showOutput ) { savedOut = System . out ; savedErr = System . err ; System . setOut ( new PrintStream ( new OutputStream ( ) { public void write ( int b ) { } } ) ) ; System . setErr ( new PrintStream ( new OutputStream ( ) { public void write ( int b ) { } } ) ) ; } } else { savedOut = System . out ; savedErr = System . err ; if ( ! showOutput ) { System . setOut ( systemOut ) ; System . setErr ( systemError ) ; } else { System . setOut ( new PrintStream ( new TeeOutputStream ( savedOut , systemOut ) ) ) ; System . setErr ( new PrintStream ( new TeeOutputStream ( savedErr , systemError ) ) ) ; } perm = null ; } } else { if ( perm != null ) { perm . setSecurityManager ( ) ; } } Test suite = null ; Throwable exception = null ; boolean startTestSuiteSuccess = false ; try { try { Class testClass = null ; if ( loader == null ) { testClass = Class . forName ( junitTest . getName ( ) ) ; } else { testClass = Class . forName ( junitTest . getName ( ) , true , loader ) ; } Method suiteMethod = null ; try { suiteMethod = testClass . getMethod ( "suite" , new Class [ 0 ] ) ; } catch ( NoSuchMethodException e ) { } if ( suiteMethod != null ) { suite = ( Test ) suiteMethod . invoke ( null , new Class [ 0 ] ) ; } else { Class junit4TestAdapterClass = null ; try { Class . forName ( "java.lang.annotation.Annotation" ) ; if ( loader == null ) { junit4TestAdapterClass = Class . forName ( "junit.framework.JUnit4TestAdapter" ) ; } else { junit4TestAdapterClass = Class . forName ( "junit.framework.JUnit4TestAdapter" , true , loader ) ; } } catch ( ClassNotFoundException e ) { } junit4 = junit4TestAdapterClass != null ; if ( junit4 ) { suite = ( Test ) junit4TestAdapterClass . getConstructor ( new Class [ ] { Class . class } ) . newInstance ( new Object [ ] { testClass } ) ; } else { suite = new TestSuite ( testClass ) ; } } } catch ( Throwable e ) { retCode = ERRORS ; exception = e ; } long start = System . currentTimeMillis ( ) ; fireStartTestSuite ( ) ; startTestSuiteSuccess = true ; if ( exception != null ) { for ( int i = 0 ; i < formatters . size ( ) ; i ++ ) { ( ( TestListener ) formatters . elementAt ( i ) ) . addError ( null , exception ) ; } junitTest . setCounts ( 1 , 0 , 1 ) ; junitTest . setRunTime ( 0 ) ; } else { try { logTestListenerEvent ( "tests to run: " + suite . countTestCases ( ) ) ; suite . run ( res ) ; } finally { if ( junit4 ) { int [ ] cnts = findJUnit4FailureErrorCount ( res ) ; junitTest . setCounts ( res . runCount ( ) , cnts [ 0 ] , cnts [ 1 ] ) ; } else { junitTest . setCounts ( res . runCount ( ) , res . failureCount ( ) , res . errorCount ( ) ) ; } junitTest . setRunTime ( System . currentTimeMillis ( ) - start ) ; } } } finally { if ( perm != null ) { perm . restoreSecurityManager ( ) ; } if ( savedOut != null ) { System . setOut ( savedOut ) ; } if ( savedErr != null ) { System . setErr ( savedErr ) ; } systemError . close ( ) ; systemError = null ; systemOut . close ( ) ; systemOut = null ; if ( startTestSuiteSuccess ) { sendOutAndErr ( new String ( outStrm . toByteArray ( ) ) , new String ( errStrm . toByteArray ( ) ) ) ; } } fireEndTestSuite ( ) ; if ( retCode != SUCCESS || res . errorCount ( ) != 0 ) { retCode = ERRORS ; } else if ( res . failureCount ( ) != 0 ) { retCode = FAILURES ; } } public int getRetCode ( ) { return retCode ; } public void startTest ( Test t ) { String testName = JUnitVersionHelper . getTestCaseName ( t ) ; logTestListenerEvent ( "startTest(" + testName + ")" ) ; } public void endTest ( Test test ) { String testName = JUnitVersionHelper . getTestCaseName ( test ) ; logTestListenerEvent ( "endTest(" + testName + ")" ) ; } private void logTestListenerEvent ( String msg ) { PrintStream out = savedOut != null ? savedOut : System . out ; if ( logTestListenerEvents ) { out . flush ( ) ; out . println ( JUnitTask . TESTLISTENER_PREFIX + msg ) ; out . flush ( ) ; } } public void addFailure ( Test test , Throwable t ) { String testName = JUnitVersionHelper . getTestCaseName ( test ) ; logTestListenerEvent ( "addFailure(" + testName + ", " + t . getMessage ( ) + ")" ) ; if ( haltOnFailure ) { res . stop ( ) ; } } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable t ) { String testName = JUnitVersionHelper . getTestCaseName ( test ) ; logTestListenerEvent ( "addError(" + testName + ", " + t . getMessage ( ) + ")" ) ; if ( haltOnError ) { res . stop ( ) ; } } public void setPermissions ( Permissions permissions ) { perm = permissions ; } public void handleOutput ( String output ) { if ( ! logTestListenerEvents && output . startsWith ( JUnitTask . TESTLISTENER_PREFIX ) ) { } else if ( systemOut != null ) { systemOut . print ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { return - 1 ; } public void handleErrorOutput ( String output ) { if ( systemError != null ) { systemError . print ( output ) ; } } public void handleFlush ( String output ) { if ( systemOut != null ) { systemOut . print ( output ) ; } } public void handleErrorFlush ( String output ) { if ( systemError != null ) { systemError . print ( output ) ; } } private void sendOutAndErr ( String out , String err ) { for ( int i = 0 ; i < formatters . size ( ) ; i ++ ) { JUnitResultFormatter formatter = ( ( JUnitResultFormatter ) formatters . elementAt ( i ) ) ; formatter . setSystemOutput ( out ) ; formatter . setSystemError ( err ) ; } } private void fireStartTestSuite ( ) { for ( int i = 0 ; i < formatters . size ( ) ; i ++ ) { ( ( JUnitResultFormatter ) formatters . elementAt ( i ) ) . startTestSuite ( junitTest ) ; } } private void fireEndTestSuite ( ) { for ( int i = 0 ; i < formatters . size ( ) ; i ++ ) { ( ( JUnitResultFormatter ) formatters . elementAt ( i ) ) . endTestSuite ( junitTest ) ; } } public void addFormatter ( JUnitResultFormatter f ) { formatters . addElement ( f ) ; } public void addFormatter ( JUnitTaskMirror . JUnitResultFormatterMirror f ) { formatters . addElement ( ( JUnitResultFormatter ) f ) ; } public static void main ( String [ ] args ) throws IOException { boolean haltError = false ; boolean haltFail = false ; boolean stackfilter = true ; Properties props = new Properties ( ) ; boolean showOut = false ; boolean outputToFormat = true ; boolean logTestListenerEvents = false ; if ( args . length == 0 ) { System . err . println ( "required argument TestClassName missing" ) ; System . exit ( ERRORS ) ; } if ( args [ 0 ] . startsWith ( Constants . TESTSFILE ) ) { multipleTests = true ; args [ 0 ] = args [ 0 ] . substring ( Constants . TESTSFILE . length ( ) ) ; } for ( int i = 1 ; i < args . length ; i ++ ) { if ( args [ i ] . startsWith ( Constants . HALT_ON_ERROR ) ) { haltError = Project . toBoolean ( args [ i ] . substring ( Constants . HALT_ON_ERROR . length ( ) ) ) ; } else if ( args [ i ] . startsWith ( Constants . HALT_ON_FAILURE ) ) { haltFail = Project . toBoolean ( args [ i ] . substring ( Constants . HALT_ON_FAILURE . length ( ) ) ) ; } else if ( args [ i ] . startsWith ( Constants . FILTERTRACE ) ) { stackfilter = Project . toBoolean ( args [ i ] . substring ( Constants . FILTERTRACE . length ( ) ) ) ; } else if ( args [ i ] . startsWith ( Constants . CRASHFILE ) ) { crashFile = args [ i ] . substring ( Constants . CRASHFILE . length ( ) ) ; registerTestCase ( Constants . BEFORE_FIRST_TEST ) ; } else if ( args [ i ] . startsWith ( Constants . FORMATTER ) ) { try { createAndStoreFormatter ( args [ i ] . substring ( Constants . FORMATTER . length ( ) ) ) ; } catch ( BuildException be ) { System . err . println ( be . getMessage ( ) ) ; System . exit ( ERRORS ) ; } } else if ( args [ i ] . startsWith ( Constants . PROPSFILE ) ) { FileInputStream in = new FileInputStream ( args [ i ] . substring ( Constants . PROPSFILE . length ( ) ) ) ; props . load ( in ) ; in . close ( ) ; } else if ( args [ i ] . startsWith ( Constants . SHOWOUTPUT ) ) { showOut = Project . toBoolean ( args [ i ] . substring ( Constants . SHOWOUTPUT . length ( ) ) ) ; } else if ( args [ i ] . startsWith ( Constants . LOGTESTLISTENEREVENTS ) ) { logTestListenerEvents = Project . toBoolean ( args [ i ] . substring ( Constants . LOGTESTLISTENEREVENTS . length ( ) ) ) ; } else if ( args [ i ] . startsWith ( Constants . OUTPUT_TO_FORMATTERS ) ) { outputToFormat = Project . toBoolean ( args [ i ] . substring ( Constants . OUTPUT_TO_FORMATTERS . length ( ) ) ) ; } } Hashtable p = System . getProperties ( ) ; for ( Enumeration e = p . keys ( ) ; e . hasMoreElements ( ) ; ) { Object key = e . nextElement ( ) ; props . put ( key , p . get ( key ) ) ; } int returnCode = SUCCESS ; if ( multipleTests ) { try { java . io . BufferedReader reader = new java . io . BufferedReader ( new java . io . FileReader ( args [ 0 ] ) ) ; String testCaseName ; int code = 0 ; boolean errorOccurred = false ; boolean failureOccurred = false ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line , "," ) ; testCaseName = st . nextToken ( ) ; JUnitTest t = new JUnitTest ( testCaseName ) ; t . setTodir ( new File ( st . nextToken ( ) ) ) ; t . setOutfile ( st . nextToken ( ) ) ; code = launch ( t , haltError , stackfilter , haltFail , showOut , outputToFormat , logTestListenerEvents , props ) ; errorOccurred = ( code == ERRORS ) ; failureOccurred = ( code != SUCCESS ) ; if ( errorOccurred || failureOccurred ) { if ( ( errorOccurred && haltError ) || ( failureOccurred && haltFail ) ) { registerNonCrash ( ) ; System . exit ( code ) ; } else { if ( code > returnCode ) { returnCode = code ; } System . out . println ( "TEST " + t . getName ( ) + " FAILED" ) ; } } } } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { returnCode = launch ( new JUnitTest ( args [ 0 ] ) , haltError , stackfilter , haltFail , showOut , outputToFormat , logTestListenerEvents , props ) ; } registerNonCrash ( ) ; System . exit ( returnCode ) ; } private static Vector fromCmdLine = new Vector ( ) ; private static void transferFormatters ( JUnitTestRunner runner , JUnitTest test ) { runner . addFormatter ( new JUnitResultFormatter ( ) { public void startTestSuite ( JUnitTest suite ) throws BuildException { } public void endTestSuite ( JUnitTest suite ) throws BuildException { } public void setOutput ( OutputStream out ) { } public void setSystemOutput ( String out ) { } public void setSystemError ( String err ) { } public void addError ( Test arg0 , Throwable arg1 ) { } public void addFailure ( Test arg0 , AssertionFailedError arg1 ) { } public void endTest ( Test arg0 ) { } public void startTest ( Test arg0 ) { registerTestCase ( JUnitVersionHelper . getTestCaseName ( arg0 ) ) ; } } ) ; for ( int i = 0 ; i < fromCmdLine . size ( ) ; i ++ ) { FormatterElement fe = ( FormatterElement ) fromCmdLine . elementAt ( i ) ; if ( multipleTests && fe . getUseFile ( ) ) { File destFile = new File ( test . getTodir ( ) , test . getOutfile ( ) + fe . getExtension ( ) ) ; fe . setOutfile ( destFile ) ; } runner . addFormatter ( ( JUnitResultFormatter ) fe . createFormatter ( ) ) ; } } private static void createAndStoreFormatter ( String line ) throws BuildException { FormatterElement fe = new FormatterElement ( ) ; int pos = line . indexOf ( ',' ) ; if ( pos == - 1 ) { fe . setClassname ( line ) ; fe . setUseFile ( false ) ; } else { fe . setClassname ( line . substring ( 0 , pos ) ) ; fe . setUseFile ( true ) ; if ( ! multipleTests ) { fe . setOutfile ( new File ( line . substring ( pos + 1 ) ) ) ; } else { int fName = line . indexOf ( IGNORED_FILE_NAME ) ; if ( fName > - 1 ) { fe . setExtension ( line . substring ( fName + IGNORED_FILE_NAME . length ( ) ) ) ; } } } fromCmdLine . addElement ( fe ) ; } public static String getFilteredTrace ( Throwable t ) { String trace = StringUtils . getStackTrace ( t ) ; return JUnitTestRunner . filterStack ( trace ) ; } public static String filterStack ( String stack ) { if ( ! filtertrace ) { return stack ; } StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; StringReader sr = new StringReader ( stack ) ; BufferedReader br = new BufferedReader ( sr ) ; String line ; try { while ( ( line = br . readLine ( ) ) != null ) { if ( ! filterLine ( line ) ) { pw . println ( line ) ; } } } catch ( Exception e ) { return stack ; } return sw . toString ( ) ; } private static boolean filterLine ( String line ) { for ( int i = 0 ; i < DEFAULT_TRACE_FILTERS . length ; i ++ ) { if ( line . indexOf ( DEFAULT_TRACE_FILTERS [ i ] ) != - 1 ) { return true ; } } return false ; } private static int launch ( JUnitTest t , boolean haltError , boolean stackfilter , boolean haltFail , boolean showOut , boolean outputToFormat , boolean logTestListenerEvents , Properties props ) { t . setProperties ( props ) ; JUnitTestRunner runner = new JUnitTestRunner ( t , haltError , stackfilter , haltFail , showOut , logTestListenerEvents , null ) ; runner . forked = true ; runner . outputToFormatters = outputToFormat ; transferFormatters ( runner , t ) ; runner . run ( ) ; return runner . getRetCode ( ) ; } private static void registerNonCrash ( ) throws IOException { if ( crashFile != null ) { FileWriter out = null ; try { out = new FileWriter ( crashFile ) ; out . write ( Constants . TERMINATED_SUCCESSFULLY + "\n" ) ; out . flush ( ) ; } finally { if ( out != null ) { out . close ( ) ; } } } } private static void registerTestCase ( String testCase ) { if ( crashFile != null ) { try { FileWriter out = null ; try { out = new FileWriter ( crashFile ) ; out . write ( testCase + "\n" ) ; out . flush ( ) ; } finally { if ( out != null ) { out . close ( ) ; } } } catch ( IOException e ) { } } } private TestListener wrapListener ( final TestListener testListener ) { return new TestListener ( ) { public void addError ( Test test , Throwable t ) { if ( junit4 && t instanceof AssertionFailedError ) { testListener . addFailure ( test , ( AssertionFailedError ) t ) ; } else if ( junit4 && t . getClass ( ) . getName ( ) . equals ( "java.lang.AssertionError" ) ) { try { String msg = t . getMessage ( ) ; AssertionFailedError failure = msg != null ? new AssertionFailedError ( msg ) : new AssertionFailedError ( ) ; Method initCause = Throwable . class . getMethod ( "initCause" , new Class [ ] { Throwable . class } ) ; initCause . invoke ( failure , new Object [ ] { t } ) ; testListener . addFailure ( test , failure ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; testListener . addError ( test , t ) ; } } else { testListener . addError ( test , t ) ; } } public void addFailure ( Test test , AssertionFailedError t ) { testListener . addFailure ( test , t ) ; } public void addFailure ( Test test , Throwable t ) { if ( t instanceof AssertionFailedError ) { testListener . addFailure ( test , ( AssertionFailedError ) t ) ; } else { testListener . addError ( test , t ) ; } } public void endTest ( Test test ) { testListener . endTest ( test ) ; } public void startTest ( Test test ) { testListener . startTest ( test ) ; } } ; } private int [ ] findJUnit4FailureErrorCount ( TestResult res ) { int failures = 0 ; int errors = 0 ; Enumeration e = res . failures ( ) ; while ( e . hasMoreElements ( ) ) { e . nextElement ( ) ; failures ++ ; } e = res . errors ( ) ; while ( e . hasMoreElements ( ) ) { Throwable t = ( ( TestFailure ) e . nextElement ( ) ) . thrownException ( ) ; if ( t instanceof AssertionFailedError || t . getClass ( ) . getName ( ) . equals ( "java.lang.AssertionError" ) ) { failures ++ ; } else { errors ++ ; } } return new int [ ] { failures , errors } ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Reader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . StringTokenizer ; import java . util . TreeMap ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . types . spi . Service ; import org . apache . tools . zip . JarMarker ; import org . apache . tools . zip . ZipExtraField ; import org . apache . tools . zip . ZipOutputStream ; public class Jar extends Zip { private static final String INDEX_NAME = "META-INF/INDEX.LIST" ; private static final String MANIFEST_NAME = "META-INF/MANIFEST.MF" ; private List serviceList = new ArrayList ( ) ; private Manifest configuredManifest ; private Manifest savedConfiguredManifest ; private Manifest filesetManifest ; private Manifest originalManifest ; private FilesetManifestConfig filesetManifestConfig ; private boolean mergeManifestsMain = true ; private Manifest manifest ; private String manifestEncoding ; private File manifestFile ; private boolean index = false ; private boolean createEmpty = false ; private Vector rootEntries ; private Path indexJars ; private static final ZipExtraField [ ] JAR_MARKER = new ZipExtraField [ ] { JarMarker . getInstance ( ) } ; protected String emptyBehavior = "create" ; public Jar ( ) { super ( ) ; archiveType = "jar" ; emptyBehavior = "create" ; setEncoding ( "UTF8" ) ; rootEntries = new Vector ( ) ; } public void setWhenempty ( WhenEmpty we ) { log ( "JARs are never empty, they contain at least a manifest file" , Project . MSG_WARN ) ; } public void setWhenmanifestonly ( WhenEmpty we ) { emptyBehavior = we . getValue ( ) ; } public void setJarfile ( File jarFile ) { setDestFile ( jarFile ) ; } public void setIndex ( boolean flag ) { index = flag ; } public void setManifestEncoding ( String manifestEncoding ) { this . manifestEncoding = manifestEncoding ; } public void addConfiguredManifest ( Manifest newManifest ) throws ManifestException { if ( configuredManifest == null ) { configuredManifest = newManifest ; } else { configuredManifest . merge ( newManifest ) ; } savedConfiguredManifest = configuredManifest ; } public void setManifest ( File manifestFile ) { if ( ! manifestFile . exists ( ) ) { throw new BuildException ( "Manifest file: " + manifestFile + " does not exist." , getLocation ( ) ) ; } this . manifestFile = manifestFile ; } private Manifest getManifest ( File manifestFile ) { Manifest newManifest = null ; FileInputStream fis = null ; InputStreamReader isr = null ; try { fis = new FileInputStream ( manifestFile ) ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( fis ) ; } else { isr = new InputStreamReader ( fis , manifestEncoding ) ; } newManifest = getManifest ( isr ) ; } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading manifest: " + e . getMessage ( ) , e ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " + manifestFile + " (" + e . getMessage ( ) + ")" , e ) ; } finally { if ( isr != null ) { try { isr . close ( ) ; } catch ( IOException e ) { } } } return newManifest ; } private Manifest getManifestFromJar ( File jarFile ) throws IOException { ZipFile zf = null ; try { zf = new ZipFile ( jarFile ) ; Enumeration e = zf . entries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; if ( ze . getName ( ) . equalsIgnoreCase ( MANIFEST_NAME ) ) { InputStreamReader isr = new InputStreamReader ( zf . getInputStream ( ze ) , "UTF-8" ) ; return getManifest ( isr ) ; } } return null ; } finally { if ( zf != null ) { try { zf . close ( ) ; } catch ( IOException e ) { } } } } private Manifest getManifest ( Reader r ) { Manifest newManifest = null ; try { newManifest = new Manifest ( r ) ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest: " + manifestFile , e , getLocation ( ) ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file" + " (" + e . getMessage ( ) + ")" , e ) ; } return newManifest ; } public void setFilesetmanifest ( FilesetManifestConfig config ) { filesetManifestConfig = config ; mergeManifestsMain = "merge" . equals ( config . getValue ( ) ) ; if ( filesetManifestConfig != null && ! filesetManifestConfig . getValue ( ) . equals ( "skip" ) ) { doubleFilePass = true ; } } public void addMetainf ( ZipFileSet fs ) { fs . setPrefix ( "META-INF/" ) ; super . addFileset ( fs ) ; } public void addConfiguredIndexJars ( Path p ) { if ( indexJars == null ) { indexJars = new Path ( getProject ( ) ) ; } indexJars . append ( p ) ; } public void addConfiguredService ( Service service ) { service . check ( ) ; serviceList . add ( service ) ; } private void writeServices ( ZipOutputStream zOut ) throws IOException { Iterator serviceIterator ; Service service ; serviceIterator = serviceList . iterator ( ) ; while ( serviceIterator . hasNext ( ) ) { service = ( Service ) serviceIterator . next ( ) ; super . zipFile ( service . getAsStream ( ) , zOut , "META-INF/service/" + service . getType ( ) , System . currentTimeMillis ( ) , null , ZipFileSet . DEFAULT_FILE_MODE ) ; } } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( ! skipWriting ) { Manifest jarManifest = createManifest ( ) ; writeManifest ( zOut , jarManifest ) ; writeServices ( zOut ) ; } } private Manifest createManifest ( ) throws BuildException { try { Manifest finalManifest = Manifest . getDefaultManifest ( ) ; if ( manifest == null ) { if ( manifestFile != null ) { manifest = getManifest ( manifestFile ) ; } } if ( isInUpdateMode ( ) ) { finalManifest . merge ( originalManifest ) ; } finalManifest . merge ( filesetManifest ) ; finalManifest . merge ( configuredManifest ) ; finalManifest . merge ( manifest , ! mergeManifestsMain ) ; return finalManifest ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } private void writeManifest ( ZipOutputStream zOut , Manifest manifest ) throws IOException { for ( Enumeration e = manifest . getWarnings ( ) ; e . hasMoreElements ( ) ; ) { log ( "Manifest warning: " + ( String ) e . nextElement ( ) , Project . MSG_WARN ) ; } zipDir ( null , zOut , "META-INF/" , ZipFileSet . DEFAULT_DIR_MODE , JAR_MARKER ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; OutputStreamWriter osw = new OutputStreamWriter ( baos , Manifest . JAR_ENCODING ) ; PrintWriter writer = new PrintWriter ( osw ) ; manifest . write ( writer ) ; writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , MANIFEST_NAME , System . currentTimeMillis ( ) , null , ZipFileSet . DEFAULT_FILE_MODE ) ; super . initZipOutputStream ( zOut ) ; } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( index ) { createIndexList ( zOut ) ; } } private void createIndexList ( ZipOutputStream zOut ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( baos , "UTF8" ) ) ; writer . println ( "JarIndex-Version: 1.0" ) ; writer . println ( ) ; writer . println ( zipFile . getName ( ) ) ; writeIndexLikeList ( new ArrayList ( addedDirs . keySet ( ) ) , rootEntries , writer ) ; writer . println ( ) ; if ( indexJars != null ) { Manifest mf = createManifest ( ) ; Manifest . Attribute classpath = mf . getMainSection ( ) . getAttribute ( Manifest . ATTRIBUTE_CLASSPATH ) ; String [ ] cpEntries = null ; if ( classpath != null && classpath . getValue ( ) != null ) { StringTokenizer tok = new StringTokenizer ( classpath . getValue ( ) , " " ) ; cpEntries = new String [ tok . countTokens ( ) ] ; int c = 0 ; while ( tok . hasMoreTokens ( ) ) { cpEntries [ c ++ ] = tok . nextToken ( ) ; } } String [ ] indexJarEntries = indexJars . list ( ) ; for ( int i = 0 ; i < indexJarEntries . length ; i ++ ) { String name = findJarName ( indexJarEntries [ i ] , cpEntries ) ; if ( name != null ) { ArrayList dirs = new ArrayList ( ) ; ArrayList files = new ArrayList ( ) ; grabFilesAndDirs ( indexJarEntries [ i ] , dirs , files ) ; if ( dirs . size ( ) + files . size ( ) > 0 ) { writer . println ( name ) ; writeIndexLikeList ( dirs , files , writer ) ; writer . println ( ) ; } } } } writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , INDEX_NAME , System . currentTimeMillis ( ) , null , ZipFileSet . DEFAULT_FILE_MODE ) ; } protected void zipFile ( InputStream is , ZipOutputStream zOut , String vPath , long lastModified , File fromArchive , int mode ) throws IOException { if ( MANIFEST_NAME . equalsIgnoreCase ( vPath ) ) { if ( ! doubleFilePass || ( doubleFilePass && skipWriting ) ) { filesetManifest ( fromArchive , is ) ; } } else if ( INDEX_NAME . equalsIgnoreCase ( vPath ) && index ) { log ( "Warning: selected " + archiveType + " files include a META-INF/INDEX.LIST which will" + " be replaced by a newly generated one." , Project . MSG_WARN ) ; } else { if ( index && vPath . indexOf ( "/" ) == - 1 ) { rootEntries . addElement ( vPath ) ; } super . zipFile ( is , zOut , vPath , lastModified , fromArchive , mode ) ; } } private void filesetManifest ( File file , InputStream is ) throws IOException { if ( manifestFile != null && manifestFile . equals ( file ) ) { log ( "Found manifest " + file , Project . MSG_VERBOSE ) ; try { if ( is != null ) { InputStreamReader isr ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( is ) ; } else { isr = new InputStreamReader ( is , manifestEncoding ) ; } manifest = getManifest ( isr ) ; } else { manifest = getManifest ( file ) ; } } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading " + "manifest: " + e . getMessage ( ) , e ) ; } } else if ( filesetManifestConfig != null && ! filesetManifestConfig . getValue ( ) . equals ( "skip" ) ) { log ( "Found manifest to merge in file " + file , Project . MSG_VERBOSE ) ; try { Manifest newManifest = null ; if ( is != null ) { InputStreamReader isr ; if ( manifestEncoding == null ) { isr = new InputStreamReader ( is ) ; } else { isr = new InputStreamReader ( is , manifestEncoding ) ; } newManifest = getManifest ( isr ) ; } else { newManifest = getManifest ( file ) ; } if ( filesetManifest == null ) { filesetManifest = newManifest ; } else { filesetManifest . merge ( newManifest ) ; } } catch ( UnsupportedEncodingException e ) { throw new BuildException ( "Unsupported encoding while reading " + "manifest: " + e . getMessage ( ) , e ) ; } catch ( ManifestException e ) { log ( "Manifest in file " + file + " is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } else { } } protected ArchiveState getResourcesToAdd ( ResourceCollection [ ] rcs , File zipFile , boolean needsUpdate ) throws BuildException { if ( zipFile . exists ( ) ) { try { originalManifest = getManifestFromJar ( zipFile ) ; if ( originalManifest == null ) { log ( "Updating jar since the current jar has no manifest" , Project . MSG_VERBOSE ) ; needsUpdate = true ; } else { Manifest mf = createManifest ( ) ; if ( ! mf . equals ( originalManifest ) ) { log ( "Updating jar since jar manifest has changed" , Project . MSG_VERBOSE ) ; needsUpdate = true ; } } } catch ( Throwable t ) { log ( "error while reading original manifest in file: " + zipFile . toString ( ) + t . getMessage ( ) , Project . MSG_WARN ) ; needsUpdate = true ; } } else { needsUpdate = true ; } createEmpty = needsUpdate ; return super . getResourcesToAdd ( rcs , zipFile , needsUpdate ) ; } protected boolean createEmptyZip ( File zipFile ) throws BuildException { if ( ! createEmpty ) { return true ; } if ( emptyBehavior . equals ( "skip" ) ) { log ( "Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included." , Project . MSG_WARN ) ; return true ; } else if ( emptyBehavior . equals ( "fail" ) ) { throw new BuildException ( "Cannot create " + archiveType + " archive " + zipFile + ": no files were included." , getLocation ( ) ) ; } ZipOutputStream zOut = null ; try { log ( "Building MANIFEST-only jar: " + getDestFile ( ) . getAbsolutePath ( ) ) ; zOut = new ZipOutputStream ( new FileOutputStream ( getDestFile ( ) ) ) ; zOut . setEncoding ( getEncoding ( ) ) ; if ( isCompress ( ) ) { zOut . setMethod ( ZipOutputStream . DEFLATED ) ; } else { zOut . setMethod ( ZipOutputStream . STORED ) ; } initZipOutputStream ( zOut ) ; finalizeZipOutputStream ( zOut ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create almost empty JAR archive" + " (" + ioe . getMessage ( ) + ")" , ioe , getLocation ( ) ) ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { } createEmpty = false ; } return true ; } protected void cleanUp ( ) { super . cleanUp ( ) ; if ( ! doubleFilePass || ( doubleFilePass && ! skipWriting ) ) { manifest = null ; configuredManifest = savedConfiguredManifest ; filesetManifest = null ; originalManifest = null ; } rootEntries . removeAllElements ( ) ; } public void reset ( ) { super . reset ( ) ; emptyBehavior = "create" ; configuredManifest = null ; filesetManifestConfig = null ; mergeManifestsMain = false ; manifestFile = null ; index = false ; } public static class FilesetManifestConfig extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "skip" , "merge" , "mergewithoutmain" } ; } } protected final void writeIndexLikeList ( List dirs , List files , PrintWriter writer ) throws IOException { Collections . sort ( dirs ) ; Collections . sort ( files ) ; Iterator iter = dirs . iterator ( ) ; while ( iter . hasNext ( ) ) { String dir = ( String ) iter . next ( ) ; dir = dir . replace ( '\\' , '/' ) ; if ( dir . startsWith ( "./" ) ) { dir = dir . substring ( 2 ) ; } while ( dir . startsWith ( "/" ) ) { dir = dir . substring ( 1 ) ; } int pos = dir . lastIndexOf ( '/' ) ; if ( pos != - 1 ) { dir = dir . substring ( 0 , pos ) ; } if ( dir . startsWith ( "META-INF" ) ) { continue ; } writer . println ( dir ) ; } iter = files . iterator ( ) ; while ( iter . hasNext ( ) ) { writer . println ( iter . next ( ) ) ; } } protected static final String findJarName ( String fileName , String [ ] classpath ) { if ( classpath == null ) { return ( new File ( fileName ) ) . getName ( ) ; } fileName = fileName . replace ( File . separatorChar , '/' ) ; TreeMap matches = new TreeMap ( new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { if ( o1 instanceof String && o2 instanceof String ) { return ( ( String ) o2 ) . length ( ) - ( ( String ) o1 ) . length ( ) ; } return 0 ; } } ) ; for ( int i = 0 ; i < classpath . length ; i ++ ) { if ( fileName . endsWith ( classpath [ i ] ) ) { matches . put ( classpath [ i ] , classpath [ i ] ) ; } else { int slash = classpath [ i ] . indexOf ( "/" ) ; String candidate = classpath [ i ] ; while ( slash > - 1 ) { candidate = candidate . substring ( slash + 1 ) ; if ( fileName . endsWith ( candidate ) ) { matches . put ( candidate , classpath [ i ] ) ; break ; } slash = candidate . indexOf ( "/" ) ; } } } return matches . size ( ) == 0 ? null : ( String ) matches . get ( matches . firstKey ( ) ) ; } protected static final void grabFilesAndDirs ( String file , List dirs , List files ) throws IOException { org . apache . tools . zip . ZipFile zf = null ; try { zf = new org . apache . tools . zip . ZipFile ( file , "utf-8" ) ; Enumeration entries = zf . getEntries ( ) ; HashSet dirSet = new HashSet ( ) ; while ( entries . hasMoreElements ( ) ) { org . apache . tools . zip . ZipEntry ze = ( org . apache . tools . zip . ZipEntry ) entries . nextElement ( ) ; String name = ze . getName ( ) ; if ( ! name . startsWith ( "META-INF/" ) ) { if ( ze . isDirectory ( ) ) { dirSet . add ( name ) ; } else if ( name . indexOf ( "/" ) == - 1 ) { files . add ( name ) ; } else { dirSet . add ( name . substring ( 0 , name . lastIndexOf ( "/" ) + 1 ) ) ; } } } dirs . addAll ( dirSet ) ; } finally { if ( zf != null ) { zf . close ( ) ; } } } } 	1
package org . apache . tools . zip ; public final class ZipLong implements Cloneable { private long value ; public ZipLong ( long value ) { this . value = value ; } public ZipLong ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipLong ( byte [ ] bytes , int offset ) { value = ZipLong . getValue ( bytes , offset ) ; } public byte [ ] getBytes ( ) { return ZipLong . getBytes ( value ) ; } public long getValue ( ) { return value ; } public static byte [ ] getBytes ( long value ) { byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000L ) > > 24 ) ; return result ; } public static long getValue ( byte [ ] bytes , int offset ) { long value = ( bytes [ offset + 3 ] << 24 ) & 0xFF000000L ; value += ( bytes [ offset + 2 ] << 16 ) & 0xFF0000 ; value += ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; return value ; } public static long getValue ( byte [ ] bytes ) { return getValue ( bytes , 0 ) ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipLong ) ) { return false ; } return value == ( ( ZipLong ) o ) . getValue ( ) ; } public int hashCode ( ) { return ( int ) value ; } } 	1
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . List ; import java . util . Stack ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; public abstract class BaseResourceCollectionContainer extends DataType implements ResourceCollection , Cloneable { private List rc = new ArrayList ( ) ; private Collection coll = null ; private boolean cache = true ; public synchronized void setCache ( boolean b ) { cache = b ; } public synchronized boolean isCache ( ) { return cache ; } public synchronized void clear ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } rc . clear ( ) ; FailFast . invalidate ( this ) ; coll = null ; setChecked ( false ) ; } public synchronized void add ( ResourceCollection c ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } rc . add ( c ) ; FailFast . invalidate ( this ) ; coll = null ; setChecked ( false ) ; } public synchronized void addAll ( Collection c ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } try { for ( Iterator i = c . iterator ( ) ; i . hasNext ( ) ; ) { add ( ( ResourceCollection ) i . next ( ) ) ; } } catch ( ClassCastException e ) { throw new BuildException ( e ) ; } } public final synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionContainer ) getCheckedRef ( ) ) . iterator ( ) ; } dieOnCircularReference ( ) ; return new FailFast ( this , cacheCollection ( ) . iterator ( ) ) ; } public synchronized int size ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionContainer ) getCheckedRef ( ) ) . size ( ) ; } dieOnCircularReference ( ) ; return cacheCollection ( ) . size ( ) ; } public synchronized boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionContainer ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } dieOnCircularReference ( ) ; boolean goEarly = true ; for ( Iterator i = rc . iterator ( ) ; goEarly && i . hasNext ( ) ; ) { goEarly &= ( ( ResourceCollection ) i . next ( ) ) . isFilesystemOnly ( ) ; } if ( goEarly ) { return true ; } for ( Iterator i = cacheCollection ( ) . iterator ( ) ; i . hasNext ( ) ; ) { if ( ! ( i . next ( ) instanceof FileResource ) ) { return false ; } } return true ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { for ( Iterator i = rc . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { stk . push ( o ) ; invokeCircularReferenceCheck ( ( DataType ) o , stk , p ) ; stk . pop ( ) ; } } setChecked ( true ) ; } } protected final synchronized List getResourceCollections ( ) { dieOnCircularReference ( ) ; return Collections . unmodifiableList ( rc ) ; } protected abstract Collection getCollection ( ) ; public Object clone ( ) { try { BaseResourceCollectionContainer c = ( BaseResourceCollectionContainer ) super . clone ( ) ; c . rc = new ArrayList ( rc ) ; c . coll = null ; return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public synchronized String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } if ( cacheCollection ( ) . size ( ) == 0 ) { return "" ; } StringBuffer sb = new StringBuffer ( ) ; for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { if ( sb . length ( ) > 0 ) { sb . append ( File . pathSeparatorChar ) ; } sb . append ( i . next ( ) ) ; } return sb . toString ( ) ; } private synchronized Collection cacheCollection ( ) { if ( coll == null || ! isCache ( ) ) { coll = getCollection ( ) ; } return coll ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . FileUtils ; public abstract class AbstractCvsTask extends Task { public static final int DEFAULT_COMPRESSION_LEVEL = 3 ; private static final int MAXIMUM_COMRESSION_LEVEL = 9 ; private Commandline cmd = new Commandline ( ) ; private Vector vecCommandlines = new Vector ( ) ; private String cvsRoot ; private String cvsRsh ; private String cvsPackage ; private String tag ; private static final String DEFAULT_COMMAND = "checkout" ; private String command = null ; private boolean quiet = false ; private boolean reallyquiet = false ; private int compression = 0 ; private boolean noexec = false ; private int port = 0 ; private File passFile = null ; private File dest ; private boolean append = false ; private File output ; private File error ; private boolean failOnError = false ; private ExecuteStreamHandler executeStreamHandler ; private OutputStream outputStream ; private OutputStream errorStream ; public AbstractCvsTask ( ) { super ( ) ; } public void setExecuteStreamHandler ( ExecuteStreamHandler handler ) { this . executeStreamHandler = handler ; } protected ExecuteStreamHandler getExecuteStreamHandler ( ) { if ( this . executeStreamHandler == null ) { setExecuteStreamHandler ( new PumpStreamHandler ( getOutputStream ( ) , getErrorStream ( ) ) ) ; } return this . executeStreamHandler ; } protected void setOutputStream ( OutputStream outputStream ) { this . outputStream = outputStream ; } protected OutputStream getOutputStream ( ) { if ( this . outputStream == null ) { if ( output != null ) { try { setOutputStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else { setOutputStream ( new LogOutputStream ( this , Project . MSG_INFO ) ) ; } } return this . outputStream ; } protected void setErrorStream ( OutputStream errorStream ) { this . errorStream = errorStream ; } protected OutputStream getErrorStream ( ) { if ( this . errorStream == null ) { if ( error != null ) { try { setErrorStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else { setErrorStream ( new LogOutputStream ( this , Project . MSG_WARN ) ) ; } } return this . errorStream ; } protected void runCommand ( Commandline toExecute ) throws BuildException { Environment env = new Environment ( ) ; if ( port > 0 ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_CLIENT_PORT" ) ; var . setValue ( String . valueOf ( port ) ) ; env . addVariable ( var ) ; } if ( passFile == null ) { File defaultPassFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; if ( defaultPassFile . exists ( ) ) { this . setPassfile ( defaultPassFile ) ; } } if ( passFile != null ) { if ( passFile . isFile ( ) && passFile . canRead ( ) ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_PASSFILE" ) ; var . setValue ( String . valueOf ( passFile ) ) ; env . addVariable ( var ) ; log ( "Using cvs passfile: " + String . valueOf ( passFile ) , Project . MSG_VERBOSE ) ; } else if ( ! passFile . canRead ( ) ) { log ( "cvs passfile: " + String . valueOf ( passFile ) + " ignored as it is not readable" , Project . MSG_WARN ) ; } else { log ( "cvs passfile: " + String . valueOf ( passFile ) + " ignored as it is not a file" , Project . MSG_WARN ) ; } } if ( cvsRsh != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_RSH" ) ; var . setValue ( String . valueOf ( cvsRsh ) ) ; env . addVariable ( var ) ; } Execute exe = new Execute ( getExecuteStreamHandler ( ) , null ) ; exe . setAntRun ( getProject ( ) ) ; if ( dest == null ) { dest = getProject ( ) . getBaseDir ( ) ; } if ( ! dest . exists ( ) ) { dest . mkdirs ( ) ; } exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; exe . setEnvironment ( env . getVariables ( ) ) ; try { String actualCommandLine = executeToString ( exe ) ; log ( actualCommandLine , Project . MSG_VERBOSE ) ; int retCode = exe . execute ( ) ; log ( "retCode=" + retCode , Project . MSG_DEBUG ) ; if ( failOnError && Execute . isFailure ( retCode ) ) { throw new BuildException ( "cvs exited with error code " + retCode + StringUtils . LINE_SEP + "Command line was [" + actualCommandLine + "]" , getLocation ( ) ) ; } } catch ( IOException e ) { if ( failOnError ) { throw new BuildException ( e , getLocation ( ) ) ; } log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } catch ( BuildException e ) { if ( failOnError ) { throw ( e ) ; } Throwable t = e . getException ( ) ; if ( t == null ) { t = e ; } log ( "Caught exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e , getLocation ( ) ) ; } log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } public void execute ( ) throws BuildException { String savedCommand = getCommand ( ) ; if ( this . getCommand ( ) == null && vecCommandlines . size ( ) == 0 ) { this . setCommand ( AbstractCvsTask . DEFAULT_COMMAND ) ; } String c = this . getCommand ( ) ; Commandline cloned = null ; if ( c != null ) { cloned = ( Commandline ) cmd . clone ( ) ; cloned . createArgument ( true ) . setLine ( c ) ; this . addConfiguredCommandline ( cloned , true ) ; } try { for ( int i = 0 ; i < vecCommandlines . size ( ) ; i ++ ) { this . runCommand ( ( Commandline ) vecCommandlines . elementAt ( i ) ) ; } } finally { if ( cloned != null ) { removeCommandline ( cloned ) ; } setCommand ( savedCommand ) ; FileUtils . close ( outputStream ) ; FileUtils . close ( errorStream ) ; } } private String executeToString ( Execute execute ) { StringBuffer stringBuffer = new StringBuffer ( Commandline . describeCommand ( execute . getCommandline ( ) ) ) ; String newLine = StringUtils . LINE_SEP ; String [ ] variableArray = execute . getEnvironment ( ) ; if ( variableArray != null ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( newLine ) ; stringBuffer . append ( "environment:" ) ; stringBuffer . append ( newLine ) ; for ( int z = 0 ; z < variableArray . length ; z ++ ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( "\t" ) ; stringBuffer . append ( variableArray [ z ] ) ; } } return stringBuffer . toString ( ) ; } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) { root = null ; } } this . cvsRoot = root ; } public String getCvsRoot ( ) { return this . cvsRoot ; } public void setCvsRsh ( String rsh ) { if ( rsh != null ) { if ( rsh . trim ( ) . equals ( "" ) ) { rsh = null ; } } this . cvsRsh = rsh ; } public String getCvsRsh ( ) { return this . cvsRsh ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return this . port ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public File getPassFile ( ) { return this . passFile ; } public void setDest ( File dest ) { this . dest = dest ; } public File getDest ( ) { return this . dest ; } public void setPackage ( String p ) { this . cvsPackage = p ; } public String getPackage ( ) { return this . cvsPackage ; } public String getTag ( ) { return tag ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { tag = p ; addCommandArgument ( "-r" + p ) ; } } public void addCommandArgument ( String arg ) { this . addCommandArgument ( cmd , arg ) ; } public void addCommandArgument ( Commandline c , String arg ) { c . createArgument ( ) . setValue ( arg ) ; } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-D" ) ; addCommandArgument ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public String getCommand ( ) { return this . command ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setReallyquiet ( boolean q ) { reallyquiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setAppend ( boolean value ) { this . append = value ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } protected void configureCommandline ( Commandline c ) { if ( c == null ) { return ; } c . setExecutable ( "cvs" ) ; if ( cvsPackage != null ) { c . createArgument ( ) . setLine ( cvsPackage ) ; } if ( this . compression > 0 && this . compression <= MAXIMUM_COMRESSION_LEVEL ) { c . createArgument ( true ) . setValue ( "-z" + this . compression ) ; } if ( quiet && ! reallyquiet ) { c . createArgument ( true ) . setValue ( "-q" ) ; } if ( reallyquiet ) { c . createArgument ( true ) . setValue ( "-Q" ) ; } if ( noexec ) { c . createArgument ( true ) . setValue ( "-n" ) ; } if ( cvsRoot != null ) { c . createArgument ( true ) . setLine ( "-d" + cvsRoot ) ; } } protected void removeCommandline ( Commandline c ) { vecCommandlines . removeElement ( c ) ; } public void addConfiguredCommandline ( Commandline c ) { this . addConfiguredCommandline ( c , false ) ; } public void addConfiguredCommandline ( Commandline c , boolean insertAtStart ) { if ( c == null ) { return ; } this . configureCommandline ( c ) ; if ( insertAtStart ) { vecCommandlines . insertElementAt ( c , 0 ) ; } else { vecCommandlines . addElement ( c ) ; } } public void setCompressionLevel ( int level ) { this . compression = level ; } public void setCompression ( boolean usecomp ) { setCompressionLevel ( usecomp ? AbstractCvsTask . DEFAULT_COMPRESSION_LEVEL : 0 ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . AbstractFileSet ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; public class Sync extends Task { private MyCopy myCopy ; private SyncTarget syncTarget ; public void init ( ) throws BuildException { myCopy = new MyCopy ( ) ; configureTask ( myCopy ) ; myCopy . setFiltering ( false ) ; myCopy . setIncludeEmptyDirs ( false ) ; myCopy . setPreserveLastModified ( true ) ; } private void configureTask ( Task helper ) { helper . setProject ( getProject ( ) ) ; helper . setTaskName ( getTaskName ( ) ) ; helper . setOwningTarget ( getOwningTarget ( ) ) ; helper . init ( ) ; } public void execute ( ) throws BuildException { File toDir = myCopy . getToDir ( ) ; Set allFiles = myCopy . nonOrphans ; boolean noRemovalNecessary = ! toDir . exists ( ) || toDir . list ( ) . length < 1 ; log ( "PASS#1: Copying files to " + toDir , Project . MSG_DEBUG ) ; myCopy . execute ( ) ; if ( noRemovalNecessary ) { log ( "NO removing necessary in " + toDir , Project . MSG_DEBUG ) ; return ; } log ( "PASS#2: Removing orphan files from " + toDir , Project . MSG_DEBUG ) ; int [ ] removedFileCount = removeOrphanFiles ( allFiles , toDir ) ; logRemovedCount ( removedFileCount [ 0 ] , "dangling director" , "y" , "ies" ) ; logRemovedCount ( removedFileCount [ 1 ] , "dangling file" , "" , "s" ) ; if ( ! myCopy . getIncludeEmptyDirs ( ) ) { log ( "PASS#3: Removing empty directories from " + toDir , Project . MSG_DEBUG ) ; int removedDirCount = removeEmptyDirectories ( toDir , false ) ; logRemovedCount ( removedDirCount , "empty director" , "y" , "ies" ) ; } } private void logRemovedCount ( int count , String prefix , String singularSuffix , String pluralSuffix ) { File toDir = myCopy . getToDir ( ) ; String what = ( prefix == null ) ? "" : prefix ; what += ( count < 2 ) ? singularSuffix : pluralSuffix ; if ( count > 0 ) { log ( "Removed " + count + " " + what + " from " + toDir , Project . MSG_INFO ) ; } else { log ( "NO " + what + " to remove from " + toDir , Project . MSG_VERBOSE ) ; } } private int [ ] removeOrphanFiles ( Set nonOrphans , File toDir ) { int [ ] removedCount = new int [ ] { 0 , 0 } ; String [ ] excls = ( String [ ] ) nonOrphans . toArray ( new String [ nonOrphans . size ( ) + 1 ] ) ; excls [ nonOrphans . size ( ) ] = "" ; DirectoryScanner ds = null ; if ( syncTarget != null ) { FileSet fs = new FileSet ( ) ; fs . setDir ( toDir ) ; fs . setCaseSensitive ( syncTarget . isCaseSensitive ( ) ) ; fs . setFollowSymlinks ( syncTarget . isFollowSymlinks ( ) ) ; PatternSet ps = syncTarget . mergePatterns ( getProject ( ) ) ; fs . appendExcludes ( ps . getIncludePatterns ( getProject ( ) ) ) ; fs . appendIncludes ( ps . getExcludePatterns ( getProject ( ) ) ) ; fs . setDefaultexcludes ( ! syncTarget . getDefaultexcludes ( ) ) ; FileSelector [ ] s = syncTarget . getSelectors ( getProject ( ) ) ; if ( s . length > 0 ) { NoneSelector ns = new NoneSelector ( ) ; for ( int i = 0 ; i < s . length ; i ++ ) { ns . appendSelector ( s [ i ] ) ; } fs . appendSelector ( ns ) ; } ds = fs . getDirectoryScanner ( getProject ( ) ) ; } else { ds = new DirectoryScanner ( ) ; ds . setBasedir ( toDir ) ; } ds . addExcludes ( excls ) ; ds . scan ( ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( toDir , files [ i ] ) ; log ( "Removing orphan file: " + f , Project . MSG_DEBUG ) ; f . delete ( ) ; ++ removedCount [ 1 ] ; } String [ ] dirs = ds . getIncludedDirectories ( ) ; for ( int i = dirs . length - 1 ; i >= 0 ; -- i ) { File f = new File ( toDir , dirs [ i ] ) ; if ( f . list ( ) . length < 1 ) { log ( "Removing orphan directory: " + f , Project . MSG_DEBUG ) ; f . delete ( ) ; ++ removedCount [ 0 ] ; } } return removedCount ; } private int removeEmptyDirectories ( File dir , boolean removeIfEmpty ) { int removedCount = 0 ; if ( dir . isDirectory ( ) ) { File [ ] children = dir . listFiles ( ) ; for ( int i = 0 ; i < children . length ; ++ i ) { File file = children [ i ] ; if ( file . isDirectory ( ) ) { removedCount += removeEmptyDirectories ( file , true ) ; } } if ( children . length > 0 ) { children = dir . listFiles ( ) ; } if ( children . length < 1 && removeIfEmpty ) { log ( "Removing empty directory: " + dir , Project . MSG_DEBUG ) ; dir . delete ( ) ; ++ removedCount ; } } return removedCount ; } public void setTodir ( File destDir ) { myCopy . setTodir ( destDir ) ; } public void setVerbose ( boolean verbose ) { myCopy . setVerbose ( verbose ) ; } public void setOverwrite ( boolean overwrite ) { myCopy . setOverwrite ( overwrite ) ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { myCopy . setIncludeEmptyDirs ( includeEmpty ) ; } public void setFailOnError ( boolean failonerror ) { myCopy . setFailOnError ( failonerror ) ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { myCopy . add ( rc ) ; } public void setGranularity ( long granularity ) { myCopy . setGranularity ( granularity ) ; } public void addPreserveInTarget ( SyncTarget s ) { if ( syncTarget != null ) { throw new BuildException ( "you must not specify multiple " + "preserveintarget elements." ) ; } syncTarget = s ; } public static class MyCopy extends Copy { private Set nonOrphans = new HashSet ( ) ; public MyCopy ( ) { } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { assertTrue ( "No mapper" , mapperElement == null ) ; super . scan ( fromDir , toDir , files , dirs ) ; for ( int i = 0 ; i < files . length ; ++ i ) { nonOrphans . add ( files [ i ] ) ; } for ( int i = 0 ; i < dirs . length ; ++ i ) { nonOrphans . add ( dirs [ i ] ) ; } } protected Map scan ( Resource [ ] resources , File toDir ) { assertTrue ( "No mapper" , mapperElement == null ) ; Map m = super . scan ( resources , toDir ) ; Iterator iter = m . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { nonOrphans . add ( ( ( Resource ) iter . next ( ) ) . getName ( ) ) ; } return m ; } public File getToDir ( ) { return destDir ; } public boolean getIncludeEmptyDirs ( ) { return includeEmpty ; } protected boolean supportsNonFileResources ( ) { return true ; } } public static class SyncTarget extends AbstractFileSet { public SyncTarget ( ) { super ( ) ; } public void setDir ( File dir ) throws BuildException { throw new BuildException ( "preserveintarget doesn't support the dir " + "attribute" ) ; } } private static void assertTrue ( String message , boolean condition ) { if ( ! condition ) { throw new BuildException ( "Assertion Error: " + message ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . PrintStream ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . BuildLogger ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . SubBuildListener ; import org . apache . tools . ant . util . StringUtils ; public class RecorderEntry implements BuildLogger , SubBuildListener { private String filename = null ; private boolean record = true ; private int loglevel = Project . MSG_INFO ; private PrintStream out = null ; private long targetStartTime = 0L ; private boolean emacsMode = false ; private Project project ; protected RecorderEntry ( String name ) { targetStartTime = System . currentTimeMillis ( ) ; filename = name ; } public String getFilename ( ) { return filename ; } public void setRecordState ( Boolean state ) { if ( state != null ) { flush ( ) ; record = state . booleanValue ( ) ; } } public void buildStarted ( BuildEvent event ) { log ( "> BUILD STARTED" , Project . MSG_DEBUG ) ; } public void buildFinished ( BuildEvent event ) { log ( "< BUILD FINISHED" , Project . MSG_DEBUG ) ; if ( record && out != null ) { Throwable error = event . getException ( ) ; if ( error == null ) { out . println ( StringUtils . LINE_SEP + "BUILD SUCCESSFUL" ) ; } else { out . println ( StringUtils . LINE_SEP + "BUILD FAILED" + StringUtils . LINE_SEP ) ; error . printStackTrace ( out ) ; } } cleanup ( ) ; } public void subBuildFinished ( BuildEvent event ) { if ( event . getProject ( ) == project ) { cleanup ( ) ; } } public void subBuildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { log ( ">> TARGET STARTED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; log ( StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" , Project . MSG_INFO ) ; targetStartTime = System . currentTimeMillis ( ) ; } public void targetFinished ( BuildEvent event ) { log ( "<< TARGET FINISHED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; String time = formatTime ( System . currentTimeMillis ( ) - targetStartTime ) ; log ( event . getTarget ( ) + ":  duration " + time , Project . MSG_VERBOSE ) ; flush ( ) ; } public void taskStarted ( BuildEvent event ) { log ( ">>> TASK STARTED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; } public void taskFinished ( BuildEvent event ) { log ( "<<< TASK FINISHED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; flush ( ) ; } public void messageLogged ( BuildEvent event ) { log ( "--- MESSAGE LOGGED" , Project . MSG_DEBUG ) ; StringBuffer buf = new StringBuffer ( ) ; if ( event . getTask ( ) != null ) { String name = event . getTask ( ) . getTaskName ( ) ; if ( ! emacsMode ) { String label = "[" + name + "] " ; int size = DefaultLogger . LEFT_COLUMN_SIZE - label . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { buf . append ( " " ) ; } buf . append ( label ) ; } } buf . append ( event . getMessage ( ) ) ; log ( buf . toString ( ) , event . getPriority ( ) ) ; } private void log ( String mesg , int level ) { if ( record && ( level <= loglevel ) && out != null ) { out . println ( mesg ) ; } } private void flush ( ) { if ( record && out != null ) { out . flush ( ) ; } } public void setMessageOutputLevel ( int level ) { if ( level >= Project . MSG_ERR && level <= Project . MSG_DEBUG ) { loglevel = level ; } } public void setOutputPrintStream ( PrintStream output ) { closeFile ( ) ; out = output ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void setErrorPrintStream ( PrintStream err ) { setOutputPrintStream ( err ) ; } private static String formatTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; if ( minutes > 0 ) { return Long . toString ( minutes ) + " minute" + ( minutes == 1 ? " " : "s " ) + Long . toString ( seconds % 60 ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } else { return Long . toString ( seconds ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } } public void setProject ( Project project ) { this . project = project ; if ( project != null ) { project . addBuildListener ( this ) ; } } public void cleanup ( ) { closeFile ( ) ; if ( project != null ) { project . removeBuildListener ( this ) ; } project = null ; } void openFile ( boolean append ) throws BuildException { openFileImpl ( append ) ; } void closeFile ( ) { if ( out != null ) { out . close ( ) ; out = null ; } } void reopenFile ( ) throws BuildException { openFileImpl ( true ) ; } private void openFileImpl ( boolean append ) throws BuildException { if ( out == null ) { try { out = new PrintStream ( new FileOutputStream ( filename , append ) ) ; } catch ( IOException ioe ) { throw new BuildException ( "Problems opening file using a " + "recorder entry" , ioe ) ; } } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class Manifest { public static final String ATTRIBUTE_MANIFEST_VERSION = "Manifest-Version" ; public static final String ATTRIBUTE_SIGNATURE_VERSION = "Signature-Version" ; public static final String ATTRIBUTE_NAME = "Name" ; public static final String ATTRIBUTE_FROM = "From" ; public static final String ATTRIBUTE_CLASSPATH = "Class-Path" ; public static final String DEFAULT_MANIFEST_VERSION = "1.0" ; public static final int MAX_LINE_LENGTH = 72 ; public static final int MAX_SECTION_LENGTH = MAX_LINE_LENGTH - 2 ; public static final String EOL = "\r\n" ; public static final String ERROR_FROM_FORBIDDEN = "Manifest attributes should not start " + "with \"" + ATTRIBUTE_FROM + "\" in \"" ; public static final String JAR_ENCODING = "UTF-8" ; public static class Attribute { private static final int MAX_NAME_VALUE_LENGTH = 68 ; private static final int MAX_NAME_LENGTH = 70 ; private String name = null ; private Vector values = new Vector ( ) ; private int currentIndex = 0 ; public Attribute ( ) { } public Attribute ( String line ) throws ManifestException { parse ( line ) ; } public Attribute ( String name , String value ) { this . name = name ; setValue ( value ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( name != null ) { hashCode += getKey ( ) . hashCode ( ) ; } hashCode += values . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Attribute rhsAttribute = ( Attribute ) rhs ; String lhsKey = getKey ( ) ; String rhsKey = rhsAttribute . getKey ( ) ; if ( ( lhsKey == null && rhsKey != null ) || ( lhsKey != null && rhsKey == null ) || ! lhsKey . equals ( rhsKey ) ) { return false ; } return values . equals ( rhsAttribute . values ) ; } public void parse ( String line ) throws ManifestException { int index = line . indexOf ( ": " ) ; if ( index == - 1 ) { throw new ManifestException ( "Manifest line \"" + line + "\" is not valid as it does not " + "contain a name and a value separated by ': ' " ) ; } name = line . substring ( 0 , index ) ; setValue ( line . substring ( index + 2 ) ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String getKey ( ) { if ( name == null ) { return null ; } return name . toLowerCase ( ) ; } public void setValue ( String value ) { if ( currentIndex >= values . size ( ) ) { values . addElement ( value ) ; currentIndex = values . size ( ) - 1 ; } else { values . setElementAt ( value , currentIndex ) ; } } public String getValue ( ) { if ( values . size ( ) == 0 ) { return null ; } String fullValue = "" ; for ( Enumeration e = getValues ( ) ; e . hasMoreElements ( ) ; ) { String value = ( String ) e . nextElement ( ) ; fullValue += value + " " ; } return fullValue . trim ( ) ; } public void addValue ( String value ) { currentIndex ++ ; setValue ( value ) ; } public Enumeration getValues ( ) { return values . elements ( ) ; } public void addContinuation ( String line ) { String currentValue = ( String ) values . elementAt ( currentIndex ) ; setValue ( currentValue + line . substring ( 1 ) ) ; } public void write ( PrintWriter writer ) throws IOException { for ( Enumeration e = getValues ( ) ; e . hasMoreElements ( ) ; ) { writeValue ( writer , ( String ) e . nextElement ( ) ) ; } } private void writeValue ( PrintWriter writer , String value ) throws IOException { String line = null ; int nameLength = name . getBytes ( JAR_ENCODING ) . length ; if ( nameLength > MAX_NAME_VALUE_LENGTH ) { if ( nameLength > MAX_NAME_LENGTH ) { throw new IOException ( "Unable to write manifest line " + name + ": " + value ) ; } writer . print ( name + ": " + EOL ) ; line = " " + value ; } else { line = name + ": " + value ; } while ( line . getBytes ( JAR_ENCODING ) . length > MAX_SECTION_LENGTH ) { int breakIndex = MAX_SECTION_LENGTH ; if ( breakIndex >= line . length ( ) ) { breakIndex = line . length ( ) - 1 ; } String section = line . substring ( 0 , breakIndex ) ; while ( section . getBytes ( JAR_ENCODING ) . length > MAX_SECTION_LENGTH && breakIndex > 0 ) { breakIndex -- ; section = line . substring ( 0 , breakIndex ) ; } if ( breakIndex == 0 ) { throw new IOException ( "Unable to write manifest line " + name + ": " + value ) ; } writer . print ( section + EOL ) ; line = " " + line . substring ( breakIndex ) ; } writer . print ( line + EOL ) ; } } public static class Section { private Vector warnings = new Vector ( ) ; private String name = null ; private Hashtable attributes = new Hashtable ( ) ; private Vector attributeIndex = new Vector ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String read ( BufferedReader reader ) throws ManifestException , IOException { Attribute attribute = null ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null || line . length ( ) == 0 ) { return null ; } if ( line . charAt ( 0 ) == ' ' ) { if ( attribute == null ) { if ( name != null ) { name += line . substring ( 1 ) ; } else { throw new ManifestException ( "Can't start an " + "attribute with a continuation line " + line ) ; } } else { attribute . addContinuation ( line ) ; } } else { attribute = new Attribute ( line ) ; String nameReadAhead = addAttributeAndCheck ( attribute ) ; attribute = getAttribute ( attribute . getKey ( ) ) ; if ( nameReadAhead != null ) { return nameReadAhead ; } } } } public void merge ( Section section ) throws ManifestException { if ( name == null && section . getName ( ) != null || name != null && ! ( name . equalsIgnoreCase ( section . getName ( ) ) ) ) { throw new ManifestException ( "Unable to merge sections " + "with different names" ) ; } Enumeration e = section . getAttributeKeys ( ) ; Attribute classpathAttribute = null ; while ( e . hasMoreElements ( ) ) { String attributeName = ( String ) e . nextElement ( ) ; Attribute attribute = section . getAttribute ( attributeName ) ; if ( attributeName . equalsIgnoreCase ( ATTRIBUTE_CLASSPATH ) ) { if ( classpathAttribute == null ) { classpathAttribute = new Attribute ( ) ; classpathAttribute . setName ( ATTRIBUTE_CLASSPATH ) ; } Enumeration cpe = attribute . getValues ( ) ; while ( cpe . hasMoreElements ( ) ) { String value = ( String ) cpe . nextElement ( ) ; classpathAttribute . addValue ( value ) ; } } else { storeAttribute ( attribute ) ; } } if ( classpathAttribute != null ) { storeAttribute ( classpathAttribute ) ; } Enumeration warnEnum = section . warnings . elements ( ) ; while ( warnEnum . hasMoreElements ( ) ) { warnings . addElement ( warnEnum . nextElement ( ) ) ; } } public void write ( PrintWriter writer ) throws IOException { if ( name != null ) { Attribute nameAttr = new Attribute ( ATTRIBUTE_NAME , name ) ; nameAttr . write ( writer ) ; } Enumeration e = getAttributeKeys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; Attribute attribute = getAttribute ( key ) ; attribute . write ( writer ) ; } writer . print ( EOL ) ; } public Attribute getAttribute ( String attributeName ) { return ( Attribute ) attributes . get ( attributeName . toLowerCase ( ) ) ; } public Enumeration getAttributeKeys ( ) { return attributeIndex . elements ( ) ; } public String getAttributeValue ( String attributeName ) { Attribute attribute = getAttribute ( attributeName . toLowerCase ( ) ) ; if ( attribute == null ) { return null ; } return attribute . getValue ( ) ; } public void removeAttribute ( String attributeName ) { String key = attributeName . toLowerCase ( ) ; attributes . remove ( key ) ; attributeIndex . removeElement ( key ) ; } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { String check = addAttributeAndCheck ( attribute ) ; if ( check != null ) { throw new BuildException ( "Specify the section name using " + "the \"name\" attribute of the <section> element rather " + "than using a \"Name\" manifest attribute" ) ; } } public String addAttributeAndCheck ( Attribute attribute ) throws ManifestException { if ( attribute . getName ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getKey ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { warnings . addElement ( "\"" + ATTRIBUTE_NAME + "\" attributes " + "should not occur in the main section and must be the " + "first element in all other sections: \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; return attribute . getValue ( ) ; } if ( attribute . getKey ( ) . startsWith ( ATTRIBUTE_FROM . toLowerCase ( ) ) ) { warnings . addElement ( ERROR_FROM_FORBIDDEN + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; } else { String attributeKey = attribute . getKey ( ) ; if ( attributeKey . equalsIgnoreCase ( ATTRIBUTE_CLASSPATH ) ) { Attribute classpathAttribute = ( Attribute ) attributes . get ( attributeKey ) ; if ( classpathAttribute == null ) { storeAttribute ( attribute ) ; } else { warnings . addElement ( "Multiple Class-Path attributes " + "are supported but violate the Jar " + "specification and may not be correctly " + "processed in all environments" ) ; Enumeration e = attribute . getValues ( ) ; while ( e . hasMoreElements ( ) ) { String value = ( String ) e . nextElement ( ) ; classpathAttribute . addValue ( value ) ; } } } else if ( attributes . containsKey ( attributeKey ) ) { throw new ManifestException ( "The attribute \"" + attribute . getName ( ) + "\" may not occur more " + "than once in the same section" ) ; } else { storeAttribute ( attribute ) ; } } return null ; } public Object clone ( ) { Section cloned = new Section ( ) ; cloned . setName ( name ) ; Enumeration e = getAttributeKeys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; Attribute attribute = getAttribute ( key ) ; cloned . storeAttribute ( new Attribute ( attribute . getName ( ) , attribute . getValue ( ) ) ) ; } return cloned ; } private void storeAttribute ( Attribute attribute ) { if ( attribute == null ) { return ; } String attributeKey = attribute . getKey ( ) ; attributes . put ( attributeKey , attribute ) ; if ( ! attributeIndex . contains ( attributeKey ) ) { attributeIndex . addElement ( attributeKey ) ; } } public Enumeration getWarnings ( ) { return warnings . elements ( ) ; } public int hashCode ( ) { return attributes . hashCode ( ) ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Section rhsSection = ( Section ) rhs ; return attributes . equals ( rhsSection . attributes ) ; } } private String manifestVersion = DEFAULT_MANIFEST_VERSION ; private Section mainSection = new Section ( ) ; private Hashtable sections = new Hashtable ( ) ; private Vector sectionIndex = new Vector ( ) ; public static Manifest getDefaultManifest ( ) throws BuildException { InputStream in = null ; InputStreamReader insr = null ; try { String defManifest = "/org/apache/tools/ant/defaultManifest.mf" ; in = Manifest . class . getResourceAsStream ( defManifest ) ; if ( in == null ) { throw new BuildException ( "Could not find default manifest: " + defManifest ) ; } try { insr = new InputStreamReader ( in , "UTF-8" ) ; Manifest defaultManifest = new Manifest ( insr ) ; Attribute createdBy = new Attribute ( "Created-By" , System . getProperty ( "java.vm.version" ) + " (" + System . getProperty ( "java.vm.vendor" ) + ")" ) ; defaultManifest . getMainSection ( ) . storeAttribute ( createdBy ) ; return defaultManifest ; } catch ( UnsupportedEncodingException e ) { insr = new InputStreamReader ( in ) ; return new Manifest ( insr ) ; } } catch ( ManifestException e ) { throw new BuildException ( "Default manifest is invalid !!" , e ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read default manifest" , e ) ; } finally { FileUtils . close ( insr ) ; FileUtils . close ( in ) ; } } public Manifest ( ) { manifestVersion = null ; } public Manifest ( Reader r ) throws ManifestException , IOException { BufferedReader reader = new BufferedReader ( r ) ; String nextSectionName = mainSection . read ( reader ) ; String readManifestVersion = mainSection . getAttributeValue ( ATTRIBUTE_MANIFEST_VERSION ) ; if ( readManifestVersion != null ) { manifestVersion = readManifestVersion ; mainSection . removeAttribute ( ATTRIBUTE_MANIFEST_VERSION ) ; } String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) == 0 ) { continue ; } Section section = new Section ( ) ; if ( nextSectionName == null ) { Attribute sectionName = new Attribute ( line ) ; if ( ! sectionName . getName ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { throw new ManifestException ( "Manifest sections should " + "start with a \"" + ATTRIBUTE_NAME + "\" attribute and not \"" + sectionName . getName ( ) + "\"" ) ; } nextSectionName = sectionName . getValue ( ) ; } else { Attribute firstAttribute = new Attribute ( line ) ; section . addAttributeAndCheck ( firstAttribute ) ; } section . setName ( nextSectionName ) ; nextSectionName = section . read ( reader ) ; addConfiguredSection ( section ) ; } } public void addConfiguredSection ( Section section ) throws ManifestException { String sectionName = section . getName ( ) ; if ( sectionName == null ) { throw new BuildException ( "Sections must have a name" ) ; } sections . put ( sectionName , section ) ; if ( ! sectionIndex . contains ( sectionName ) ) { sectionIndex . addElement ( sectionName ) ; } } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { if ( attribute . getKey ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getKey ( ) . equalsIgnoreCase ( ATTRIBUTE_MANIFEST_VERSION ) ) { manifestVersion = attribute . getValue ( ) ; } else { mainSection . addConfiguredAttribute ( attribute ) ; } } public void merge ( Manifest other ) throws ManifestException { merge ( other , false ) ; } public void merge ( Manifest other , boolean overwriteMain ) throws ManifestException { if ( other != null ) { if ( overwriteMain ) { mainSection = ( Section ) other . mainSection . clone ( ) ; } else { mainSection . merge ( other . mainSection ) ; } if ( other . manifestVersion != null ) { manifestVersion = other . manifestVersion ; } Enumeration e = other . getSectionNames ( ) ; while ( e . hasMoreElements ( ) ) { String sectionName = ( String ) e . nextElement ( ) ; Section ourSection = ( Section ) sections . get ( sectionName ) ; Section otherSection = ( Section ) other . sections . get ( sectionName ) ; if ( ourSection == null ) { if ( otherSection != null ) { addConfiguredSection ( ( Section ) otherSection . clone ( ) ) ; } } else { ourSection . merge ( otherSection ) ; } } } } public void write ( PrintWriter writer ) throws IOException { writer . print ( ATTRIBUTE_MANIFEST_VERSION + ": " + manifestVersion + EOL ) ; String signatureVersion = mainSection . getAttributeValue ( ATTRIBUTE_SIGNATURE_VERSION ) ; if ( signatureVersion != null ) { writer . print ( ATTRIBUTE_SIGNATURE_VERSION + ": " + signatureVersion + EOL ) ; mainSection . removeAttribute ( ATTRIBUTE_SIGNATURE_VERSION ) ; } mainSection . write ( writer ) ; if ( signatureVersion != null ) { try { Attribute svAttr = new Attribute ( ATTRIBUTE_SIGNATURE_VERSION , signatureVersion ) ; mainSection . addConfiguredAttribute ( svAttr ) ; } catch ( ManifestException e ) { } } Enumeration e = sectionIndex . elements ( ) ; while ( e . hasMoreElements ( ) ) { String sectionName = ( String ) e . nextElement ( ) ; Section section = getSection ( sectionName ) ; section . write ( writer ) ; } } public String toString ( ) { StringWriter sw = new StringWriter ( ) ; try { write ( new PrintWriter ( sw ) ) ; } catch ( IOException e ) { return null ; } return sw . toString ( ) ; } public Enumeration getWarnings ( ) { Vector warnings = new Vector ( ) ; Enumeration warnEnum = mainSection . getWarnings ( ) ; while ( warnEnum . hasMoreElements ( ) ) { warnings . addElement ( warnEnum . nextElement ( ) ) ; } Enumeration e = sections . elements ( ) ; while ( e . hasMoreElements ( ) ) { Section section = ( Section ) e . nextElement ( ) ; Enumeration e2 = section . getWarnings ( ) ; while ( e2 . hasMoreElements ( ) ) { warnings . addElement ( e2 . nextElement ( ) ) ; } } return warnings . elements ( ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( manifestVersion != null ) { hashCode += manifestVersion . hashCode ( ) ; } hashCode += mainSection . hashCode ( ) ; hashCode += sections . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Manifest rhsManifest = ( Manifest ) rhs ; if ( manifestVersion == null ) { if ( rhsManifest . manifestVersion != null ) { return false ; } } else if ( ! manifestVersion . equals ( rhsManifest . manifestVersion ) ) { return false ; } if ( ! mainSection . equals ( rhsManifest . mainSection ) ) { return false ; } return sections . equals ( rhsManifest . sections ) ; } public String getManifestVersion ( ) { return manifestVersion ; } public Section getMainSection ( ) { return mainSection ; } public Section getSection ( String name ) { return ( Section ) sections . get ( name ) ; } public Enumeration getSectionNames ( ) { return sectionIndex . elements ( ) ; } } 	1
package org . apache . tools . bzip2 ; import java . io . InputStream ; import java . io . IOException ; public class CBZip2InputStream extends InputStream implements BZip2Constants { private static void reportCRCError ( ) throws IOException { System . err . println ( "BZip2 CRC error" ) ; } private void makeMaps ( ) { final boolean [ ] inUse = this . data . inUse ; final byte [ ] seqToUnseq = this . data . seqToUnseq ; int nInUseShadow = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) seqToUnseq [ nInUseShadow ++ ] = ( byte ) i ; } this . nInUse = nInUseShadow ; } private int last ; private int origPtr ; private int blockSize100k ; private boolean blockRandomised ; private int bsBuff ; private int bsLive ; private final CRC crc = new CRC ( ) ; private int nInUse ; private InputStream in ; private int currentChar = - 1 ; private static final int EOF = 0 ; private static final int START_BLOCK_STATE = 1 ; private static final int RAND_PART_A_STATE = 2 ; private static final int RAND_PART_B_STATE = 3 ; private static final int RAND_PART_C_STATE = 4 ; private static final int NO_RAND_PART_A_STATE = 5 ; private static final int NO_RAND_PART_B_STATE = 6 ; private static final int NO_RAND_PART_C_STATE = 7 ; private int currentState = START_BLOCK_STATE ; private int storedBlockCRC , storedCombinedCRC ; private int computedBlockCRC , computedCombinedCRC ; private int su_count ; private int su_ch2 ; private int su_chPrev ; private int su_i2 ; private int su_j2 ; private int su_rNToGo ; private int su_rTPos ; private int su_tPos ; private char su_z ; private CBZip2InputStream . Data data ; public CBZip2InputStream ( final InputStream in ) throws IOException { super ( ) ; this . in = in ; init ( ) ; } public int read ( ) throws IOException { if ( this . in != null ) { return read0 ( ) ; } else { throw new IOException ( "stream closed" ) ; } } public int read ( final byte [ ] dest , final int offs , final int len ) throws IOException { if ( offs < 0 ) { throw new IndexOutOfBoundsException ( "offs(" + offs + ") < 0." ) ; } if ( len < 0 ) { throw new IndexOutOfBoundsException ( "len(" + len + ") < 0." ) ; } if ( offs + len > dest . length ) { throw new IndexOutOfBoundsException ( "offs(" + offs + ") + len(" + len + ") > dest.length(" + dest . length + ")." ) ; } if ( this . in == null ) { throw new IOException ( "stream closed" ) ; } final int hi = offs + len ; int destOffs = offs ; for ( int b ; ( destOffs < hi ) && ( ( b = read0 ( ) ) >= 0 ) ; ) { dest [ destOffs ++ ] = ( byte ) b ; } return ( destOffs == offs ) ? - 1 : ( destOffs - offs ) ; } private int read0 ( ) throws IOException { final int retChar = this . currentChar ; switch ( this . currentState ) { case EOF : return - 1 ; case START_BLOCK_STATE : throw new IllegalStateException ( ) ; case RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case RAND_PART_B_STATE : setupRandPartB ( ) ; break ; case RAND_PART_C_STATE : setupRandPartC ( ) ; break ; case NO_RAND_PART_A_STATE : throw new IllegalStateException ( ) ; case NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; break ; case NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; break ; default : throw new IllegalStateException ( ) ; } return retChar ; } private void init ( ) throws IOException { int magic2 = this . in . read ( ) ; if ( magic2 != 'h' ) { throw new IOException ( "Stream is not BZip2 formatted: expected 'h'" + " as first byte but got '" + ( char ) magic2 + "'" ) ; } int blockSize = this . in . read ( ) ; if ( ( blockSize < '1' ) || ( blockSize > '9' ) ) { throw new IOException ( "Stream is not BZip2 formatted: illegal " + "blocksize " + ( char ) blockSize ) ; } this . blockSize100k = blockSize - '0' ; initBlock ( ) ; setupBlock ( ) ; } private void initBlock ( ) throws IOException { char magic0 = bsGetUByte ( ) ; char magic1 = bsGetUByte ( ) ; char magic2 = bsGetUByte ( ) ; char magic3 = bsGetUByte ( ) ; char magic4 = bsGetUByte ( ) ; char magic5 = bsGetUByte ( ) ; if ( magic0 == 0x17 && magic1 == 0x72 && magic2 == 0x45 && magic3 == 0x38 && magic4 == 0x50 && magic5 == 0x90 ) { complete ( ) ; } else if ( magic0 != 0x31 || magic1 != 0x41 || magic2 != 0x59 || magic3 != 0x26 || magic4 != 0x53 || magic5 != 0x59 ) { this . currentState = EOF ; throw new IOException ( "bad block header" ) ; } else { this . storedBlockCRC = bsGetInt ( ) ; this . blockRandomised = bsR ( 1 ) == 1 ; if ( this . data == null ) { this . data = new Data ( this . blockSize100k ) ; } getAndMoveToFrontDecode ( ) ; this . crc . initialiseCRC ( ) ; this . currentState = START_BLOCK_STATE ; } } private void endBlock ( ) throws IOException { this . computedBlockCRC = this . crc . getFinalCRC ( ) ; if ( this . storedBlockCRC != this . computedBlockCRC ) { this . computedCombinedCRC = ( this . storedCombinedCRC << 1 ) | ( this . storedCombinedCRC > > > 31 ) ; this . computedCombinedCRC ^= this . storedBlockCRC ; reportCRCError ( ) ; } this . computedCombinedCRC = ( this . computedCombinedCRC << 1 ) | ( this . computedCombinedCRC > > > 31 ) ; this . computedCombinedCRC ^= this . computedBlockCRC ; } private void complete ( ) throws IOException { this . storedCombinedCRC = bsGetInt ( ) ; this . currentState = EOF ; this . data = null ; if ( this . storedCombinedCRC != this . computedCombinedCRC ) { reportCRCError ( ) ; } } public void close ( ) throws IOException { InputStream inShadow = this . in ; if ( inShadow != null ) { try { if ( inShadow != System . in ) { inShadow . close ( ) ; } } finally { this . data = null ; this . in = null ; } } } private int bsR ( final int n ) throws IOException { int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; if ( bsLiveShadow < n ) { final InputStream inShadow = this . in ; do { int thech = inShadow . read ( ) ; if ( thech < 0 ) { throw new IOException ( "unexpected end of stream" ) ; } bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; } while ( bsLiveShadow < n ) ; this . bsBuff = bsBuffShadow ; } this . bsLive = bsLiveShadow - n ; return ( bsBuffShadow > > ( bsLiveShadow - n ) ) & ( ( 1 << n ) - 1 ) ; } private boolean bsGetBit ( ) throws IOException { int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; if ( bsLiveShadow < 1 ) { int thech = this . in . read ( ) ; if ( thech < 0 ) { throw new IOException ( "unexpected end of stream" ) ; } bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; this . bsBuff = bsBuffShadow ; } this . bsLive = bsLiveShadow - 1 ; return ( ( bsBuffShadow > > ( bsLiveShadow - 1 ) ) & 1 ) != 0 ; } private char bsGetUByte ( ) throws IOException { return ( char ) bsR ( 8 ) ; } private int bsGetInt ( ) throws IOException { return ( ( ( ( ( bsR ( 8 ) << 8 ) | bsR ( 8 ) ) << 8 ) | bsR ( 8 ) ) << 8 ) | bsR ( 8 ) ; } private static void hbCreateDecodeTables ( final int [ ] limit , final int [ ] base , final int [ ] perm , final char [ ] length , final int minLen , final int maxLen , final int alphaSize ) { for ( int i = minLen , pp = 0 ; i <= maxLen ; i ++ ) { for ( int j = 0 ; j < alphaSize ; j ++ ) { if ( length [ j ] == i ) { perm [ pp ++ ] = j ; } } } for ( int i = MAX_CODE_LEN ; -- i > 0 ; ) { base [ i ] = 0 ; limit [ i ] = 0 ; } for ( int i = 0 ; i < alphaSize ; i ++ ) { base [ length [ i ] + 1 ] ++ ; } for ( int i = 1 , b = base [ 0 ] ; i < MAX_CODE_LEN ; i ++ ) { b += base [ i ] ; base [ i ] = b ; } for ( int i = minLen , vec = 0 , b = base [ i ] ; i <= maxLen ; i ++ ) { final int nb = base [ i + 1 ] ; vec += nb - b ; b = nb ; limit [ i ] = vec - 1 ; vec <<= 1 ; } for ( int i = minLen + 1 ; i <= maxLen ; i ++ ) { base [ i ] = ( ( limit [ i - 1 ] + 1 ) << 1 ) - base [ i ] ; } } private void recvDecodingTables ( ) throws IOException { final Data dataShadow = this . data ; final boolean [ ] inUse = dataShadow . inUse ; final byte [ ] pos = dataShadow . recvDecodingTables_pos ; final byte [ ] selector = dataShadow . selector ; final byte [ ] selectorMtf = dataShadow . selectorMtf ; int inUse16 = 0 ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( bsGetBit ( ) ) { inUse16 |= 1 << i ; } } for ( int i = 256 ; -- i >= 0 ; ) { inUse [ i ] = false ; } for ( int i = 0 ; i < 16 ; i ++ ) { if ( ( inUse16 & ( 1 << i ) ) != 0 ) { final int i16 = i << 4 ; for ( int j = 0 ; j < 16 ; j ++ ) { if ( bsGetBit ( ) ) { inUse [ i16 + j ] = true ; } } } } makeMaps ( ) ; final int alphaSize = this . nInUse + 2 ; final int nGroups = bsR ( 3 ) ; final int nSelectors = bsR ( 15 ) ; for ( int i = 0 ; i < nSelectors ; i ++ ) { int j = 0 ; while ( bsGetBit ( ) ) { j ++ ; } selectorMtf [ i ] = ( byte ) j ; } for ( int v = nGroups ; -- v >= 0 ; ) { pos [ v ] = ( byte ) v ; } for ( int i = 0 ; i < nSelectors ; i ++ ) { int v = selectorMtf [ i ] & 0xff ; final byte tmp = pos [ v ] ; while ( v > 0 ) { pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } final char [ ] [ ] len = dataShadow . temp_charArray2d ; for ( int t = 0 ; t < nGroups ; t ++ ) { int curr = bsR ( 5 ) ; final char [ ] len_t = len [ t ] ; for ( int i = 0 ; i < alphaSize ; i ++ ) { while ( bsGetBit ( ) ) { curr += bsGetBit ( ) ? - 1 : 1 ; } len_t [ i ] = ( char ) curr ; } } createHuffmanDecodingTables ( alphaSize , nGroups ) ; } private void createHuffmanDecodingTables ( final int alphaSize , final int nGroups ) { final Data dataShadow = this . data ; final char [ ] [ ] len = dataShadow . temp_charArray2d ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; for ( int t = 0 ; t < nGroups ; t ++ ) { int minLen = 32 ; int maxLen = 0 ; final char [ ] len_t = len [ t ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { final char lent = len_t [ i ] ; if ( lent > maxLen ) { maxLen = lent ; } if ( lent < minLen ) { minLen = lent ; } } hbCreateDecodeTables ( limit [ t ] , base [ t ] , perm [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; minLens [ t ] = minLen ; } } private void getAndMoveToFrontDecode ( ) throws IOException { this . origPtr = bsR ( 24 ) ; recvDecodingTables ( ) ; final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final byte [ ] ll8 = dataShadow . ll8 ; final int [ ] unzftab = dataShadow . unzftab ; final byte [ ] selector = dataShadow . selector ; final byte [ ] seqToUnseq = dataShadow . seqToUnseq ; final char [ ] yy = dataShadow . getAndMoveToFrontDecode_yy ; final int [ ] minLens = dataShadow . minLens ; final int [ ] [ ] limit = dataShadow . limit ; final int [ ] [ ] base = dataShadow . base ; final int [ ] [ ] perm = dataShadow . perm ; final int limitLast = this . blockSize100k * 100000 ; for ( int i = 256 ; -- i >= 0 ; ) { yy [ i ] = ( char ) i ; unzftab [ i ] = 0 ; } int groupNo = 0 ; int groupPos = G_SIZE - 1 ; final int eob = this . nInUse + 1 ; int nextSym = getAndMoveToFrontDecode0 ( 0 ) ; int bsBuffShadow = this . bsBuff ; int bsLiveShadow = this . bsLive ; int lastShadow = - 1 ; int zt = selector [ groupNo ] & 0xff ; int [ ] base_zt = base [ zt ] ; int [ ] limit_zt = limit [ zt ] ; int [ ] perm_zt = perm [ zt ] ; int minLens_zt = minLens [ zt ] ; while ( nextSym != eob ) { if ( ( nextSym == RUNA ) || ( nextSym == RUNB ) ) { int s = - 1 ; for ( int n = 1 ; true ; n <<= 1 ) { if ( nextSym == RUNA ) { s += n ; } else if ( nextSym == RUNB ) { s += n << 1 ; } else { break ; } if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } final byte ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch & 0xff ] += s + 1 ; while ( s -- >= 0 ) { ll8 [ ++ lastShadow ] = ch ; } if ( lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } } else { if ( ++ lastShadow >= limitLast ) { throw new IOException ( "block overrun" ) ; } final char tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] & 0xff ] ++ ; ll8 [ lastShadow ] = seqToUnseq [ tmp ] ; if ( nextSym <= 16 ) { for ( int j = nextSym - 1 ; j > 0 ; ) { yy [ j ] = yy [ -- j ] ; } } else { System . arraycopy ( yy , 0 , yy , 1 , nextSym - 1 ) ; } yy [ 0 ] = tmp ; if ( groupPos == 0 ) { groupPos = G_SIZE - 1 ; zt = selector [ ++ groupNo ] & 0xff ; base_zt = base [ zt ] ; limit_zt = limit [ zt ] ; perm_zt = perm [ zt ] ; minLens_zt = minLens [ zt ] ; } else { groupPos -- ; } int zn = minLens_zt ; while ( bsLiveShadow < zn ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } int zvec = ( bsBuffShadow > > ( bsLiveShadow - zn ) ) & ( ( 1 << zn ) - 1 ) ; bsLiveShadow -= zn ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } nextSym = perm_zt [ zvec - base_zt [ zn ] ] ; } } this . last = lastShadow ; this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; } private int getAndMoveToFrontDecode0 ( final int groupNo ) throws IOException { final InputStream inShadow = this . in ; final Data dataShadow = this . data ; final int zt = dataShadow . selector [ groupNo ] & 0xff ; final int [ ] limit_zt = dataShadow . limit [ zt ] ; int zn = dataShadow . minLens [ zt ] ; int zvec = bsR ( zn ) ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; while ( zvec > limit_zt [ zn ] ) { zn ++ ; while ( bsLiveShadow < 1 ) { final int thech = inShadow . read ( ) ; if ( thech >= 0 ) { bsBuffShadow = ( bsBuffShadow << 8 ) | thech ; bsLiveShadow += 8 ; continue ; } else { throw new IOException ( "unexpected end of stream" ) ; } } bsLiveShadow -- ; zvec = ( zvec << 1 ) | ( ( bsBuffShadow > > bsLiveShadow ) & 1 ) ; } this . bsLive = bsLiveShadow ; this . bsBuff = bsBuffShadow ; return dataShadow . perm [ zt ] [ zvec - dataShadow . base [ zt ] [ zn ] ] ; } private void setupBlock ( ) throws IOException { if ( this . data == null ) { return ; } final int [ ] cftab = this . data . cftab ; final int [ ] tt = this . data . initTT ( this . last + 1 ) ; final byte [ ] ll8 = this . data . ll8 ; cftab [ 0 ] = 0 ; System . arraycopy ( this . data . unzftab , 0 , cftab , 1 , 256 ) ; for ( int i = 1 , c = cftab [ 0 ] ; i <= 256 ; i ++ ) { c += cftab [ i ] ; cftab [ i ] = c ; } for ( int i = 0 , lastShadow = this . last ; i <= lastShadow ; i ++ ) { tt [ cftab [ ll8 [ i ] & 0xff ] ++ ] = i ; } if ( ( this . origPtr < 0 ) || ( this . origPtr >= tt . length ) ) { throw new IOException ( "stream corrupted" ) ; } this . su_tPos = tt [ this . origPtr ] ; this . su_count = 0 ; this . su_i2 = 0 ; this . su_ch2 = 256 ; if ( this . blockRandomised ) { this . su_rNToGo = 0 ; this . su_rTPos = 0 ; setupRandPartA ( ) ; } else { setupNoRandPartA ( ) ; } } private void setupRandPartA ( ) throws IOException { if ( this . su_i2 <= this . last ) { this . su_chPrev = this . su_ch2 ; int su_ch2Shadow = this . data . ll8 [ this . su_tPos ] & 0xff ; this . su_tPos = this . data . tt [ this . su_tPos ] ; if ( this . su_rNToGo == 0 ) { this . su_rNToGo = BZip2Constants . rNums [ this . su_rTPos ] - 1 ; if ( ++ this . su_rTPos == 512 ) { this . su_rTPos = 0 ; } } else { this . su_rNToGo -- ; } this . su_ch2 = su_ch2Shadow ^= ( this . su_rNToGo == 1 ) ? 1 : 0 ; this . su_i2 ++ ; this . currentChar = su_ch2Shadow ; this . currentState = RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; } else { endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } } private void setupNoRandPartA ( ) throws IOException { if ( this . su_i2 <= this . last ) { this . su_chPrev = this . su_ch2 ; int su_ch2Shadow = this . data . ll8 [ this . su_tPos ] & 0xff ; this . su_ch2 = su_ch2Shadow ; this . su_tPos = this . data . tt [ this . su_tPos ] ; this . su_i2 ++ ; this . currentChar = su_ch2Shadow ; this . currentState = NO_RAND_PART_B_STATE ; this . crc . updateCRC ( su_ch2Shadow ) ; } else { this . currentState = NO_RAND_PART_A_STATE ; endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } } private void setupRandPartB ( ) throws IOException { if ( this . su_ch2 != this . su_chPrev ) { this . currentState = RAND_PART_A_STATE ; this . su_count = 1 ; setupRandPartA ( ) ; } else if ( ++ this . su_count >= 4 ) { this . su_z = ( char ) ( this . data . ll8 [ this . su_tPos ] & 0xff ) ; this . su_tPos = this . data . tt [ this . su_tPos ] ; if ( this . su_rNToGo == 0 ) { this . su_rNToGo = BZip2Constants . rNums [ this . su_rTPos ] - 1 ; if ( ++ this . su_rTPos == 512 ) { this . su_rTPos = 0 ; } } else { this . su_rNToGo -- ; } this . su_j2 = 0 ; this . currentState = RAND_PART_C_STATE ; if ( this . su_rNToGo == 1 ) { this . su_z ^= 1 ; } setupRandPartC ( ) ; } else { this . currentState = RAND_PART_A_STATE ; setupRandPartA ( ) ; } } private void setupRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { this . currentChar = this . su_ch2 ; this . crc . updateCRC ( this . su_ch2 ) ; this . su_j2 ++ ; } else { this . currentState = RAND_PART_A_STATE ; this . su_i2 ++ ; this . su_count = 0 ; setupRandPartA ( ) ; } } private void setupNoRandPartB ( ) throws IOException { if ( this . su_ch2 != this . su_chPrev ) { this . su_count = 1 ; setupNoRandPartA ( ) ; } else if ( ++ this . su_count >= 4 ) { this . su_z = ( char ) ( this . data . ll8 [ this . su_tPos ] & 0xff ) ; this . su_tPos = this . data . tt [ this . su_tPos ] ; this . su_j2 = 0 ; setupNoRandPartC ( ) ; } else { setupNoRandPartA ( ) ; } } private void setupNoRandPartC ( ) throws IOException { if ( this . su_j2 < this . su_z ) { int su_ch2Shadow = this . su_ch2 ; this . currentChar = su_ch2Shadow ; this . crc . updateCRC ( su_ch2Shadow ) ; this . su_j2 ++ ; this . currentState = NO_RAND_PART_C_STATE ; } else { this . su_i2 ++ ; this . su_count = 0 ; setupNoRandPartA ( ) ; } } private static final class Data extends Object { final boolean [ ] inUse = new boolean [ 256 ] ; final byte [ ] seqToUnseq = new byte [ 256 ] ; final byte [ ] selector = new byte [ MAX_SELECTORS ] ; final byte [ ] selectorMtf = new byte [ MAX_SELECTORS ] ; final int [ ] unzftab = new int [ 256 ] ; final int [ ] [ ] limit = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] [ ] base = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] [ ] perm = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] minLens = new int [ N_GROUPS ] ; final int [ ] cftab = new int [ 257 ] ; final char [ ] getAndMoveToFrontDecode_yy = new char [ 256 ] ; final char [ ] [ ] temp_charArray2d = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final byte [ ] recvDecodingTables_pos = new byte [ N_GROUPS ] ; int [ ] tt ; byte [ ] ll8 ; Data ( int blockSize100k ) { super ( ) ; this . ll8 = new byte [ blockSize100k * BZip2Constants . baseBlockSize ] ; } final int [ ] initTT ( int length ) { int [ ] ttShadow = this . tt ; if ( ( ttShadow == null ) || ( ttShadow . length < length ) ) { this . tt = ttShadow = new int [ length ] ; } return ttShadow ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . ExecTask ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class BorlandDeploymentTool extends GenericDeploymentTool implements ExecuteStreamHandler { public static final String PUBLICID_BORLAND_EJB = "-//Inprise Corporation//DTD Enterprise JavaBeans 1.1//EN" ; protected static final String DEFAULT_BAS45_EJB11_DTD_LOCATION = "/com/inprise/j2ee/xml/dtds/ejb-jar.dtd" ; protected static final String DEFAULT_BAS_DTD_LOCATION = "/com/inprise/j2ee/xml/dtds/ejb-inprise.dtd" ; protected static final String BAS_DD = "ejb-inprise.xml" ; protected static final String BES_DD = "ejb-borland.xml" ; protected static final String JAVA2IIOP = "java2iiop" ; protected static final String VERIFY = "com.inprise.ejb.util.Verify" ; private String jarSuffix = "-ejb.jar" ; private String borlandDTD ; private boolean java2iiopdebug = false ; private String java2iioparams = null ; private boolean generateclient = false ; static final int BES = 5 ; static final int BAS = 4 ; private int version = BAS ; private boolean verify = true ; private String verifyArgs = "" ; private Hashtable genfiles = new Hashtable ( ) ; public void setDebug ( boolean debug ) { this . java2iiopdebug = debug ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public void setSuffix ( String inString ) { this . jarSuffix = inString ; } public void setVerifyArgs ( String args ) { this . verifyArgs = args ; } public void setBASdtd ( String inString ) { this . borlandDTD = inString ; } public void setGenerateclient ( boolean b ) { this . generateclient = b ; } public void setVersion ( int version ) { this . version = version ; } public void setJava2iiopParams ( String params ) { this . java2iioparams = params ; } protected DescriptorHandler getBorlandDescriptorHandler ( final File srcDir ) { DescriptorHandler handler = new DescriptorHandler ( getTask ( ) , srcDir ) { protected void processElement ( ) { if ( currentElement . equals ( "type-storage" ) ) { String fileNameWithMETA = currentText ; String fileName = fileNameWithMETA . substring ( META_DIR . length ( ) , fileNameWithMETA . length ( ) ) ; File descriptorFile = new File ( srcDir , fileName ) ; ejbFiles . put ( fileNameWithMETA , descriptorFile ) ; } } } ; handler . registerDTD ( PUBLICID_BORLAND_EJB , borlandDTD == null ? DEFAULT_BAS_DTD_LOCATION : borlandDTD ) ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; handler . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return handler ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { if ( ! ( version == BES || version == BAS ) ) { throw new BuildException ( "version " + version + " is not supported" ) ; } String dd = ( version == BES ? BES_DD : BAS_DD ) ; log ( "vendor file : " + ddPrefix + dd , Project . MSG_DEBUG ) ; File borlandDD = new File ( getConfig ( ) . descriptorDir , ddPrefix + dd ) ; if ( borlandDD . exists ( ) ) { log ( "Borland specific file found " + borlandDD , Project . MSG_VERBOSE ) ; ejbFiles . put ( META_DIR + dd , borlandDD ) ; } else { log ( "Unable to locate borland deployment descriptor. " + "It was expected to be in " + borlandDD . getPath ( ) , Project . MSG_WARN ) ; return ; } } File getVendorOutputJarFile ( String baseName ) { return new File ( getDestDir ( ) , baseName + jarSuffix ) ; } private void verifyBorlandJar ( File sourceJar ) { if ( version == BAS ) { verifyBorlandJarV4 ( sourceJar ) ; return ; } if ( version == BES ) { verifyBorlandJarV5 ( sourceJar ) ; return ; } log ( "verify jar skipped because the version is invalid [" + version + "]" , Project . MSG_WARN ) ; } private void verifyBorlandJarV5 ( File sourceJar ) { log ( "verify BES " + sourceJar , Project . MSG_INFO ) ; try { ExecTask execTask = null ; execTask = new ExecTask ( getTask ( ) ) ; execTask . setDir ( new File ( "." ) ) ; execTask . setExecutable ( "iastool" ) ; if ( getCombinedClasspath ( ) != null ) { execTask . createArg ( ) . setValue ( "-VBJclasspath" ) ; execTask . createArg ( ) . setValue ( getCombinedClasspath ( ) . toString ( ) ) ; } if ( java2iiopdebug ) { execTask . createArg ( ) . setValue ( "-debug" ) ; } execTask . createArg ( ) . setValue ( "-verify" ) ; execTask . createArg ( ) . setValue ( "-src" ) ; execTask . createArg ( ) . setValue ( sourceJar . getPath ( ) ) ; log ( "Calling iastool" , Project . MSG_VERBOSE ) ; execTask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling generateclient Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } private void verifyBorlandJarV4 ( File sourceJar ) { org . apache . tools . ant . taskdefs . Java javaTask = null ; log ( "verify BAS " + sourceJar , Project . MSG_INFO ) ; try { String args = verifyArgs ; args += " " + sourceJar . getPath ( ) ; javaTask = new Java ( getTask ( ) ) ; javaTask . setTaskName ( "verify" ) ; javaTask . setClassname ( VERIFY ) ; Commandline . Argument arguments = javaTask . createArg ( ) ; arguments . setLine ( args ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath != null ) { javaTask . setClasspath ( classpath ) ; javaTask . setFork ( true ) ; } log ( "Calling " + VERIFY + " for " + sourceJar . toString ( ) , Project . MSG_VERBOSE ) ; javaTask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling " + VERIFY + " Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } private void generateClient ( File sourceJar ) { getTask ( ) . getProject ( ) . addTaskDefinition ( "internal_bas_generateclient" , org . apache . tools . ant . taskdefs . optional . ejb . BorlandGenerateClient . class ) ; org . apache . tools . ant . taskdefs . optional . ejb . BorlandGenerateClient gentask = null ; log ( "generate client for " + sourceJar , Project . MSG_INFO ) ; try { Project project = getTask ( ) . getProject ( ) ; gentask = ( BorlandGenerateClient ) project . createTask ( "internal_bas_generateclient" ) ; gentask . setEjbjar ( sourceJar ) ; gentask . setDebug ( java2iiopdebug ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath != null ) { gentask . setClasspath ( classpath ) ; } gentask . setVersion ( version ) ; gentask . setTaskName ( "generate client" ) ; gentask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling " + VERIFY + " Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } private void buildBorlandStubs ( Iterator ithomes ) { Execute execTask = null ; execTask = new Execute ( this ) ; Project project = getTask ( ) . getProject ( ) ; execTask . setAntRun ( project ) ; execTask . setWorkingDirectory ( project . getBaseDir ( ) ) ; Commandline commandline = new Commandline ( ) ; commandline . setExecutable ( JAVA2IIOP ) ; if ( java2iiopdebug ) { commandline . createArgument ( ) . setValue ( "-VBJdebug" ) ; } commandline . createArgument ( ) . setValue ( "-VBJclasspath" ) ; commandline . createArgument ( ) . setPath ( getCombinedClasspath ( ) ) ; commandline . createArgument ( ) . setValue ( "-list_files" ) ; commandline . createArgument ( ) . setValue ( "-no_tie" ) ; if ( java2iioparams != null ) { log ( "additional  " + java2iioparams + " to java2iiop " , 0 ) ; commandline . createArgument ( ) . setValue ( java2iioparams ) ; } commandline . createArgument ( ) . setValue ( "-root_dir" ) ; commandline . createArgument ( ) . setValue ( getConfig ( ) . srcDir . getAbsolutePath ( ) ) ; commandline . createArgument ( ) . setValue ( "-compile" ) ; while ( ithomes . hasNext ( ) ) { commandline . createArgument ( ) . setValue ( ithomes . next ( ) . toString ( ) ) ; } try { log ( "Calling java2iiop" , Project . MSG_VERBOSE ) ; log ( commandline . describeCommand ( ) , Project . MSG_DEBUG ) ; execTask . setCommandline ( commandline . getCommandline ( ) ) ; int result = execTask . execute ( ) ; if ( Execute . isFailure ( result ) ) { String msg = "Failed executing java2iiop (ret code is " + result + ")" ; throw new BuildException ( msg , getTask ( ) . getLocation ( ) ) ; } } catch ( java . io . IOException e ) { log ( "java2iiop exception :" + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( e , getTask ( ) . getLocation ( ) ) ; } } protected void writeJar ( String baseName , File jarFile , Hashtable files , String publicId ) throws BuildException { Vector homes = new Vector ( ) ; Iterator it = files . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { String clazz = ( String ) it . next ( ) ; if ( clazz . endsWith ( "Home.class" ) ) { String home = toClass ( clazz ) ; homes . add ( home ) ; log ( " Home " + home , Project . MSG_VERBOSE ) ; } } buildBorlandStubs ( homes . iterator ( ) ) ; files . putAll ( genfiles ) ; super . writeJar ( baseName , jarFile , files , publicId ) ; if ( verify ) { verifyBorlandJar ( jarFile ) ; } if ( generateclient ) { generateClient ( jarFile ) ; } } private String toClass ( String filename ) { String classname = filename . substring ( 0 , filename . lastIndexOf ( ".class" ) ) ; classname = classname . replace ( '\\' , '.' ) ; return classname ; } private String toClassFile ( String filename ) { String classfile = filename . substring ( 0 , filename . lastIndexOf ( ".java" ) ) ; classfile = classfile + ".class" ; return classfile ; } public void start ( ) throws IOException { } public void stop ( ) { } public void setProcessInputStream ( OutputStream param1 ) throws IOException { } public void setProcessOutputStream ( InputStream is ) throws IOException { try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String javafile ; while ( ( javafile = reader . readLine ( ) ) != null ) { if ( javafile . endsWith ( ".java" ) ) { String classfile = toClassFile ( javafile ) ; String key = classfile . substring ( getConfig ( ) . srcDir . getAbsolutePath ( ) . length ( ) + 1 ) ; genfiles . put ( key , new File ( classfile ) ) ; } } reader . close ( ) ; } catch ( Exception e ) { String msg = "Exception while parsing  java2iiop output. Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } public void setProcessErrorStream ( InputStream is ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String s = reader . readLine ( ) ; if ( s != null ) { log ( "[java2iiop] " + s , Project . MSG_ERR ) ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . unix ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; public abstract class AbstractAccessTask extends org . apache . tools . ant . taskdefs . ExecuteOn { public AbstractAccessTask ( ) { super . setParallel ( true ) ; super . setSkipEmptyFilesets ( true ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setFile ( src ) ; addFileset ( fs ) ; } public void setCommand ( Commandline cmdl ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the command attribute" , getLocation ( ) ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the " + "skipemptyfileset attribute" , getLocation ( ) ) ; } public void setAddsourcefile ( boolean b ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the addsourcefile attribute" , getLocation ( ) ) ; } protected boolean isValidOs ( ) { return Os . isFamily ( "unix" ) && super . isValidOs ( ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . extension ; import java . util . ArrayList ; import java . util . Arrays ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Reference ; public class ExtensionSet extends DataType { private final ArrayList extensions = new ArrayList ( ) ; private final ArrayList extensionsFilesets = new ArrayList ( ) ; public void addExtension ( final ExtensionAdapter extensionAdapter ) { extensions . add ( extensionAdapter ) ; } public void addLibfileset ( final LibFileSet fileSet ) { extensionsFilesets . add ( fileSet ) ; } public void addFileset ( final FileSet fileSet ) { extensionsFilesets . add ( fileSet ) ; } public Extension [ ] toExtensions ( final Project proj ) throws BuildException { final ArrayList extensionsList = ExtensionUtil . toExtensions ( extensions ) ; ExtensionUtil . extractExtensions ( proj , extensionsList , extensionsFilesets ) ; return ( Extension [ ] ) extensionsList . toArray ( new Extension [ extensionsList . size ( ) ] ) ; } public void setRefid ( final Reference reference ) throws BuildException { if ( ! extensions . isEmpty ( ) || ! extensionsFilesets . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } final Object object = reference . getReferencedObject ( getProject ( ) ) ; if ( object instanceof ExtensionSet ) { final ExtensionSet other = ( ExtensionSet ) object ; extensions . addAll ( other . extensions ) ; extensionsFilesets . addAll ( other . extensionsFilesets ) ; } else { final String message = reference . getRefId ( ) + " doesn\'t refer to a ExtensionSet" ; throw new BuildException ( message ) ; } super . setRefid ( reference ) ; } public String toString ( ) { return "ExtensionSet" + Arrays . asList ( toExtensions ( getProject ( ) ) ) ; } } 	0
package org . apache . tools . ant . types . resources . selectors ; import java . util . Iterator ; import org . apache . tools . ant . types . Resource ; public class Or extends ResourceSelectorContainer implements ResourceSelector { public Or ( ) { } public Or ( ResourceSelector [ ] r ) { super ( r ) ; } public boolean isSelected ( Resource r ) { for ( Iterator i = getSelectors ( ) ; i . hasNext ( ) ; ) { if ( ( ( ResourceSelector ) i . next ( ) ) . isSelected ( r ) ) { return true ; } } return false ; } } 	0
package org . apache . tools . bzip2 ; public interface BZip2Constants { int baseBlockSize = 100000 ; int MAX_ALPHA_SIZE = 258 ; int MAX_CODE_LEN = 23 ; int RUNA = 0 ; int RUNB = 1 ; int N_GROUPS = 6 ; int G_SIZE = 50 ; int N_ITERS = 4 ; int MAX_SELECTORS = ( 2 + ( 900000 / G_SIZE ) ) ; int NUM_OVERSHOOT_BYTES = 20 ; int [ ] rNums = { 619 , 720 , 127 , 481 , 931 , 816 , 813 , 233 , 566 , 247 , 985 , 724 , 205 , 454 , 863 , 491 , 741 , 242 , 949 , 214 , 733 , 859 , 335 , 708 , 621 , 574 , 73 , 654 , 730 , 472 , 419 , 436 , 278 , 496 , 867 , 210 , 399 , 680 , 480 , 51 , 878 , 465 , 811 , 169 , 869 , 675 , 611 , 697 , 867 , 561 , 862 , 687 , 507 , 283 , 482 , 129 , 807 , 591 , 733 , 623 , 150 , 238 , 59 , 379 , 684 , 877 , 625 , 169 , 643 , 105 , 170 , 607 , 520 , 932 , 727 , 476 , 693 , 425 , 174 , 647 , 73 , 122 , 335 , 530 , 442 , 853 , 695 , 249 , 445 , 515 , 909 , 545 , 703 , 919 , 874 , 474 , 882 , 500 , 594 , 612 , 641 , 801 , 220 , 162 , 819 , 984 , 589 , 513 , 495 , 799 , 161 , 604 , 958 , 533 , 221 , 400 , 386 , 867 , 600 , 782 , 382 , 596 , 414 , 171 , 516 , 375 , 682 , 485 , 911 , 276 , 98 , 553 , 163 , 354 , 666 , 933 , 424 , 341 , 533 , 870 , 227 , 730 , 475 , 186 , 263 , 647 , 537 , 686 , 600 , 224 , 469 , 68 , 770 , 919 , 190 , 373 , 294 , 822 , 808 , 206 , 184 , 943 , 795 , 384 , 383 , 461 , 404 , 758 , 839 , 887 , 715 , 67 , 618 , 276 , 204 , 918 , 873 , 777 , 604 , 560 , 951 , 160 , 578 , 722 , 79 , 804 , 96 , 409 , 713 , 940 , 652 , 934 , 970 , 447 , 318 , 353 , 859 , 672 , 112 , 785 , 645 , 863 , 803 , 350 , 139 , 93 , 354 , 99 , 820 , 908 , 609 , 772 , 154 , 274 , 580 , 184 , 79 , 626 , 630 , 742 , 653 , 282 , 762 , 623 , 680 , 81 , 927 , 626 , 789 , 125 , 411 , 521 , 938 , 300 , 821 , 78 , 343 , 175 , 128 , 250 , 170 , 774 , 972 , 275 , 999 , 639 , 495 , 78 , 352 , 126 , 857 , 956 , 358 , 619 , 580 , 124 , 737 , 594 , 701 , 612 , 669 , 112 , 134 , 694 , 363 , 992 , 809 , 743 , 168 , 974 , 944 , 375 , 748 , 52 , 600 , 747 , 642 , 182 , 862 , 81 , 344 , 805 , 988 , 739 , 511 , 655 , 814 , 334 , 249 , 515 , 897 , 955 , 664 , 981 , 649 , 113 , 974 , 459 , 893 , 228 , 433 , 837 , 553 , 268 , 926 , 240 , 102 , 654 , 459 , 51 , 686 , 754 , 806 , 760 , 493 , 403 , 415 , 394 , 687 , 700 , 946 , 670 , 656 , 610 , 738 , 392 , 760 , 799 , 887 , 653 , 978 , 321 , 576 , 617 , 626 , 502 , 894 , 679 , 243 , 440 , 680 , 879 , 194 , 572 , 640 , 724 , 926 , 56 , 204 , 700 , 707 , 151 , 457 , 449 , 797 , 195 , 791 , 558 , 945 , 679 , 297 , 59 , 87 , 824 , 713 , 663 , 412 , 693 , 342 , 606 , 134 , 108 , 571 , 364 , 631 , 212 , 174 , 643 , 304 , 329 , 343 , 97 , 430 , 751 , 497 , 314 , 983 , 374 , 822 , 928 , 140 , 206 , 73 , 263 , 980 , 736 , 876 , 478 , 430 , 305 , 170 , 514 , 364 , 692 , 829 , 82 , 855 , 953 , 676 , 246 , 369 , 970 , 294 , 750 , 807 , 827 , 150 , 790 , 288 , 923 , 804 , 378 , 215 , 828 , 592 , 281 , 565 , 555 , 710 , 82 , 896 , 831 , 547 , 261 , 524 , 462 , 293 , 465 , 502 , 56 , 661 , 821 , 976 , 991 , 658 , 869 , 905 , 758 , 745 , 193 , 768 , 550 , 608 , 933 , 378 , 286 , 215 , 979 , 792 , 961 , 61 , 688 , 793 , 644 , 986 , 403 , 106 , 366 , 905 , 644 , 372 , 567 , 466 , 434 , 645 , 210 , 389 , 550 , 919 , 135 , 780 , 773 , 635 , 389 , 707 , 100 , 626 , 958 , 165 , 504 , 920 , 176 , 193 , 713 , 857 , 265 , 203 , 50 , 668 , 108 , 645 , 990 , 626 , 197 , 510 , 357 , 358 , 850 , 858 , 364 , 936 , 638 } ; } 	0
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; private boolean handleDirSep = false ; private boolean caseSensitive = true ; public void setHandleDirSep ( boolean handleDirSep ) { this . handleDirSep = handleDirSep ; } public void setCaseSensitive ( boolean caseSensitive ) { this . caseSensitive = caseSensitive ; } public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! modifyName ( sourceFileName ) . startsWith ( modifyName ( fromPrefix ) ) || ! modifyName ( sourceFileName ) . endsWith ( modifyName ( fromPostfix ) ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } private String modifyName ( String name ) { if ( ! caseSensitive ) { name = name . toLowerCase ( ) ; } if ( handleDirSep ) { if ( name . indexOf ( '\\' ) != - 1 ) { name = name . replace ( '\\' , '/' ) ; } } return name ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class War extends Jar { private File deploymentDescriptor ; private boolean needxmlfile = true ; private File addedWebXmlFile ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final String XML_DESCRIPTOR_PATH = "WEB-INF/web.xml" ; private static final String XML_DESCRIPTOR_PATH_LC = XML_DESCRIPTOR_PATH . toLowerCase ( Locale . ENGLISH ) ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { setDestFile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( XML_DESCRIPTOR_PATH ) ; super . addFileset ( fs ) ; } public void setNeedxmlfile ( boolean needxmlfile ) { this . needxmlfile = needxmlfile ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { String vPathLowerCase = vPath . toLowerCase ( Locale . ENGLISH ) ; boolean addFile = true ; if ( XML_DESCRIPTOR_PATH_LC . equals ( vPathLowerCase ) ) { if ( addedWebXmlFile != null ) { addFile = false ; if ( ! FILE_UTILS . fileNameEquals ( addedWebXmlFile , file ) ) { log ( "Warning: selected " + archiveType + " files include a second " + XML_DESCRIPTOR_PATH + " which will be ignored.\n" + "The duplicate entry is at " + file + '\n' + "The file that will be used is " + addedWebXmlFile , Project . MSG_WARN ) ; } } else { addedWebXmlFile = file ; addFile = true ; deploymentDescriptor = file ; } } if ( addFile ) { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { if ( addedWebXmlFile == null && deploymentDescriptor == null && needxmlfile && ! isInUpdateMode ( ) ) { throw new BuildException ( "No WEB-INF/web.xml file was added.\n" + "If this is your intent, set needxml='false' " ) ; } addedWebXmlFile = null ; super . cleanUp ( ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class MSVSSADD extends MSVSS { private String localPath = null ; protected Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getLocalpath ( ) == null ) { String msg = "localPath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_ADD ) ; commandLine . createArgument ( ) . setValue ( getLocalpath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritable ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; return commandLine ; } protected String getLocalpath ( ) { return localPath ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public final void setWritable ( boolean writable ) { super . setInternalWritable ( writable ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } public void setLocalpath ( Path localPath ) { this . localPath = localPath . toString ( ) ; } } 	0
package org . apache . tools . ant . types ; import java . security . UnresolvedPermission ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; public class Permissions { private List grantedPermissions = new LinkedList ( ) ; private List revokedPermissions = new LinkedList ( ) ; private java . security . Permissions granted = null ; private SecurityManager origSm = null ; private boolean active = false ; private boolean delegateToOldSM ; public Permissions ( ) { this ( false ) ; } public Permissions ( boolean delegateToOldSM ) { this . delegateToOldSM = delegateToOldSM ; } public void addConfiguredGrant ( Permissions . Permission perm ) { grantedPermissions . add ( perm ) ; } public void addConfiguredRevoke ( Permissions . Permission perm ) { revokedPermissions . add ( perm ) ; } public synchronized void setSecurityManager ( ) throws BuildException { origSm = System . getSecurityManager ( ) ; init ( ) ; System . setSecurityManager ( new MySM ( ) ) ; active = true ; } private void init ( ) throws BuildException { granted = new java . security . Permissions ( ) ; for ( Iterator i = revokedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { Permissions . Permission p = ( Permissions . Permission ) i . next ( ) ; if ( p . getClassName ( ) == null ) { throw new BuildException ( "Revoked permission " + p + " does not contain a class." ) ; } } for ( Iterator i = grantedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { Permissions . Permission p = ( Permissions . Permission ) i . next ( ) ; if ( p . getClassName ( ) == null ) { throw new BuildException ( "Granted permission " + p + " does not contain a class." ) ; } else { java . security . Permission perm = new UnresolvedPermission ( p . getClassName ( ) , p . getName ( ) , p . getActions ( ) , null ) ; granted . add ( perm ) ; } } granted . add ( new java . net . SocketPermission ( "localhost:1024-" , "listen" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vendor.url" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.class.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.arch" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "file.encoding" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "file.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "path.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "line.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.name" , "read" ) ) ; } public synchronized void restoreSecurityManager ( ) { active = false ; System . setSecurityManager ( origSm ) ; } private class MySM extends SecurityManager { public void checkExit ( int status ) { java . security . Permission perm = new java . lang . RuntimePermission ( "exitVM" , null ) ; try { checkPermission ( perm ) ; } catch ( SecurityException e ) { throw new ExitException ( e . getMessage ( ) , status ) ; } } public void checkPermission ( java . security . Permission perm ) { if ( active ) { if ( delegateToOldSM && ! perm . getName ( ) . equals ( "exitVM" ) ) { boolean permOK = false ; if ( granted . implies ( perm ) ) { permOK = true ; } checkRevoked ( perm ) ; if ( ! permOK && origSm != null ) { origSm . checkPermission ( perm ) ; } } else { if ( ! granted . implies ( perm ) ) { throw new SecurityException ( "Permission " + perm + " was not granted." ) ; } checkRevoked ( perm ) ; } } } private void checkRevoked ( java . security . Permission perm ) { for ( Iterator i = revokedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { if ( ( ( Permissions . Permission ) i . next ( ) ) . matches ( perm ) ) { throw new SecurityException ( "Permission " + perm + " was revoked." ) ; } } } } public static class Permission { private String className ; private String name ; private String actionString ; private Set actions ; public void setClass ( String aClass ) { className = aClass . trim ( ) ; } public String getClassName ( ) { return className ; } public void setName ( String aName ) { name = aName . trim ( ) ; } public String getName ( ) { return name ; } public void setActions ( String actions ) { actionString = actions ; if ( actions . length ( ) > 0 ) { this . actions = parseActions ( actions ) ; } } public String getActions ( ) { return actionString ; } boolean matches ( java . security . Permission perm ) { if ( ! className . equals ( perm . getClass ( ) . getName ( ) ) ) { return false ; } if ( name != null ) { if ( name . endsWith ( "*" ) ) { if ( ! perm . getName ( ) . startsWith ( name . substring ( 0 , name . length ( ) - 1 ) ) ) { return false ; } } else { if ( ! name . equals ( perm . getName ( ) ) ) { return false ; } } } if ( actions != null ) { Set as = parseActions ( perm . getActions ( ) ) ; int size = as . size ( ) ; as . removeAll ( actions ) ; if ( as . size ( ) == size ) { return false ; } } return true ; } private Set parseActions ( String actions ) { Set result = new HashSet ( ) ; StringTokenizer tk = new StringTokenizer ( actions , "," ) ; while ( tk . hasMoreTokens ( ) ) { String item = tk . nextToken ( ) . trim ( ) ; if ( ! item . equals ( "" ) ) { result . add ( item ) ; } } return result ; } public String toString ( ) { return ( "Permission: " + className + " (\"" + name + "\", \"" + actions + "\")" ) ; } } } 	0
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . ReflectWrapper ; import org . apache . tools . ant . util . StringUtils ; public class HasFreeSpace implements Condition { private String partition ; private String needed ; public boolean eval ( ) throws BuildException { validate ( ) ; try { if ( JavaEnvUtils . isAtLeastJavaVersion ( "1.6" ) ) { File fs = new File ( partition ) ; ReflectWrapper w = new ReflectWrapper ( fs ) ; long free = ( ( Long ) w . invoke ( "getFreeSpace" ) ) . longValue ( ) ; return free >= StringUtils . parseHumanSizes ( needed ) ; } else { throw new BuildException ( "HasFreeSpace condition not supported on Java5 or less." ) ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } } private void validate ( ) throws BuildException { if ( null == partition ) { throw new BuildException ( "Please set the partition attribute." ) ; } if ( null == needed ) { throw new BuildException ( "Please set the needed attribute." ) ; } } public String getPartition ( ) { return partition ; } public void setPartition ( String partition ) { this . partition = partition ; } public String getNeeded ( ) { return needed ; } public void setNeeded ( String needed ) { this . needed = needed ; } } 	0
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . PrintStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . UUEncoder ; class UUMailer extends PlainMailer { protected void attach ( File file , PrintStream out ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not " + "readable." ) ; } FileInputStream finstr = new FileInputStream ( file ) ; try { BufferedInputStream in = new BufferedInputStream ( finstr ) ; UUEncoder encoder = new UUEncoder ( file . getName ( ) ) ; encoder . encode ( in , out ) ; } finally { finstr . close ( ) ; } } } 	0
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; public interface ResourceSelector { boolean isSelected ( Resource r ) ; } 	0
package org . apache . tools . ant . util ; import java . io . File ; import java . io . Reader ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . BufferedInputStream ; import java . util . Arrays ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . TimeComparison ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . Touchable ; import org . apache . tools . ant . types . resources . selectors . Or ; import org . apache . tools . ant . types . resources . selectors . And ; import org . apache . tools . ant . types . resources . selectors . Not ; import org . apache . tools . ant . types . resources . selectors . Date ; import org . apache . tools . ant . types . resources . selectors . Type ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . selectors . SelectorUtils ; public class ResourceUtils { private static final class Outdated implements ResourceSelector { private Resource control ; private long granularity ; private Outdated ( Resource control , long granularity ) { this . control = control ; this . granularity = granularity ; } public boolean isSelected ( Resource r ) { return SelectorUtils . isOutOfDate ( control , r , granularity ) ; } } private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final ResourceSelector NOT_EXISTS = new Not ( new Exists ( ) ) ; public static Resource [ ] selectOutOfDateSources ( ProjectComponent logTo , Resource [ ] source , FileNameMapper mapper , ResourceFactory targets ) { return selectOutOfDateSources ( logTo , source , mapper , targets , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public static Resource [ ] selectOutOfDateSources ( ProjectComponent logTo , Resource [ ] source , FileNameMapper mapper , ResourceFactory targets , long granularity ) { Union u = new Union ( ) ; u . addAll ( Arrays . asList ( source ) ) ; ResourceCollection rc = selectOutOfDateSources ( logTo , u , mapper , targets , granularity ) ; return rc . size ( ) == 0 ? new Resource [ 0 ] : ( ( Union ) rc ) . listResources ( ) ; } public static ResourceCollection selectOutOfDateSources ( ProjectComponent logTo , ResourceCollection source , FileNameMapper mapper , ResourceFactory targets , long granularity ) { if ( source . size ( ) == 0 ) { logTo . log ( "No sources found." , Project . MSG_VERBOSE ) ; return Resources . NONE ; } source = Union . getInstance ( source ) ; logFuture ( logTo , source , granularity ) ; Union result = new Union ( ) ; for ( Iterator iter = source . iterator ( ) ; iter . hasNext ( ) ; ) { Resource sr = ( Resource ) iter . next ( ) ; String srName = sr . getName ( ) ; srName = srName == null ? srName : srName . replace ( '/' , File . separatorChar ) ; String [ ] targetnames = null ; try { targetnames = mapper . mapFileName ( srName ) ; } catch ( Exception e ) { logTo . log ( "Caught " + e + " mapping resource " + sr , Project . MSG_VERBOSE ) ; } if ( targetnames == null || targetnames . length == 0 ) { logTo . log ( sr + " skipped - don\'t know how to handle it" , Project . MSG_VERBOSE ) ; continue ; } Union targetColl = new Union ( ) ; for ( int i = 0 ; i < targetnames . length ; i ++ ) { targetColl . add ( targets . getResource ( targetnames [ i ] . replace ( File . separatorChar , '/' ) ) ) ; } Restrict r = new Restrict ( ) ; r . add ( new And ( new ResourceSelector [ ] { Type . FILE , new Or ( new ResourceSelector [ ] { NOT_EXISTS , new Outdated ( sr , granularity ) } ) } ) ) ; r . add ( targetColl ) ; if ( r . size ( ) > 0 ) { result . add ( sr ) ; Resource t = ( Resource ) ( r . iterator ( ) . next ( ) ) ; logTo . log ( sr . getName ( ) + " added as " + t . getName ( ) + ( t . isExists ( ) ? " is outdated." : " doesn\'t exist." ) , Project . MSG_VERBOSE ) ; continue ; } logTo . log ( sr . getName ( ) + " omitted as " + targetColl . toString ( ) + ( targetColl . size ( ) == 1 ? " is" : " are " ) + " up to date." , Project . MSG_VERBOSE ) ; } return result ; } public static void copyResource ( Resource source , Resource dest ) throws IOException { copyResource ( source , dest , null ) ; } public static void copyResource ( Resource source , Resource dest , Project project ) throws IOException { copyResource ( source , dest , null , null , false , false , null , null , project ) ; } public static void copyResource ( Resource source , Resource dest , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { if ( ! overwrite ) { long slm = source . getLastModified ( ) ; if ( dest . isExists ( ) && slm != 0 && dest . getLastModified ( ) > slm ) { return ; } } final boolean filterSetsAvailable = ( filters != null && filters . hasFilters ( ) ) ; final boolean filterChainsAvailable = ( filterChains != null && filterChains . size ( ) > 0 ) ; if ( filterSetsAvailable ) { BufferedReader in = null ; BufferedWriter out = null ; try { InputStreamReader isr = null ; if ( inputEncoding == null ) { isr = new InputStreamReader ( source . getInputStream ( ) ) ; } else { isr = new InputStreamReader ( source . getInputStream ( ) , inputEncoding ) ; } in = new BufferedReader ( isr ) ; OutputStreamWriter osw = null ; if ( outputEncoding == null ) { osw = new OutputStreamWriter ( dest . getOutputStream ( ) ) ; } else { osw = new OutputStreamWriter ( dest . getOutputStream ( ) , outputEncoding ) ; } out = new BufferedWriter ( osw ) ; if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( FileUtils . BUF_SIZE ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } LineTokenizer lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; String newline = null ; String line = lineTokenizer . getToken ( in ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { newline = filters . replaceTokens ( line ) ; out . write ( newline ) ; } line = lineTokenizer . getToken ( in ) ; } } finally { FileUtils . close ( out ) ; FileUtils . close ( in ) ; } } else if ( filterChainsAvailable || ( inputEncoding != null && ! inputEncoding . equals ( outputEncoding ) ) || ( inputEncoding == null && outputEncoding != null ) ) { BufferedReader in = null ; BufferedWriter out = null ; try { InputStreamReader isr = null ; if ( inputEncoding == null ) { isr = new InputStreamReader ( source . getInputStream ( ) ) ; } else { isr = new InputStreamReader ( source . getInputStream ( ) , inputEncoding ) ; } in = new BufferedReader ( isr ) ; OutputStreamWriter osw = null ; if ( outputEncoding == null ) { osw = new OutputStreamWriter ( dest . getOutputStream ( ) ) ; } else { osw = new OutputStreamWriter ( dest . getOutputStream ( ) , outputEncoding ) ; } out = new BufferedWriter ( osw ) ; if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( FileUtils . BUF_SIZE ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } char [ ] buffer = new char [ FileUtils . BUF_SIZE ] ; while ( true ) { int nRead = in . read ( buffer , 0 , buffer . length ) ; if ( nRead == - 1 ) { break ; } out . write ( buffer , 0 , nRead ) ; } } finally { FileUtils . close ( out ) ; FileUtils . close ( in ) ; } } else { InputStream in = null ; OutputStream out = null ; try { in = source . getInputStream ( ) ; out = dest . getOutputStream ( ) ; byte [ ] buffer = new byte [ FileUtils . BUF_SIZE ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } finally { FileUtils . close ( out ) ; FileUtils . close ( in ) ; } } if ( preserveLastModified && dest instanceof Touchable ) { setLastModified ( ( Touchable ) dest , source . getLastModified ( ) ) ; } } public static void setLastModified ( Touchable t , long time ) { t . touch ( ( time < 0 ) ? System . currentTimeMillis ( ) : time ) ; } public static boolean contentEquals ( Resource r1 , Resource r2 , boolean text ) throws IOException { if ( r1 . isExists ( ) != r2 . isExists ( ) ) { return false ; } if ( ! r1 . isExists ( ) ) { return true ; } if ( r1 . isDirectory ( ) || r2 . isDirectory ( ) ) { return false ; } if ( r1 . equals ( r2 ) ) { return true ; } if ( ! text && r1 . getSize ( ) != r2 . getSize ( ) ) { return false ; } return compareContent ( r1 , r2 , text ) == 0 ; } public static int compareContent ( Resource r1 , Resource r2 , boolean text ) throws IOException { if ( r1 . equals ( r2 ) ) { return 0 ; } boolean e1 = r1 . isExists ( ) ; boolean e2 = r2 . isExists ( ) ; if ( ! ( e1 || e2 ) ) { return 0 ; } if ( e1 != e2 ) { return e1 ? 1 : - 1 ; } boolean d1 = r1 . isDirectory ( ) ; boolean d2 = r2 . isDirectory ( ) ; if ( d1 && d2 ) { return 0 ; } if ( d1 || d2 ) { return d1 ? - 1 : 1 ; } return text ? textCompare ( r1 , r2 ) : binaryCompare ( r1 , r2 ) ; } private static int binaryCompare ( Resource r1 , Resource r2 ) throws IOException { InputStream in1 = null ; InputStream in2 = null ; try { in1 = new BufferedInputStream ( r1 . getInputStream ( ) ) ; in2 = new BufferedInputStream ( r2 . getInputStream ( ) ) ; for ( int b1 = in1 . read ( ) ; b1 != - 1 ; b1 = in1 . read ( ) ) { int b2 = in2 . read ( ) ; if ( b1 != b2 ) { return b1 > b2 ? 1 : - 1 ; } } return in2 . read ( ) == - 1 ? 0 : - 1 ; } finally { FileUtils . close ( in1 ) ; FileUtils . close ( in2 ) ; } } private static int textCompare ( Resource r1 , Resource r2 ) throws IOException { BufferedReader in1 = null ; BufferedReader in2 = null ; try { in1 = new BufferedReader ( new InputStreamReader ( r1 . getInputStream ( ) ) ) ; in2 = new BufferedReader ( new InputStreamReader ( r2 . getInputStream ( ) ) ) ; String expected = in1 . readLine ( ) ; while ( expected != null ) { String actual = in2 . readLine ( ) ; if ( ! expected . equals ( actual ) ) { return expected . compareTo ( actual ) ; } expected = in1 . readLine ( ) ; } return in2 . readLine ( ) == null ? 0 : - 1 ; } finally { FileUtils . close ( in1 ) ; FileUtils . close ( in2 ) ; } } private static void logFuture ( ProjectComponent logTo , ResourceCollection rc , long granularity ) { long now = System . currentTimeMillis ( ) + granularity ; Date sel = new Date ( ) ; sel . setMillis ( now ) ; sel . setWhen ( TimeComparison . AFTER ) ; Restrict future = new Restrict ( ) ; future . add ( sel ) ; future . add ( rc ) ; for ( Iterator iter = future . iterator ( ) ; iter . hasNext ( ) ; ) { logTo . log ( "Warning: " + ( ( Resource ) iter . next ( ) ) . getName ( ) + " modified in the future." , Project . MSG_WARN ) ; } } } 	1
package org . apache . tools . ant ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Constructor ; public class AntTypeDefinition { private String name ; private Class clazz ; private Class adapterClass ; private Class adaptToClass ; private String className ; private ClassLoader classLoader ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setClass ( Class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } this . classLoader = ( classLoader == null ) ? clazz . getClassLoader ( ) : classLoader ; this . className = ( className == null ) ? clazz . getName ( ) : className ; } public void setClassName ( String className ) { this . className = className ; } public String getClassName ( ) { return className ; } public void setAdapterClass ( Class adapterClass ) { this . adapterClass = adapterClass ; } public void setAdaptToClass ( Class adaptToClass ) { this . adaptToClass = adaptToClass ; } public void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } public ClassLoader getClassLoader ( ) { return classLoader ; } public Class getExposedClass ( Project project ) { if ( adaptToClass != null ) { Class z = getTypeClass ( project ) ; if ( z == null || adaptToClass . isAssignableFrom ( z ) ) { return z ; } } return ( adapterClass == null ) ? getTypeClass ( project ) : adapterClass ; } public Class getTypeClass ( Project project ) { try { return innerGetTypeClass ( ) ; } catch ( NoClassDefFoundError ncdfe ) { project . log ( "Could not load a dependent class (" + ncdfe . getMessage ( ) + ") for type " + name , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { project . log ( "Could not load class (" + className + ") for type " + name , Project . MSG_DEBUG ) ; } return null ; } public Class innerGetTypeClass ( ) throws ClassNotFoundException { if ( clazz != null ) { return clazz ; } if ( classLoader == null ) { clazz = Class . forName ( className ) ; } else { clazz = classLoader . loadClass ( className ) ; } return clazz ; } public Object create ( Project project ) { return icreate ( project ) ; } private Object icreate ( Project project ) { Class c = getTypeClass ( project ) ; if ( c == null ) { return null ; } Object o = createAndSet ( project , c ) ; if ( o == null || adapterClass == null ) { return o ; } if ( adaptToClass != null ) { if ( adaptToClass . isAssignableFrom ( o . getClass ( ) ) ) { return o ; } } TypeAdapter adapterObject = ( TypeAdapter ) createAndSet ( project , adapterClass ) ; if ( adapterObject == null ) { return null ; } adapterObject . setProxy ( o ) ; return adapterObject ; } public void checkClass ( Project project ) { if ( clazz == null ) { clazz = getTypeClass ( project ) ; if ( clazz == null ) { throw new BuildException ( "Unable to create class for " + getName ( ) ) ; } } if ( adapterClass != null && ( adaptToClass == null || ! adaptToClass . isAssignableFrom ( clazz ) ) ) { TypeAdapter adapter = ( TypeAdapter ) createAndSet ( project , adapterClass ) ; if ( adapter == null ) { throw new BuildException ( "Unable to create adapter object" ) ; } adapter . checkProxyClass ( clazz ) ; } } private Object createAndSet ( Project project , Class c ) { try { Object o = innerCreateAndSet ( c , project ) ; return o ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; throw new BuildException ( "Could not create type " + name + " due to " + t , t ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = "Type " + name + ": A class needed by class " + c + " cannot be found: " + ncdfe . getMessage ( ) ; throw new BuildException ( msg , ncdfe ) ; } catch ( NoSuchMethodException nsme ) { throw new BuildException ( "Could not create type " + name + " as the class " + c + " has no compatible constructor" ) ; } catch ( InstantiationException nsme ) { throw new BuildException ( "Could not create type " + name + " as the class " + c + " is abstract" ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Could not create type " + name + " as the constructor " + c + " is not accessible" ) ; } catch ( Throwable t ) { throw new BuildException ( "Could not create type " + name + " due to " + t , t ) ; } } public Object innerCreateAndSet ( Class newclass , Project project ) throws NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { Constructor ctor = null ; boolean noArg = false ; try { ctor = newclass . getConstructor ( new Class [ 0 ] ) ; noArg = true ; } catch ( NoSuchMethodException nse ) { ctor = newclass . getConstructor ( new Class [ ] { Project . class } ) ; noArg = false ; } Object o = ctor . newInstance ( ( ( noArg ) ? new Object [ 0 ] : new Object [ ] { project } ) ) ; project . setProjectReference ( o ) ; return o ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { return ( other != null && other . getClass ( ) == getClass ( ) && other . getTypeClass ( project ) . equals ( getTypeClass ( project ) ) && other . getExposedClass ( project ) . equals ( getExposedClass ( project ) ) && other . adapterClass == adapterClass && other . adaptToClass == adaptToClass ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( other == null || getClass ( ) != other . getClass ( ) || ! getClassName ( ) . equals ( other . getClassName ( ) ) || ! extractClassname ( adapterClass ) . equals ( extractClassname ( other . adapterClass ) ) || ! extractClassname ( adaptToClass ) . equals ( extractClassname ( other . adaptToClass ) ) ) { return false ; } ClassLoader oldLoader = other . getClassLoader ( ) ; ClassLoader newLoader = getClassLoader ( ) ; return oldLoader == newLoader || ( oldLoader instanceof AntClassLoader && newLoader instanceof AntClassLoader && ( ( AntClassLoader ) oldLoader ) . getClasspath ( ) . equals ( ( ( AntClassLoader ) newLoader ) . getClasspath ( ) ) ) ; } private String extractClassname ( Class c ) { return ( c == null ) ? "<null>" : c . getClass ( ) . getName ( ) ; } } 	0
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; public class AntlibDefinition extends Task { private String uri = "" ; private ClassLoader antlibClassLoader ; public void setURI ( String uri ) throws BuildException { if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } if ( uri . startsWith ( "ant:" ) ) { throw new BuildException ( "Attempt to use a reserved URI " + uri ) ; } this . uri = uri ; } public String getURI ( ) { return uri ; } public void setAntlibClassLoader ( ClassLoader classLoader ) { this . antlibClassLoader = classLoader ; } public ClassLoader getAntlibClassLoader ( ) { return antlibClassLoader ; } } 	0
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Java ; public class WebLogicHotDeploymentTool extends AbstractHotDeploymentTool implements HotDeploymentTool { private static final String WEBLOGIC_DEPLOY_CLASS_NAME = "weblogic.deploy" ; private static final String [ ] VALID_ACTIONS = { ACTION_DELETE , ACTION_DEPLOY , ACTION_LIST , ACTION_UNDEPLOY , ACTION_UPDATE } ; private boolean debug ; private String application ; private String component ; public void deploy ( ) { Java java = new Java ( getTask ( ) ) ; java . setFork ( true ) ; java . setFailonerror ( true ) ; java . setClasspath ( getClasspath ( ) ) ; java . setClassname ( WEBLOGIC_DEPLOY_CLASS_NAME ) ; java . createArg ( ) . setLine ( getArguments ( ) ) ; java . execute ( ) ; } public void validateAttributes ( ) throws BuildException { super . validateAttributes ( ) ; String action = getTask ( ) . getAction ( ) ; if ( ( getPassword ( ) == null ) ) { throw new BuildException ( "The password attribute must be set." ) ; } if ( ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) ) && application == null ) { throw new BuildException ( "The application attribute must be set " + "if action = " + action ) ; } if ( ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) ) && getTask ( ) . getSource ( ) == null ) { throw new BuildException ( "The source attribute must be set if " + "action = " + action ) ; } if ( ( action . equals ( ACTION_DELETE ) || action . equals ( ACTION_UNDEPLOY ) ) && application == null ) { throw new BuildException ( "The application attribute must be set if " + "action = " + action ) ; } } public String getArguments ( ) throws BuildException { String action = getTask ( ) . getAction ( ) ; String args = null ; if ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) ) { args = buildDeployArgs ( ) ; } else if ( action . equals ( ACTION_DELETE ) || action . equals ( ACTION_UNDEPLOY ) ) { args = buildUndeployArgs ( ) ; } else if ( action . equals ( ACTION_LIST ) ) { args = buildListArgs ( ) ; } return args ; } protected boolean isActionValid ( ) { boolean valid = false ; String action = getTask ( ) . getAction ( ) ; for ( int i = 0 ; i < VALID_ACTIONS . length ; i ++ ) { if ( action . equals ( VALID_ACTIONS [ i ] ) ) { valid = true ; break ; } } return valid ; } protected StringBuffer buildArgsPrefix ( ) { ServerDeploy task = getTask ( ) ; return new StringBuffer ( 1024 ) . append ( ( getServer ( ) != null ) ? "-url " + getServer ( ) : "" ) . append ( " " ) . append ( debug ? "-debug " : "" ) . append ( ( getUserName ( ) != null ) ? "-username " + getUserName ( ) : "" ) . append ( " " ) . append ( task . getAction ( ) ) . append ( " " ) . append ( getPassword ( ) ) . append ( " " ) ; } protected String buildDeployArgs ( ) { String args = buildArgsPrefix ( ) . append ( application ) . append ( " " ) . append ( getTask ( ) . getSource ( ) ) . toString ( ) ; if ( component != null ) { args = "-component " + component + " " + args ; } return args ; } protected String buildUndeployArgs ( ) { return buildArgsPrefix ( ) . append ( application ) . append ( " " ) . toString ( ) ; } protected String buildListArgs ( ) { return buildArgsPrefix ( ) . toString ( ) ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setApplication ( String application ) { this . application = application ; } public void setComponent ( String component ) { this . component = component ; } } 	0
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; public class MSVSSLABEL extends MSVSS { Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { throw new BuildException ( "vsspath attribute must be set!" , getLocation ( ) ) ; } String label = getLabel ( ) ; if ( label . equals ( "" ) ) { String msg = "label attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_LABEL ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( label ) ; commandLine . createArgument ( ) . setValue ( getVersion ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; return commandLine ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } } 	0
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . types . Parameterizable ; public interface ExtendFileSelector extends FileSelector , Parameterizable { } 	0
package org . apache . tools . ant . util . optional ; import org . apache . tools . ant . BuildException ; import java . util . Iterator ; import org . apache . tools . ant . util . ScriptRunnerBase ; import org . apache . tools . ant . util . ReflectUtil ; import org . apache . tools . ant . util . ReflectWrapper ; public class JavaxScriptRunner extends ScriptRunnerBase { private ReflectWrapper engine ; public String getManagerName ( ) { return "javax" ; } public boolean supportsLanguage ( ) { if ( engine != null ) { return true ; } checkLanguage ( ) ; ClassLoader origLoader = replaceContextLoader ( ) ; try { return createEngine ( ) != null ; } catch ( Exception ex ) { return false ; } finally { restoreContextLoader ( origLoader ) ; } } public void executeScript ( String execName ) throws BuildException { evaluateScript ( execName ) ; } public Object evaluateScript ( String execName ) throws BuildException { checkLanguage ( ) ; ClassLoader origLoader = replaceContextLoader ( ) ; try { ReflectWrapper engine = createEngine ( ) ; if ( engine == null ) { throw new BuildException ( "Unable to create javax script engine for " + getLanguage ( ) ) ; } for ( Iterator i = getBeans ( ) . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; Object value = getBeans ( ) . get ( key ) ; engine . invoke ( "put" , String . class , key , Object . class , value ) ; } return engine . invoke ( "eval" , String . class , getScript ( ) ) ; } catch ( Exception be ) { Throwable t = be ; Throwable te = ( Throwable ) ReflectUtil . invoke ( be , "getCause" ) ; if ( te != null ) { if ( te instanceof BuildException ) { throw ( BuildException ) te ; } else { t = te ; } } throw new BuildException ( t ) ; } finally { restoreContextLoader ( origLoader ) ; } } private ReflectWrapper createEngine ( ) throws Exception { if ( engine != null ) { return engine ; } ReflectWrapper manager = new ReflectWrapper ( getClass ( ) . getClassLoader ( ) , "javax.script.ScriptEngineManager" ) ; Object e = manager . invoke ( "getEngineByName" , String . class , getLanguage ( ) ) ; if ( e == null ) { return null ; } ReflectWrapper ret = new ReflectWrapper ( e ) ; if ( getKeepEngine ( ) ) { this . engine = ret ; } return ret ; } } 	1
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class P4Change extends P4Base { protected String emptyChangeList = null ; protected String description = "AutoSubmit By Ant" ; public void execute ( ) throws BuildException { if ( emptyChangeList == null ) { emptyChangeList = getEmptyChangeList ( ) ; } final Project myProj = getProject ( ) ; P4Handler handler = new P4HandlerAdapter ( ) { public void process ( String line ) { if ( util . match ( "/Change/" , line ) ) { line = util . substitute ( "s/[^0-9]//g" , line ) ; int changenumber = Integer . parseInt ( line ) ; log ( "Change Number is " + changenumber , Project . MSG_INFO ) ; myProj . setProperty ( "p4.change" , "" + changenumber ) ; } else if ( util . match ( "/error/" , line ) ) { throw new BuildException ( "Perforce Error, check client settings and/or server" ) ; } } } ; handler . setOutput ( emptyChangeList ) ; execP4Command ( "change -i" , handler ) ; } public String getEmptyChangeList ( ) throws BuildException { final StringBuffer stringbuf = new StringBuffer ( ) ; execP4Command ( "change -o" , new P4HandlerAdapter ( ) { public void process ( String line ) { if ( ! util . match ( "/^#/" , line ) ) { if ( util . match ( "/error/" , line ) ) { log ( "Client Error" , Project . MSG_VERBOSE ) ; throw new BuildException ( "Perforce Error, " + "check client settings and/or server" ) ; } else if ( util . match ( "/<enter description here>/" , line ) ) { description = backslash ( description ) ; line = util . substitute ( "s/<enter description here>/" + description + "/" , line ) ; } else if ( util . match ( "/\\/\\//" , line ) ) { return ; } stringbuf . append ( line ) ; stringbuf . append ( "\n" ) ; } } } ) ; return stringbuf . toString ( ) ; } public static final String backslash ( String value ) { final StringBuffer buf = new StringBuffer ( value . length ( ) ) ; final int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; if ( c == '/' ) { buf . append ( '\\' ) ; } buf . append ( c ) ; } return buf . toString ( ) ; } public void setDescription ( String desc ) { this . description = desc ; } } 	0
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import java . io . IOException ; import java . io . File ; import java . util . List ; import java . util . LinkedList ; import java . util . Iterator ; import java . util . ArrayList ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FileSet ; public class Scp extends SSHBase { private static final String [ ] FROM_ATTRS = { "file" , "localfile" , "remotefile" } ; private static final String [ ] TO_ATTRS = { "todir" , "localtodir" , "remotetodir" , "localtofile" , "remotetofile" } ; private String fromUri ; private String toUri ; private List fileSets = null ; private boolean isFromRemote , isToRemote ; private boolean isSftp = false ; public void setFile ( String aFromUri ) { setFromUri ( aFromUri ) ; this . isFromRemote = isRemoteUri ( this . fromUri ) ; } public void setTodir ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = isRemoteUri ( this . toUri ) ; } public void setLocalFile ( String aFromUri ) { setFromUri ( aFromUri ) ; this . isFromRemote = false ; } public void setRemoteFile ( String aFromUri ) { setFromUri ( aFromUri ) ; this . isFromRemote = true ; } public void setLocalTodir ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = false ; } public void setRemoteTodir ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = true ; } public void setLocalTofile ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = false ; } public void setRemoteTofile ( String aToUri ) { setToUri ( aToUri ) ; this . isToRemote = true ; } public void setSftp ( boolean yesOrNo ) { isSftp = yesOrNo ; } public void addFileset ( FileSet set ) { if ( fileSets == null ) { fileSets = new LinkedList ( ) ; } fileSets . add ( set ) ; } public void init ( ) throws BuildException { super . init ( ) ; this . toUri = null ; this . fromUri = null ; this . fileSets = null ; } public void execute ( ) throws BuildException { if ( toUri == null ) { throw exactlyOne ( TO_ATTRS ) ; } if ( fromUri == null && fileSets == null ) { throw exactlyOne ( FROM_ATTRS , "one or more nested filesets" ) ; } try { if ( isFromRemote && ! isToRemote ) { download ( fromUri , toUri ) ; } else if ( ! isFromRemote && isToRemote ) { if ( fileSets != null ) { upload ( fileSets , toUri ) ; } else { upload ( fromUri , toUri ) ; } } else if ( isFromRemote && isToRemote ) { throw new BuildException ( "Copying from a remote server to a remote server is not supported." ) ; } else { throw new BuildException ( "'todir' and 'file' attributes " + "must have syntax like the following: " + "user:password@host:/path" ) ; } } catch ( Exception e ) { if ( getFailonerror ( ) ) { throw new BuildException ( e ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_ERR ) ; } } } private void download ( String fromSshUri , String toPath ) throws JSchException , IOException { String file = parseUri ( fromSshUri ) ; Session session = null ; try { session = openSession ( ) ; ScpFromMessage message = null ; if ( ! isSftp ) { message = new ScpFromMessage ( getVerbose ( ) , session , file , getProject ( ) . resolveFile ( toPath ) , fromSshUri . endsWith ( "*" ) ) ; } else { message = new ScpFromMessageBySftp ( getVerbose ( ) , session , file , getProject ( ) . resolveFile ( toPath ) , fromSshUri . endsWith ( "*" ) ) ; } log ( "Receiving file: " + file ) ; message . setLogListener ( this ) ; message . execute ( ) ; } finally { if ( session != null ) { session . disconnect ( ) ; } } } private void upload ( List fileSet , String toSshUri ) throws IOException , JSchException { String file = parseUri ( toSshUri ) ; Session session = null ; try { List list = new ArrayList ( fileSet . size ( ) ) ; for ( Iterator i = fileSet . iterator ( ) ; i . hasNext ( ) ; ) { FileSet set = ( FileSet ) i . next ( ) ; Directory d = createDirectory ( set ) ; if ( d != null ) { list . add ( d ) ; } } if ( ! list . isEmpty ( ) ) { session = openSession ( ) ; ScpToMessage message = null ; if ( ! isSftp ) { message = new ScpToMessage ( getVerbose ( ) , session , list , file ) ; } else { message = new ScpToMessageBySftp ( getVerbose ( ) , session , list , file ) ; } message . setLogListener ( this ) ; message . execute ( ) ; } } finally { if ( session != null ) { session . disconnect ( ) ; } } } private void upload ( String fromPath , String toSshUri ) throws IOException , JSchException { String file = parseUri ( toSshUri ) ; Session session = null ; try { session = openSession ( ) ; ScpToMessage message = null ; if ( ! isSftp ) { message = new ScpToMessage ( getVerbose ( ) , session , getProject ( ) . resolveFile ( fromPath ) , file ) ; } else { message = new ScpToMessageBySftp ( getVerbose ( ) , session , getProject ( ) . resolveFile ( fromPath ) , file ) ; } message . setLogListener ( this ) ; message . execute ( ) ; } finally { if ( session != null ) { session . disconnect ( ) ; } } } private String parseUri ( String uri ) { int indexOfAt = uri . lastIndexOf ( '@' ) ; int indexOfColon = uri . indexOf ( ':' ) ; if ( indexOfColon > - 1 && indexOfColon < indexOfAt ) { setUsername ( uri . substring ( 0 , indexOfColon ) ) ; setPassword ( uri . substring ( indexOfColon + 1 , indexOfAt ) ) ; } else { setUsername ( uri . substring ( 0 , indexOfAt ) ) ; } if ( getUserInfo ( ) . getPassword ( ) == null && getUserInfo ( ) . getPassphrase ( ) == null ) { throw new BuildException ( "neither password nor passphrase for user " + getUserInfo ( ) . getName ( ) + " has been " + "given.  Can't authenticate." ) ; } int indexOfPath = uri . indexOf ( ':' , indexOfAt + 1 ) ; if ( indexOfPath == - 1 ) { throw new BuildException ( "no remote path in " + uri ) ; } setHost ( uri . substring ( indexOfAt + 1 , indexOfPath ) ) ; String remotePath = uri . substring ( indexOfPath + 1 ) ; if ( remotePath . equals ( "" ) ) { remotePath = "." ; } return remotePath ; } private boolean isRemoteUri ( String uri ) { boolean isRemote = true ; int indexOfAt = uri . indexOf ( '@' ) ; if ( indexOfAt < 0 ) { isRemote = false ; } return isRemote ; } private Directory createDirectory ( FileSet set ) { DirectoryScanner scanner = set . getDirectoryScanner ( getProject ( ) ) ; Directory root = new Directory ( scanner . getBasedir ( ) ) ; String [ ] files = scanner . getIncludedFiles ( ) ; if ( files . length != 0 ) { for ( int j = 0 ; j < files . length ; j ++ ) { String [ ] path = Directory . getPath ( files [ j ] ) ; Directory current = root ; File currentParent = scanner . getBasedir ( ) ; for ( int i = 0 ; i < path . length ; i ++ ) { File file = new File ( currentParent , path [ i ] ) ; if ( file . isDirectory ( ) ) { current . addDirectory ( new Directory ( file ) ) ; current = current . getChild ( file ) ; currentParent = current . getDirectory ( ) ; } else if ( file . isFile ( ) ) { current . addFile ( file ) ; } } } } else { root = null ; } return root ; } private void setFromUri ( String fromUri ) { if ( this . fromUri != null ) { throw exactlyOne ( FROM_ATTRS ) ; } this . fromUri = fromUri ; } private void setToUri ( String toUri ) { if ( this . toUri != null ) { throw exactlyOne ( TO_ATTRS ) ; } this . toUri = toUri ; } private BuildException exactlyOne ( String [ ] attrs ) { return exactlyOne ( attrs , null ) ; } private BuildException exactlyOne ( String [ ] attrs , String alt ) { StringBuffer buf = new StringBuffer ( "Exactly one of " ) . append ( '[' ) . append ( attrs [ 0 ] ) ; for ( int i = 1 ; i < attrs . length ; i ++ ) { buf . append ( '|' ) . append ( attrs [ i ] ) ; } buf . append ( ']' ) ; if ( alt != null ) { buf . append ( " or " ) . append ( alt ) ; } return new BuildException ( buf . append ( " is required." ) . toString ( ) ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . javah ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . launch . Locator ; import org . apache . tools . ant . taskdefs . ExecuteJava ; import org . apache . tools . ant . taskdefs . optional . Javah ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class SunJavah implements JavahAdapter { public static final String IMPLEMENTATION_NAME = "sun" ; public boolean compile ( Javah javah ) throws BuildException { Commandline cmd = setupJavahCommand ( javah ) ; ExecuteJava ej = new ExecuteJava ( ) ; Class c = null ; try { try { c = Class . forName ( "com.sun.tools.javah.oldjavah.Main" ) ; } catch ( ClassNotFoundException cnfe ) { c = Class . forName ( "com.sun.tools.javah.Main" ) ; } } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Can't load javah" , ex , javah . getLocation ( ) ) ; } cmd . setExecutable ( c . getName ( ) ) ; ej . setJavaCommand ( cmd ) ; File f = Locator . getClassSource ( c ) ; if ( f != null ) { ej . setClasspath ( new Path ( javah . getProject ( ) , f . getPath ( ) ) ) ; } return ej . fork ( javah ) == 0 ; } private Commandline setupJavahCommand ( Javah javah ) { Commandline cmd = new Commandline ( ) ; if ( javah . getDestdir ( ) != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( javah . getDestdir ( ) ) ; } if ( javah . getOutputfile ( ) != null ) { cmd . createArgument ( ) . setValue ( "-o" ) ; cmd . createArgument ( ) . setFile ( javah . getOutputfile ( ) ) ; } if ( javah . getClasspath ( ) != null ) { cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( javah . getClasspath ( ) ) ; } if ( javah . getVerbose ( ) ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( javah . getOld ( ) ) { cmd . createArgument ( ) . setValue ( "-old" ) ; } if ( javah . getForce ( ) ) { cmd . createArgument ( ) . setValue ( "-force" ) ; } if ( javah . getStubs ( ) && ! javah . getOld ( ) ) { throw new BuildException ( "stubs only available in old mode." , javah . getLocation ( ) ) ; } if ( javah . getStubs ( ) ) { cmd . createArgument ( ) . setValue ( "-stubs" ) ; } Path bcp = new Path ( javah . getProject ( ) ) ; if ( javah . getBootclasspath ( ) != null ) { bcp . append ( javah . getBootclasspath ( ) ) ; } bcp = bcp . concatSystemBootClasspath ( "ignore" ) ; if ( bcp . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bcp ) ; } cmd . addArguments ( javah . getCurrentArgs ( ) ) ; javah . logAndAddFiles ( cmd ) ; return cmd ; } } 	0
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . util . Enumeration ; import java . util . LinkedList ; import java . util . List ; import java . util . ListIterator ; import java . util . Properties ; import java . util . Vector ; public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private SysProperties sysProperties = new SysProperties ( ) ; private Path classpath = null ; private Path bootclasspath = null ; private String vmVersion ; private String maxMemory = null ; private Assertions assertions = null ; private boolean executeJar = false ; private boolean cloneVm = false ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; private Vector propertySets = new Vector ( ) ; public String [ ] getVariables ( ) throws BuildException { List definitions = new LinkedList ( ) ; ListIterator list = definitions . listIterator ( ) ; addDefinitionsToList ( list ) ; if ( definitions . size ( ) == 0 ) { return null ; } else { return ( String [ ] ) definitions . toArray ( new String [ definitions . size ( ) ] ) ; } } public void addDefinitionsToList ( ListIterator listIt ) { String [ ] props = super . getVariables ( ) ; if ( props != null ) { for ( int i = 0 ; i < props . length ; i ++ ) { listIt . add ( "-D" + props [ i ] ) ; } } Properties propertySetProperties = mergePropertySets ( ) ; for ( Enumeration e = propertySetProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = propertySetProperties . getProperty ( key ) ; listIt . add ( "-D" + key + "=" + value ) ; } } public int size ( ) { Properties p = mergePropertySets ( ) ; return variables . size ( ) + p . size ( ) ; } public void setSystem ( ) throws BuildException { try { sys = System . getProperties ( ) ; Properties p = new Properties ( ) ; for ( Enumeration e = sys . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; p . put ( name , sys . getProperty ( name ) ) ; } p . putAll ( mergePropertySets ( ) ) ; for ( Enumeration e = variables . elements ( ) ; e . hasMoreElements ( ) ; ) { Environment . Variable v = ( Environment . Variable ) e . nextElement ( ) ; v . validate ( ) ; p . put ( v . getKey ( ) , v . getValue ( ) ) ; } System . setProperties ( p ) ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public void restoreSystem ( ) throws BuildException { if ( sys == null ) { throw new BuildException ( "Unbalanced nesting of SysProperties" ) ; } try { System . setProperties ( sys ) ; sys = null ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public Object clone ( ) throws CloneNotSupportedException { try { SysProperties c = ( SysProperties ) super . clone ( ) ; c . variables = ( Vector ) variables . clone ( ) ; c . propertySets = ( Vector ) propertySets . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { return null ; } } public void addSyspropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void addSysproperties ( SysProperties ps ) { variables . addAll ( ps . variables ) ; propertySets . addAll ( ps . propertySets ) ; } private Properties mergePropertySets ( ) { Properties p = new Properties ( ) ; for ( Enumeration e = propertySets . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; p . putAll ( ps . getProperties ( ) ) ; } return p ; } } public CommandlineJava ( ) { setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; setVmversion ( JavaEnvUtils . getJavaVersion ( ) ) ; } public Commandline . Argument createArgument ( ) { return javaCommand . createArgument ( ) ; } public Commandline . Argument createVmArgument ( ) { return vmCommand . createArgument ( ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { sysProperties . addSyspropertyset ( sysp ) ; } public void addSysproperties ( SysProperties sysp ) { sysProperties . addSysproperties ( sysp ) ; } public void setVm ( String vm ) { vmCommand . setExecutable ( vm ) ; } public void setVmversion ( String value ) { vmVersion = value ; } public void setCloneVm ( boolean cloneVm ) { this . cloneVm = cloneVm ; } public Assertions getAssertions ( ) { return assertions ; } public void setAssertions ( Assertions assertions ) { this . assertions = assertions ; } public void setJar ( String jarpathname ) { javaCommand . setExecutable ( jarpathname ) ; executeJar = true ; } public String getJar ( ) { if ( executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public void setClassname ( String classname ) { javaCommand . setExecutable ( classname ) ; executeJar = false ; } public String getClassname ( ) { if ( ! executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public Path createClasspath ( Project p ) { if ( classpath == null ) { classpath = new Path ( p ) ; } return classpath ; } public Path createBootclasspath ( Project p ) { if ( bootclasspath == null ) { bootclasspath = new Path ( p ) ; } return bootclasspath ; } public String getVmversion ( ) { return vmVersion ; } public String [ ] getCommandline ( ) { List commands = new LinkedList ( ) ; final ListIterator listIterator = commands . listIterator ( ) ; addCommandsToList ( listIterator ) ; return ( String [ ] ) commands . toArray ( new String [ commands . size ( ) ] ) ; } private void addCommandsToList ( final ListIterator listIterator ) { getActualVMCommand ( ) . addCommandToList ( listIterator ) ; sysProperties . addDefinitionsToList ( listIterator ) ; if ( isCloneVm ( ) ) { SysProperties clonedSysProperties = new SysProperties ( ) ; PropertySet ps = new PropertySet ( ) ; PropertySet . BuiltinPropertySetName sys = new PropertySet . BuiltinPropertySetName ( ) ; sys . setValue ( "system" ) ; ps . appendBuiltin ( sys ) ; clonedSysProperties . addSyspropertyset ( ps ) ; clonedSysProperties . addDefinitionsToList ( listIterator ) ; } Path bcp = calculateBootclasspath ( true ) ; if ( bcp . size ( ) > 0 ) { listIterator . add ( "-Xbootclasspath:" + bcp . toString ( ) ) ; } if ( haveClasspath ( ) ) { listIterator . add ( "-classpath" ) ; listIterator . add ( classpath . concatSystemClasspath ( "ignore" ) . toString ( ) ) ; } if ( getAssertions ( ) != null ) { getAssertions ( ) . applyAssertions ( listIterator ) ; } if ( executeJar ) { listIterator . add ( "-jar" ) ; } javaCommand . addCommandToList ( listIterator ) ; } public void setMaxmemory ( String max ) { this . maxMemory = max ; } public String toString ( ) { return Commandline . toString ( getCommandline ( ) ) ; } public String describeCommand ( ) { return Commandline . describeCommand ( getCommandline ( ) ) ; } public String describeJavaCommand ( ) { return Commandline . describeCommand ( getJavaCommand ( ) ) ; } protected Commandline getActualVMCommand ( ) { Commandline actualVMCommand = ( Commandline ) vmCommand . clone ( ) ; if ( maxMemory != null ) { if ( vmVersion . startsWith ( "1.1" ) ) { actualVMCommand . createArgument ( ) . setValue ( "-mx" + maxMemory ) ; } else { actualVMCommand . createArgument ( ) . setValue ( "-Xmx" + maxMemory ) ; } } return actualVMCommand ; } public int size ( ) { int size = getActualVMCommand ( ) . size ( ) + javaCommand . size ( ) + sysProperties . size ( ) ; if ( isCloneVm ( ) ) { size += System . getProperties ( ) . size ( ) ; } if ( haveClasspath ( ) ) { size += 2 ; } if ( calculateBootclasspath ( true ) . size ( ) > 0 ) { size ++ ; } if ( executeJar ) { size ++ ; } if ( getAssertions ( ) != null ) { size += getAssertions ( ) . size ( ) ; } return size ; } public Commandline getJavaCommand ( ) { return javaCommand ; } public Commandline getVmCommand ( ) { return getActualVMCommand ( ) ; } public Path getClasspath ( ) { return classpath ; } public Path getBootclasspath ( ) { return bootclasspath ; } public void setSystemProperties ( ) throws BuildException { sysProperties . setSystem ( ) ; } public void restoreSystemProperties ( ) throws BuildException { sysProperties . restoreSystem ( ) ; } public SysProperties getSystemProperties ( ) { return sysProperties ; } public Object clone ( ) throws CloneNotSupportedException { try { CommandlineJava c = ( CommandlineJava ) super . clone ( ) ; c . vmCommand = ( Commandline ) vmCommand . clone ( ) ; c . javaCommand = ( Commandline ) javaCommand . clone ( ) ; c . sysProperties = ( SysProperties ) sysProperties . clone ( ) ; if ( classpath != null ) { c . classpath = ( Path ) classpath . clone ( ) ; } if ( bootclasspath != null ) { c . bootclasspath = ( Path ) bootclasspath . clone ( ) ; } if ( assertions != null ) { c . assertions = ( Assertions ) assertions . clone ( ) ; } return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public void clearJavaArgs ( ) { javaCommand . clearArgs ( ) ; } protected boolean haveClasspath ( ) { Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; return fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ; } protected boolean haveBootclasspath ( boolean log ) { return calculateBootclasspath ( log ) . size ( ) > 0 ; } private Path calculateBootclasspath ( boolean log ) { if ( vmVersion . startsWith ( "1.1" ) ) { if ( bootclasspath != null && log ) { bootclasspath . log ( "Ignoring bootclasspath as " + "the target VM doesn't support it." ) ; } } else { if ( bootclasspath != null ) { return bootclasspath . concatSystemBootClasspath ( isCloneVm ( ) ? "last" : "ignore" ) ; } else if ( isCloneVm ( ) ) { return Path . systemBootClasspath ; } } return new Path ( null ) ; } private boolean isCloneVm ( ) { return cloneVm || "true" . equals ( System . getProperty ( "ant.build.clonevm" ) ) ; } } 	0
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; public final class ClassConstants extends BaseFilterReader implements ChainableReader { private String queuedData = null ; private static final String JAVA_CLASS_HELPER = "org.apache.tools.ant.filters.util.JavaClassHelper" ; public ClassConstants ( ) { super ( ) ; } public ClassConstants ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { final String clazz = readFully ( ) ; if ( clazz == null ) { ch = - 1 ; } else { final byte [ ] bytes = clazz . getBytes ( "ISO-8859-1" ) ; try { final Class javaClassHelper = Class . forName ( JAVA_CLASS_HELPER ) ; if ( javaClassHelper != null ) { final Class [ ] params = { byte [ ] . class } ; final Method getConstants = javaClassHelper . getMethod ( "getConstants" , params ) ; final Object [ ] args = { bytes } ; final StringBuffer sb = ( StringBuffer ) getConstants . invoke ( null , args ) ; if ( sb . length ( ) > 0 ) { queuedData = sb . toString ( ) ; return read ( ) ; } } } catch ( NoClassDefFoundError ex ) { throw ex ; } catch ( RuntimeException ex ) { throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof NoClassDefFoundError ) { throw ( NoClassDefFoundError ) t ; } if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } throw new BuildException ( t ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } return ch ; } public Reader chain ( final Reader rdr ) { ClassConstants newFilter = new ClassConstants ( rdr ) ; return newFilter ; } } 	0
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCLock extends ClearCase { private boolean mReplace = false ; private boolean mObsolete = false ; private String mComment = null ; private String mNusers = null ; private String mPname = null ; private String mObjselect = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_LOCK ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getOpType ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getReplace ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_REPLACE ) ; } if ( getObsolete ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_OBSOLETE ) ; } else { getNusersCommand ( cmd ) ; } getCommentCommand ( cmd ) ; if ( getObjselect ( ) == null && getPname ( ) == null ) { throw new BuildException ( "Should select either an element " + "(pname) or an object (objselect)" ) ; } getPnameCommand ( cmd ) ; if ( getObjselect ( ) != null ) { cmd . createArgument ( ) . setValue ( getObjselect ( ) ) ; } } public void setReplace ( boolean replace ) { mReplace = replace ; } public boolean getReplace ( ) { return mReplace ; } public void setObsolete ( boolean obsolete ) { mObsolete = obsolete ; } public boolean getObsolete ( ) { return mObsolete ; } public void setNusers ( String nusers ) { mNusers = nusers ; } public String getNusers ( ) { return mNusers ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setPname ( String pname ) { mPname = pname ; } public String getPname ( ) { return mPname ; } public void setObjSel ( String objsel ) { mObjselect = objsel ; } public void setObjselect ( String objselect ) { mObjselect = objselect ; } public String getObjselect ( ) { return mObjselect ; } private void getNusersCommand ( Commandline cmd ) { if ( getNusers ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_NUSERS ) ; cmd . createArgument ( ) . setValue ( getNusers ( ) ) ; } } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getPnameCommand ( Commandline cmd ) { if ( getPname ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_PNAME ) ; cmd . createArgument ( ) . setValue ( getPname ( ) ) ; } } private String getOpType ( ) { if ( getPname ( ) != null ) { return getPname ( ) ; } else { return getObjselect ( ) ; } } public static final String FLAG_REPLACE = "-replace" ; public static final String FLAG_NUSERS = "-nusers" ; public static final String FLAG_OBSOLETE = "-obsolete" ; public static final String FLAG_COMMENT = "-comment" ; public static final String FLAG_PNAME = "-pname" ; } 	0
package org . apache . tools . ant . taskdefs ; public class Cvs extends AbstractCvsTask { public Cvs ( ) { } } 	0
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Reference { private String refid ; private Project project ; public Reference ( ) { } public Reference ( String id ) { setRefId ( id ) ; } public Reference ( Project p , String id ) { setRefId ( id ) ; setProject ( p ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public void setProject ( Project p ) { this . project = p ; } public Project getProject ( ) { return project ; } public Object getReferencedObject ( Project fallback ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project == null ? fallback . getReference ( refid ) : project . getReference ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } public Object getReferencedObject ( ) throws BuildException { if ( project == null ) { throw new BuildException ( "No project set on reference to " + refid ) ; } return getReferencedObject ( project ) ; } } 	0
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public final class LineContains extends BaseParamFilterReader implements ChainableReader { private static final String CONTAINS_KEY = "contains" ; private static final String NEGATE_KEY = "negate" ; private Vector contains = new Vector ( ) ; private String line = null ; private boolean negate = false ; public LineContains ( ) { super ( ) ; } public LineContains ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { final int containsSize = contains . size ( ) ; for ( line = readLine ( ) ; line != null ; line = readLine ( ) ) { boolean matches = true ; for ( int i = 0 ; matches && i < containsSize ; i ++ ) { String containsStr = ( String ) contains . elementAt ( i ) ; matches = line . indexOf ( containsStr ) >= 0 ; } if ( matches ^ isNegated ( ) ) { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public void addConfiguredContains ( final Contains contains ) { this . contains . addElement ( contains . getValue ( ) ) ; } public void setNegate ( boolean b ) { negate = b ; } public boolean isNegated ( ) { return negate ; } private void setContains ( final Vector contains ) { this . contains = contains ; } private Vector getContains ( ) { return contains ; } public Reader chain ( final Reader rdr ) { LineContains newFilter = new LineContains ( rdr ) ; newFilter . setContains ( getContains ( ) ) ; newFilter . setNegate ( isNegated ( ) ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( CONTAINS_KEY . equals ( params [ i ] . getType ( ) ) ) { contains . addElement ( params [ i ] . getValue ( ) ) ; } else if ( NEGATE_KEY . equals ( params [ i ] . getType ( ) ) ) { setNegate ( Project . toBoolean ( params [ i ] . getValue ( ) ) ) ; } } } } public static class Contains { private String value ; public final void setValue ( String contains ) { value = contains ; } public final String getValue ( ) { return value ; } } } 	0
package org . apache . tools . ant . taskdefs . optional . junit ; public class Constants { static final String HALT_ON_ERROR = "haltOnError=" ; static final String HALT_ON_FAILURE = "haltOnFailure=" ; static final String FILTERTRACE = "filtertrace=" ; static final String CRASHFILE = "crashfile=" ; static final String BEFORE_FIRST_TEST = "BeforeFirstTest" ; static final String PROPSFILE = "propsfile=" ; static final String SHOWOUTPUT = "showoutput=" ; static final String OUTPUT_TO_FORMATTERS = "outputtoformatters=" ; static final String FORMATTER = "formatter=" ; static final String LOGTESTLISTENEREVENTS = "logtestlistenerevents=" ; static final String TESTSFILE = "testsfile=" ; static final String TERMINATED_SUCCESSFULLY = "terminated successfully" ; } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Available extends Task implements Condition { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String property ; private String classname ; private String filename ; private File file ; private Path filepath ; private String resource ; private FileDir type ; private Path classpath ; private AntClassLoader loader ; private String value = "true" ; private boolean isTask = false ; private boolean ignoreSystemclasses = false ; private boolean searchParents = false ; public void setSearchParents ( boolean searchParents ) { this . searchParents = searchParents ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setFilepath ( Path filepath ) { createFilepath ( ) . append ( filepath ) ; } public Path createFilepath ( ) { if ( this . filepath == null ) { this . filepath = new Path ( getProject ( ) ) ; } return this . filepath . createPath ( ) ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public void setClassname ( String classname ) { if ( ! "" . equals ( classname ) ) { this . classname = classname ; } } public void setFile ( File file ) { this . file = file ; this . filename = FILE_UTILS . removeLeadingPath ( getProject ( ) . getBaseDir ( ) , file ) ; } public void setResource ( String resource ) { this . resource = resource ; } public void setType ( String type ) { log ( "DEPRECATED - The setType(String) method has been deprecated." + " Use setType(Available.FileDir) instead." , Project . MSG_WARN ) ; this . type = new FileDir ( ) ; this . type . setValue ( type ) ; } public void setType ( FileDir type ) { this . type = type ; } public void setIgnoresystemclasses ( boolean ignore ) { this . ignoreSystemclasses = ignore ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required" , getLocation ( ) ) ; } isTask = true ; try { if ( eval ( ) ) { String oldvalue = getProject ( ) . getProperty ( property ) ; if ( null != oldvalue && ! oldvalue . equals ( value ) ) { log ( "DEPRECATED - <available> used to override an existing" + " property." + StringUtils . LINE_SEP + "  Build file should not reuse the same property" + " name for different values." , Project . MSG_WARN ) ; } getProject ( ) . setProperty ( property , value ) ; } } finally { isTask = false ; } } public boolean eval ( ) throws BuildException { try { if ( classname == null && file == null && resource == null ) { throw new BuildException ( "At least one of (classname|file|" + "resource) is required" , getLocation ( ) ) ; } if ( type != null ) { if ( file == null ) { throw new BuildException ( "The type attribute is only valid " + "when specifying the file " + "attribute." , getLocation ( ) ) ; } } if ( classpath != null ) { classpath . setProject ( getProject ( ) ) ; this . loader = getProject ( ) . createClassLoader ( classpath ) ; } String appendix = "" ; if ( isTask ) { appendix = " to set property " + property ; } else { setTaskName ( "available" ) ; } if ( ( classname != null ) && ! checkClass ( classname ) ) { log ( "Unable to load class " + classname + appendix , Project . MSG_VERBOSE ) ; return false ; } if ( ( file != null ) && ! checkFile ( ) ) { StringBuffer buf = new StringBuffer ( "Unable to find " ) ; if ( type != null ) { buf . append ( type ) . append ( ' ' ) ; } buf . append ( filename ) . append ( appendix ) ; log ( buf . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } if ( ( resource != null ) && ! checkResource ( resource ) ) { log ( "Unable to load resource " + resource + appendix , Project . MSG_VERBOSE ) ; return false ; } } finally { if ( loader != null ) { loader . cleanup ( ) ; loader = null ; } if ( ! isTask ) { setTaskName ( null ) ; } } return true ; } private boolean checkFile ( ) { if ( filepath == null ) { return checkFile ( file , filename ) ; } else { String [ ] paths = filepath . list ( ) ; for ( int i = 0 ; i < paths . length ; ++ i ) { log ( "Searching " + paths [ i ] , Project . MSG_DEBUG ) ; File path = new File ( paths [ i ] ) ; if ( path . exists ( ) && filename . equals ( paths [ i ] ) ) { if ( type == null ) { log ( "Found: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) && path . isDirectory ( ) ) { log ( "Found directory: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isFile ( ) && path . isFile ( ) ) { log ( "Found file: " + path , Project . MSG_VERBOSE ) ; return true ; } return false ; } File parent = path . getParentFile ( ) ; if ( parent != null && parent . exists ( ) && filename . equals ( parent . getAbsolutePath ( ) ) ) { if ( type == null ) { log ( "Found: " + parent , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) ) { log ( "Found directory: " + parent , Project . MSG_VERBOSE ) ; return true ; } return false ; } if ( path . exists ( ) && path . isDirectory ( ) ) { if ( checkFile ( new File ( path , filename ) , filename + " in " + path ) ) { return true ; } } while ( searchParents && parent != null && parent . exists ( ) ) { if ( checkFile ( new File ( parent , filename ) , filename + " in " + parent ) ) { return true ; } parent = parent . getParentFile ( ) ; } } } return false ; } private boolean checkFile ( File f , String text ) { if ( type != null ) { if ( type . isDir ( ) ) { if ( f . isDirectory ( ) ) { log ( "Found directory: " + text , Project . MSG_VERBOSE ) ; } return f . isDirectory ( ) ; } else if ( type . isFile ( ) ) { if ( f . isFile ( ) ) { log ( "Found file: " + text , Project . MSG_VERBOSE ) ; } return f . isFile ( ) ; } } if ( f . exists ( ) ) { log ( "Found: " + text , Project . MSG_VERBOSE ) ; } return f . exists ( ) ; } private boolean checkResource ( String resource ) { if ( loader != null ) { return ( loader . getResourceAsStream ( resource ) != null ) ; } else { ClassLoader cL = this . getClass ( ) . getClassLoader ( ) ; if ( cL != null ) { return ( cL . getResourceAsStream ( resource ) != null ) ; } else { return ( ClassLoader . getSystemResourceAsStream ( resource ) != null ) ; } } } private boolean checkClass ( String classname ) { try { if ( ignoreSystemclasses ) { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; if ( loader != null ) { try { loader . findClass ( classname ) ; } catch ( SecurityException se ) { return true ; } } else { return false ; } } else if ( loader != null ) { loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { Class . forName ( classname , true , l ) ; } else { Class . forName ( classname ) ; } } return true ; } catch ( ClassNotFoundException e ) { log ( "class \"" + classname + "\" was not found" , Project . MSG_DEBUG ) ; return false ; } catch ( NoClassDefFoundError e ) { log ( "Could not load dependent class \"" + e . getMessage ( ) + "\" for class \"" + classname + "\"" , Project . MSG_DEBUG ) ; return false ; } } public static class FileDir extends EnumeratedAttribute { private static final String [ ] VALUES = { "file" , "dir" } ; public String [ ] getValues ( ) { return VALUES ; } public boolean isDir ( ) { return "dir" . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFile ( ) { return "file" . equalsIgnoreCase ( getValue ( ) ) ; } } } 	1
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class TypeSelector extends BaseExtendSelector { private String type = null ; public static final String TYPE_KEY = "type" ; public TypeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{typeselector type: " ) ; buf . append ( type ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setType ( FileType fileTypes ) { this . type = fileTypes . getValue ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( TYPE_KEY . equalsIgnoreCase ( paramname ) ) { FileType t = new FileType ( ) ; t . setValue ( parameters [ i ] . getValue ( ) ) ; setType ( t ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( type == null ) { setError ( "The type attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return type . equals ( FileType . DIR ) ; } else { return type . equals ( FileType . FILE ) ; } } public static class FileType extends EnumeratedAttribute { public static final String FILE = "file" ; public static final String DIR = "dir" ; public String [ ] getValues ( ) { return new String [ ] { FILE , DIR } ; } } } 	0
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Sleep extends Task { private boolean failOnError = true ; private int seconds = 0 ; private int hours = 0 ; private int minutes = 0 ; private int milliseconds = 0 ; public Sleep ( ) { } public void setSeconds ( int seconds ) { this . seconds = seconds ; } public void setHours ( int hours ) { this . hours = hours ; } public void setMinutes ( int minutes ) { this . minutes = minutes ; } public void setMilliseconds ( int milliseconds ) { this . milliseconds = milliseconds ; } public void doSleep ( long millis ) { try { Thread . sleep ( millis ) ; } catch ( InterruptedException ie ) { } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } private long getSleepTime ( ) { return ( ( ( ( long ) hours * 60 ) + minutes ) * 60 + seconds ) * 1000 + milliseconds ; } public void validate ( ) throws BuildException { if ( getSleepTime ( ) < 0 ) { throw new BuildException ( "Negative sleep periods are not " + "supported" ) ; } } public void execute ( ) throws BuildException { try { validate ( ) ; long sleepTime = getSleepTime ( ) ; log ( "sleeping for " + sleepTime + " milliseconds" , Project . MSG_VERBOSE ) ; doSleep ( sleepTime ) ; } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e ) ; } else { String text = e . toString ( ) ; log ( text , Project . MSG_ERR ) ; } } } } 	0
package org . apache . tools . ant . types . resources . comparators ; import java . util . Comparator ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Resource ; public abstract class ResourceComparator extends DataType implements Comparator { public final int compare ( Object foo , Object bar ) { dieOnCircularReference ( ) ; ResourceComparator c = isReference ( ) ? ( ResourceComparator ) getCheckedRef ( ) : this ; return c . resourceCompare ( ( Resource ) foo , ( Resource ) bar ) ; } public boolean equals ( Object o ) { if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( o ) ; } if ( o == null ) { return false ; } return o == this || o . getClass ( ) . equals ( getClass ( ) ) ; } public synchronized int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return getClass ( ) . hashCode ( ) ; } protected abstract int resourceCompare ( Resource foo , Resource bar ) ; } 	0
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Type extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { boolean f = foo . isDirectory ( ) ; if ( f == bar . isDirectory ( ) ) { return 0 ; } return f ? 1 : - 1 ; } } 	0
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class TabsToSpaces extends BaseParamFilterReader implements ChainableReader { private static final int DEFAULT_TAB_LENGTH = 8 ; private static final String TAB_LENGTH_KEY = "tablength" ; private int tabLength = DEFAULT_TAB_LENGTH ; private int spacesRemaining = 0 ; public TabsToSpaces ( ) { super ( ) ; } public TabsToSpaces ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( spacesRemaining > 0 ) { spacesRemaining -- ; ch = ' ' ; } else { ch = in . read ( ) ; if ( ch == '\t' ) { spacesRemaining = tabLength - 1 ; ch = ' ' ; } } return ch ; } public void setTablength ( final int tabLength ) { this . tabLength = tabLength ; } private int getTablength ( ) { return tabLength ; } public Reader chain ( final Reader rdr ) { TabsToSpaces newFilter = new TabsToSpaces ( rdr ) ; newFilter . setTablength ( getTablength ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { if ( TAB_LENGTH_KEY . equals ( params [ i ] . getName ( ) ) ) { tabLength = new Integer ( params [ i ] . getValue ( ) ) . intValue ( ) ; break ; } } } } } } 	0
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jikes extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jikes compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; Path sourcepath = null ; if ( compileSourcepath != null ) { sourcepath = compileSourcepath ; } else { sourcepath = src ; } if ( sourcepath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( sourcepath ) ; } Path classpath = new Path ( project ) ; if ( bootclasspath == null || bootclasspath . size ( ) == 0 ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; String jikesPath = System . getProperty ( "jikes.class.path" ) ; if ( jikesPath != null ) { classpath . append ( new Path ( project , jikesPath ) ) ; } if ( extdirs != null && extdirs . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jikes" : exec ) ; if ( deprecation ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { String debugLevel = attributes . getDebugLevel ( ) ; if ( debugLevel != null ) { cmd . createArgument ( ) . setValue ( "-g:" + debugLevel ) ; } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else { cmd . createArgument ( ) . setValue ( "-g:none" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( depend ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } String emacsProperty = project . getProperty ( "build.compiler.emacs" ) ; if ( emacsProperty != null && Project . toBoolean ( emacsProperty ) ) { cmd . createArgument ( ) . setValue ( "+E" ) ; } String warningsProperty = project . getProperty ( "build.compiler.warnings" ) ; if ( warningsProperty != null ) { attributes . log ( "!! the build.compiler.warnings property is " + "deprecated. !!" , Project . MSG_WARN ) ; attributes . log ( "!! Use the nowarn attribute instead. !!" , Project . MSG_WARN ) ; if ( ! Project . toBoolean ( warningsProperty ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } String pedanticProperty = project . getProperty ( "build.compiler.pedantic" ) ; if ( pedanticProperty != null && Project . toBoolean ( pedanticProperty ) ) { cmd . createArgument ( ) . setValue ( "+P" ) ; } String fullDependProperty = project . getProperty ( "build.compiler.fulldepend" ) ; if ( fullDependProperty != null && Project . toBoolean ( fullDependProperty ) ) { cmd . createArgument ( ) . setValue ( "+F" ) ; } if ( attributes . getSource ( ) != null ) { cmd . createArgument ( ) . setValue ( "-source" ) ; String source = attributes . getSource ( ) ; if ( source . equals ( "1.1" ) || source . equals ( "1.2" ) ) { attributes . log ( "Jikes doesn't support '-source " + source + "', will use '-source 1.3' instead" ) ; cmd . createArgument ( ) . setValue ( "1.3" ) ; } else { cmd . createArgument ( ) . setValue ( source ) ; } } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; Path boot = getBootClassPath ( ) ; if ( boot . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( boot ) ; } logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0
package org . apache . tools . ant . types ; import java . util . Iterator ; public interface ResourceCollection { Iterator iterator ( ) ; int size ( ) ; boolean isFilesystemOnly ( ) ; } 	0
package org . apache . tools . ant . util ; import java . util . Stack ; public class IdentityStack extends Stack { public static IdentityStack getInstance ( Stack s ) { if ( s instanceof IdentityStack ) { return ( IdentityStack ) s ; } IdentityStack result = new IdentityStack ( ) ; if ( s != null ) { result . addAll ( s ) ; } return result ; } public IdentityStack ( ) { } public IdentityStack ( Object o ) { super ( ) ; push ( o ) ; } public synchronized boolean contains ( Object o ) { return indexOf ( o ) >= 0 ; } public synchronized int indexOf ( Object o , int pos ) { for ( int i = pos ; i < size ( ) ; i ++ ) { if ( get ( i ) == o ) { return i ; } } return - 1 ; } public synchronized int lastIndexOf ( Object o , int pos ) { for ( int i = pos ; i >= 0 ; i -- ) { if ( get ( i ) == o ) { return i ; } } return - 1 ; } } 	0
package org . apache . tools . ant ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . io . IOException ; import org . apache . tools . ant . taskdefs . PreSetDef ; public class UnknownElement extends Task { private String elementName ; private String namespace = "" ; private String qname ; private Object realThing ; private List children = null ; private boolean presetDefed = false ; public UnknownElement ( String elementName ) { this . elementName = elementName ; } public List getChildren ( ) { return children ; } public String getTag ( ) { return elementName ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { if ( namespace . equals ( ProjectHelper . ANT_CURRENT_URI ) ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; namespace = helper . getCurrentAntlibUri ( ) ; } this . namespace = namespace == null ? "" : namespace ; } public String getQName ( ) { return qname ; } public void setQName ( String qname ) { this . qname = qname ; } public RuntimeConfigurable getWrapper ( ) { return super . getWrapper ( ) ; } public void maybeConfigure ( ) throws BuildException { if ( realThing != null ) { return ; } configure ( makeObject ( this , getWrapper ( ) ) ) ; } public void configure ( Object realObject ) { realThing = realObject ; getWrapper ( ) . setProxy ( realThing ) ; Task task = null ; if ( realThing instanceof Task ) { task = ( Task ) realThing ; task . setRuntimeConfigurableWrapper ( getWrapper ( ) ) ; if ( getWrapper ( ) . getId ( ) != null ) { this . getOwningTarget ( ) . replaceChild ( this , ( Task ) realThing ) ; } } if ( task != null ) { task . maybeConfigure ( ) ; } else { getWrapper ( ) . maybeConfigure ( getProject ( ) ) ; } handleChildren ( realThing , getWrapper ( ) ) ; } protected void handleOutput ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( realThing instanceof Task ) { return ( ( Task ) realThing ) . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } protected void handleFlush ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } protected void handleErrorOutput ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } protected void handleErrorFlush ( String output ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void execute ( ) { if ( realThing == null ) { throw new BuildException ( "Could not create task of type: " + elementName , getLocation ( ) ) ; } if ( realThing instanceof Task ) { ( ( Task ) realThing ) . execute ( ) ; } realThing = null ; getWrapper ( ) . setProxy ( null ) ; } public void addChild ( UnknownElement child ) { if ( children == null ) { children = new ArrayList ( ) ; } children . add ( child ) ; } protected void handleChildren ( Object parent , RuntimeConfigurable parentWrapper ) throws BuildException { if ( parent instanceof TypeAdapter ) { parent = ( ( TypeAdapter ) parent ) . getProxy ( ) ; } String parentUri = getNamespace ( ) ; Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( getProject ( ) , parentClass ) ; if ( children != null ) { Iterator it = children . iterator ( ) ; for ( int i = 0 ; it . hasNext ( ) ; i ++ ) { RuntimeConfigurable childWrapper = parentWrapper . getChild ( i ) ; UnknownElement child = ( UnknownElement ) it . next ( ) ; try { if ( ! handleChild ( parentUri , ih , parent , child , childWrapper ) ) { if ( ! ( parent instanceof TaskContainer ) ) { ih . throwNotSupported ( getProject ( ) , parent , child . getTag ( ) ) ; } else { TaskContainer container = ( TaskContainer ) parent ; container . addTask ( child ) ; } } } catch ( UnsupportedElementException ex ) { throw new BuildException ( parentWrapper . getElementTag ( ) + " doesn't support the nested \"" + ex . getElement ( ) + "\" element." , ex ) ; } } } } protected String getComponentName ( ) { return ProjectHelper . genComponentName ( getNamespace ( ) , getTag ( ) ) ; } public void applyPreSet ( UnknownElement u ) { if ( presetDefed ) { return ; } getWrapper ( ) . applyPreSet ( u . getWrapper ( ) ) ; if ( u . children != null ) { List newChildren = new ArrayList ( ) ; newChildren . addAll ( u . children ) ; if ( children != null ) { newChildren . addAll ( children ) ; } children = newChildren ; } presetDefed = true ; } protected Object makeObject ( UnknownElement ue , RuntimeConfigurable w ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String name = ue . getComponentName ( ) ; Object o = helper . createComponent ( ue , ue . getNamespace ( ) , name ) ; if ( o == null ) { throw getNotFoundException ( "task or type" , name ) ; } if ( o instanceof PreSetDef . PreSetDefinition ) { PreSetDef . PreSetDefinition def = ( PreSetDef . PreSetDefinition ) o ; o = def . createObject ( ue . getProject ( ) ) ; if ( o == null ) { throw getNotFoundException ( "preset " + name , def . getPreSets ( ) . getComponentName ( ) ) ; } ue . applyPreSet ( def . getPreSets ( ) ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . setTaskType ( ue . getTaskType ( ) ) ; task . setTaskName ( ue . getTaskName ( ) ) ; task . init ( ) ; } } if ( o instanceof UnknownElement ) { o = ( ( UnknownElement ) o ) . makeObject ( ( UnknownElement ) o , w ) ; } if ( o instanceof Task ) { ( ( Task ) o ) . setOwningTarget ( getOwningTarget ( ) ) ; } if ( o instanceof ProjectComponent ) { ( ( ProjectComponent ) o ) . setLocation ( getLocation ( ) ) ; } return o ; } protected Task makeTask ( UnknownElement ue , RuntimeConfigurable w ) { Task task = getProject ( ) . createTask ( ue . getTag ( ) ) ; if ( task != null ) { task . setLocation ( getLocation ( ) ) ; task . setOwningTarget ( getOwningTarget ( ) ) ; task . init ( ) ; } return task ; } protected BuildException getNotFoundException ( String what , String name ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String msg = helper . diagnoseCreationFailure ( name , what ) ; return new BuildException ( msg , getLocation ( ) ) ; } public String getTaskName ( ) { return realThing == null || ! ( realThing instanceof Task ) ? super . getTaskName ( ) : ( ( Task ) realThing ) . getTaskName ( ) ; } public Task getTask ( ) { if ( realThing instanceof Task ) { return ( Task ) realThing ; } return null ; } public Object getRealThing ( ) { return realThing ; } public void setRealThing ( Object realThing ) { this . realThing = realThing ; } private boolean handleChild ( String parentUri , IntrospectionHelper ih , Object parent , UnknownElement child , RuntimeConfigurable childWrapper ) { String childName = ProjectHelper . genComponentName ( child . getNamespace ( ) , child . getTag ( ) ) ; if ( ih . supportsNestedElement ( parentUri , childName ) ) { IntrospectionHelper . Creator creator = ih . getElementCreator ( getProject ( ) , parentUri , parent , childName , child ) ; creator . setPolyType ( childWrapper . getPolyType ( ) ) ; Object realChild = creator . create ( ) ; if ( realChild instanceof PreSetDef . PreSetDefinition ) { PreSetDef . PreSetDefinition def = ( PreSetDef . PreSetDefinition ) realChild ; realChild = creator . getRealObject ( ) ; child . applyPreSet ( def . getPreSets ( ) ) ; } childWrapper . setCreator ( creator ) ; childWrapper . setProxy ( realChild ) ; if ( realChild instanceof Task ) { Task childTask = ( Task ) realChild ; childTask . setRuntimeConfigurableWrapper ( childWrapper ) ; childTask . setTaskName ( childName ) ; childTask . setTaskType ( childName ) ; } if ( realChild instanceof ProjectComponent ) { ( ( ProjectComponent ) realChild ) . setLocation ( child . getLocation ( ) ) ; } childWrapper . maybeConfigure ( getProject ( ) ) ; child . handleChildren ( realChild , childWrapper ) ; creator . store ( ) ; return true ; } return false ; } public boolean similar ( Object obj ) { if ( obj == null ) { return false ; } if ( ! getClass ( ) . getName ( ) . equals ( obj . getClass ( ) . getName ( ) ) ) { return false ; } UnknownElement other = ( UnknownElement ) obj ; if ( ! equalsString ( elementName , other . elementName ) ) { return false ; } if ( ! namespace . equals ( other . namespace ) ) { return false ; } if ( ! qname . equals ( other . qname ) ) { return false ; } if ( ! getWrapper ( ) . getAttributeMap ( ) . equals ( other . getWrapper ( ) . getAttributeMap ( ) ) ) { return false ; } if ( ! getWrapper ( ) . getText ( ) . toString ( ) . equals ( other . getWrapper ( ) . getText ( ) . toString ( ) ) ) { return false ; } if ( children == null || children . size ( ) == 0 ) { return other . children == null || other . children . size ( ) == 0 ; } if ( other . children == null ) { return false ; } if ( children . size ( ) != other . children . size ( ) ) { return false ; } for ( int i = 0 ; i < children . size ( ) ; ++ i ) { UnknownElement child = ( UnknownElement ) children . get ( i ) ; if ( ! child . similar ( other . children . get ( i ) ) ) { return false ; } } return true ; } private static boolean equalsString ( String a , String b ) { return ( a == null ) ? ( b == null ) : a . equals ( b ) ; } public UnknownElement copy ( Project newProject ) { UnknownElement ret = new UnknownElement ( getTag ( ) ) ; ret . setNamespace ( getNamespace ( ) ) ; ret . setProject ( newProject ) ; ret . setQName ( getQName ( ) ) ; ret . setTaskType ( getTaskType ( ) ) ; ret . setTaskName ( getTaskName ( ) ) ; ret . setLocation ( getLocation ( ) ) ; if ( getOwningTarget ( ) == null ) { Target t = new Target ( ) ; t . setProject ( getProject ( ) ) ; ret . setOwningTarget ( t ) ; } else { ret . setOwningTarget ( getOwningTarget ( ) ) ; } RuntimeConfigurable copyRC = new RuntimeConfigurable ( ret , getTaskName ( ) ) ; copyRC . setPolyType ( getWrapper ( ) . getPolyType ( ) ) ; Map m = getWrapper ( ) . getAttributeMap ( ) ; for ( Iterator i = m . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; copyRC . setAttribute ( ( String ) entry . getKey ( ) , ( String ) entry . getValue ( ) ) ; } copyRC . addText ( getWrapper ( ) . getText ( ) . toString ( ) ) ; for ( Enumeration e = getWrapper ( ) . getChildren ( ) ; e . hasMoreElements ( ) ; ) { RuntimeConfigurable r = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement ueChild = ( UnknownElement ) r . getProxy ( ) ; UnknownElement copyChild = ueChild . copy ( newProject ) ; copyRC . addChild ( copyChild . getWrapper ( ) ) ; ret . addChild ( copyChild ) ; } return ret ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . security . DigestInputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . NoSuchProviderException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileInputStream ; import java . io . FileReader ; import java . io . BufferedReader ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Iterator ; import java . util . Hashtable ; import java . util . Enumeration ; import java . util . Set ; import java . util . Arrays ; import java . text . MessageFormat ; import java . text . ParseException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . Type ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Checksum extends MatchingTask implements Condition { private static class FileUnion extends Restrict { private Union u ; FileUnion ( ) { u = new Union ( ) ; super . add ( u ) ; super . add ( Type . FILE ) ; } public void add ( ResourceCollection rc ) { u . add ( rc ) ; } } private File file = null ; private File todir ; private String algorithm = "MD5" ; private String provider = null ; private String fileext ; private String property ; private Map allDigests = new HashMap ( ) ; private Map relativeFilePaths = new HashMap ( ) ; private String totalproperty ; private boolean forceOverwrite ; private String verifyProperty ; private FileUnion resources = null ; private Hashtable includeFileMap = new Hashtable ( ) ; private MessageDigest messageDigest ; private boolean isCondition ; private int readBufferSize = 8 * 1024 ; private MessageFormat format = FormatElement . getDefault ( ) . getFormat ( ) ; public void setFile ( File file ) { this . file = file ; } public void setTodir ( File todir ) { this . todir = todir ; } public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void setProvider ( String provider ) { this . provider = provider ; } public void setFileext ( String fileext ) { this . fileext = fileext ; } public void setProperty ( String property ) { this . property = property ; } public void setTotalproperty ( String totalproperty ) { this . totalproperty = totalproperty ; } public void setVerifyproperty ( String verifyProperty ) { this . verifyProperty = verifyProperty ; } public void setForceOverwrite ( boolean forceOverwrite ) { this . forceOverwrite = forceOverwrite ; } public void setReadBufferSize ( int size ) { this . readBufferSize = size ; } public void setFormat ( FormatElement e ) { format = e . getFormat ( ) ; } public void setPattern ( String p ) { format = new MessageFormat ( p ) ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { if ( rc == null ) { return ; } resources = ( resources == null ) ? new FileUnion ( ) : resources ; resources . add ( rc ) ; } public void execute ( ) throws BuildException { isCondition = false ; boolean value = validateAndExecute ( ) ; if ( verifyProperty != null ) { getProject ( ) . setNewProperty ( verifyProperty , ( value ? Boolean . TRUE . toString ( ) : Boolean . FALSE . toString ( ) ) ) ; } } public boolean eval ( ) throws BuildException { isCondition = true ; return validateAndExecute ( ) ; } private boolean validateAndExecute ( ) throws BuildException { String savedFileExt = fileext ; if ( file == null && ( resources == null || resources . size ( ) == 0 ) ) { throw new BuildException ( "Specify at least one source - a file or a resource collection." ) ; } if ( ! ( resources == null || resources . isFilesystemOnly ( ) ) ) { throw new BuildException ( "Can only calculate checksums for file-based resources." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Checksum cannot be generated for directories" ) ; } if ( file != null && totalproperty != null ) { throw new BuildException ( "File and Totalproperty cannot co-exist." ) ; } if ( property != null && fileext != null ) { throw new BuildException ( "Property and FileExt cannot co-exist." ) ; } if ( property != null ) { if ( forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when Property is specified" ) ; } int ct = 0 ; if ( resources != null ) { ct += resources . size ( ) ; } if ( file != null ) { ct ++ ; } if ( ct > 1 ) { throw new BuildException ( "Multiple files cannot be used when Property is specified" ) ; } } if ( verifyProperty != null ) { isCondition = true ; } if ( verifyProperty != null && forceOverwrite ) { throw new BuildException ( "VerifyProperty and ForceOverwrite cannot co-exist." ) ; } if ( isCondition && forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when conditions are being used." ) ; } messageDigest = null ; if ( provider != null ) { try { messageDigest = MessageDigest . getInstance ( algorithm , provider ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , getLocation ( ) ) ; } catch ( NoSuchProviderException noprovider ) { throw new BuildException ( noprovider , getLocation ( ) ) ; } } else { try { messageDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , getLocation ( ) ) ; } } if ( messageDigest == null ) { throw new BuildException ( "Unable to create Message Digest" , getLocation ( ) ) ; } if ( fileext == null ) { fileext = "." + algorithm ; } else if ( fileext . trim ( ) . length ( ) == 0 ) { throw new BuildException ( "File extension when specified must not be an empty string" ) ; } try { if ( resources != null ) { for ( Iterator i = resources . iterator ( ) ; i . hasNext ( ) ; ) { FileResource fr = ( FileResource ) i . next ( ) ; File src = fr . getFile ( ) ; if ( totalproperty != null || todir != null ) { relativeFilePaths . put ( src , fr . getName ( ) . replace ( File . separatorChar , '/' ) ) ; } addToIncludeFileMap ( src ) ; } } if ( file != null ) { if ( totalproperty != null || todir != null ) { relativeFilePaths . put ( file , file . getName ( ) . replace ( File . separatorChar , '/' ) ) ; } addToIncludeFileMap ( file ) ; } return generateChecksums ( ) ; } finally { fileext = savedFileExt ; includeFileMap . clear ( ) ; } } private void addToIncludeFileMap ( File file ) throws BuildException { if ( file . exists ( ) ) { if ( property == null ) { File checksumFile = getChecksumFile ( file ) ; if ( forceOverwrite || isCondition || ( file . lastModified ( ) > checksumFile . lastModified ( ) ) ) { includeFileMap . put ( file , checksumFile ) ; } else { log ( file + " omitted as " + checksumFile + " is up to date." , Project . MSG_VERBOSE ) ; if ( totalproperty != null ) { String checksum = readChecksum ( checksumFile ) ; byte [ ] digest = decodeHex ( checksum . toCharArray ( ) ) ; allDigests . put ( file , digest ) ; } } } else { includeFileMap . put ( file , property ) ; } } else { String message = "Could not find file " + file . getAbsolutePath ( ) + " to generate checksum for." ; log ( message ) ; throw new BuildException ( message , getLocation ( ) ) ; } } private File getChecksumFile ( File file ) { File directory ; if ( todir != null ) { String path = ( String ) relativeFilePaths . get ( file ) ; if ( path == null ) { throw new BuildException ( "Internal error: " + "relativeFilePaths could not match file" + file + "\n" + "please file a bug report on this" ) ; } directory = new File ( todir , path ) . getParentFile ( ) ; directory . mkdirs ( ) ; } else { directory = file . getParentFile ( ) ; } File checksumFile = new File ( directory , file . getName ( ) + fileext ) ; return checksumFile ; } private boolean generateChecksums ( ) throws BuildException { boolean checksumMatches = true ; FileInputStream fis = null ; FileOutputStream fos = null ; byte [ ] buf = new byte [ readBufferSize ] ; try { for ( Enumeration e = includeFileMap . keys ( ) ; e . hasMoreElements ( ) ; ) { messageDigest . reset ( ) ; File src = ( File ) e . nextElement ( ) ; if ( ! isCondition ) { log ( "Calculating " + algorithm + " checksum for " + src , Project . MSG_VERBOSE ) ; } fis = new FileInputStream ( src ) ; DigestInputStream dis = new DigestInputStream ( fis , messageDigest ) ; while ( dis . read ( buf , 0 , readBufferSize ) != - 1 ) { } dis . close ( ) ; fis . close ( ) ; fis = null ; byte [ ] fileDigest = messageDigest . digest ( ) ; if ( totalproperty != null ) { allDigests . put ( src , fileDigest ) ; } String checksum = createDigestString ( fileDigest ) ; Object destination = includeFileMap . get ( src ) ; if ( destination instanceof java . lang . String ) { String prop = ( String ) destination ; if ( isCondition ) { checksumMatches = checksumMatches && checksum . equals ( property ) ; } else { getProject ( ) . setNewProperty ( prop , checksum ) ; } } else if ( destination instanceof java . io . File ) { if ( isCondition ) { File existingFile = ( File ) destination ; if ( existingFile . exists ( ) ) { try { String suppliedChecksum = readChecksum ( existingFile ) ; checksumMatches = checksumMatches && checksum . equals ( suppliedChecksum ) ; } catch ( BuildException be ) { checksumMatches = false ; } } else { checksumMatches = false ; } } else { File dest = ( File ) destination ; fos = new FileOutputStream ( dest ) ; fos . write ( format . format ( new Object [ ] { checksum , src . getName ( ) , } ) . getBytes ( ) ) ; fos . write ( StringUtils . LINE_SEP . getBytes ( ) ) ; fos . close ( ) ; fos = null ; } } } if ( totalproperty != null ) { Set keys = allDigests . keySet ( ) ; Object [ ] keyArray = keys . toArray ( ) ; Arrays . sort ( keyArray ) ; messageDigest . reset ( ) ; for ( int i = 0 ; i < keyArray . length ; i ++ ) { File src = ( File ) keyArray [ i ] ; byte [ ] digest = ( byte [ ] ) allDigests . get ( src ) ; messageDigest . update ( digest ) ; String fileName = ( String ) relativeFilePaths . get ( src ) ; messageDigest . update ( fileName . getBytes ( ) ) ; } String totalChecksum = createDigestString ( messageDigest . digest ( ) ) ; getProject ( ) . setNewProperty ( totalproperty , totalChecksum ) ; } } catch ( Exception e ) { throw new BuildException ( e , getLocation ( ) ) ; } finally { FileUtils . close ( fis ) ; FileUtils . close ( fos ) ; } return checksumMatches ; } private String createDigestString ( byte [ ] fileDigest ) { StringBuffer checksumSb = new StringBuffer ( ) ; for ( int i = 0 ; i < fileDigest . length ; i ++ ) { String hexStr = Integer . toHexString ( 0x00ff & fileDigest [ i ] ) ; if ( hexStr . length ( ) < 2 ) { checksumSb . append ( "0" ) ; } checksumSb . append ( hexStr ) ; } return checksumSb . toString ( ) ; } public static byte [ ] decodeHex ( char [ ] data ) throws BuildException { int l = data . length ; if ( ( l & 0x01 ) != 0 ) { throw new BuildException ( "odd number of characters." ) ; } byte [ ] out = new byte [ l > > 1 ] ; for ( int i = 0 , j = 0 ; j < l ; i ++ ) { int f = Character . digit ( data [ j ++ ] , 16 ) << 4 ; f = f | Character . digit ( data [ j ++ ] , 16 ) ; out [ i ] = ( byte ) ( f & 0xFF ) ; } return out ; } private String readChecksum ( File f ) { BufferedReader diskChecksumReader = null ; try { diskChecksumReader = new BufferedReader ( new FileReader ( f ) ) ; Object [ ] result = format . parse ( diskChecksumReader . readLine ( ) ) ; if ( result == null || result . length == 0 || result [ 0 ] == null ) { throw new BuildException ( "failed to find a checksum" ) ; } return ( String ) result [ 0 ] ; } catch ( IOException e ) { throw new BuildException ( "Couldn't read checksum file " + f , e ) ; } catch ( ParseException e ) { throw new BuildException ( "Couldn't read checksum file " + f , e ) ; } finally { FileUtils . close ( diskChecksumReader ) ; } } public static class FormatElement extends EnumeratedAttribute { private static HashMap formatMap = new HashMap ( ) ; private static final String CHECKSUM = "CHECKSUM" ; private static final String MD5SUM = "MD5SUM" ; private static final String SVF = "SVF" ; static { formatMap . put ( CHECKSUM , new MessageFormat ( "{0}" ) ) ; formatMap . put ( MD5SUM , new MessageFormat ( "{0} *{1}" ) ) ; formatMap . put ( SVF , new MessageFormat ( "MD5 ({1}) = {0}" ) ) ; } public FormatElement ( ) { super ( ) ; } public static FormatElement getDefault ( ) { FormatElement e = new FormatElement ( ) ; e . setValue ( CHECKSUM ) ; return e ; } public MessageFormat getFormat ( ) { return ( MessageFormat ) formatMap . get ( getValue ( ) ) ; } public String [ ] getValues ( ) { return new String [ ] { CHECKSUM , MD5SUM , SVF } ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . jar . JarOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public class WebsphereDeploymentTool extends GenericDeploymentTool { public static final String PUBLICID_EJB11 = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN" ; public static final String PUBLICID_EJB20 = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN" ; protected static final String SCHEMA_DIR = "Schema/" ; protected static final String WAS_EXT = "ibm-ejb-jar-ext.xmi" ; protected static final String WAS_BND = "ibm-ejb-jar-bnd.xmi" ; protected static final String WAS_CMP_MAP = "Map.mapxmi" ; protected static final String WAS_CMP_SCHEMA = "Schema.dbxmi" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String jarSuffix = ".jar" ; private String ejb11DTD ; private boolean keepGeneric = false ; private boolean alwaysRebuild = true ; private boolean ejbdeploy = true ; private boolean newCMP = false ; private Path wasClasspath = null ; private String dbVendor ; private String dbName ; private String dbSchema ; private boolean codegen ; private boolean quiet = true ; private boolean novalidate ; private boolean nowarn ; private boolean noinform ; private boolean trace ; private String rmicOptions ; private boolean use35MappingRules ; private String tempdir = "_ejbdeploy_temp" ; private File websphereHome ; public Path createWASClasspath ( ) { if ( wasClasspath == null ) { wasClasspath = new Path ( getTask ( ) . getProject ( ) ) ; } return wasClasspath . createPath ( ) ; } public void setWASClasspath ( Path wasClasspath ) { this . wasClasspath = wasClasspath ; } public void setDbvendor ( String dbvendor ) { this . dbVendor = dbvendor ; } public void setDbname ( String dbName ) { this . dbName = dbName ; } public void setDbschema ( String dbSchema ) { this . dbSchema = dbSchema ; } public void setCodegen ( boolean codegen ) { this . codegen = codegen ; } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; } public void setNovalidate ( boolean novalidate ) { this . novalidate = novalidate ; } public void setNowarn ( boolean nowarn ) { this . nowarn = nowarn ; } public void setNoinform ( boolean noinform ) { this . noinform = noinform ; } public void setTrace ( boolean trace ) { this . trace = trace ; } public void setRmicoptions ( String options ) { this . rmicOptions = options ; } public void setUse35 ( boolean attr ) { use35MappingRules = attr ; } public void setRebuild ( boolean rebuild ) { this . alwaysRebuild = rebuild ; } public void setSuffix ( String inString ) { this . jarSuffix = inString ; } public void setKeepgeneric ( boolean inValue ) { this . keepGeneric = inValue ; } public void setEjbdeploy ( boolean ejbdeploy ) { this . ejbdeploy = ejbdeploy ; } public void setEJBdtd ( String inString ) { this . ejb11DTD = inString ; } public void setOldCMP ( boolean oldCMP ) { this . newCMP = ! oldCMP ; } public void setNewCMP ( boolean newCMP ) { this . newCMP = newCMP ; } public void setTempdir ( String tempdir ) { this . tempdir = tempdir ; } protected DescriptorHandler getDescriptorHandler ( File srcDir ) { DescriptorHandler handler = new DescriptorHandler ( getTask ( ) , srcDir ) ; handler . registerDTD ( PUBLICID_EJB11 , ejb11DTD ) ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; handler . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return handler ; } protected DescriptorHandler getWebsphereDescriptorHandler ( final File srcDir ) { DescriptorHandler handler = new DescriptorHandler ( getTask ( ) , srcDir ) { protected void processElement ( ) { } } ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; handler . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return handler ; } protected void addVendorFiles ( Hashtable ejbFiles , String baseName ) { String ddPrefix = ( usingBaseJarName ( ) ? "" : baseName ) ; String dbPrefix = ( dbVendor == null ) ? "" : dbVendor + "-" ; File websphereEXT = new File ( getConfig ( ) . descriptorDir , ddPrefix + WAS_EXT ) ; if ( websphereEXT . exists ( ) ) { ejbFiles . put ( META_DIR + WAS_EXT , websphereEXT ) ; } else { log ( "Unable to locate websphere extensions. " + "It was expected to be in " + websphereEXT . getPath ( ) , Project . MSG_VERBOSE ) ; } File websphereBND = new File ( getConfig ( ) . descriptorDir , ddPrefix + WAS_BND ) ; if ( websphereBND . exists ( ) ) { ejbFiles . put ( META_DIR + WAS_BND , websphereBND ) ; } else { log ( "Unable to locate websphere bindings. " + "It was expected to be in " + websphereBND . getPath ( ) , Project . MSG_VERBOSE ) ; } if ( ! newCMP ) { log ( "The old method for locating CMP files has been DEPRECATED." , Project . MSG_VERBOSE ) ; log ( "Please adjust your websphere descriptor and set " + "newCMP=\"true\" to use the new CMP descriptor " + "inclusion mechanism. " , Project . MSG_VERBOSE ) ; } else { try { File websphereMAP = new File ( getConfig ( ) . descriptorDir , ddPrefix + dbPrefix + WAS_CMP_MAP ) ; if ( websphereMAP . exists ( ) ) { ejbFiles . put ( META_DIR + WAS_CMP_MAP , websphereMAP ) ; } else { log ( "Unable to locate the websphere Map: " + websphereMAP . getPath ( ) , Project . MSG_VERBOSE ) ; } File websphereSchema = new File ( getConfig ( ) . descriptorDir , ddPrefix + dbPrefix + WAS_CMP_SCHEMA ) ; if ( websphereSchema . exists ( ) ) { ejbFiles . put ( META_DIR + SCHEMA_DIR + WAS_CMP_SCHEMA , websphereSchema ) ; } else { log ( "Unable to locate the websphere Schema: " + websphereSchema . getPath ( ) , Project . MSG_VERBOSE ) ; } } catch ( Exception e ) { String msg = "Exception while adding Vendor specific files: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } } File getVendorOutputJarFile ( String baseName ) { return new File ( getDestDir ( ) , baseName + jarSuffix ) ; } protected String getOptions ( ) { StringBuffer options = new StringBuffer ( ) ; if ( dbVendor != null ) { options . append ( " -dbvendor " ) . append ( dbVendor ) ; } if ( dbName != null ) { options . append ( " -dbname \"" ) . append ( dbName ) . append ( "\"" ) ; } if ( dbSchema != null ) { options . append ( " -dbschema \"" ) . append ( dbSchema ) . append ( "\"" ) ; } if ( codegen ) { options . append ( " -codegen" ) ; } if ( quiet ) { options . append ( " -quiet" ) ; } if ( novalidate ) { options . append ( " -novalidate" ) ; } if ( nowarn ) { options . append ( " -nowarn" ) ; } if ( noinform ) { options . append ( " -noinform" ) ; } if ( trace ) { options . append ( " -trace" ) ; } if ( use35MappingRules ) { options . append ( " -35" ) ; } if ( rmicOptions != null ) { options . append ( " -rmic \"" ) . append ( rmicOptions ) . append ( "\"" ) ; } return options . toString ( ) ; } private void buildWebsphereJar ( File sourceJar , File destJar ) { try { if ( ejbdeploy ) { Java javaTask = new Java ( getTask ( ) ) ; javaTask . createJvmarg ( ) . setValue ( "-Xms64m" ) ; javaTask . createJvmarg ( ) . setValue ( "-Xmx128m" ) ; Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "websphere.lib.dir" ) ; File libdir = new File ( websphereHome , "lib" ) ; var . setValue ( libdir . getAbsolutePath ( ) ) ; javaTask . addSysproperty ( var ) ; javaTask . setDir ( websphereHome ) ; javaTask . setTaskName ( "ejbdeploy" ) ; javaTask . setClassname ( "com.ibm.etools.ejbdeploy.EJBDeploy" ) ; javaTask . createArg ( ) . setValue ( sourceJar . getPath ( ) ) ; javaTask . createArg ( ) . setValue ( tempdir ) ; javaTask . createArg ( ) . setValue ( destJar . getPath ( ) ) ; javaTask . createArg ( ) . setLine ( getOptions ( ) ) ; if ( getCombinedClasspath ( ) != null && getCombinedClasspath ( ) . toString ( ) . length ( ) > 0 ) { javaTask . createArg ( ) . setValue ( "-cp" ) ; javaTask . createArg ( ) . setValue ( getCombinedClasspath ( ) . toString ( ) ) ; } Path classpath = wasClasspath ; if ( classpath == null ) { classpath = getCombinedClasspath ( ) ; } if ( classpath != null ) { javaTask . setClasspath ( classpath ) ; javaTask . setFork ( true ) ; } else { javaTask . setFork ( true ) ; } log ( "Calling websphere.ejbdeploy for " + sourceJar . toString ( ) , Project . MSG_VERBOSE ) ; javaTask . execute ( ) ; } } catch ( Exception e ) { String msg = "Exception while calling ejbdeploy. Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } protected void writeJar ( String baseName , File jarFile , Hashtable files , String publicId ) throws BuildException { if ( ejbdeploy ) { File genericJarFile = super . getVendorOutputJarFile ( baseName ) ; super . writeJar ( baseName , genericJarFile , files , publicId ) ; if ( alwaysRebuild || isRebuildRequired ( genericJarFile , jarFile ) ) { buildWebsphereJar ( genericJarFile , jarFile ) ; } if ( ! keepGeneric ) { log ( "deleting generic jar " + genericJarFile . toString ( ) , Project . MSG_VERBOSE ) ; genericJarFile . delete ( ) ; } } else { super . writeJar ( baseName , jarFile , files , publicId ) ; } } public void validateConfigured ( ) throws BuildException { super . validateConfigured ( ) ; if ( ejbdeploy ) { String home = getTask ( ) . getProject ( ) . getProperty ( "websphere.home" ) ; if ( home == null ) { throw new BuildException ( "The 'websphere.home' property must " + "be set when 'ejbdeploy=true'" ) ; } websphereHome = getTask ( ) . getProject ( ) . resolveFile ( home ) ; } } protected boolean isRebuildRequired ( File genericJarFile , File websphereJarFile ) { boolean rebuild = false ; JarFile genericJar = null ; JarFile wasJar = null ; File newwasJarFile = null ; JarOutputStream newJarStream = null ; try { log ( "Checking if websphere Jar needs to be rebuilt for jar " + websphereJarFile . getName ( ) , Project . MSG_VERBOSE ) ; if ( genericJarFile . exists ( ) && genericJarFile . isFile ( ) && websphereJarFile . exists ( ) && websphereJarFile . isFile ( ) ) { genericJar = new JarFile ( genericJarFile ) ; wasJar = new JarFile ( websphereJarFile ) ; Hashtable genericEntries = new Hashtable ( ) ; Hashtable wasEntries = new Hashtable ( ) ; Hashtable replaceEntries = new Hashtable ( ) ; for ( Enumeration e = genericJar . entries ( ) ; e . hasMoreElements ( ) ; ) { JarEntry je = ( JarEntry ) e . nextElement ( ) ; genericEntries . put ( je . getName ( ) . replace ( '\\' , '/' ) , je ) ; } for ( Enumeration e = wasJar . entries ( ) ; e . hasMoreElements ( ) ; ) { JarEntry je = ( JarEntry ) e . nextElement ( ) ; wasEntries . put ( je . getName ( ) , je ) ; } ClassLoader genericLoader = getClassLoaderFromJar ( genericJarFile ) ; for ( Enumeration e = genericEntries . keys ( ) ; e . hasMoreElements ( ) ; ) { String filepath = ( String ) e . nextElement ( ) ; if ( wasEntries . containsKey ( filepath ) ) { JarEntry genericEntry = ( JarEntry ) genericEntries . get ( filepath ) ; JarEntry wasEntry = ( JarEntry ) wasEntries . get ( filepath ) ; if ( ( genericEntry . getCrc ( ) != wasEntry . getCrc ( ) ) || ( genericEntry . getSize ( ) != wasEntry . getSize ( ) ) ) { if ( genericEntry . getName ( ) . endsWith ( ".class" ) ) { String classname = genericEntry . getName ( ) . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . lastIndexOf ( ".class" ) ) ; Class genclass = genericLoader . loadClass ( classname ) ; if ( genclass . isInterface ( ) ) { log ( "Interface " + genclass . getName ( ) + " has changed" , Project . MSG_VERBOSE ) ; rebuild = true ; break ; } else { replaceEntries . put ( filepath , genericEntry ) ; } } else { if ( ! genericEntry . getName ( ) . equals ( "META-INF/MANIFEST.MF" ) ) { log ( "Non class file " + genericEntry . getName ( ) + " has changed" , Project . MSG_VERBOSE ) ; rebuild = true ; } break ; } } } else { log ( "File " + filepath + " not present in websphere jar" , Project . MSG_VERBOSE ) ; rebuild = true ; break ; } } if ( ! rebuild ) { log ( "No rebuild needed - updating jar" , Project . MSG_VERBOSE ) ; newwasJarFile = new File ( websphereJarFile . getAbsolutePath ( ) + ".temp" ) ; if ( newwasJarFile . exists ( ) ) { newwasJarFile . delete ( ) ; } newJarStream = new JarOutputStream ( new FileOutputStream ( newwasJarFile ) ) ; newJarStream . setLevel ( 0 ) ; for ( Enumeration e = wasEntries . elements ( ) ; e . hasMoreElements ( ) ; ) { byte [ ] buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; int bytesRead ; InputStream is ; JarEntry je = ( JarEntry ) e . nextElement ( ) ; if ( je . getCompressedSize ( ) == - 1 || je . getCompressedSize ( ) == je . getSize ( ) ) { newJarStream . setLevel ( 0 ) ; } else { newJarStream . setLevel ( JAR_COMPRESS_LEVEL ) ; } if ( replaceEntries . containsKey ( je . getName ( ) ) ) { log ( "Updating Bean class from generic Jar " + je . getName ( ) , Project . MSG_VERBOSE ) ; je = ( JarEntry ) replaceEntries . get ( je . getName ( ) ) ; is = genericJar . getInputStream ( je ) ; } else { is = wasJar . getInputStream ( je ) ; } newJarStream . putNextEntry ( new JarEntry ( je . getName ( ) ) ) ; while ( ( bytesRead = is . read ( buffer ) ) != - 1 ) { newJarStream . write ( buffer , 0 , bytesRead ) ; } is . close ( ) ; } } else { log ( "websphere Jar rebuild needed due to changed " + "interface or XML" , Project . MSG_VERBOSE ) ; } } else { rebuild = true ; } } catch ( ClassNotFoundException cnfe ) { String cnfmsg = "ClassNotFoundException while processing ejb-jar file" + ". Details: " + cnfe . getMessage ( ) ; throw new BuildException ( cnfmsg , cnfe ) ; } catch ( IOException ioe ) { String msg = "IOException while processing ejb-jar file " + ". Details: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe ) ; } finally { if ( genericJar != null ) { try { genericJar . close ( ) ; } catch ( IOException closeException ) { } } if ( wasJar != null ) { try { wasJar . close ( ) ; } catch ( IOException closeException ) { } } if ( newJarStream != null ) { try { newJarStream . close ( ) ; } catch ( IOException closeException ) { } try { FILE_UTILS . rename ( newwasJarFile , websphereJarFile ) ; } catch ( IOException renameException ) { log ( renameException . getMessage ( ) , Project . MSG_WARN ) ; rebuild = true ; } } } return rebuild ; } protected ClassLoader getClassLoaderFromJar ( File classjar ) throws IOException { Path lookupPath = new Path ( getTask ( ) . getProject ( ) ) ; lookupPath . setLocation ( classjar ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath != null ) { lookupPath . append ( classpath ) ; } return getTask ( ) . getProject ( ) . createClassLoader ( lookupPath ) ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Basename extends Task { private File file ; private String property ; private String suffix ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , getLocation ( ) ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , getLocation ( ) ) ; } String value = file . getName ( ) ; if ( suffix != null && value . endsWith ( suffix ) ) { int pos = value . length ( ) - suffix . length ( ) ; if ( pos > 0 && suffix . charAt ( 0 ) != '.' && value . charAt ( pos - 1 ) == '.' ) { pos -- ; } value = value . substring ( 0 , pos ) ; } getProject ( ) . setNewProperty ( property , value ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . javah ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . optional . Javah ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Kaffeh implements JavahAdapter { public static final String IMPLEMENTATION_NAME = "kaffeh" ; public boolean compile ( Javah javah ) throws BuildException { Commandline cmd = setupKaffehCommand ( javah ) ; try { Execute . runCommand ( javah , cmd . getCommandline ( ) ) ; return true ; } catch ( BuildException e ) { if ( e . getMessage ( ) . indexOf ( "failed with return code" ) == - 1 ) { throw e ; } } return false ; } private Commandline setupKaffehCommand ( Javah javah ) { Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( "kaffeh" ) ) ; if ( javah . getDestdir ( ) != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( javah . getDestdir ( ) ) ; } if ( javah . getOutputfile ( ) != null ) { cmd . createArgument ( ) . setValue ( "-o" ) ; cmd . createArgument ( ) . setFile ( javah . getOutputfile ( ) ) ; } Path cp = new Path ( javah . getProject ( ) ) ; if ( javah . getBootclasspath ( ) != null ) { cp . append ( javah . getBootclasspath ( ) ) ; } cp = cp . concatSystemBootClasspath ( "ignore" ) ; if ( javah . getClasspath ( ) != null ) { cp . append ( javah . getClasspath ( ) ) ; } if ( cp . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( cp ) ; } if ( ! javah . getOld ( ) ) { cmd . createArgument ( ) . setValue ( "-jni" ) ; } cmd . addArguments ( javah . getCurrentArgs ( ) ) ; javah . logAndAddFiles ( cmd ) ; return cmd ; } } 	0
package org . apache . tools . ant . util ; import java . util . List ; import java . util . Arrays ; import java . util . Iterator ; import java . util . ArrayList ; public class ChainedMapper extends ContainerMapper { public String [ ] mapFileName ( String sourceFileName ) { List inputs = new ArrayList ( ) ; List results = new ArrayList ( ) ; results . add ( sourceFileName ) ; FileNameMapper mapper = null ; for ( Iterator mIter = getMappers ( ) . iterator ( ) ; mIter . hasNext ( ) ; ) { mapper = ( FileNameMapper ) ( mIter . next ( ) ) ; if ( mapper != null ) { inputs . clear ( ) ; inputs . addAll ( results ) ; results . clear ( ) ; for ( Iterator it = inputs . iterator ( ) ; it . hasNext ( ) ; ) { String [ ] mapped = mapper . mapFileName ( ( String ) ( it . next ( ) ) ) ; if ( mapped != null ) { results . addAll ( Arrays . asList ( mapped ) ) ; } } } } return ( results . size ( ) == 0 ) ? null : ( String [ ] ) results . toArray ( new String [ results . size ( ) ] ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . ccm ; public class CCMCheckout extends CCMCheck { public CCMCheckout ( ) { super ( ) ; setCcmAction ( COMMAND_CHECKOUT ) ; } } 	0
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . Stack ; import java . util . Iterator ; import java . util . Collection ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; public abstract class BaseResourceCollectionWrapper extends DataType implements ResourceCollection , Cloneable { private static final String ONE_NESTED_MESSAGE = " expects exactly one nested resource collection." ; private ResourceCollection rc ; private Collection coll = null ; private boolean cache = true ; public synchronized void setCache ( boolean b ) { cache = b ; } public synchronized boolean isCache ( ) { return cache ; } public synchronized void add ( ResourceCollection c ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } if ( rc != null ) { throw oneNested ( ) ; } rc = c ; setChecked ( false ) ; } public final synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionWrapper ) getCheckedRef ( ) ) . iterator ( ) ; } dieOnCircularReference ( ) ; return new FailFast ( this , cacheCollection ( ) . iterator ( ) ) ; } public synchronized int size ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionWrapper ) getCheckedRef ( ) ) . size ( ) ; } dieOnCircularReference ( ) ; return cacheCollection ( ) . size ( ) ; } public synchronized boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return ( ( BaseResourceCollectionContainer ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } dieOnCircularReference ( ) ; if ( rc == null || rc . isFilesystemOnly ( ) ) { return true ; } for ( Iterator i = cacheCollection ( ) . iterator ( ) ; i . hasNext ( ) ; ) { if ( ! ( i . next ( ) instanceof FileResource ) ) { return false ; } } return true ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( rc instanceof DataType ) { stk . push ( rc ) ; invokeCircularReferenceCheck ( ( DataType ) rc , stk , p ) ; stk . pop ( ) ; } setChecked ( true ) ; } } protected final synchronized ResourceCollection getResourceCollection ( ) { dieOnCircularReference ( ) ; if ( rc == null ) { throw oneNested ( ) ; } return rc ; } protected abstract Collection getCollection ( ) ; public synchronized String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } if ( cacheCollection ( ) . size ( ) == 0 ) { return "" ; } StringBuffer sb = new StringBuffer ( ) ; for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { if ( sb . length ( ) > 0 ) { sb . append ( File . pathSeparatorChar ) ; } sb . append ( i . next ( ) ) ; } return sb . toString ( ) ; } private synchronized Collection cacheCollection ( ) { if ( coll == null || ! isCache ( ) ) { coll = getCollection ( ) ; } return coll ; } private BuildException oneNested ( ) { return new BuildException ( super . toString ( ) + ONE_NESTED_MESSAGE ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . bzip2 . CBZip2InputStream ; public class BUnzip2 extends Unpack { private static final String DEFAULT_EXTENSION = ".bz2" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; CBZip2InputStream zIn = null ; InputStream fis = null ; BufferedInputStream bis = null ; try { out = new FileOutputStream ( dest ) ; fis = srcResource . getInputStream ( ) ; bis = new BufferedInputStream ( fis ) ; int b = bis . read ( ) ; if ( b != 'B' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } b = bis . read ( ) ; if ( b != 'Z' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } zIn = new CBZip2InputStream ( bis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( bis ) ; FileUtils . close ( fis ) ; FileUtils . close ( out ) ; FileUtils . close ( zIn ) ; } } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( BUnzip2 . class ) ; } } 	0
package org . apache . tools . ant . util ; public class Base64Converter { private static final char [ ] ALPHABET = { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' , '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '/' } ; public static final char [ ] alphabet = ALPHABET ; public String encode ( String s ) { return encode ( s . getBytes ( ) ) ; } public String encode ( byte [ ] octetString ) { int bits24 ; int bits6 ; char [ ] out = new char [ ( ( octetString . length - 1 ) / 3 + 1 ) * 4 ] ; int outIndex = 0 ; int i = 0 ; while ( ( i + 3 ) <= octetString . length ) { bits24 = ( octetString [ i ++ ] & 0xFF ) << 16 ; bits24 |= ( octetString [ i ++ ] & 0xFF ) << 8 ; bits24 |= octetString [ i ++ ] ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x00000FC0 ) > > 6 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0000003F ) ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; } if ( octetString . length - i == 2 ) { bits24 = ( octetString [ i ] & 0xFF ) << 16 ; bits24 |= ( octetString [ i + 1 ] & 0xFF ) << 8 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x00000FC0 ) > > 6 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; out [ outIndex ++ ] = '=' ; } else if ( octetString . length - i == 1 ) { bits24 = ( octetString [ i ] & 0xFF ) << 16 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; out [ outIndex ++ ] = '=' ; out [ outIndex ++ ] = '=' ; } return new String ( out ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . Channel ; import com . jcraft . jsch . ChannelExec ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . SftpProgressMonitor ; import java . io . IOException ; import java . io . OutputStream ; import java . io . InputStream ; import java . text . NumberFormat ; import org . apache . tools . ant . BuildException ; public abstract class AbstractSshMessage { private Session session ; private boolean verbose ; private LogListener listener = new LogListener ( ) { public void log ( String message ) { } } ; public AbstractSshMessage ( Session session ) { this ( false , session ) ; } public AbstractSshMessage ( boolean verbose , Session session ) { this . verbose = verbose ; this . session = session ; } protected Channel openExecChannel ( String command ) throws JSchException { ChannelExec channel = ( ChannelExec ) session . openChannel ( "exec" ) ; channel . setCommand ( command ) ; return channel ; } protected ChannelSftp openSftpChannel ( ) throws JSchException { ChannelSftp channel = ( ChannelSftp ) session . openChannel ( "sftp" ) ; return channel ; } protected void sendAck ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 1 ] ; buf [ 0 ] = 0 ; out . write ( buf ) ; out . flush ( ) ; } protected void waitForAck ( InputStream in ) throws IOException , BuildException { int b = in . read ( ) ; if ( b == - 1 ) { throw new BuildException ( "No response from server" ) ; } else if ( b != 0 ) { StringBuffer sb = new StringBuffer ( ) ; int c = in . read ( ) ; while ( c > 0 && c != '\n' ) { sb . append ( ( char ) c ) ; c = in . read ( ) ; } if ( b == 1 ) { throw new BuildException ( "server indicated an error: " + sb . toString ( ) ) ; } else if ( b == 2 ) { throw new BuildException ( "server indicated a fatal error: " + sb . toString ( ) ) ; } else { throw new BuildException ( "unknown response, code " + b + " message: " + sb . toString ( ) ) ; } } } public abstract void execute ( ) throws IOException , JSchException ; public void setLogListener ( LogListener aListener ) { listener = aListener ; } protected void log ( String message ) { listener . log ( message ) ; } protected void logStats ( long timeStarted , long timeEnded , long totalLength ) { double duration = ( timeEnded - timeStarted ) / 1000.0 ; NumberFormat format = NumberFormat . getNumberInstance ( ) ; format . setMaximumFractionDigits ( 2 ) ; format . setMinimumFractionDigits ( 1 ) ; listener . log ( "File transfer time: " + format . format ( duration ) + " Average Rate: " + format . format ( totalLength / duration ) + " B/s" ) ; } protected final boolean getVerbose ( ) { return verbose ; } protected final int trackProgress ( long filesize , long totalLength , int percentTransmitted ) { int percent = ( int ) Math . round ( Math . floor ( ( totalLength / ( double ) filesize ) * 100 ) ) ; if ( percent > percentTransmitted ) { if ( filesize < 1048576 ) { if ( percent % 10 == 0 ) { if ( percent == 100 ) { System . out . println ( " 100%" ) ; } else { System . out . print ( "*" ) ; } } } else { if ( percent == 50 ) { System . out . println ( " 50%" ) ; } else if ( percent == 100 ) { System . out . println ( " 100%" ) ; } else { System . out . print ( "." ) ; } } } return percent ; } private ProgressMonitor monitor = null ; protected SftpProgressMonitor getProgressMonitor ( ) { if ( monitor == null ) { monitor = new ProgressMonitor ( ) ; } return monitor ; } private class ProgressMonitor implements SftpProgressMonitor { private long initFileSize = 0 ; private long totalLength = 0 ; private int percentTransmitted = 0 ; public void init ( int op , String src , String dest , long max ) { initFileSize = max ; totalLength = 0 ; percentTransmitted = 0 ; } public boolean count ( long len ) { totalLength += len ; percentTransmitted = trackProgress ( initFileSize , totalLength , percentTransmitted ) ; return true ; } public void end ( ) { } public long getTotalLength ( ) { return totalLength ; } } } 	0
package org . apache . tools . ant . types . resources . selectors ; import java . util . Iterator ; import org . apache . tools . ant . types . Resource ; public class Majority extends ResourceSelectorContainer implements ResourceSelector { private boolean tie = true ; public Majority ( ) { } public Majority ( ResourceSelector [ ] r ) { super ( r ) ; } public synchronized void setAllowtie ( boolean b ) { tie = b ; } public synchronized boolean isSelected ( Resource r ) { int passed = 0 ; int failed = 0 ; int count = selectorCount ( ) ; boolean even = count % 2 == 0 ; int threshold = count / 2 ; for ( Iterator i = getSelectors ( ) ; i . hasNext ( ) ; ) { if ( ( ( ResourceSelector ) i . next ( ) ) . isSelected ( r ) ) { ++ passed ; if ( passed > threshold || ( even && tie && passed == threshold ) ) { return true ; } } else { ++ failed ; if ( failed > threshold || ( even && ! tie && failed == threshold ) ) { return false ; } } } return false ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . Reader ; import java . io . FileReader ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . util . Vector ; import java . util . Enumeration ; import java . util . NoSuchElementException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . filters . FixCrLfFilter ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileUtils ; public class FixCRLF extends MatchingTask implements ChainableReader { public static final String ERROR_FILE_AND_SRCDIR = "srcdir and file are mutually exclusive" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private boolean preserveLastModified = false ; private File srcDir ; private File destDir = null ; private File file ; private FixCrLfFilter filter = new FixCrLfFilter ( ) ; private Vector fcv = null ; private String encoding = null ; private String outputEncoding = null ; public final Reader chain ( final Reader rdr ) { return filter . chain ( rdr ) ; } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setJavafiles ( boolean javafiles ) { filter . setJavafiles ( javafiles ) ; } public void setFile ( File file ) { this . file = file ; } public void setEol ( CrLf attr ) { filter . setEol ( FixCrLfFilter . CrLf . newInstance ( attr . getValue ( ) ) ) ; } public void setCr ( AddAsisRemove attr ) { log ( "DEPRECATED: The cr attribute has been deprecated," , Project . MSG_WARN ) ; log ( "Please use the eol attribute instead" , Project . MSG_WARN ) ; String option = attr . getValue ( ) ; CrLf c = new CrLf ( ) ; if ( option . equals ( "remove" ) ) { c . setValue ( "lf" ) ; } else if ( option . equals ( "asis" ) ) { c . setValue ( "asis" ) ; } else { c . setValue ( "crlf" ) ; } setEol ( c ) ; } public void setTab ( AddAsisRemove attr ) { filter . setTab ( FixCrLfFilter . AddAsisRemove . newInstance ( attr . getValue ( ) ) ) ; } public void setTablength ( int tlength ) throws BuildException { try { filter . setTablength ( tlength ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } public void setEof ( AddAsisRemove attr ) { filter . setEof ( FixCrLfFilter . AddAsisRemove . newInstance ( attr . getValue ( ) ) ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setFixlast ( boolean fixlast ) { filter . setFixlast ( fixlast ) ; } public void setPreserveLastModified ( boolean preserve ) { preserveLastModified = preserve ; } public void execute ( ) throws BuildException { validate ( ) ; String enc = encoding == null ? "default" : encoding ; log ( "options:" + " eol=" + filter . getEol ( ) . getValue ( ) + " tab=" + filter . getTab ( ) . getValue ( ) + " eof=" + filter . getEof ( ) . getValue ( ) + " tablength=" + filter . getTablength ( ) + " encoding=" + enc + " outputencoding=" + ( outputEncoding == null ? enc : outputEncoding ) , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { processFile ( files [ i ] ) ; } } private void validate ( ) throws BuildException { if ( file != null ) { if ( srcDir != null ) { throw new BuildException ( ERROR_FILE_AND_SRCDIR ) ; } fileset . setFile ( file ) ; srcDir = file . getParentFile ( ) ; } if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } } private void processFile ( String file ) throws BuildException { File srcFile = new File ( srcDir , file ) ; long lastModified = srcFile . lastModified ( ) ; File destD = destDir == null ? srcDir : destDir ; if ( fcv == null ) { FilterChain fc = new FilterChain ( ) ; fc . add ( filter ) ; fcv = new Vector ( 1 ) ; fcv . add ( fc ) ; } File tmpFile = FILE_UTILS . createTempFile ( "fixcrlf" , "" , null ) ; tmpFile . deleteOnExit ( ) ; try { FILE_UTILS . copyFile ( srcFile , tmpFile , null , fcv , false , false , encoding , outputEncoding == null ? encoding : outputEncoding , getProject ( ) ) ; File destFile = new File ( destD , file ) ; boolean destIsWrong = true ; if ( destFile . exists ( ) ) { log ( "destFile exists" , Project . MSG_DEBUG ) ; destIsWrong = ! FILE_UTILS . contentEquals ( destFile , tmpFile ) ; log ( destFile + ( destIsWrong ? " is being written" : " is not written, as the contents are identical" ) , Project . MSG_DEBUG ) ; } if ( destIsWrong ) { FILE_UTILS . rename ( tmpFile , destFile ) ; if ( preserveLastModified ) { log ( "preserved lastModified" , Project . MSG_DEBUG ) ; FILE_UTILS . setFileLastModified ( destFile , lastModified ) ; } tmpFile = null ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected class OneLiner implements Enumeration { private static final int UNDEF = - 1 ; private static final int NOTJAVA = 0 ; private static final int LOOKING = 1 ; private static final int INBUFLEN = 8192 ; private static final int LINEBUFLEN = 200 ; private static final char CTRLZ = '' ; private int state = filter . getJavafiles ( ) ? LOOKING : NOTJAVA ; private StringBuffer eolStr = new StringBuffer ( LINEBUFLEN ) ; private StringBuffer eofStr = new StringBuffer ( ) ; private BufferedReader reader ; private StringBuffer line = new StringBuffer ( ) ; private boolean reachedEof = false ; private File srcFile ; public OneLiner ( File srcFile ) throws BuildException { this . srcFile = srcFile ; try { reader = new BufferedReader ( ( ( encoding == null ) ? new FileReader ( srcFile ) : new InputStreamReader ( new FileInputStream ( srcFile ) , encoding ) ) , INBUFLEN ) ; nextLine ( ) ; } catch ( IOException e ) { throw new BuildException ( srcFile + ": " + e . getMessage ( ) , e , getLocation ( ) ) ; } } protected void nextLine ( ) throws BuildException { int ch = - 1 ; int eolcount = 0 ; eolStr = new StringBuffer ( ) ; line = new StringBuffer ( ) ; try { ch = reader . read ( ) ; while ( ch != - 1 && ch != '\r' && ch != '\n' ) { line . append ( ( char ) ch ) ; ch = reader . read ( ) ; } if ( ch == - 1 && line . length ( ) == 0 ) { reachedEof = true ; return ; } switch ( ( char ) ch ) { case '\r' : ++ eolcount ; eolStr . append ( '\r' ) ; reader . mark ( 2 ) ; ch = reader . read ( ) ; switch ( ch ) { case '\r' : ch = reader . read ( ) ; if ( ( char ) ( ch ) == '\n' ) { eolcount += 2 ; eolStr . append ( "\r\n" ) ; } else { reader . reset ( ) ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; case - 1 : break ; default : reader . reset ( ) ; break ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; default : } if ( eolcount == 0 ) { int i = line . length ( ) ; while ( -- i >= 0 && line . charAt ( i ) == CTRLZ ) { } if ( i < line . length ( ) - 1 ) { eofStr . append ( line . toString ( ) . substring ( i + 1 ) ) ; if ( i < 0 ) { line . setLength ( 0 ) ; reachedEof = true ; } else { line . setLength ( i + 1 ) ; } } } } catch ( IOException e ) { throw new BuildException ( srcFile + ": " + e . getMessage ( ) , e , getLocation ( ) ) ; } } public String getEofStr ( ) { return eofStr . substring ( 0 ) ; } public int getState ( ) { return state ; } public void setState ( int state ) { this . state = state ; } public boolean hasMoreElements ( ) { return ! reachedEof ; } public Object nextElement ( ) throws NoSuchElementException { if ( ! hasMoreElements ( ) ) { throw new NoSuchElementException ( "OneLiner" ) ; } BufferLine tmpLine = new BufferLine ( line . toString ( ) , eolStr . substring ( 0 ) ) ; nextLine ( ) ; return tmpLine ; } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } class BufferLine { private int next = 0 ; private int column = 0 ; private int lookahead = UNDEF ; private String line ; private String eolStr ; public BufferLine ( String line , String eolStr ) throws BuildException { next = 0 ; column = 0 ; this . line = line ; this . eolStr = eolStr ; } public int getNext ( ) { return next ; } public void setNext ( int next ) { this . next = next ; } public int getLookahead ( ) { return lookahead ; } public void setLookahead ( int lookahead ) { this . lookahead = lookahead ; } public char getChar ( int i ) { return line . charAt ( i ) ; } public char getNextChar ( ) { return getChar ( next ) ; } public char getNextCharInc ( ) { return getChar ( next ++ ) ; } public int getColumn ( ) { return column ; } public void setColumn ( int col ) { column = col ; } public int incColumn ( ) { return column ++ ; } public int length ( ) { return line . length ( ) ; } public int getEolLength ( ) { return eolStr . length ( ) ; } public String getLineString ( ) { return line ; } public String getEol ( ) { return eolStr ; } public String substring ( int begin ) { return line . substring ( begin ) ; } public String substring ( int begin , int end ) { return line . substring ( begin , end ) ; } public void setState ( int state ) { OneLiner . this . setState ( state ) ; } public int getState ( ) { return OneLiner . this . getState ( ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } public static class CrLf extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" , "mac" , "unix" , "dos" } ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; public interface HotDeploymentTool { String ACTION_DELETE = "delete" ; String ACTION_DEPLOY = "deploy" ; String ACTION_LIST = "list" ; String ACTION_UNDEPLOY = "undeploy" ; String ACTION_UPDATE = "update" ; void validateAttributes ( ) throws BuildException ; void deploy ( ) throws BuildException ; void setTask ( ServerDeploy task ) ; } 	0
package org . apache . tools . ant . types . resources ; import java . util . List ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . ResourceCollection ; public class Intersect extends BaseResourceCollectionContainer { protected Collection getCollection ( ) { List rcs = getResourceCollections ( ) ; int size = rcs . size ( ) ; if ( size < 2 ) { throw new BuildException ( "The intersection of " + size + " resource collection" + ( ( size == 1 ) ? "" : "s" ) + " is undefined." ) ; } ArrayList al = new ArrayList ( ) ; Iterator rc = rcs . iterator ( ) ; al . addAll ( collect ( rc . next ( ) ) ) ; while ( rc . hasNext ( ) ) { al . retainAll ( collect ( rc . next ( ) ) ) ; } return al ; } private ArrayList collect ( Object o ) { ArrayList result = new ArrayList ( ) ; for ( Iterator i = ( ( ResourceCollection ) o ) . iterator ( ) ; i . hasNext ( ) ; ) { result . add ( i . next ( ) ) ; } return result ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapter ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapterFactory ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . GlobPatternMapper ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; public class Javac extends MatchingTask { private static final String FAIL_MSG = "Compile failed; see the compiler error output for details." ; private static final String JAVAC16 = "javac1.6" ; private static final String JAVAC15 = "javac1.5" ; private static final String JAVAC14 = "javac1.4" ; private static final String JAVAC13 = "javac1.3" ; private static final String JAVAC12 = "javac1.2" ; private static final String JAVAC11 = "javac1.1" ; private static final String MODERN = "modern" ; private static final String CLASSIC = "classic" ; private static final String EXTJAVAC = "extJavac" ; private Path src ; private File destDir ; private Path compileClasspath ; private Path compileSourcepath ; private String encoding ; private boolean debug = false ; private boolean optimize = false ; private boolean deprecation = false ; private boolean depend = false ; private boolean verbose = false ; private String targetAttribute ; private Path bootclasspath ; private Path extdirs ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private boolean fork = false ; private String forkedExecutable = null ; private boolean nowarn = false ; private String memoryInitialSize ; private String memoryMaximumSize ; private FacadeTaskHelper facade = null ; protected boolean failOnError = true ; protected boolean listFiles = false ; protected File [ ] compileList = new File [ 0 ] ; private String source ; private String debugLevel ; private File tmpDir ; public Javac ( ) { facade = new FacadeTaskHelper ( assumedJavaVersion ( ) ) ; } private String assumedJavaVersion ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) { return JAVAC12 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) { return JAVAC13 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) { return JAVAC14 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_5 ) ) { return JAVAC15 ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_6 ) ) { return JAVAC16 ; } else { return CLASSIC ; } } public String getDebugLevel ( ) { return debugLevel ; } public void setDebugLevel ( String v ) { this . debugLevel = v ; } public String getSource ( ) { return source != null ? source : getProject ( ) . getProperty ( MagicNames . BUILD_JAVAC_SOURCE ) ; } public void setSource ( String v ) { this . source = v ; } public Path createSrc ( ) { if ( src == null ) { src = new Path ( getProject ( ) ) ; } return src . createPath ( ) ; } protected Path recreateSrc ( ) { src = null ; return createSrc ( ) ; } public void setSrcdir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcdir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setSourcepath ( Path sourcepath ) { if ( compileSourcepath == null ) { compileSourcepath = sourcepath ; } else { compileSourcepath . append ( sourcepath ) ; } } public Path getSourcepath ( ) { return compileSourcepath ; } public Path createSourcepath ( ) { if ( compileSourcepath == null ) { compileSourcepath = new Path ( getProject ( ) ) ; } return compileSourcepath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } } public Path getBootclasspath ( ) { return bootclasspath ; } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path getExtdirs ( ) { return extdirs ; } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( getProject ( ) ) ; } return extdirs . createPath ( ) ; } public void setListfiles ( boolean list ) { listFiles = list ; } public boolean getListfiles ( ) { return listFiles ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setProceed ( boolean proceed ) { failOnError = ! proceed ; } public boolean getFailonerror ( ) { return failOnError ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean getDeprecation ( ) { return deprecation ; } public void setMemoryInitialSize ( String memoryInitialSize ) { this . memoryInitialSize = memoryInitialSize ; } public String getMemoryInitialSize ( ) { return memoryInitialSize ; } public void setMemoryMaximumSize ( String memoryMaximumSize ) { this . memoryMaximumSize = memoryMaximumSize ; } public String getMemoryMaximumSize ( ) { return memoryMaximumSize ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setOptimize ( boolean optimize ) { this . optimize = optimize ; } public boolean getOptimize ( ) { return optimize ; } public void setDepend ( boolean depend ) { this . depend = depend ; } public boolean getDepend ( ) { return depend ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setTarget ( String target ) { this . targetAttribute = target ; } public String getTarget ( ) { return targetAttribute != null ? targetAttribute : getProject ( ) . getProperty ( MagicNames . BUILD_JAVAC_TARGET ) ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setFork ( boolean f ) { fork = f ; } public void setExecutable ( String forkExec ) { forkedExecutable = forkExec ; } public String getExecutable ( ) { return forkedExecutable ; } public boolean isForkedJavac ( ) { return fork || "extJavac" . equals ( getCompiler ( ) ) ; } public String getJavacExecutable ( ) { if ( forkedExecutable == null && isForkedJavac ( ) ) { forkedExecutable = getSystemJavac ( ) ; } else if ( forkedExecutable != null && ! isForkedJavac ( ) ) { forkedExecutable = null ; } return forkedExecutable ; } public void setNowarn ( boolean flag ) { this . nowarn = flag ; } public boolean getNowarn ( ) { return nowarn ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { String chosen = facade . getExplicitChoice ( ) ; try { String appliedCompiler = getCompiler ( ) ; facade . setImplementation ( appliedCompiler ) ; String [ ] result = facade . getArgs ( ) ; String altCompilerName = getAltCompilerName ( facade . getImplementation ( ) ) ; if ( result . length == 0 && altCompilerName != null ) { facade . setImplementation ( altCompilerName ) ; result = facade . getArgs ( ) ; } return result ; } finally { facade . setImplementation ( chosen ) ; } } private String getAltCompilerName ( String anImplementation ) { if ( JAVAC16 . equalsIgnoreCase ( anImplementation ) || JAVAC15 . equalsIgnoreCase ( anImplementation ) || JAVAC14 . equalsIgnoreCase ( anImplementation ) || JAVAC13 . equalsIgnoreCase ( anImplementation ) ) { return MODERN ; } if ( JAVAC12 . equalsIgnoreCase ( anImplementation ) || JAVAC11 . equalsIgnoreCase ( anImplementation ) ) { return CLASSIC ; } if ( MODERN . equalsIgnoreCase ( anImplementation ) ) { String nextSelected = assumedJavaVersion ( ) ; if ( JAVAC16 . equalsIgnoreCase ( nextSelected ) || JAVAC15 . equalsIgnoreCase ( nextSelected ) || JAVAC14 . equalsIgnoreCase ( nextSelected ) || JAVAC13 . equalsIgnoreCase ( nextSelected ) ) { return nextSelected ; } } if ( CLASSIC . equals ( anImplementation ) ) { return assumedJavaVersion ( ) ; } if ( EXTJAVAC . equalsIgnoreCase ( anImplementation ) ) { return assumedJavaVersion ( ) ; } return null ; } public void setTempdir ( File tmpDir ) { this . tmpDir = tmpDir ; } public File getTempdir ( ) { return tmpDir ; } public void execute ( ) throws BuildException { checkParameters ( ) ; resetFileLists ( ) ; String [ ] list = src . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = getProject ( ) . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , getLocation ( ) ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir != null ? destDir : srcDir , files ) ; } compile ( ) ; } protected void resetFileLists ( ) { compileList = new File [ 0 ] ; } protected void scanDir ( File srcDir , File destDir , String [ ] files ) { GlobPatternMapper m = new GlobPatternMapper ( ) ; m . setFrom ( "*.java" ) ; m . setTo ( "*.class" ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; File [ ] newFiles = sfs . restrictAsFiles ( files , srcDir , destDir , m ) ; if ( newFiles . length > 0 ) { File [ ] newCompileList = new File [ compileList . length + newFiles . length ] ; System . arraycopy ( compileList , 0 , newCompileList , 0 , compileList . length ) ; System . arraycopy ( newFiles , 0 , newCompileList , compileList . length , newFiles . length ) ; compileList = newCompileList ; } } public File [ ] getFileList ( ) { return compileList ; } protected boolean isJdkCompiler ( String compilerImpl ) { return MODERN . equals ( compilerImpl ) || CLASSIC . equals ( compilerImpl ) || JAVAC16 . equals ( compilerImpl ) || JAVAC15 . equals ( compilerImpl ) || JAVAC14 . equals ( compilerImpl ) || JAVAC13 . equals ( compilerImpl ) || JAVAC12 . equals ( compilerImpl ) || JAVAC11 . equals ( compilerImpl ) ; } protected String getSystemJavac ( ) { return JavaEnvUtils . getJdkExecutable ( "javac" ) ; } public void setCompiler ( String compiler ) { facade . setImplementation ( compiler ) ; } public String getCompiler ( ) { String compilerImpl = getCompilerVersion ( ) ; if ( fork ) { if ( isJdkCompiler ( compilerImpl ) ) { compilerImpl = "extJavac" ; } else { log ( "Since compiler setting isn't classic or modern," + "ignoring fork setting." , Project . MSG_WARN ) ; } } return compilerImpl ; } public String getCompilerVersion ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.compiler" ) ) ; return facade . getImplementation ( ) ; } protected void checkParameters ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( src . size ( ) == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( destDir != null && ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist " + "or is not a directory" , getLocation ( ) ) ; } } protected void compile ( ) { String compilerImpl = getCompiler ( ) ; if ( compileList . length > 0 ) { log ( "Compiling " + compileList . length + " source file" + ( compileList . length == 1 ? "" : "s" ) + ( destDir != null ? " to " + destDir : "" ) ) ; if ( listFiles ) { for ( int i = 0 ; i < compileList . length ; i ++ ) { String filename = compileList [ i ] . getAbsolutePath ( ) ; log ( filename ) ; } } CompilerAdapter adapter = CompilerAdapterFactory . getCompiler ( compilerImpl , this ) ; adapter . setJavac ( this ) ; if ( ! adapter . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , getLocation ( ) ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	1
package org . apache . tools . ant . types . resources ; public interface Touchable { void touch ( long modTime ) ; } 	0
package org . apache . tools . ant . taskdefs . optional . extension . resolvers ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . optional . extension . Extension ; import org . apache . tools . ant . taskdefs . optional . extension . ExtensionResolver ; public class LocationResolver implements ExtensionResolver { private String location ; public void setLocation ( final String location ) { this . location = location ; } public File resolve ( final Extension extension , final Project project ) throws BuildException { if ( null == location ) { final String message = "No location specified for resolver" ; throw new BuildException ( message ) ; } return project . resolveFile ( location ) ; } public String toString ( ) { return "Location[" + location + "]" ; } } 	0
package org . apache . tools . ant . taskdefs . optional . sos ; import org . apache . tools . ant . types . Commandline ; public class SOSGet extends SOS { public final void setFile ( String filename ) { super . setInternalFilename ( filename ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } protected Commandline buildCmdLine ( ) { commandLine = new Commandline ( ) ; if ( getFilename ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_GET_FILE ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_FILE ) ; commandLine . createArgument ( ) . setValue ( getFilename ( ) ) ; if ( getVersion ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_VERSION ) ; commandLine . createArgument ( ) . setValue ( getVersion ( ) ) ; } } else { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_GET_PROJECT ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; if ( getLabel ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_LABEL ) ; commandLine . createArgument ( ) . setValue ( getLabel ( ) ) ; } } getRequiredAttributes ( ) ; getOptionalAttributes ( ) ; return commandLine ; } } 	0
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; import java . util . Iterator ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . FileResourceIterator ; public abstract class ArchiveScanner extends DirectoryScanner { protected File srcFile ; private Resource src ; private Resource lastScannedResource ; private TreeMap fileEntries = new TreeMap ( ) ; private TreeMap dirEntries = new TreeMap ( ) ; private TreeMap matchFileEntries = new TreeMap ( ) ; private TreeMap matchDirEntries = new TreeMap ( ) ; private String encoding ; public void scan ( ) { if ( src == null ) { return ; } super . scan ( ) ; } public void setSrc ( File srcFile ) { setSrc ( new FileResource ( srcFile ) ) ; } public void setSrc ( Resource src ) { this . src = src ; if ( src instanceof FileResource ) { srcFile = ( ( FileResource ) src ) . getFile ( ) ; } } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String [ ] getIncludedFiles ( ) { if ( src == null ) { return super . getIncludedFiles ( ) ; } scanme ( ) ; Set s = matchFileEntries . keySet ( ) ; return ( String [ ] ) ( s . toArray ( new String [ s . size ( ) ] ) ) ; } public int getIncludedFilesCount ( ) { if ( src == null ) { return super . getIncludedFilesCount ( ) ; } scanme ( ) ; return matchFileEntries . size ( ) ; } public String [ ] getIncludedDirectories ( ) { if ( src == null ) { return super . getIncludedDirectories ( ) ; } scanme ( ) ; Set s = matchDirEntries . keySet ( ) ; return ( String [ ] ) ( s . toArray ( new String [ s . size ( ) ] ) ) ; } public int getIncludedDirsCount ( ) { if ( src == null ) { return super . getIncludedDirsCount ( ) ; } scanme ( ) ; return matchDirEntries . size ( ) ; } Iterator getResourceFiles ( ) { if ( src == null ) { return new FileResourceIterator ( getBasedir ( ) , getIncludedFiles ( ) ) ; } scanme ( ) ; return matchFileEntries . values ( ) . iterator ( ) ; } Iterator getResourceDirectories ( ) { if ( src == null ) { return new FileResourceIterator ( getBasedir ( ) , getIncludedDirectories ( ) ) ; } scanme ( ) ; return matchDirEntries . values ( ) . iterator ( ) ; } public void init ( ) { if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } } public boolean match ( String path ) { String vpath = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; return isIncluded ( vpath ) && ! isExcluded ( vpath ) ; } public Resource getResource ( String name ) { if ( src == null ) { return super . getResource ( name ) ; } if ( name . equals ( "" ) ) { return new Resource ( "" , true , Long . MAX_VALUE , true ) ; } scanme ( ) ; if ( fileEntries . containsKey ( name ) ) { return ( Resource ) fileEntries . get ( name ) ; } name = trimSeparator ( name ) ; if ( dirEntries . containsKey ( name ) ) { return ( Resource ) dirEntries . get ( name ) ; } return new Resource ( name ) ; } protected abstract void fillMapsFromArchive ( Resource archive , String encoding , Map fileEntries , Map matchFileEntries , Map dirEntries , Map matchDirEntries ) ; private void scanme ( ) { Resource thisresource = new Resource ( src . getName ( ) , src . isExists ( ) , src . getLastModified ( ) ) ; if ( lastScannedResource != null && lastScannedResource . getName ( ) . equals ( thisresource . getName ( ) ) && lastScannedResource . getLastModified ( ) == thisresource . getLastModified ( ) ) { return ; } init ( ) ; fileEntries . clear ( ) ; dirEntries . clear ( ) ; matchFileEntries . clear ( ) ; matchDirEntries . clear ( ) ; fillMapsFromArchive ( src , encoding , fileEntries , matchFileEntries , dirEntries , matchDirEntries ) ; lastScannedResource = thisresource ; } protected static final String trimSeparator ( String s ) { return s . endsWith ( "/" ) ? s . substring ( 0 , s . length ( ) - 1 ) : s ; } } 	1
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class Utf8CPInfo extends ConstantPoolEntry { private String value ; public Utf8CPInfo ( ) { super ( CONSTANT_UTF8 , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { value = cpStream . readUTF ( ) ; } public String toString ( ) { return "UTF8 Value = " + value ; } public String getValue ( ) { return value ; } } 	0
package org . apache . tools . ant . types . resources ; import java . io . IOException ; import java . io . InputStream ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; public class JavaResource extends Resource { private Path classpath ; private Reference loader ; public JavaResource ( ) { } public JavaResource ( String name , Path path ) { setName ( name ) ; classpath = path ; } public void setClasspath ( Path classpath ) { checkAttributesAllowed ( ) ; if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { checkChildrenAllowed ( ) ; if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { checkAttributesAllowed ( ) ; createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return isReference ( ) ? ( ( JavaResource ) getCheckedRef ( ) ) . getClasspath ( ) : classpath ; } public void setLoaderRef ( Reference r ) { checkAttributesAllowed ( ) ; loader = r ; } public void setRefid ( Reference r ) { if ( loader != null || classpath != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public boolean isExists ( ) { InputStream is = null ; try { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) : ( is = getInputStream ( ) ) != null ; } catch ( IOException ex ) { return false ; } finally { FileUtils . close ( is ) ; } } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } ClassLoader cl = null ; if ( loader != null ) { cl = ( ClassLoader ) loader . getReferencedObject ( ) ; } if ( cl == null ) { if ( getClasspath ( ) != null ) { cl = getProject ( ) . createClassLoader ( classpath ) ; } else { cl = JavaResource . class . getClassLoader ( ) ; } if ( loader != null && cl != null ) { getProject ( ) . addReference ( loader . getRefId ( ) , cl ) ; } } return cl == null ? ClassLoader . getSystemResourceAsStream ( getName ( ) ) : cl . getResourceAsStream ( getName ( ) ) ; } public int compareTo ( Object another ) { if ( isReference ( ) ) { return ( ( Comparable ) getCheckedRef ( ) ) . compareTo ( another ) ; } if ( another . getClass ( ) . equals ( getClass ( ) ) ) { JavaResource otherjr = ( JavaResource ) another ; if ( ! getName ( ) . equals ( otherjr . getName ( ) ) ) { return getName ( ) . compareTo ( otherjr . getName ( ) ) ; } if ( loader != otherjr . loader ) { if ( loader == null ) { return - 1 ; } if ( otherjr . loader == null ) { return 1 ; } return loader . getRefId ( ) . compareTo ( otherjr . loader . getRefId ( ) ) ; } Path p = getClasspath ( ) ; Path op = otherjr . getClasspath ( ) ; if ( p != op ) { if ( p == null ) { return - 1 ; } if ( op == null ) { return 1 ; } return p . toString ( ) . compareTo ( op . toString ( ) ) ; } return 0 ; } return super . compareTo ( another ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import javax . xml . parsers . SAXParser ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . xml . sax . SAXException ; public class IPlanetDeploymentTool extends GenericDeploymentTool { private File iashome ; private String jarSuffix = ".jar" ; private boolean keepgenerated = false ; private boolean debug = false ; private String descriptorName ; private String iasDescriptorName ; private String displayName ; private static final String IAS_DD = "ias-ejb-jar.xml" ; public void setIashome ( File iashome ) { this . iashome = iashome ; } public void setKeepgenerated ( boolean keepgenerated ) { this . keepgenerated = keepgenerated ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setSuffix ( String jarSuffix ) { this . jarSuffix = jarSuffix ; } public void setGenericJarSuffix ( String inString ) { log ( "Since a generic JAR file is not created during processing, the " + "iPlanet Deployment Tool does not support the " + "\"genericjarsuffix\" attribute.  It will be ignored." , Project . MSG_WARN ) ; } public void processDescriptor ( String descriptorName , SAXParser saxParser ) { this . descriptorName = descriptorName ; this . iasDescriptorName = null ; log ( "iPlanet Deployment Tool processing: " + descriptorName + " (and " + getIasDescriptorName ( ) + ")" , Project . MSG_VERBOSE ) ; super . processDescriptor ( descriptorName , saxParser ) ; } protected void checkConfiguration ( String descriptorFileName , SAXParser saxParser ) throws BuildException { int startOfName = descriptorFileName . lastIndexOf ( File . separatorChar ) + 1 ; String stdXml = descriptorFileName . substring ( startOfName ) ; if ( stdXml . equals ( EJB_DD ) && ( getConfig ( ) . baseJarName == null ) ) { String msg = "No name specified for the completed JAR file.  The EJB" + " descriptor should be prepended with the JAR " + "name or it should be specified using the " + "attribute \"basejarname\" in the \"ejbjar\" task." ; throw new BuildException ( msg , getLocation ( ) ) ; } File iasDescriptor = new File ( getConfig ( ) . descriptorDir , getIasDescriptorName ( ) ) ; if ( ( ! iasDescriptor . exists ( ) ) || ( ! iasDescriptor . isFile ( ) ) ) { String msg = "The iAS-specific EJB descriptor (" + iasDescriptor + ") was not found." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( iashome != null ) && ( ! iashome . isDirectory ( ) ) ) { String msg = "If \"iashome\" is specified, it must be a valid " + "directory (it was set to " + iashome + ")." ; throw new BuildException ( msg , getLocation ( ) ) ; } } protected Hashtable parseEjbFiles ( String descriptorFileName , SAXParser saxParser ) throws IOException , SAXException { Hashtable files ; IPlanetEjbc ejbc = new IPlanetEjbc ( new File ( getConfig ( ) . descriptorDir , descriptorFileName ) , new File ( getConfig ( ) . descriptorDir , getIasDescriptorName ( ) ) , getConfig ( ) . srcDir , getCombinedClasspath ( ) . toString ( ) , saxParser ) ; ejbc . setRetainSource ( keepgenerated ) ; ejbc . setDebugOutput ( debug ) ; if ( iashome != null ) { ejbc . setIasHomeDir ( iashome ) ; } try { ejbc . execute ( ) ; } catch ( IPlanetEjbc . EjbcException e ) { throw new BuildException ( "An error has occurred while trying to " + "execute the iAS ejbc utility" , e , getLocation ( ) ) ; } displayName = ejbc . getDisplayName ( ) ; files = ejbc . getEjbFiles ( ) ; String [ ] cmpDescriptors = ejbc . getCmpDescriptors ( ) ; if ( cmpDescriptors . length > 0 ) { File baseDir = getConfig ( ) . descriptorDir ; int endOfPath = descriptorFileName . lastIndexOf ( File . separator ) ; String relativePath = descriptorFileName . substring ( 0 , endOfPath + 1 ) ; for ( int i = 0 ; i < cmpDescriptors . length ; i ++ ) { int endOfCmp = cmpDescriptors [ i ] . lastIndexOf ( '/' ) ; String cmpDescriptor = cmpDescriptors [ i ] . substring ( endOfCmp + 1 ) ; File cmpFile = new File ( baseDir , relativePath + cmpDescriptor ) ; if ( ! cmpFile . exists ( ) ) { throw new BuildException ( "The CMP descriptor file (" + cmpFile + ") could not be found." , getLocation ( ) ) ; } files . put ( cmpDescriptors [ i ] , cmpFile ) ; } } return files ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { ejbFiles . put ( META_DIR + IAS_DD , new File ( getConfig ( ) . descriptorDir , getIasDescriptorName ( ) ) ) ; } File getVendorOutputJarFile ( String baseName ) { File jarFile = new File ( getDestDir ( ) , baseName + jarSuffix ) ; log ( "JAR file name: " + jarFile . toString ( ) , Project . MSG_VERBOSE ) ; return jarFile ; } protected String getPublicId ( ) { return null ; } private String getIasDescriptorName ( ) { if ( iasDescriptorName != null ) { return iasDescriptorName ; } String path = "" ; String basename ; String remainder ; int startOfFileName = descriptorName . lastIndexOf ( File . separatorChar ) ; if ( startOfFileName != - 1 ) { path = descriptorName . substring ( 0 , startOfFileName + 1 ) ; } if ( descriptorName . substring ( startOfFileName + 1 ) . equals ( EJB_DD ) ) { basename = "" ; remainder = EJB_DD ; } else { int endOfBaseName = descriptorName . indexOf ( getConfig ( ) . baseNameTerminator , startOfFileName ) ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . lastIndexOf ( '.' ) - 1 ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . length ( ) - 1 ; } } basename = descriptorName . substring ( startOfFileName + 1 , endOfBaseName + 1 ) ; remainder = descriptorName . substring ( endOfBaseName + 1 ) ; } iasDescriptorName = path + basename + "ias-" + remainder ; return iasDescriptorName ; } } 	1
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public interface SelectorContainer { boolean hasSelectors ( ) ; int selectorCount ( ) ; FileSelector [ ] getSelectors ( Project p ) ; Enumeration selectorElements ( ) ; void appendSelector ( FileSelector selector ) ; void addSelector ( SelectSelector selector ) ; void addAnd ( AndSelector selector ) ; void addOr ( OrSelector selector ) ; void addNot ( NotSelector selector ) ; void addNone ( NoneSelector selector ) ; void addMajority ( MajoritySelector selector ) ; void addDate ( DateSelector selector ) ; void addSize ( SizeSelector selector ) ; void addFilename ( FilenameSelector selector ) ; void addCustom ( ExtendSelector selector ) ; void addContains ( ContainsSelector selector ) ; void addPresent ( PresentSelector selector ) ; void addDepth ( DepthSelector selector ) ; void addDepend ( DependSelector selector ) ; void addContainsRegexp ( ContainsRegexpSelector selector ) ; void addType ( TypeSelector selector ) ; void addDifferent ( DifferentSelector selector ) ; void addModified ( ModifiedSelector selector ) ; void add ( FileSelector selector ) ; } 	0
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . io . OutputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import java . util . Iterator ; import java . util . Properties ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . security . Provider ; import java . security . Security ; import javax . activation . DataHandler ; import javax . activation . FileDataSource ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . Authenticator ; import javax . mail . MessagingException ; import javax . mail . PasswordAuthentication ; import javax . mail . internet . MimeMessage ; import javax . mail . internet . MimeBodyPart ; import javax . mail . internet . MimeMultipart ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . AddressException ; import org . apache . tools . ant . BuildException ; public class MimeMailer extends Mailer { private static final String SSL_FACTORY = "javax.net.ssl.SSLSocketFactory" ; private static final String DEFAULT_CHARSET = System . getProperty ( "file.encoding" ) ; class StringDataSource implements javax . activation . DataSource { private String data = null ; private String type = null ; private String charset = null ; private ByteArrayOutputStream out ; public InputStream getInputStream ( ) throws IOException { if ( data == null && out == null ) { throw new IOException ( "No data" ) ; } if ( out != null ) { String encodedOut = out . toString ( charset ) ; data = ( data != null ) ? data . concat ( encodedOut ) : encodedOut ; out = null ; } return new ByteArrayInputStream ( data . getBytes ( charset ) ) ; } public OutputStream getOutputStream ( ) throws IOException { out = ( out == null ) ? new ByteArrayOutputStream ( ) : out ; return out ; } public void setContentType ( String type ) { this . type = type . toLowerCase ( ) ; } public String getContentType ( ) { if ( type != null && type . indexOf ( "charset" ) > 0 && type . startsWith ( "text/" ) ) { return type ; } return new StringBuffer ( type != null ? type : "text/plain" ) . append ( "; charset=" ) . append ( charset ) . toString ( ) ; } public String getName ( ) { return "StringDataSource" ; } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } public void send ( ) { try { Properties props = new Properties ( ) ; props . put ( "mail.smtp.host" , host ) ; props . put ( "mail.smtp.port" , String . valueOf ( port ) ) ; Session sesh ; Authenticator auth ; if ( SSL ) { try { Provider p = ( Provider ) Class . forName ( "com.sun.net.ssl.internal.ssl.Provider" ) . newInstance ( ) ; Security . addProvider ( p ) ; } catch ( Exception e ) { throw new BuildException ( "could not instantiate ssl " + "security provider, check that you have JSSE in " + "your classpath" ) ; } props . put ( "mail.smtp.socketFactory.class" , SSL_FACTORY ) ; props . put ( "mail.smtp.socketFactory.fallback" , "false" ) ; } if ( user == null && password == null ) { sesh = Session . getDefaultInstance ( props , null ) ; } else { props . put ( "mail.smtp.auth" , "true" ) ; auth = new SimpleAuthenticator ( user , password ) ; sesh = Session . getInstance ( props , auth ) ; } MimeMessage msg = new MimeMessage ( sesh ) ; MimeMultipart attachments = new MimeMultipart ( ) ; if ( from . getName ( ) == null ) { msg . setFrom ( new InternetAddress ( from . getAddress ( ) ) ) ; } else { msg . setFrom ( new InternetAddress ( from . getAddress ( ) , from . getName ( ) ) ) ; } msg . setReplyTo ( internetAddresses ( replyToList ) ) ; msg . setRecipients ( Message . RecipientType . TO , internetAddresses ( toList ) ) ; msg . setRecipients ( Message . RecipientType . CC , internetAddresses ( ccList ) ) ; msg . setRecipients ( Message . RecipientType . BCC , internetAddresses ( bccList ) ) ; String charset = parseCharSetFromMimeType ( message . getMimeType ( ) ) ; if ( charset != null ) { message . setCharset ( charset ) ; } else { charset = message . getCharset ( ) ; if ( charset == null ) { charset = DEFAULT_CHARSET ; message . setCharset ( charset ) ; } } StringDataSource sds = new StringDataSource ( ) ; sds . setContentType ( message . getMimeType ( ) ) ; sds . setCharset ( charset ) ; if ( subject != null ) { msg . setSubject ( subject , charset ) ; } msg . addHeader ( "Date" , getDate ( ) ) ; for ( Iterator iter = headers . iterator ( ) ; iter . hasNext ( ) ; ) { Header h = ( Header ) iter . next ( ) ; msg . addHeader ( h . getName ( ) , h . getValue ( ) ) ; } PrintStream out = new PrintStream ( sds . getOutputStream ( ) ) ; message . print ( out ) ; out . close ( ) ; MimeBodyPart textbody = new MimeBodyPart ( ) ; textbody . setDataHandler ( new DataHandler ( sds ) ) ; attachments . addBodyPart ( textbody ) ; Enumeration e = files . elements ( ) ; while ( e . hasMoreElements ( ) ) { File file = ( File ) e . nextElement ( ) ; MimeBodyPart body ; body = new MimeBodyPart ( ) ; if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getAbsolutePath ( ) + "\" does not exist or is not " + "readable." ) ; } FileDataSource fileData = new FileDataSource ( file ) ; DataHandler fileDataHandler = new DataHandler ( fileData ) ; body . setDataHandler ( fileDataHandler ) ; body . setFileName ( file . getName ( ) ) ; attachments . addBodyPart ( body ) ; } msg . setContent ( attachments ) ; Transport . send ( msg ) ; } catch ( MessagingException e ) { throw new BuildException ( "Problem while sending mime mail:" , e ) ; } catch ( IOException e ) { throw new BuildException ( "Problem while sending mime mail:" , e ) ; } } private static InternetAddress [ ] internetAddresses ( Vector list ) throws AddressException , UnsupportedEncodingException { InternetAddress [ ] addrs = new InternetAddress [ list . size ( ) ] ; for ( int i = 0 ; i < list . size ( ) ; ++ i ) { EmailAddress addr = ( EmailAddress ) list . elementAt ( i ) ; String name = addr . getName ( ) ; addrs [ i ] = ( name == null ) ? new InternetAddress ( addr . getAddress ( ) ) : new InternetAddress ( addr . getAddress ( ) , name ) ; } return addrs ; } private String parseCharSetFromMimeType ( String type ) { int pos ; if ( type == null || ( pos = type . indexOf ( "charset" ) ) < 0 ) { return null ; } StringTokenizer token = new StringTokenizer ( type . substring ( pos ) , "=; " ) ; token . nextToken ( ) ; return token . nextToken ( ) ; } static class SimpleAuthenticator extends Authenticator { private String user = null ; private String password = null ; public SimpleAuthenticator ( String user , String password ) { this . user = user ; this . password = password ; } public PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( user , password ) ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . ssh ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . StringTokenizer ; import java . io . File ; public class Directory { private File directory ; private ArrayList childDirectories ; private ArrayList files ; private Directory parent ; public Directory ( File directory ) { this ( directory , null ) ; } public Directory ( File directory , Directory parent ) { this . parent = parent ; this . childDirectories = new ArrayList ( ) ; this . files = new ArrayList ( ) ; this . directory = directory ; } public void addDirectory ( Directory directory ) { if ( ! childDirectories . contains ( directory ) ) { childDirectories . add ( directory ) ; } } public void addFile ( File file ) { files . add ( file ) ; } public Iterator directoryIterator ( ) { return childDirectories . iterator ( ) ; } public Iterator filesIterator ( ) { return files . iterator ( ) ; } public Directory getParent ( ) { return parent ; } public boolean isRoot ( ) { return parent == null ; } public File getDirectory ( ) { return directory ; } public Directory getChild ( File dir ) { for ( int i = 0 ; i < childDirectories . size ( ) ; i ++ ) { Directory current = ( Directory ) childDirectories . get ( i ) ; if ( current . getDirectory ( ) . equals ( dir ) ) { return current ; } } return null ; } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Directory ) ) { return false ; } Directory d = ( Directory ) obj ; return this . directory . equals ( d . directory ) ; } public int hashCode ( ) { return directory . hashCode ( ) ; } public String [ ] getPath ( ) { return getPath ( directory . getAbsolutePath ( ) ) ; } public static String [ ] getPath ( String thePath ) { StringTokenizer tokenizer = new StringTokenizer ( thePath , File . separator ) ; String [ ] path = new String [ tokenizer . countTokens ( ) ] ; int i = 0 ; while ( tokenizer . hasMoreTokens ( ) ) { path [ i ] = tokenizer . nextToken ( ) ; i ++ ; } return path ; } public int fileSize ( ) { return files . size ( ) ; } } 	0
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Vector ; public class FilterSetCollection { private Vector filterSets = new Vector ( ) ; public FilterSetCollection ( ) { } public FilterSetCollection ( FilterSet filterSet ) { addFilterSet ( filterSet ) ; } public void addFilterSet ( FilterSet filterSet ) { filterSets . addElement ( filterSet ) ; } public String replaceTokens ( String line ) { String replacedLine = line ; for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; replacedLine = filterSet . replaceTokens ( replacedLine ) ; } return replacedLine ; } public boolean hasFilters ( ) { for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; if ( filterSet . hasFilters ( ) ) { return true ; } } return false ; } } 	0
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; public class DirectoryIterator implements ClassFileIterator { private Stack enumStack ; private Enumeration currentEnum ; public DirectoryIterator ( File rootDirectory , boolean changeInto ) throws IOException { super ( ) ; enumStack = new Stack ( ) ; Vector filesInRoot = getDirectoryEntries ( rootDirectory ) ; currentEnum = filesInRoot . elements ( ) ; } private Vector getDirectoryEntries ( File directory ) { Vector files = new Vector ( ) ; String [ ] filesInDir = directory . list ( ) ; if ( filesInDir != null ) { int length = filesInDir . length ; for ( int i = 0 ; i < length ; ++ i ) { files . addElement ( new File ( directory , filesInDir [ i ] ) ) ; } } return files ; } public ClassFile getNextClassFile ( ) { ClassFile nextElement = null ; try { while ( nextElement == null ) { if ( currentEnum . hasMoreElements ( ) ) { File element = ( File ) currentEnum . nextElement ( ) ; if ( element . isDirectory ( ) ) { enumStack . push ( currentEnum ) ; Vector files = getDirectoryEntries ( element ) ; currentEnum = files . elements ( ) ; } else { FileInputStream inFileStream = new FileInputStream ( element ) ; if ( element . getName ( ) . endsWith ( ".class" ) ) { ClassFile javaClass = new ClassFile ( ) ; javaClass . read ( inFileStream ) ; nextElement = javaClass ; } } } else { if ( enumStack . empty ( ) ) { break ; } else { currentEnum = ( Enumeration ) enumStack . pop ( ) ; } } } } catch ( IOException e ) { nextElement = null ; } return nextElement ; } } 	0
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class IsSigned extends DataType implements Condition { private static final String SIG_START = "META-INF/" ; private static final String SIG_END = ".SF" ; private static final int SHORT_SIG_LIMIT = 8 ; private String name ; private File file ; public void setFile ( File file ) { this . file = file ; } public void setName ( String name ) { this . name = name ; } public static boolean isSigned ( File zipFile , String name ) throws IOException { ZipFile jarFile = null ; try { jarFile = new ZipFile ( zipFile ) ; if ( null == name ) { Enumeration entries = jarFile . getEntries ( ) ; while ( entries . hasMoreElements ( ) ) { String eName = ( ( ZipEntry ) entries . nextElement ( ) ) . getName ( ) ; if ( eName . startsWith ( SIG_START ) && eName . endsWith ( SIG_END ) ) { return true ; } } return false ; } boolean shortSig = jarFile . getEntry ( SIG_START + name . toUpperCase ( ) + SIG_END ) != null ; boolean longSig = false ; if ( name . length ( ) > SHORT_SIG_LIMIT ) { longSig = jarFile . getEntry ( SIG_START + name . substring ( 0 , SHORT_SIG_LIMIT ) . toUpperCase ( ) + SIG_END ) != null ; } return shortSig || longSig ; } finally { ZipFile . closeQuietly ( jarFile ) ; } } public boolean eval ( ) { if ( file == null ) { throw new BuildException ( "The file attribute must be set." ) ; } if ( file != null && ! file . exists ( ) ) { log ( "The file \"" + file . getAbsolutePath ( ) + "\" does not exist." , Project . MSG_VERBOSE ) ; return false ; } boolean r = false ; try { r = isSigned ( file , name ) ; } catch ( IOException e ) { log ( "Got IOException reading file \"" + file . getAbsolutePath ( ) + "\"" + e , Project . MSG_WARN ) ; } if ( r ) { log ( "File \"" + file . getAbsolutePath ( ) + "\" is signed." , Project . MSG_VERBOSE ) ; } return r ; } } 	1
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import java . io . ByteArrayOutputStream ; import java . util . StringTokenizer ; public class CvsVersion extends AbstractCvsTask { static final long VERSION_1_11_2 = 11102 ; static final long MULTIPLY = 100 ; private String clientVersion ; private String serverVersion ; private String clientVersionProperty ; private String serverVersionProperty ; public String getClientVersion ( ) { return clientVersion ; } public String getServerVersion ( ) { return serverVersion ; } public void setClientVersionProperty ( String clientVersionProperty ) { this . clientVersionProperty = clientVersionProperty ; } public void setServerVersionProperty ( String serverVersionProperty ) { this . serverVersionProperty = serverVersionProperty ; } public boolean supportsCvsLogWithSOption ( ) { if ( serverVersion == null ) { return false ; } StringTokenizer tokenizer = new StringTokenizer ( serverVersion , "." ) ; long counter = MULTIPLY * MULTIPLY ; long version = 0 ; while ( tokenizer . hasMoreTokens ( ) ) { String s = tokenizer . nextToken ( ) ; int i = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isDigit ( s . charAt ( i ) ) ) { break ; } } String s2 = s . substring ( 0 , i ) ; version = version + counter * Long . parseLong ( s2 ) ; if ( counter == 1 ) { break ; } counter = counter / MULTIPLY ; } return ( version >= VERSION_1_11_2 ) ; } public void execute ( ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; this . setOutputStream ( bos ) ; ByteArrayOutputStream berr = new ByteArrayOutputStream ( ) ; this . setErrorStream ( berr ) ; setCommand ( "version" ) ; super . execute ( ) ; String output = bos . toString ( ) ; StringTokenizer st = new StringTokenizer ( output ) ; boolean client = false ; boolean server = false ; boolean cvs = false ; while ( st . hasMoreTokens ( ) ) { String currentToken = st . nextToken ( ) ; if ( currentToken . equals ( "Client:" ) ) { client = true ; } else if ( currentToken . equals ( "Server:" ) ) { server = true ; } else if ( currentToken . equals ( "(CVS)" ) ) { cvs = true ; } if ( client && cvs ) { if ( st . hasMoreTokens ( ) ) { clientVersion = st . nextToken ( ) ; } client = false ; cvs = false ; } else if ( server && cvs ) { if ( st . hasMoreTokens ( ) ) { serverVersion = st . nextToken ( ) ; } server = false ; cvs = false ; } } if ( clientVersionProperty != null ) { getProject ( ) . setNewProperty ( clientVersionProperty , clientVersion ) ; } if ( serverVersionProperty != null ) { getProject ( ) . setNewProperty ( serverVersionProperty , serverVersion ) ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; public class ConstantPool { private Vector entries ; private Hashtable utf8Indexes ; public ConstantPool ( ) { entries = new Vector ( ) ; entries . addElement ( null ) ; utf8Indexes = new Hashtable ( ) ; } public void read ( DataInputStream classStream ) throws IOException { int numEntries = classStream . readUnsignedShort ( ) ; for ( int i = 1 ; i < numEntries ; ) { ConstantPoolEntry nextEntry = ConstantPoolEntry . readEntry ( classStream ) ; i += nextEntry . getNumEntries ( ) ; addEntry ( nextEntry ) ; } } public int size ( ) { return entries . size ( ) ; } public int addEntry ( ConstantPoolEntry entry ) { int index = entries . size ( ) ; entries . addElement ( entry ) ; int numSlots = entry . getNumEntries ( ) ; for ( int j = 0 ; j < numSlots - 1 ; ++ j ) { entries . addElement ( null ) ; } if ( entry instanceof Utf8CPInfo ) { Utf8CPInfo utf8Info = ( Utf8CPInfo ) entry ; utf8Indexes . put ( utf8Info . getValue ( ) , new Integer ( index ) ) ; } return index ; } public void resolve ( ) { for ( Enumeration i = entries . elements ( ) ; i . hasMoreElements ( ) ; ) { ConstantPoolEntry poolInfo = ( ConstantPoolEntry ) i . nextElement ( ) ; if ( poolInfo != null && ! poolInfo . isResolved ( ) ) { poolInfo . resolve ( this ) ; } } } public ConstantPoolEntry getEntry ( int index ) { return ( ConstantPoolEntry ) entries . elementAt ( index ) ; } public int getUTF8Entry ( String value ) { int index = - 1 ; Integer indexInteger = ( Integer ) utf8Indexes . get ( value ) ; if ( indexInteger != null ) { index = indexInteger . intValue ( ) ; } return index ; } public int getClassEntry ( String className ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof ClassCPInfo ) { ClassCPInfo classinfo = ( ClassCPInfo ) element ; if ( classinfo . getClassName ( ) . equals ( className ) ) { index = i ; } } } return index ; } public int getConstantEntry ( Object constantValue ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof ConstantCPInfo ) { ConstantCPInfo constantEntry = ( ConstantCPInfo ) element ; if ( constantEntry . getValue ( ) . equals ( constantValue ) ) { index = i ; } } } return index ; } public int getMethodRefEntry ( String methodClassName , String methodName , String methodType ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof MethodRefCPInfo ) { MethodRefCPInfo methodRefEntry = ( MethodRefCPInfo ) element ; if ( methodRefEntry . getMethodClassName ( ) . equals ( methodClassName ) && methodRefEntry . getMethodName ( ) . equals ( methodName ) && methodRefEntry . getMethodType ( ) . equals ( methodType ) ) { index = i ; } } } return index ; } public int getInterfaceMethodRefEntry ( String interfaceMethodClassName , String interfaceMethodName , String interfaceMethodType ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof InterfaceMethodRefCPInfo ) { InterfaceMethodRefCPInfo interfaceMethodRefEntry = ( InterfaceMethodRefCPInfo ) element ; if ( interfaceMethodRefEntry . getInterfaceMethodClassName ( ) . equals ( interfaceMethodClassName ) && interfaceMethodRefEntry . getInterfaceMethodName ( ) . equals ( interfaceMethodName ) && interfaceMethodRefEntry . getInterfaceMethodType ( ) . equals ( interfaceMethodType ) ) { index = i ; } } } return index ; } public int getFieldRefEntry ( String fieldClassName , String fieldName , String fieldType ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof FieldRefCPInfo ) { FieldRefCPInfo fieldRefEntry = ( FieldRefCPInfo ) element ; if ( fieldRefEntry . getFieldClassName ( ) . equals ( fieldClassName ) && fieldRefEntry . getFieldName ( ) . equals ( fieldName ) && fieldRefEntry . getFieldType ( ) . equals ( fieldType ) ) { index = i ; } } } return index ; } public int getNameAndTypeEntry ( String name , String type ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof NameAndTypeCPInfo ) { NameAndTypeCPInfo nameAndTypeEntry = ( NameAndTypeCPInfo ) element ; if ( nameAndTypeEntry . getName ( ) . equals ( name ) && nameAndTypeEntry . getType ( ) . equals ( type ) ) { index = i ; } } } return index ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( "\n" ) ; int size = entries . size ( ) ; for ( int i = 0 ; i < size ; ++ i ) { sb . append ( "[" + i + "] = " + getEntry ( i ) + "\n" ) ; } return sb . toString ( ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCCheckout extends ClearCase { private boolean mReserved = true ; private String mOut = null ; private boolean mNdata = false ; private String mBranch = null ; private boolean mVersion = false ; private boolean mNwarn = false ; private String mComment = null ; private String mCfile = null ; private boolean mNotco = true ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CHECKOUT ) ; checkOptions ( commandLine ) ; if ( ! getNotco ( ) && lsCheckout ( ) ) { getProject ( ) . log ( "Already checked out in this view: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; return ; } if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private boolean lsCheckout ( ) { Commandline cmdl = new Commandline ( ) ; String result ; cmdl . setExecutable ( getClearToolCommand ( ) ) ; cmdl . createArgument ( ) . setValue ( COMMAND_LSCO ) ; cmdl . createArgument ( ) . setValue ( "-cview" ) ; cmdl . createArgument ( ) . setValue ( "-short" ) ; cmdl . createArgument ( ) . setValue ( "-d" ) ; cmdl . createArgument ( ) . setValue ( getViewPath ( ) ) ; result = runS ( cmdl ) ; return ( result != null && result . length ( ) > 0 ) ? true : false ; } private void checkOptions ( Commandline cmd ) { if ( getReserved ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RESERVED ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_UNRESERVED ) ; } if ( getOut ( ) != null ) { getOutCommand ( cmd ) ; } else { if ( getNoData ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NODATA ) ; } } if ( getBranch ( ) != null ) { getBranchCommand ( cmd ) ; } else { if ( getVersion ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_VERSION ) ; } } if ( getNoWarn ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOWARN ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setReserved ( boolean reserved ) { mReserved = reserved ; } public boolean getReserved ( ) { return mReserved ; } public void setNotco ( boolean notco ) { mNotco = notco ; } public boolean getNotco ( ) { return mNotco ; } public void setOut ( String outf ) { mOut = outf ; } public String getOut ( ) { return mOut ; } public void setNoData ( boolean ndata ) { mNdata = ndata ; } public boolean getNoData ( ) { return mNdata ; } public void setBranch ( String branch ) { mBranch = branch ; } public String getBranch ( ) { return mBranch ; } public void setVersion ( boolean version ) { mVersion = version ; } public boolean getVersion ( ) { return mVersion ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } private void getOutCommand ( Commandline cmd ) { if ( getOut ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_OUT ) ; cmd . createArgument ( ) . setValue ( getOut ( ) ) ; } } private void getBranchCommand ( Commandline cmd ) { if ( getBranch ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_BRANCH ) ; cmd . createArgument ( ) . setValue ( getBranch ( ) ) ; } } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_RESERVED = "-reserved" ; public static final String FLAG_UNRESERVED = "-unreserved" ; public static final String FLAG_OUT = "-out" ; public static final String FLAG_NODATA = "-ndata" ; public static final String FLAG_BRANCH = "-branch" ; public static final String FLAG_VERSION = "-version" ; public static final String FLAG_NOWARN = "-nwarn" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . DynamicConfigurator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; public class XSLTProcess extends MatchingTask implements XSLTLogger { private File destDir = null ; private File baseDir = null ; private String xslFile = null ; private Resource xslResource = null ; private String targetExtension = ".html" ; private String fileNameParameter = null ; private String fileDirParameter = null ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private String processor ; private Path classpath = null ; private XSLTLiaison liaison ; private boolean stylesheetLoaded = false ; private boolean force = false ; private Vector outputProperties = new Vector ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; private static final String TRAX_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private boolean performDirectoryScan = true ; private Factory factory = null ; private boolean reuseLoadedStylesheet = true ; private AntClassLoader loader = null ; private Mapper mapperElement = null ; private Union resources = new Union ( ) ; private boolean useImplicitFileset = true ; public static final String PROCESSOR_TRAX = "trax" ; public XSLTProcess ( ) { } public void setScanIncludedDirectories ( boolean b ) { performDirectoryScan = b ; } public void setReloadStylesheet ( boolean b ) { reuseLoadedStylesheet = ! b ; } public void addMapper ( Mapper mapper ) { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = mapper ; } public void add ( ResourceCollection rc ) { resources . add ( rc ) ; } public void addConfiguredStyle ( Resources rc ) { if ( rc . size ( ) != 1 ) { throw new BuildException ( "The style element must be specified" + " with exactly one nested resource." ) ; } setXslResource ( ( Resource ) rc . iterator ( ) . next ( ) ) ; } public void setXslResource ( Resource xslResource ) { this . xslResource = xslResource ; } public void add ( FileNameMapper fileNameMapper ) throws BuildException { Mapper mapper = new Mapper ( getProject ( ) ) ; mapper . add ( fileNameMapper ) ; addMapper ( mapper ) ; } public void execute ( ) throws BuildException { if ( "style" . equals ( getTaskType ( ) ) ) { log ( "Warning: the task name <style> is deprecated. Use <xslt> instead." , Project . MSG_WARN ) ; } File savedBaseDir = baseDir ; DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( xslResource == null && xslFile == null ) { throw new BuildException ( "specify the " + "stylesheet either as a filename in style " + "attribute or as a nested resource" , getLocation ( ) ) ; } if ( xslResource != null && xslFile != null ) { throw new BuildException ( "specify the " + "stylesheet either as a filename in style " + "attribute or as a nested resource but not " + "as both" , getLocation ( ) ) ; } if ( inFile != null && ! inFile . exists ( ) ) { throw new BuildException ( "input file " + inFile . toString ( ) + " does not exist" , getLocation ( ) ) ; } try { if ( baseDir == null ) { baseDir = getProject ( ) . resolveFile ( "." ) ; } liaison = getLiaison ( ) ; if ( liaison instanceof XSLTLoggerAware ) { ( ( XSLTLoggerAware ) liaison ) . setLogger ( this ) ; } log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; if ( xslFile != null ) { File stylesheet = getProject ( ) . resolveFile ( xslFile ) ; if ( ! stylesheet . exists ( ) ) { stylesheet = FILE_UTILS . resolveFile ( baseDir , xslFile ) ; if ( stylesheet . exists ( ) ) { log ( "DEPRECATED - the 'style' attribute should be relative " + "to the project's" ) ; log ( "             basedir, not the tasks's basedir." ) ; } } FileResource fr = new FileResource ( ) ; fr . setProject ( getProject ( ) ) ; fr . setFile ( stylesheet ) ; xslResource = fr ; } if ( inFile != null && outFile != null ) { process ( inFile , outFile , xslResource ) ; return ; } checkDest ( ) ; if ( useImplicitFileset ) { scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , xslResource ) ; } if ( performDirectoryScan ) { dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , dirs [ j ] + File . separator + list [ i ] , destDir , xslResource ) ; } } } } else { if ( resources . size ( ) == 0 ) { throw new BuildException ( "no resources specified" ) ; } } processResources ( xslResource ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; loader = null ; } liaison = null ; stylesheetLoaded = false ; baseDir = savedBaseDir ; } } public void setForce ( boolean force ) { this . force = force ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = xslFile ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProcessor ( String processor ) { this . processor = processor ; } public void setUseImplicitFileset ( boolean useimplicitfileset ) { useImplicitFileset = useimplicitfileset ; } public void addConfiguredXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog . addConfiguredXMLCatalog ( xmlCatalog ) ; } public void setFileNameParameter ( String fileNameParameter ) { this . fileNameParameter = fileNameParameter ; } public void setFileDirParameter ( String fileDirParameter ) { this . fileDirParameter = fileDirParameter ; } private void resolveProcessor ( String proc ) throws Exception { String classname ; if ( proc . equals ( PROCESSOR_TRAX ) ) { classname = TRAX_LIAISON_CLASS ; } else { classname = proc ; } Class clazz = loadClass ( classname ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } private Class loadClass ( String classname ) throws Exception { if ( classpath == null ) { return Class . forName ( classname ) ; } else { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setThreadContextLoader ( ) ; Class c = Class . forName ( classname , true , loader ) ; return c ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void checkDest ( ) { if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } } private void processResources ( Resource stylesheet ) { Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } File base = baseDir ; String name = r . getName ( ) ; if ( r instanceof FileResource ) { FileResource f = ( FileResource ) r ; base = f . getBaseDir ( ) ; if ( base == null ) { name = f . getFile ( ) . getAbsolutePath ( ) ; } } process ( base , name , destDir , stylesheet ) ; } } private void process ( File baseDir , String xmlFile , File destDir , Resource stylesheet ) throws BuildException { File outF = null ; File inF = null ; try { long styleSheetLastModified = stylesheet . getLastModified ( ) ; inF = new File ( baseDir , xmlFile ) ; if ( inF . isDirectory ( ) ) { log ( "Skipping " + inF + " it is a directory." , Project . MSG_VERBOSE ) ; return ; } FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else { mapper = new StyleMapper ( ) ; } String [ ] outFileName = mapper . mapFileName ( xmlFile ) ; if ( outFileName == null || outFileName . length == 0 ) { log ( "Skipping " + inFile + " it cannot get mapped to output." , Project . MSG_VERBOSE ) ; return ; } else if ( outFileName == null || outFileName . length > 1 ) { log ( "Skipping " + inFile + " its mapping is ambiguos." , Project . MSG_VERBOSE ) ; return ; } outF = new File ( destDir , outFileName [ 0 ] ) ; if ( force || inF . lastModified ( ) > outF . lastModified ( ) || styleSheetLastModified > outF . lastModified ( ) ) { ensureDirectoryFor ( outF ) ; log ( "Processing " + inF + " to " + outF ) ; configureLiaison ( stylesheet ) ; setLiaisonDynamicFileParameters ( liaison , inF ) ; liaison . transform ( inF , outF ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outF != null ) { outF . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , Resource stylesheet ) throws BuildException { try { long styleSheetLastModified = stylesheet . getLastModified ( ) ; log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( force || inFile . lastModified ( ) >= outFile . lastModified ( ) || styleSheetLastModified >= outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; configureLiaison ( stylesheet ) ; setLiaisonDynamicFileParameters ( liaison , inFile ) ; liaison . transform ( inFile , outFile ) ; } else { log ( "Skipping input file " + inFile + " because it is older than output file " + outFile + " and so is the stylesheet " + stylesheet , Project . MSG_DEBUG ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = targetFile . getParentFile ( ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } public Factory getFactory ( ) { return factory ; } public XMLCatalog getXMLCatalog ( ) { xmlCatalog . setProject ( getProject ( ) ) ; return xmlCatalog ; } public Enumeration getOutputProperties ( ) { return outputProperties . elements ( ) ; } protected XSLTLiaison getLiaison ( ) { if ( liaison == null ) { if ( processor != null ) { try { resolveProcessor ( processor ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } else { try { resolveProcessor ( PROCESSOR_TRAX ) ; } catch ( Throwable e1 ) { e1 . printStackTrace ( ) ; throw new BuildException ( e1 ) ; } } } return liaison ; } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public static class Param { private String name = null ; private String expression = null ; private String ifProperty ; private String unlessProperty ; private Project project ; public void setProject ( Project project ) { this . project = project ; } public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) { throw new BuildException ( "Name attribute is missing." ) ; } return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) { throw new BuildException ( "Expression attribute is missing." ) ; } return expression ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean shouldUse ( ) { if ( ifProperty != null && project . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && project . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } } public OutputProperty createOutputProperty ( ) { OutputProperty p = new OutputProperty ( ) ; outputProperties . addElement ( p ) ; return p ; } public static class OutputProperty { private String name ; private String value ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } public void init ( ) throws BuildException { super . init ( ) ; xmlCatalog . setProject ( getProject ( ) ) ; } protected void configureLiaison ( File stylesheet ) throws BuildException { FileResource fr = new FileResource ( ) ; fr . setProject ( getProject ( ) ) ; fr . setFile ( stylesheet ) ; configureLiaison ( fr ) ; } protected void configureLiaison ( Resource stylesheet ) throws BuildException { if ( stylesheetLoaded && reuseLoadedStylesheet ) { return ; } stylesheetLoaded = true ; try { log ( "Loading stylesheet " + stylesheet , Project . MSG_INFO ) ; if ( liaison instanceof XSLTLiaison2 ) { ( ( XSLTLiaison2 ) liaison ) . configure ( this ) ; } if ( liaison instanceof XSLTLiaison3 ) { ( ( XSLTLiaison3 ) liaison ) . setStylesheet ( stylesheet ) ; } else { if ( stylesheet instanceof FileResource ) { liaison . setStylesheet ( ( ( FileResource ) stylesheet ) . getFile ( ) ) ; } else { throw new BuildException ( liaison . getClass ( ) . toString ( ) + " accepts the stylesheet only as a file" , getLocation ( ) ) ; } } for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; if ( p . shouldUse ( ) ) { liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } } } catch ( Exception ex ) { log ( "Failed to transform using stylesheet " + stylesheet , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } private void setLiaisonDynamicFileParameters ( XSLTLiaison liaison , File inFile ) throws Exception { if ( fileNameParameter != null ) { liaison . addParam ( fileNameParameter , inFile . getName ( ) ) ; } if ( fileDirParameter != null ) { String fileName = FileUtils . getRelativePath ( baseDir , inFile ) ; File file = new File ( fileName ) ; liaison . addParam ( fileDirParameter , ( file . getParent ( ) != null ) ? file . getParent ( ) . replace ( '\\' , '/' ) : "." ) ; } } public Factory createFactory ( ) throws BuildException { if ( factory != null ) { throw new BuildException ( "'factory' element must be unique" ) ; } factory = new Factory ( ) ; return factory ; } public static class Factory { private String name ; private Vector attributes = new Vector ( ) ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void addAttribute ( Attribute attr ) { attributes . addElement ( attr ) ; } public Enumeration getAttributes ( ) { return attributes . elements ( ) ; } public static class Attribute implements DynamicConfigurator { private String name ; private Object value ; public String getName ( ) { return name ; } public Object getValue ( ) { return value ; } public Object createDynamicElement ( String name ) throws BuildException { return null ; } public void setDynamicAttribute ( String name , String value ) throws BuildException { if ( "name" . equalsIgnoreCase ( name ) ) { this . name = value ; } else if ( "value" . equalsIgnoreCase ( name ) ) { if ( "true" . equalsIgnoreCase ( value ) ) { this . value = Boolean . TRUE ; } else if ( "false" . equalsIgnoreCase ( value ) ) { this . value = Boolean . FALSE ; } else { try { this . value = new Integer ( value ) ; } catch ( NumberFormatException e ) { this . value = value ; } } } else { throw new BuildException ( "Unsupported attribute: " + name ) ; } } } } private class StyleMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String xmlFile ) { int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { xmlFile = xmlFile . substring ( 0 , dotPos ) ; } return new String [ ] { xmlFile + targetExtension } ; } } } 	1
package org . apache . tools . ant ; public interface TypeAdapter { void setProject ( Project p ) ; Project getProject ( ) ; void setProxy ( Object o ) ; Object getProxy ( ) ; void checkProxyClass ( Class proxyClass ) ; } 	0
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Union ; import java . io . File ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . StringTokenizer ; import java . util . Vector ; import java . sql . Connection ; import java . sql . Statement ; import java . sql . SQLException ; import java . sql . SQLWarning ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; public class SQLExec extends JDBCTask { public static class DelimiterType extends EnumeratedAttribute { public static final String NORMAL = "normal" , ROW = "row" ; public String [ ] getValues ( ) { return new String [ ] { NORMAL , ROW } ; } } private int goodSql = 0 ; private int totalSql = 0 ; private Connection conn = null ; private Union resources = new Union ( ) ; private Statement statement = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private boolean showtrailers = true ; private File output = null ; private String onError = "abort" ; private String encoding = null ; private boolean append = false ; private boolean keepformat = false ; private boolean escapeProcessing = true ; private boolean expandProperties = false ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void setExpandProperties ( boolean expandProperties ) { this . expandProperties = expandProperties ; } public boolean getExpandProperties ( ) { return expandProperties ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { resources . add ( rc ) ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . delimiterType = delimiterType . getValue ( ) ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setShowtrailers ( boolean showtrailers ) { this . showtrailers = showtrailers ; } public void setOutput ( File output ) { this . output = output ; } public void setAppend ( boolean append ) { this . append = append ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void setKeepformat ( boolean keepformat ) { this . keepformat = keepformat ; } public void setEscapeProcessing ( boolean enable ) { escapeProcessing = enable ; } public void execute ( ) throws BuildException { Vector savedTransaction = ( Vector ) transactions . clone ( ) ; String savedSqlCommand = sqlCommand ; sqlCommand = sqlCommand . trim ( ) ; try { if ( srcFile == null && sqlCommand . length ( ) == 0 && resources . size ( ) == 0 ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file or resource " + "collection, " + "transactions or sql statement " + "must be set!" , getLocation ( ) ) ; } } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , getLocation ( ) ) ; } Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; Transaction t = createTransaction ( ) ; t . setSrcResource ( r ) ; } Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; conn = getConnection ( ) ; if ( ! isValidRdbms ( conn ) ) { return ; } try { statement = conn . createStatement ( ) ; statement . setEscapeProcessing ( escapeProcessing ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getAbsolutePath ( ) , append ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! isAutocommit ( ) ) { log ( "Committing transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { closeQuietly ( ) ; throw new BuildException ( e , getLocation ( ) ) ; } catch ( SQLException e ) { closeQuietly ( ) ; throw new BuildException ( e , getLocation ( ) ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException ex ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } finally { transactions = savedTransaction ; sqlCommand = savedSqlCommand ; } } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { StringBuffer sql = new StringBuffer ( ) ; String line ; BufferedReader in = new BufferedReader ( reader ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( ! keepformat ) { line = line . trim ( ) ; } line = getProject ( ) . replaceProperties ( line ) ; if ( ! keepformat ) { if ( line . startsWith ( "//" ) ) { continue ; } if ( line . startsWith ( "--" ) ) { continue ; } StringTokenizer st = new StringTokenizer ( line ) ; if ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( "REM" . equalsIgnoreCase ( token ) ) { continue ; } } } if ( ! keepformat ) { sql . append ( " " ) ; sql . append ( line ) ; } else { sql . append ( "\n" ) ; sql . append ( line ) ; } if ( ! keepformat ) { if ( line . indexOf ( "--" ) >= 0 ) { sql . append ( "\n" ) ; } } if ( ( delimiterType . equals ( DelimiterType . NORMAL ) && StringUtils . endsWith ( sql , delimiter ) ) || ( delimiterType . equals ( DelimiterType . ROW ) && line . equals ( delimiter ) ) ) { execSQL ( sql . substring ( 0 , sql . length ( ) - delimiter . length ( ) ) , out ) ; sql . replace ( 0 , sql . length ( ) , "" ) ; } } if ( sql . length ( ) > 0 ) { execSQL ( sql . toString ( ) , out ) ; } } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) { return ; } ResultSet resultSet = null ; try { totalSql ++ ; log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; boolean ret ; int updateCount = 0 , updateCountTotal = 0 ; ret = statement . execute ( sql ) ; updateCount = statement . getUpdateCount ( ) ; resultSet = statement . getResultSet ( ) ; do { if ( ! ret ) { if ( updateCount != - 1 ) { updateCountTotal += updateCount ; } } else { if ( print ) { printResults ( resultSet , out ) ; } } ret = statement . getMoreResults ( ) ; if ( ret ) { updateCount = statement . getUpdateCount ( ) ; resultSet = statement . getResultSet ( ) ; } } while ( ret ) ; log ( updateCountTotal + " rows affected" , Project . MSG_VERBOSE ) ; if ( print && showtrailers ) { out . println ( updateCountTotal + " rows affected" ) ; } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) { throw e ; } log ( e . toString ( ) , Project . MSG_ERR ) ; } finally { if ( resultSet != null ) { resultSet . close ( ) ; } } } protected void printResults ( PrintStream out ) throws SQLException { ResultSet rs = statement . getResultSet ( ) ; try { printResults ( rs , out ) ; } finally { if ( rs != null ) { rs . close ( ) ; } } } protected void printResults ( ResultSet rs , PrintStream out ) throws SQLException { if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line = new StringBuffer ( ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line = new StringBuffer ( ) ; } } out . println ( ) ; } private void closeQuietly ( ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private Resource tSrcResource = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { if ( src != null ) { setSrcResource ( new FileResource ( src ) ) ; } } public void setSrcResource ( Resource src ) { if ( tSrcResource != null ) { throw new BuildException ( "only one resource per transaction" ) ; } tSrcResource = src ; } public void addText ( String sql ) { if ( sql != null ) { if ( getExpandProperties ( ) ) { sql = getProject ( ) . replaceProperties ( sql ) ; } this . tSqlCommand += sql ; } } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource " + "collections are supported." ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcResource != null ) { log ( "Executing resource: " + tSrcResource . toString ( ) , Project . MSG_INFO ) ; InputStream is = null ; Reader reader = null ; try { is = tSrcResource . getInputStream ( ) ; reader = ( encoding == null ) ? new InputStreamReader ( is ) : new InputStreamReader ( is , encoding ) ; runStatements ( reader , out ) ; } finally { FileUtils . close ( is ) ; FileUtils . close ( reader ) ; } } } } } 	1
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCCheckin extends ClearCase { private String mComment = null ; private String mCfile = null ; private boolean mNwarn = false ; private boolean mPtime = false ; private boolean mKeep = false ; private boolean mIdentical = true ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CHECKIN ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getNoWarn ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOWARN ) ; } if ( getPreserveTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PRESERVETIME ) ; } if ( getKeepCopy ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_KEEPCOPY ) ; } if ( getIdentical ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_IDENTICAL ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setPreserveTime ( boolean ptime ) { mPtime = ptime ; } public boolean getPreserveTime ( ) { return mPtime ; } public void setKeepCopy ( boolean keep ) { mKeep = keep ; } public boolean getKeepCopy ( ) { return mKeep ; } public void setIdentical ( boolean identical ) { mIdentical = identical ; } public boolean getIdentical ( ) { return mIdentical ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_NOWARN = "-nwarn" ; public static final String FLAG_PRESERVETIME = "-ptime" ; public static final String FLAG_KEEPCOPY = "-keep" ; public static final String FLAG_IDENTICAL = "-identical" ; } 	0
package org . apache . tools . ant . util ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . io . OutputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . text . DecimalFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . PathTokenizer ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . launch . Locator ; public class FileUtils { private static final FileUtils PRIMARY_INSTANCE = new FileUtils ( ) ; private static Random rand = new Random ( System . currentTimeMillis ( ) + Runtime . getRuntime ( ) . freeMemory ( ) ) ; private static boolean onNetWare = Os . isFamily ( "netware" ) ; private static boolean onDos = Os . isFamily ( "dos" ) ; private static boolean onWin9x = Os . isFamily ( "win9x" ) ; private static boolean onWindows = Os . isFamily ( "windows" ) ; static final int BUF_SIZE = 8192 ; public static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000 ; public static final long UNIX_FILE_TIMESTAMP_GRANULARITY = 1000 ; public static final long NTFS_FILE_TIMESTAMP_GRANULARITY = 1 ; private Object cacheFromUriLock = new Object ( ) ; private String cacheFromUriRequest = null ; private String cacheFromUriResponse = null ; public static FileUtils newFileUtils ( ) { return new FileUtils ( ) ; } public static FileUtils getFileUtils ( ) { return PRIMARY_INSTANCE ; } protected FileUtils ( ) { } public URL getFileURL ( File file ) throws MalformedURLException { return new URL ( toURI ( file . getAbsolutePath ( ) ) ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , null , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified , encoding ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , encoding , project ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , inputEncoding , outputEncoding , project ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , null , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { copyFile ( sourceFile , destFile , filters , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , preserveLastModified , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( sourceFile , destFile , filters , null , overwrite , preserveLastModified , encoding , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( sourceFile , destFile , filters , filterChains , overwrite , preserveLastModified , encoding , encoding , project ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { ResourceUtils . copyResource ( new FileResource ( sourceFile ) , new FileResource ( destFile ) , filters , filterChains , overwrite , preserveLastModified , inputEncoding , outputEncoding , project ) ; } public void setFileLastModified ( File file , long time ) { ResourceUtils . setLastModified ( new FileResource ( file ) , time ) ; } public File resolveFile ( File file , String filename ) { if ( ! isAbsolutePath ( filename ) ) { char sep = File . separatorChar ; filename = filename . replace ( '/' , sep ) . replace ( '\\' , sep ) ; if ( isContextRelativePath ( filename ) ) { file = null ; String udir = System . getProperty ( "user.dir" ) ; if ( filename . charAt ( 0 ) == sep && udir . charAt ( 0 ) == sep ) { filename = dissect ( udir ) [ 0 ] + filename . substring ( 1 ) ; } } filename = new File ( file , filename ) . getAbsolutePath ( ) ; } return normalize ( filename ) ; } public static boolean isContextRelativePath ( String filename ) { if ( ! ( onDos || onNetWare ) || filename . length ( ) == 0 ) { return false ; } char sep = File . separatorChar ; filename = filename . replace ( '/' , sep ) . replace ( '\\' , sep ) ; char c = filename . charAt ( 0 ) ; int len = filename . length ( ) ; return ( c == sep && ( len == 1 || filename . charAt ( 1 ) != sep ) ) || ( Character . isLetter ( c ) && len > 1 && filename . indexOf ( ':' ) == 1 && ( len == 2 || filename . charAt ( 2 ) != sep ) ) ; } public static boolean isAbsolutePath ( String filename ) { int len = filename . length ( ) ; if ( len == 0 ) { return false ; } char sep = File . separatorChar ; filename = filename . replace ( '/' , sep ) . replace ( '\\' , sep ) ; char c = filename . charAt ( 0 ) ; if ( ! ( onDos || onNetWare ) ) { return ( c == sep ) ; } if ( c == sep ) { if ( ! ( onDos && len > 4 && filename . charAt ( 1 ) == sep ) ) { return false ; } int nextsep = filename . indexOf ( sep , 2 ) ; return nextsep > 2 && nextsep + 1 < len ; } int colon = filename . indexOf ( ':' ) ; return ( Character . isLetter ( c ) && colon == 1 && filename . length ( ) > 2 && filename . charAt ( 2 ) == sep ) || ( onNetWare && colon > 0 ) ; } public static String translatePath ( String toProcess ) { if ( toProcess == null || toProcess . length ( ) == 0 ) { return "" ; } StringBuffer path = new StringBuffer ( toProcess . length ( ) + 50 ) ; PathTokenizer tokenizer = new PathTokenizer ( toProcess ) ; while ( tokenizer . hasMoreTokens ( ) ) { String pathComponent = tokenizer . nextToken ( ) ; pathComponent = pathComponent . replace ( '/' , File . separatorChar ) ; pathComponent = pathComponent . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) != 0 ) { path . append ( File . pathSeparatorChar ) ; } path . append ( pathComponent ) ; } return path . toString ( ) ; } public File normalize ( final String path ) { Stack s = new Stack ( ) ; String [ ] dissect = dissect ( path ) ; s . push ( dissect [ 0 ] ) ; StringTokenizer tok = new StringTokenizer ( dissect [ 1 ] , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String thisToken = tok . nextToken ( ) ; if ( "." . equals ( thisToken ) ) { continue ; } else if ( ".." . equals ( thisToken ) ) { if ( s . size ( ) < 2 ) { return new File ( path ) ; } s . pop ( ) ; } else { s . push ( thisToken ) ; } } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i > 1 ) { sb . append ( File . separatorChar ) ; } sb . append ( s . elementAt ( i ) ) ; } return new File ( sb . toString ( ) ) ; } public String [ ] dissect ( String path ) { char sep = File . separatorChar ; path = path . replace ( '/' , sep ) . replace ( '\\' , sep ) ; if ( ! isAbsolutePath ( path ) ) { throw new BuildException ( path + " is not an absolute path" ) ; } String root = null ; int colon = path . indexOf ( ':' ) ; if ( colon > 0 && ( onDos || onNetWare ) ) { int next = colon + 1 ; root = path . substring ( 0 , next ) ; char [ ] ca = path . toCharArray ( ) ; root += sep ; next = ( ca [ next ] == sep ) ? next + 1 : next ; StringBuffer sbPath = new StringBuffer ( ) ; for ( int i = next ; i < ca . length ; i ++ ) { if ( ca [ i ] != sep || ca [ i - 1 ] != sep ) { sbPath . append ( ca [ i ] ) ; } } path = sbPath . toString ( ) ; } else if ( path . length ( ) > 1 && path . charAt ( 1 ) == sep ) { int nextsep = path . indexOf ( sep , 2 ) ; nextsep = path . indexOf ( sep , nextsep + 1 ) ; root = ( nextsep > 2 ) ? path . substring ( 0 , nextsep + 1 ) : path ; path = path . substring ( root . length ( ) ) ; } else { root = File . separator ; path = path . substring ( 1 ) ; } return new String [ ] { root , path } ; } public String toVMSPath ( File f ) { String osPath ; String path = normalize ( f . getAbsolutePath ( ) ) . getPath ( ) ; String name = f . getName ( ) ; boolean isAbsolute = path . charAt ( 0 ) == File . separatorChar ; boolean isDirectory = f . isDirectory ( ) && ! name . regionMatches ( true , name . length ( ) - 4 , ".DIR" , 0 , 4 ) ; String device = null ; StringBuffer directory = null ; String file = null ; int index = 0 ; if ( isAbsolute ) { index = path . indexOf ( File . separatorChar , 1 ) ; if ( index == - 1 ) { return path . substring ( 1 ) + ":[000000]" ; } else { device = path . substring ( 1 , index ++ ) ; } } if ( isDirectory ) { directory = new StringBuffer ( path . substring ( index ) . replace ( File . separatorChar , '.' ) ) ; } else { int dirEnd = path . lastIndexOf ( File . separatorChar , path . length ( ) ) ; if ( dirEnd == - 1 || dirEnd < index ) { file = path . substring ( index ) ; } else { directory = new StringBuffer ( path . substring ( index , dirEnd ) . replace ( File . separatorChar , '.' ) ) ; index = dirEnd + 1 ; if ( path . length ( ) > index ) { file = path . substring ( index ) ; } } } if ( ! isAbsolute && directory != null ) { directory . insert ( 0 , '.' ) ; } osPath = ( ( device != null ) ? device + ":" : "" ) + ( ( directory != null ) ? "[" + directory + "]" : "" ) + ( ( file != null ) ? file : "" ) ; return osPath ; } public File createTempFile ( String prefix , String suffix , File parentDir ) { return createTempFile ( prefix , suffix , parentDir , false ) ; } public File createTempFile ( String prefix , String suffix , File parentDir , boolean deleteOnExit ) { File result = null ; String parent = ( parentDir == null ) ? System . getProperty ( "java.io.tmpdir" ) : parentDir . getPath ( ) ; DecimalFormat fmt = new DecimalFormat ( "#####" ) ; synchronized ( rand ) { do { result = new File ( parent , prefix + fmt . format ( Math . abs ( rand . nextInt ( ) ) ) + suffix ) ; } while ( result . exists ( ) ) ; } if ( deleteOnExit ) { result . deleteOnExit ( ) ; } return result ; } public boolean contentEquals ( File f1 , File f2 ) throws IOException { return contentEquals ( f1 , f2 , false ) ; } public boolean contentEquals ( File f1 , File f2 , boolean textfile ) throws IOException { return ResourceUtils . contentEquals ( new FileResource ( f1 ) , new FileResource ( f2 ) , textfile ) ; } public File getParentFile ( File f ) { return ( f == null ) ? null : f . getParentFile ( ) ; } public static final String readFully ( Reader rdr ) throws IOException { return readFully ( rdr , BUF_SIZE ) ; } public static final String readFully ( Reader rdr , int bufferSize ) throws IOException { if ( bufferSize <= 0 ) { throw new IllegalArgumentException ( "Buffer size must be greater " + "than 0" ) ; } final char [ ] buffer = new char [ bufferSize ] ; int bufferLength = 0 ; StringBuffer textBuffer = null ; while ( bufferLength != - 1 ) { bufferLength = rdr . read ( buffer ) ; if ( bufferLength > 0 ) { textBuffer = ( textBuffer == null ) ? new StringBuffer ( ) : textBuffer ; textBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; } } return ( textBuffer == null ) ? null : textBuffer . toString ( ) ; } public boolean createNewFile ( File f ) throws IOException { return f . createNewFile ( ) ; } public boolean createNewFile ( File f , boolean mkdirs ) throws IOException { File parent = f . getParentFile ( ) ; if ( mkdirs && ! ( parent . exists ( ) ) ) { parent . mkdirs ( ) ; } return f . createNewFile ( ) ; } public boolean isSymbolicLink ( File parent , String name ) throws IOException { if ( parent == null ) { File f = new File ( name ) ; parent = f . getParentFile ( ) ; name = f . getName ( ) ; } File toTest = new File ( parent . getCanonicalPath ( ) , name ) ; return ! toTest . getAbsolutePath ( ) . equals ( toTest . getCanonicalPath ( ) ) ; } public String removeLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( l . equals ( p ) ) { return "" ; } if ( ! l . endsWith ( File . separator ) ) { l += File . separator ; } return ( p . startsWith ( l ) ) ? p . substring ( l . length ( ) ) : p ; } public boolean isLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( l . equals ( p ) ) { return true ; } if ( ! l . endsWith ( File . separator ) ) { l += File . separator ; } return p . startsWith ( l ) ; } public String toURI ( String path ) { Class uriClazz = null ; try { uriClazz = Class . forName ( "java.net.URI" ) ; } catch ( ClassNotFoundException e ) { } if ( uriClazz != null ) { try { File f = new File ( path ) . getAbsoluteFile ( ) ; java . lang . reflect . Method toURIMethod = File . class . getMethod ( "toURI" , new Class [ 0 ] ) ; Object uriObj = toURIMethod . invoke ( f , new Object [ ] { } ) ; java . lang . reflect . Method toASCIIStringMethod = uriClazz . getMethod ( "toASCIIString" , new Class [ 0 ] ) ; return ( String ) toASCIIStringMethod . invoke ( uriObj , new Object [ ] { } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } boolean isDir = new File ( path ) . isDirectory ( ) ; StringBuffer sb = new StringBuffer ( "file:" ) ; path = resolveFile ( null , path ) . getPath ( ) ; sb . append ( "//" ) ; if ( ! path . startsWith ( File . separator ) ) { sb . append ( "/" ) ; } path = path . replace ( '\\' , '/' ) ; try { sb . append ( Locator . encodeURI ( path ) ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( exc ) ; } if ( isDir && ! path . endsWith ( "/" ) ) { sb . append ( '/' ) ; } return sb . toString ( ) ; } public String fromURI ( String uri ) { synchronized ( cacheFromUriLock ) { if ( uri . equals ( cacheFromUriRequest ) ) { return cacheFromUriResponse ; } String path = Locator . fromURI ( uri ) ; String ret = isAbsolutePath ( path ) ? normalize ( path ) . getAbsolutePath ( ) : path ; cacheFromUriRequest = uri ; cacheFromUriResponse = ret ; return ret ; } } public boolean fileNameEquals ( File f1 , File f2 ) { return normalize ( f1 . getAbsolutePath ( ) ) . equals ( normalize ( f2 . getAbsolutePath ( ) ) ) ; } public void rename ( File from , File to ) throws IOException { if ( to . exists ( ) && ! to . delete ( ) ) { throw new IOException ( "Failed to delete " + to + " while trying to rename " + from ) ; } File parent = to . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new IOException ( "Failed to create directory " + parent + " while trying to rename " + from ) ; } if ( ! from . renameTo ( to ) ) { copyFile ( from , to ) ; if ( ! from . delete ( ) ) { throw new IOException ( "Failed to delete " + from + " while trying to rename it." ) ; } } } public long getFileTimestampGranularity ( ) { if ( onWin9x ) { return FAT_FILE_TIMESTAMP_GRANULARITY ; } else if ( onWindows ) { return NTFS_FILE_TIMESTAMP_GRANULARITY ; } else if ( onDos ) { return FAT_FILE_TIMESTAMP_GRANULARITY ; } return UNIX_FILE_TIMESTAMP_GRANULARITY ; } public boolean isUpToDate ( File source , File dest , long granularity ) { if ( ! dest . exists ( ) ) { return false ; } long sourceTime = source . lastModified ( ) ; long destTime = dest . lastModified ( ) ; return isUpToDate ( sourceTime , destTime , granularity ) ; } public boolean isUpToDate ( File source , File dest ) { return isUpToDate ( source , dest , getFileTimestampGranularity ( ) ) ; } public boolean isUpToDate ( long sourceTime , long destTime , long granularity ) { if ( destTime == - 1 ) { return false ; } return destTime >= sourceTime + granularity ; } public boolean isUpToDate ( long sourceTime , long destTime ) { return isUpToDate ( sourceTime , destTime , getFileTimestampGranularity ( ) ) ; } public static void close ( Writer device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void close ( Reader device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void close ( OutputStream device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void close ( InputStream device ) { if ( device != null ) { try { device . close ( ) ; } catch ( IOException ioex ) { } } } public static void delete ( File file ) { if ( file != null ) { file . delete ( ) ; } } public static String getRelativePath ( File fromFile , File toFile ) throws Exception { String fromPath = fromFile . getCanonicalPath ( ) ; String toPath = toFile . getCanonicalPath ( ) ; String [ ] fromPathStack = getPathStack ( fromPath ) ; String [ ] toPathStack = getPathStack ( toPath ) ; if ( 0 < toPathStack . length && 0 < fromPathStack . length ) { if ( ! fromPathStack [ 0 ] . equals ( toPathStack [ 0 ] ) ) { return getPath ( Arrays . asList ( toPathStack ) ) ; } } else { return getPath ( Arrays . asList ( toPathStack ) ) ; } int minLength = Math . min ( fromPathStack . length , toPathStack . length ) ; int same = 1 ; for ( ; same < minLength ; same ++ ) { if ( ! fromPathStack [ same ] . equals ( toPathStack [ same ] ) ) { break ; } } List relativePathStack = new ArrayList ( ) ; for ( int i = same ; i < fromPathStack . length ; i ++ ) { relativePathStack . add ( ".." ) ; } for ( int i = same ; i < toPathStack . length ; i ++ ) { relativePathStack . add ( toPathStack [ i ] ) ; } return getPath ( relativePathStack ) ; } public static String [ ] getPathStack ( String path ) { String normalizedPath = path . replace ( File . separatorChar , '/' ) ; Object [ ] tokens = StringUtils . split ( normalizedPath , '/' ) . toArray ( ) ; String [ ] rv = new String [ tokens . length ] ; System . arraycopy ( tokens , 0 , rv , 0 , tokens . length ) ; return rv ; } public static String getPath ( List pathStack ) { return getPath ( pathStack , '/' ) ; } public static String getPath ( final List pathStack , final char separatorChar ) { final StringBuffer buffer = new StringBuffer ( ) ; final Iterator iter = pathStack . iterator ( ) ; if ( iter . hasNext ( ) ) { buffer . append ( iter . next ( ) ) ; } while ( iter . hasNext ( ) ) { buffer . append ( separatorChar ) ; buffer . append ( iter . next ( ) ) ; } return buffer . toString ( ) ; } public String getDefaultEncoding ( ) { InputStreamReader is = new InputStreamReader ( new InputStream ( ) { public int read ( ) { return - 1 ; } } ) ; try { return is . getEncoding ( ) ; } finally { close ( is ) ; } } } 	1
package org . apache . tools . ant ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; public class PropertyHelper { private Project project ; private PropertyHelper next ; private Hashtable properties = new Hashtable ( ) ; private Hashtable userProperties = new Hashtable ( ) ; private Hashtable inheritedProperties = new Hashtable ( ) ; protected PropertyHelper ( ) { } public void setProject ( Project p ) { this . project = p ; } public void setNext ( PropertyHelper next ) { this . next = next ; } public PropertyHelper getNext ( ) { return next ; } public static synchronized PropertyHelper getPropertyHelper ( Project project ) { PropertyHelper helper = ( PropertyHelper ) project . getReference ( MagicNames . REFID_PROPERTY_HELPER ) ; if ( helper != null ) { return helper ; } helper = new PropertyHelper ( ) ; helper . setProject ( project ) ; project . addReference ( MagicNames . REFID_PROPERTY_HELPER , helper ) ; return helper ; } public boolean setPropertyHook ( String ns , String name , Object value , boolean inherited , boolean user , boolean isNew ) { if ( getNext ( ) != null ) { boolean subst = getNext ( ) . setPropertyHook ( ns , name , value , inherited , user , isNew ) ; if ( subst ) { return true ; } } return false ; } public Object getPropertyHook ( String ns , String name , boolean user ) { if ( getNext ( ) != null ) { Object o = getNext ( ) . getPropertyHook ( ns , name , user ) ; if ( o != null ) { return o ; } } if ( name . startsWith ( "toString:" ) ) { name = name . substring ( "toString:" . length ( ) ) ; Object v = project . getReference ( name ) ; return ( v == null ) ? null : v . toString ( ) ; } return null ; } public void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { parsePropertyStringDefault ( value , fragments , propertyRefs ) ; } public String replaceProperties ( String ns , String value , Hashtable keys ) throws BuildException { if ( value == null || value . indexOf ( '$' ) == - 1 ) { return value ; } Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; parsePropertyString ( value , fragments , propertyRefs ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; Object replacement = null ; if ( keys != null ) { replacement = keys . get ( propertyName ) ; } if ( replacement == null ) { replacement = getProperty ( ns , propertyName ) ; } if ( replacement == null ) { project . log ( "Property \"" + propertyName + "\" has not been set" , Project . MSG_VERBOSE ) ; } fragment = ( replacement != null ) ? replacement . toString ( ) : "${" + propertyName + "}" ; } sb . append ( fragment ) ; } return sb . toString ( ) ; } public synchronized boolean setProperty ( String ns , String name , Object value , boolean verbose ) { if ( null != userProperties . get ( name ) ) { if ( verbose ) { project . log ( "Override ignored for user property \"" + name + "\"" , Project . MSG_VERBOSE ) ; } return false ; } boolean done = setPropertyHook ( ns , name , value , false , false , false ) ; if ( done ) { return true ; } if ( null != properties . get ( name ) && verbose ) { project . log ( "Overriding previous definition of property \"" + name + "\"" , Project . MSG_VERBOSE ) ; } if ( verbose ) { project . log ( "Setting project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; } properties . put ( name , value ) ; return true ; } public synchronized void setNewProperty ( String ns , String name , Object value ) { if ( null != properties . get ( name ) ) { project . log ( "Override ignored for property \"" + name + "\"" , Project . MSG_VERBOSE ) ; return ; } boolean done = setPropertyHook ( ns , name , value , false , false , true ) ; if ( done ) { return ; } project . log ( "Setting project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; if ( name != null && value != null ) { properties . put ( name , value ) ; } } public synchronized void setUserProperty ( String ns , String name , Object value ) { project . log ( "Setting ro project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; userProperties . put ( name , value ) ; boolean done = setPropertyHook ( ns , name , value , false , true , false ) ; if ( done ) { return ; } properties . put ( name , value ) ; } public synchronized void setInheritedProperty ( String ns , String name , Object value ) { inheritedProperties . put ( name , value ) ; project . log ( "Setting ro project property: " + name + " -> " + value , Project . MSG_DEBUG ) ; userProperties . put ( name , value ) ; boolean done = setPropertyHook ( ns , name , value , true , false , false ) ; if ( done ) { return ; } properties . put ( name , value ) ; } public synchronized Object getProperty ( String ns , String name ) { if ( name == null ) { return null ; } Object o = getPropertyHook ( ns , name , false ) ; if ( o != null ) { return o ; } return properties . get ( name ) ; } public synchronized Object getUserProperty ( String ns , String name ) { if ( name == null ) { return null ; } Object o = getPropertyHook ( ns , name , true ) ; if ( o != null ) { return o ; } return userProperties . get ( name ) ; } public Hashtable getProperties ( ) { return new Hashtable ( properties ) ; } public Hashtable getUserProperties ( ) { return new Hashtable ( userProperties ) ; } protected Hashtable getInternalProperties ( ) { return properties ; } protected Hashtable getInternalUserProperties ( ) { return userProperties ; } protected Hashtable getInternalInheritedProperties ( ) { return inheritedProperties ; } public void copyInheritedProperties ( Project other ) { Enumeration e = inheritedProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = e . nextElement ( ) . toString ( ) ; if ( other . getUserProperty ( arg ) != null ) { continue ; } Object value = inheritedProperties . get ( arg ) ; other . setInheritedProperty ( arg , value . toString ( ) ) ; } } public void copyUserProperties ( Project other ) { Enumeration e = userProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object arg = e . nextElement ( ) ; if ( inheritedProperties . containsKey ( arg ) ) { continue ; } Object value = userProperties . get ( arg ) ; other . setUserProperty ( arg . toString ( ) , value . toString ( ) ) ; } } static void parsePropertyStringDefault ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { int prev = 0 ; int pos ; while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos > 0 ) { fragments . addElement ( value . substring ( prev , pos ) ) ; } if ( pos == ( value . length ( ) - 1 ) ) { fragments . addElement ( "$" ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { if ( value . charAt ( pos + 1 ) == '$' ) { fragments . addElement ( "$" ) ; prev = pos + 2 ; } else { fragments . addElement ( value . substring ( pos , pos + 2 ) ) ; prev = pos + 2 ; } } else { int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new BuildException ( "Syntax error in property: " + value ) ; } String propertyName = value . substring ( pos + 2 , endName ) ; fragments . addElement ( null ) ; propertyRefs . addElement ( propertyName ) ; prev = endName + 1 ; } } if ( prev < value . length ( ) ) { fragments . addElement ( value . substring ( prev ) ) ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; public class ImportTypelib extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File srcFile ; private File destFile ; private String namespace ; private boolean useSysArray = false ; private boolean unsafe = false ; private String extraOptions = null ; public void setDestFile ( File destFile ) { this . destFile = destFile ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public void setSrcFile ( File srcFile ) { this . srcFile = srcFile ; } public void setUnsafe ( boolean unsafe ) { this . unsafe = unsafe ; } public void setUseSysArray ( boolean useSysArray ) { this . useSysArray = useSysArray ; } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } protected void validate ( ) throws BuildException { if ( destFile == null ) { throw new BuildException ( "destination file must be specified" ) ; } if ( destFile . isDirectory ( ) ) { throw new BuildException ( "destination file is a directory" ) ; } if ( srcFile == null || ! srcFile . exists ( ) ) { throw new BuildException ( "source file does not exist" ) ; } if ( srcFile . isDirectory ( ) ) { throw new BuildException ( "source file is a directory" ) ; } if ( namespace == null ) { throw new BuildException ( "No namespace" ) ; } } private boolean isExecuteNeeded ( ) { if ( ! destFile . exists ( ) ) { log ( "Destination file does not exist: a build is required" , Project . MSG_VERBOSE ) ; return true ; } long sourceTime = srcFile . lastModified ( ) ; long destTime = destFile . lastModified ( ) ; if ( sourceTime > ( destTime + FILE_UTILS . getFileTimestampGranularity ( ) ) ) { log ( "Source file is newer than the dest file: a rebuild is required" , Project . MSG_VERBOSE ) ; return true ; } else { log ( "The output file is up to date" , Project . MSG_VERBOSE ) ; return false ; } } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; validate ( ) ; log ( "Importing typelib " + srcFile + " to assembly " + destFile + " in namespace " + namespace , Project . MSG_VERBOSE ) ; if ( ! isExecuteNeeded ( ) ) { return ; } NetCommand command = new NetCommand ( this , "ImportTypelib" , "tlbimp" ) ; command . setFailOnError ( true ) ; command . addArgument ( srcFile . toString ( ) ) ; command . addArgument ( "/nologo" ) ; command . addArgument ( "/out:" + destFile ) ; command . addArgument ( "/namespace:" , namespace ) ; if ( useSysArray ) { command . addArgument ( "/sysarray" ) ; } if ( unsafe ) { command . addArgument ( "/unsafe" ) ; } command . addArgument ( extraOptions ) ; command . runCommand ( ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . extension . resolvers ; import java . io . File ; import java . net . URL ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Get ; import org . apache . tools . ant . taskdefs . optional . extension . Extension ; import org . apache . tools . ant . taskdefs . optional . extension . ExtensionResolver ; public class URLResolver implements ExtensionResolver { private File destfile ; private File destdir ; private URL url ; public void setUrl ( final URL url ) { this . url = url ; } public void setDestfile ( final File destfile ) { this . destfile = destfile ; } public void setDestdir ( final File destdir ) { this . destdir = destdir ; } public File resolve ( final Extension extension , final Project project ) throws BuildException { validate ( ) ; final File file = getDest ( ) ; final Get get = new Get ( ) ; get . setProject ( project ) ; get . setDest ( file ) ; get . setSrc ( url ) ; get . execute ( ) ; return file ; } private File getDest ( ) { File result ; if ( null != destfile ) { result = destfile ; } else { final String file = url . getFile ( ) ; String filename ; if ( null == file || file . length ( ) <= 1 ) { filename = "default.file" ; } else { int index = file . lastIndexOf ( '/' ) ; if ( - 1 == index ) { index = 0 ; } filename = file . substring ( index ) ; } result = new File ( destdir , filename ) ; } return result ; } private void validate ( ) { if ( null == url ) { final String message = "Must specify URL" ; throw new BuildException ( message ) ; } if ( null == destdir && null == destfile ) { final String message = "Must specify destination file or directory" ; throw new BuildException ( message ) ; } else if ( null != destdir && null != destfile ) { final String message = "Must not specify both destination file or directory" ; throw new BuildException ( message ) ; } } public String toString ( ) { return "URL[" + url + "]" ; } } 	0
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . ExecuteJava ; import org . apache . tools . ant . taskdefs . optional . Native2Ascii ; import org . apache . tools . ant . types . Commandline ; public final class KaffeNative2Ascii extends DefaultNative2Ascii { private static final String [ ] N2A_CLASSNAMES = new String [ ] { "gnu.classpath.tools.native2ascii.Native2Ascii" , "kaffe.tools.native2ascii.Native2Ascii" , } ; public static final String IMPLEMENTATION_NAME = "kaffe" ; protected void setup ( Commandline cmd , Native2Ascii args ) throws BuildException { if ( args . getReverse ( ) ) { throw new BuildException ( "-reverse is not supported by Kaffe" ) ; } super . setup ( cmd , args ) ; } protected boolean run ( Commandline cmd , ProjectComponent log ) throws BuildException { ExecuteJava ej = new ExecuteJava ( ) ; Class c = getN2aClass ( ) ; if ( c == null ) { throw new BuildException ( "Couldn't load Kaffe's Native2Ascii" + " class" ) ; } cmd . setExecutable ( c . getName ( ) ) ; ej . setJavaCommand ( cmd ) ; ej . execute ( log . getProject ( ) ) ; return true ; } private static Class getN2aClass ( ) { for ( int i = 0 ; i < N2A_CLASSNAMES . length ; i ++ ) { try { return Class . forName ( N2A_CLASSNAMES [ i ] ) ; } catch ( ClassNotFoundException cnfe ) { } } return null ; } } 	0
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; public class Substitution extends DataType { public static final String DATA_TYPE_NAME = "substitition" ; private String expression ; public Substitution ( ) { this . expression = null ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getExpression ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExpression ( p ) ; } return expression ; } public Substitution getRef ( Project p ) { return ( Substitution ) getCheckedRef ( p ) ; } } 	1
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . BuildException ; public class CvsUser { private String userID ; private String displayName ; public void setDisplayname ( final String displayName ) { this . displayName = displayName ; } public void setUserid ( final String userID ) { this . userID = userID ; } public String getUserID ( ) { return userID ; } public String getDisplayname ( ) { return displayName ; } public void validate ( ) throws BuildException { if ( null == userID ) { final String message = "Username attribute must be set." ; throw new BuildException ( message ) ; } if ( null == displayName ) { final String message = "Displayname attribute must be set for userID " + userID ; throw new BuildException ( message ) ; } } } 	0
package org . apache . tools . zip ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipException ; public class ExtraFieldUtils { private static Hashtable implementations ; static { implementations = new Hashtable ( ) ; register ( AsiExtraField . class ) ; register ( JarMarker . class ) ; } public static void register ( Class c ) { try { ZipExtraField ze = ( ZipExtraField ) c . newInstance ( ) ; implementations . put ( ze . getHeaderId ( ) , c ) ; } catch ( ClassCastException cc ) { throw new RuntimeException ( c + " doesn\'t implement ZipExtraField" ) ; } catch ( InstantiationException ie ) { throw new RuntimeException ( c + " is not a concrete class" ) ; } catch ( IllegalAccessException ie ) { throw new RuntimeException ( c + "\'s no-arg constructor is not public" ) ; } } public static ZipExtraField createExtraField ( ZipShort headerId ) throws InstantiationException , IllegalAccessException { Class c = ( Class ) implementations . get ( headerId ) ; if ( c != null ) { return ( ZipExtraField ) c . newInstance ( ) ; } UnrecognizedExtraField u = new UnrecognizedExtraField ( ) ; u . setHeaderId ( headerId ) ; return u ; } public static ZipExtraField [ ] parse ( byte [ ] data ) throws ZipException { Vector v = new Vector ( ) ; int start = 0 ; while ( start <= data . length - 4 ) { ZipShort headerId = new ZipShort ( data , start ) ; int length = ( new ZipShort ( data , start + 2 ) ) . getValue ( ) ; if ( start + 4 + length > data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } try { ZipExtraField ze = createExtraField ( headerId ) ; ze . parseFromLocalFileData ( data , start + 4 , length ) ; v . addElement ( ze ) ; } catch ( InstantiationException ie ) { throw new ZipException ( ie . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new ZipException ( iae . getMessage ( ) ) ; } start += ( length + 4 ) ; } if ( start != data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } ZipExtraField [ ] result = new ZipExtraField [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public static byte [ ] mergeLocalFileDataData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getLocalFileDataLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getLocalFileDataLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getLocalFileDataData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } public static byte [ ] mergeCentralDirectoryData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getCentralDirectoryLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getCentralDirectoryLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getCentralDirectoryData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } } 	1
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . LinkedList ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . util . LineTokenizer ; public final class TailFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private static final String SKIP_KEY = "skip" ; private static final int DEFAULT_NUM_LINES = 10 ; private long lines = DEFAULT_NUM_LINES ; private long skip = 0 ; private boolean completedReadAhead = false ; private LineTokenizer lineTokenizer = null ; private String line = null ; private int linePos = 0 ; private LinkedList lineList = new LinkedList ( ) ; public TailFilter ( ) { super ( ) ; } public TailFilter ( final Reader in ) { super ( in ) ; lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = lineTokenizer . getToken ( in ) ; line = tailFilter ( line ) ; if ( line == null ) { return - 1 ; } linePos = 0 ; } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public void setLines ( final long lines ) { this . lines = lines ; } private long getLines ( ) { return lines ; } public void setSkip ( final long skip ) { this . skip = skip ; } private long getSkip ( ) { return skip ; } public Reader chain ( final Reader rdr ) { TailFilter newFilter = new TailFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setSkip ( getSkip ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { setLines ( new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ) ; continue ; } if ( SKIP_KEY . equals ( params [ i ] . getName ( ) ) ) { skip = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } } } } private String tailFilter ( String line ) { if ( ! completedReadAhead ) { if ( line != null ) { lineList . add ( line ) ; if ( lines == - 1 ) { if ( lineList . size ( ) > skip ) { return ( String ) lineList . removeFirst ( ) ; } } else { long linesToKeep = lines + ( skip > 0 ? skip : 0 ) ; if ( linesToKeep < lineList . size ( ) ) { lineList . removeFirst ( ) ; } } return "" ; } completedReadAhead = true ; if ( skip > 0 ) { for ( int i = 0 ; i < skip ; ++ i ) { lineList . removeLast ( ) ; } } if ( lines > - 1 ) { while ( lineList . size ( ) > lines ) { lineList . removeFirst ( ) ; } } } if ( lineList . size ( ) > 0 ) { return ( String ) lineList . removeFirst ( ) ; } return null ; } } 	0
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . tools . ant . BuildException ; public class Xalan2Executor extends XalanExecutor { private static final String APAC = "org.apache.xalan." ; private static final String SPAC = "com.sun.org.apache.xalan." ; private TransformerFactory tfactory = TransformerFactory . newInstance ( ) ; protected String getImplementation ( ) throws BuildException { return tfactory . getClass ( ) . getName ( ) ; } protected String getProcVersion ( String classNameImpl ) throws BuildException { try { if ( classNameImpl . equals ( APAC + "processor.TransformerFactoryImpl" ) || classNameImpl . equals ( APAC + "xslt.XSLTProcessorFactory" ) ) { return getXalanVersion ( APAC + "processor.XSLProcessorVersion" ) ; } if ( classNameImpl . equals ( APAC + "xsltc.trax.TransformerFactoryImpl" ) ) { return getXSLTCVersion ( APAC + "xsltc.ProcessorVersion" ) ; } if ( classNameImpl . equals ( SPAC + "internal.xsltc.trax.TransformerFactoryImpl" ) ) { return getXSLTCVersion ( SPAC + "internal.xsltc.ProcessorVersion" ) ; } throw new BuildException ( "Could not find a valid processor version" + " implementation from " + classNameImpl ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find processor version " + "implementation" , e ) ; } } void execute ( ) throws Exception { String systemId = caller . getStylesheetSystemId ( ) ; Source xslSrc = new StreamSource ( systemId ) ; Transformer tformer = tfactory . newTransformer ( xslSrc ) ; Source xmlSrc = new DOMSource ( caller . document ) ; OutputStream os = getOutputStream ( ) ; try { tformer . setParameter ( "output.dir" , caller . toDir . getAbsolutePath ( ) ) ; Result result = new StreamResult ( os ) ; tformer . transform ( xmlSrc , result ) ; } finally { os . close ( ) ; } } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . PrintStream ; import java . io . OutputStream ; import java . util . Iterator ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . PropertyOutputStream ; public class Length extends Task implements Condition { private static final String ALL = "all" ; private static final String EACH = "each" ; private static final String STRING = "string" ; private static final String LENGTH_REQUIRED = "Use of the Length condition requires that the length attribute be set." ; private String property ; private String string ; private Boolean trim ; private String mode = ALL ; private Comparison when = Comparison . EQUAL ; private Long length ; private Resources resources ; public synchronized void setProperty ( String property ) { this . property = property ; } public synchronized void setFile ( File file ) { add ( new FileResource ( file ) ) ; } public synchronized void add ( FileSet fs ) { add ( ( ResourceCollection ) fs ) ; } public synchronized void add ( ResourceCollection c ) { if ( c == null ) { return ; } resources = ( resources == null ) ? new Resources ( ) : resources ; resources . add ( c ) ; } public synchronized void setLength ( long ell ) { length = new Long ( ell ) ; } public synchronized void setWhen ( When w ) { setWhen ( ( Comparison ) w ) ; } public synchronized void setWhen ( Comparison c ) { when = c ; } public synchronized void setMode ( FileMode m ) { this . mode = m . getValue ( ) ; } public synchronized void setString ( String string ) { this . string = string ; this . mode = STRING ; } public synchronized void setTrim ( boolean trim ) { this . trim = trim ? Boolean . TRUE : Boolean . FALSE ; } public boolean getTrim ( ) { return trim != null && trim . booleanValue ( ) ; } public void execute ( ) { validate ( ) ; PrintStream ps = new PrintStream ( ( property != null ) ? ( OutputStream ) new PropertyOutputStream ( getProject ( ) , property ) : ( OutputStream ) new LogOutputStream ( this , Project . MSG_INFO ) ) ; if ( STRING . equals ( mode ) ) { ps . print ( getLength ( string , getTrim ( ) ) ) ; ps . close ( ) ; } else if ( EACH . equals ( mode ) ) { handleResources ( new EachHandler ( ps ) ) ; } else if ( ALL . equals ( mode ) ) { handleResources ( new AllHandler ( ps ) ) ; } } public boolean eval ( ) { validate ( ) ; if ( length == null ) { throw new BuildException ( LENGTH_REQUIRED ) ; } Long ell = null ; if ( STRING . equals ( mode ) ) { ell = new Long ( getLength ( string , getTrim ( ) ) ) ; } else { ConditionHandler h = new ConditionHandler ( ) ; handleResources ( h ) ; ell = new Long ( h . getLength ( ) ) ; } return when . evaluate ( ell . compareTo ( length ) ) ; } private void validate ( ) { if ( string != null ) { if ( resources != null ) { throw new BuildException ( "the string length function" + " is incompatible with the file/resource length function" ) ; } if ( ! ( STRING . equals ( mode ) ) ) { throw new BuildException ( "the mode attribute is for use" + " with the file/resource length function" ) ; } } else if ( resources != null ) { if ( ! ( EACH . equals ( mode ) || ALL . equals ( mode ) ) ) { throw new BuildException ( "invalid mode setting for" + " file/resource length function: \"" + mode + "\"" ) ; } else if ( trim != null ) { throw new BuildException ( "the trim attribute is" + " for use with the string length function only" ) ; } } else { throw new BuildException ( "you must set either the string attribute" + " or specify one or more files using the file attribute or" + " nested resource collections" ) ; } } private void handleResources ( Handler h ) { for ( Iterator i = resources . iterator ( ) ; i . hasNext ( ) ; ) { Resource r = ( Resource ) i . next ( ) ; if ( ! r . isExists ( ) ) { log ( r + " does not exist" , Project . MSG_ERR ) ; } else if ( r . isDirectory ( ) ) { log ( r + " is a directory; length unspecified" , Project . MSG_ERR ) ; } else { h . handle ( r ) ; } } h . complete ( ) ; } private static long getLength ( String s , boolean t ) { return ( t ? s . trim ( ) : s ) . length ( ) ; } public static class FileMode extends EnumeratedAttribute { static final String [ ] MODES = new String [ ] { EACH , ALL } ; public String [ ] getValues ( ) { return MODES ; } } public static class When extends Comparison { } private abstract class Handler { private PrintStream ps ; Handler ( PrintStream ps ) { this . ps = ps ; } protected PrintStream getPs ( ) { return ps ; } protected abstract void handle ( Resource r ) ; void complete ( ) { ps . close ( ) ; } } private class EachHandler extends Handler { EachHandler ( PrintStream ps ) { super ( ps ) ; } protected void handle ( Resource r ) { getPs ( ) . print ( r . toString ( ) ) ; getPs ( ) . print ( " : " ) ; long size = r . getSize ( ) ; if ( size == Resource . UNKNOWN_SIZE ) { getPs ( ) . println ( "unknown" ) ; } else { getPs ( ) . println ( size ) ; } } } private class AllHandler extends Handler { private long accum = 0L ; AllHandler ( PrintStream ps ) { super ( ps ) ; } protected long getAccum ( ) { return accum ; } protected synchronized void handle ( Resource r ) { long size = r . getSize ( ) ; if ( size == Resource . UNKNOWN_SIZE ) { log ( "Size unknown for " + r . toString ( ) , Project . MSG_WARN ) ; } else { accum += size ; } } void complete ( ) { getPs ( ) . print ( accum ) ; super . complete ( ) ; } } private class ConditionHandler extends AllHandler { ConditionHandler ( ) { super ( null ) ; } void complete ( ) { } long getLength ( ) { return getAccum ( ) ; } } } 	1
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import java . io . File ; import org . apache . tools . ant . Project ; public class SelectSelector extends BaseSelectorContainer { private String ifProperty ; private String unlessProperty ; public SelectSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{select" ) ; if ( ifProperty != null ) { buf . append ( " if: " ) ; buf . append ( ifProperty ) ; } if ( unlessProperty != null ) { buf . append ( " unless: " ) ; buf . append ( unlessProperty ) ; } buf . append ( " " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } private SelectSelector getRef ( ) { Object o = getCheckedRef ( this . getClass ( ) , "SelectSelector" ) ; return ( SelectSelector ) o ; } public boolean hasSelectors ( ) { if ( isReference ( ) ) { return getRef ( ) . hasSelectors ( ) ; } return super . hasSelectors ( ) ; } public int selectorCount ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorCount ( ) ; } return super . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { if ( isReference ( ) ) { return getRef ( ) . getSelectors ( p ) ; } return super . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorElements ( ) ; } return super . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } super . appendSelector ( selector ) ; } public void verifySettings ( ) { int cnt = selectorCount ( ) ; if ( cnt < 0 || cnt > 1 ) { setError ( "Only one selector is allowed within the " + "<selector> tag" ) ; } } public boolean passesConditions ( ) { if ( ifProperty != null && getProject ( ) . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && getProject ( ) . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( ! ( passesConditions ( ) ) ) { return false ; } Enumeration e = selectorElements ( ) ; if ( ! ( e . hasMoreElements ( ) ) ) { return true ; } FileSelector f = ( FileSelector ) e . nextElement ( ) ; return f . isSelected ( basedir , filename , file ) ; } } 	0
package org . apache . tools . ant . listener ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Properties ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; public final class AnsiColorLogger extends DefaultLogger { private static final int ATTR_DIM = 2 ; private static final int FG_RED = 31 ; private static final int FG_GREEN = 32 ; private static final int FG_BLUE = 34 ; private static final int FG_MAGENTA = 35 ; private static final int FG_CYAN = 36 ; private static final String PREFIX = "[" ; private static final String SUFFIX = "m" ; private static final char SEPARATOR = ';' ; private static final String END_COLOR = PREFIX + SUFFIX ; private String errColor = PREFIX + ATTR_DIM + SEPARATOR + FG_RED + SUFFIX ; private String warnColor = PREFIX + ATTR_DIM + SEPARATOR + FG_MAGENTA + SUFFIX ; private String infoColor = PREFIX + ATTR_DIM + SEPARATOR + FG_CYAN + SUFFIX ; private String verboseColor = PREFIX + ATTR_DIM + SEPARATOR + FG_GREEN + SUFFIX ; private String debugColor = PREFIX + ATTR_DIM + SEPARATOR + FG_BLUE + SUFFIX ; private boolean colorsSet = false ; private void setColors ( ) { String userColorFile = System . getProperty ( "ant.logger.defaults" ) ; String systemColorFile = "/org/apache/tools/ant/listener/defaults.properties" ; InputStream in = null ; try { Properties prop = new Properties ( ) ; if ( userColorFile != null ) { in = new FileInputStream ( userColorFile ) ; } else { in = getClass ( ) . getResourceAsStream ( systemColorFile ) ; } if ( in != null ) { prop . load ( in ) ; } String errC = prop . getProperty ( "AnsiColorLogger.ERROR_COLOR" ) ; String warn = prop . getProperty ( "AnsiColorLogger.WARNING_COLOR" ) ; String info = prop . getProperty ( "AnsiColorLogger.INFO_COLOR" ) ; String verbose = prop . getProperty ( "AnsiColorLogger.VERBOSE_COLOR" ) ; String debug = prop . getProperty ( "AnsiColorLogger.DEBUG_COLOR" ) ; if ( errC != null ) { errColor = PREFIX + errC + SUFFIX ; } if ( warn != null ) { warnColor = PREFIX + warn + SUFFIX ; } if ( info != null ) { infoColor = PREFIX + info + SUFFIX ; } if ( verbose != null ) { verboseColor = PREFIX + verbose + SUFFIX ; } if ( debug != null ) { debugColor = PREFIX + debug + SUFFIX ; } } catch ( IOException ioe ) { } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } } } protected void printMessage ( final String message , final PrintStream stream , final int priority ) { if ( message != null && stream != null ) { if ( ! colorsSet ) { setColors ( ) ; colorsSet = true ; } final StringBuffer msg = new StringBuffer ( message ) ; switch ( priority ) { case Project . MSG_ERR : msg . insert ( 0 , errColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_WARN : msg . insert ( 0 , warnColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_INFO : msg . insert ( 0 , infoColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_VERBOSE : msg . insert ( 0 , verboseColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_DEBUG : default : msg . insert ( 0 , debugColor ) ; msg . append ( END_COLOR ) ; break ; } final String strmessage = msg . toString ( ) ; stream . println ( strmessage ) ; } } } 	0
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public class Quantifier extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "all" , "each" , "every" , "any" , "some" , "one" , "majority" , "most" , "none" } ; public static final Quantifier ALL = new Quantifier ( "all" ) ; public static final Quantifier ANY = new Quantifier ( "any" ) ; public static final Quantifier ONE = new Quantifier ( "one" ) ; public static final Quantifier MAJORITY = new Quantifier ( "majority" ) ; public static final Quantifier NONE = new Quantifier ( "none" ) ; private abstract static class Predicate { abstract boolean eval ( int t , int f ) ; } private static final Predicate ALL_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return f == 0 ; } } ; private static final Predicate ANY_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t > 0 ; } } ; private static final Predicate ONE_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t == 1 ; } } ; private static final Predicate MAJORITY_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t > f ; } } ; private static final Predicate NONE_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t == 0 ; } } ; private static final Predicate [ ] PREDS = new Predicate [ VALUES . length ] ; static { PREDS [ 0 ] = ALL_PRED ; PREDS [ 1 ] = ALL_PRED ; PREDS [ 2 ] = ALL_PRED ; PREDS [ 3 ] = ANY_PRED ; PREDS [ 4 ] = ANY_PRED ; PREDS [ 5 ] = ONE_PRED ; PREDS [ 6 ] = MAJORITY_PRED ; PREDS [ 7 ] = MAJORITY_PRED ; PREDS [ 8 ] = NONE_PRED ; } public Quantifier ( ) { } public Quantifier ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } public boolean evaluate ( boolean [ ] b ) { int t = 0 ; for ( int i = 0 ; i < b . length ; i ++ ) { if ( b [ i ] ) { t ++ ; } } return evaluate ( t , b . length - t ) ; } public boolean evaluate ( int t , int f ) { int index = getIndex ( ) ; if ( index == - 1 ) { throw new BuildException ( "Quantifier value not set." ) ; } return PREDS [ index ] . eval ( t , f ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . clearcase ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . ExecTask ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; public abstract class ClearCase extends Task { private String mClearToolDir = "" ; private String mviewPath = null ; private String mobjSelect = null ; private static int pcnt = 0 ; private boolean mFailonerr = true ; public final void setClearToolDir ( String dir ) { mClearToolDir = FileUtils . translatePath ( dir ) ; } protected final String getClearToolCommand ( ) { String toReturn = mClearToolDir ; if ( ! toReturn . equals ( "" ) && ! toReturn . endsWith ( "/" ) ) { toReturn += "/" ; } toReturn += CLEARTOOL_EXE ; return toReturn ; } public final void setViewPath ( String viewPath ) { mviewPath = viewPath ; } public String getViewPath ( ) { return mviewPath ; } public String getViewPathBasename ( ) { return ( new File ( mviewPath ) ) . getName ( ) ; } public final void setObjSelect ( String objSelect ) { mobjSelect = objSelect ; } public String getObjSelect ( ) { return mobjSelect ; } protected int run ( Commandline cmd ) { try { Project aProj = getProject ( ) ; Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( aProj ) ; exe . setWorkingDirectory ( aProj . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; return exe . execute ( ) ; } catch ( java . io . IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } protected String runS ( Commandline cmdline ) { String outV = "opts.cc.runS.output" + pcnt ++ ; ExecTask exe = new ExecTask ( this ) ; Commandline . Argument arg = exe . createArg ( ) ; exe . setExecutable ( cmdline . getExecutable ( ) ) ; arg . setLine ( Commandline . toString ( cmdline . getArguments ( ) ) ) ; exe . setOutputproperty ( outV ) ; exe . execute ( ) ; return getProject ( ) . getProperty ( outV ) ; } public void setFailOnErr ( boolean failonerr ) { mFailonerr = failonerr ; } public boolean getFailOnErr ( ) { return mFailonerr ; } private static final String CLEARTOOL_EXE = "cleartool" ; public static final String COMMAND_UPDATE = "update" ; public static final String COMMAND_CHECKOUT = "checkout" ; public static final String COMMAND_CHECKIN = "checkin" ; public static final String COMMAND_UNCHECKOUT = "uncheckout" ; public static final String COMMAND_LOCK = "lock" ; public static final String COMMAND_UNLOCK = "unlock" ; public static final String COMMAND_MKBL = "mkbl" ; public static final String COMMAND_MKLABEL = "mklabel" ; public static final String COMMAND_MKLBTYPE = "mklbtype" ; public static final String COMMAND_RMTYPE = "rmtype" ; public static final String COMMAND_LSCO = "lsco" ; public static final String COMMAND_MKELEM = "mkelem" ; public static final String COMMAND_MKATTR = "mkattr" ; public static final String COMMAND_MKDIR = "mkdir" ; } 	0
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCUnlock extends ClearCase { private String mComment = null ; private String mPname = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_UNLOCK ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getOpType ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { getCommentCommand ( cmd ) ; if ( getObjSelect ( ) == null && getPname ( ) == null ) { throw new BuildException ( "Should select either an element " + "(pname) or an object (objselect)" ) ; } getPnameCommand ( cmd ) ; if ( getObjSelect ( ) != null ) { cmd . createArgument ( ) . setValue ( getObjSelect ( ) ) ; } } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setPname ( String pname ) { mPname = pname ; } public String getPname ( ) { return mPname ; } public void setObjselect ( String objselect ) { setObjSelect ( objselect ) ; } public void setObjSel ( String objsel ) { setObjSelect ( objsel ) ; } public String getObjselect ( ) { return getObjSelect ( ) ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getPnameCommand ( Commandline cmd ) { if ( getPname ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_PNAME ) ; cmd . createArgument ( ) . setValue ( getPname ( ) ) ; } } private String getOpType ( ) { if ( getPname ( ) != null ) { return getPname ( ) ; } else { return getObjSelect ( ) ; } } public static final String FLAG_COMMENT = "-comment" ; public static final String FLAG_PNAME = "-pname" ; } 	0
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . ResourceCollection ; public class ResourceCount extends Task implements Condition { private static final String ONE_NESTED_MESSAGE = "ResourceCount can count resources from exactly one nested ResourceCollection." ; private static final String COUNT_REQUIRED = "Use of the ResourceCount condition requires that the count attribute be set." ; private ResourceCollection rc ; private Comparison when = Comparison . EQUAL ; private Integer count ; private String property ; public void add ( ResourceCollection r ) { if ( rc != null ) { throw new BuildException ( ONE_NESTED_MESSAGE ) ; } rc = r ; } public void setRefid ( Reference r ) { Object o = r . getReferencedObject ( ) ; if ( ! ( o instanceof ResourceCollection ) ) { throw new BuildException ( r . getRefId ( ) + " doesn\'t denote a ResourceCollection" ) ; } add ( ( ResourceCollection ) o ) ; } public void execute ( ) { if ( rc == null ) { throw new BuildException ( ONE_NESTED_MESSAGE ) ; } if ( property == null ) { log ( "resource count = " + rc . size ( ) ) ; } else { getProject ( ) . setNewProperty ( property , Integer . toString ( rc . size ( ) ) ) ; } } public boolean eval ( ) { if ( rc == null ) { throw new BuildException ( ONE_NESTED_MESSAGE ) ; } if ( count == null ) { throw new BuildException ( COUNT_REQUIRED ) ; } return when . evaluate ( new Integer ( rc . size ( ) ) . compareTo ( count ) ) ; } public void setCount ( int c ) { count = new Integer ( c ) ; } public void setWhen ( Comparison c ) { when = c ; } public void setProperty ( String p ) { property = p ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . Reader ; import java . io . Writer ; import java . io . FileReader ; import java . io . InputStream ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . OutputStream ; import java . io . StringReader ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . util . Arrays ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . StringResource ; import org . apache . tools . ant . types . resources . selectors . Not ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . ConcatResourceInputStream ; public class Concat extends Task { private static final int BUFFER_SIZE = 8192 ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final ResourceSelector EXISTS = new Exists ( ) ; private static final ResourceSelector NOT_EXISTS = new Not ( EXISTS ) ; private File destinationFile ; private boolean append ; private String encoding ; private String outputEncoding ; private boolean binary ; private StringBuffer textBuffer ; private Resources rc ; private Vector filterChains ; private boolean forceOverwrite = true ; private TextElement footer ; private TextElement header ; private boolean fixLastLine = false ; private String eolString ; private Writer outputWriter = null ; public Concat ( ) { reset ( ) ; } public void reset ( ) { append = false ; forceOverwrite = true ; destinationFile = null ; encoding = null ; outputEncoding = null ; fixLastLine = false ; filterChains = null ; footer = null ; header = null ; binary = false ; outputWriter = null ; textBuffer = null ; eolString = System . getProperty ( "line.separator" ) ; rc = null ; } public void setDestfile ( File destinationFile ) { this . destinationFile = destinationFile ; } public void setAppend ( boolean append ) { this . append = append ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; if ( outputEncoding == null ) { outputEncoding = encoding ; } } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setForce ( boolean force ) { this . forceOverwrite = force ; } public Path createPath ( ) { Path path = new Path ( getProject ( ) ) ; add ( path ) ; return path ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void addFilelist ( FileList list ) { add ( list ) ; } public void add ( ResourceCollection c ) { rc = rc == null ? new Resources ( ) : rc ; rc . add ( c ) ; } public void addFilterChain ( FilterChain filterChain ) { if ( filterChains == null ) { filterChains = new Vector ( ) ; } filterChains . addElement ( filterChain ) ; } public void addText ( String text ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( text . length ( ) ) ; } textBuffer . append ( text ) ; } public void addHeader ( TextElement headerToAdd ) { this . header = headerToAdd ; } public void addFooter ( TextElement footerToAdd ) { this . footer = footerToAdd ; } public void setFixLastLine ( boolean fixLastLine ) { this . fixLastLine = fixLastLine ; } public void setEol ( FixCRLF . CrLf crlf ) { String s = crlf . getValue ( ) ; if ( s . equals ( "cr" ) || s . equals ( "mac" ) ) { eolString = "\r" ; } else if ( s . equals ( "lf" ) || s . equals ( "unix" ) ) { eolString = "\n" ; } else if ( s . equals ( "crlf" ) || s . equals ( "dos" ) ) { eolString = "\r\n" ; } } public void setWriter ( Writer outputWriter ) { this . outputWriter = outputWriter ; } public void setBinary ( boolean binary ) { this . binary = binary ; } private ResourceCollection validate ( ) { sanitizeText ( ) ; if ( binary ) { if ( destinationFile == null ) { throw new BuildException ( "destfile attribute is required for binary concatenation" ) ; } if ( textBuffer != null ) { throw new BuildException ( "Nested text is incompatible with binary concatenation" ) ; } if ( encoding != null || outputEncoding != null ) { throw new BuildException ( "Seting input or output encoding is incompatible with binary" + " concatenation" ) ; } if ( filterChains != null ) { throw new BuildException ( "Setting filters is incompatible with binary concatenation" ) ; } if ( fixLastLine ) { throw new BuildException ( "Setting fixlastline is incompatible with binary concatenation" ) ; } if ( header != null || footer != null ) { throw new BuildException ( "Nested header or footer is incompatible with binary concatenation" ) ; } } if ( destinationFile != null && outputWriter != null ) { throw new BuildException ( "Cannot specify both a destination file and an output writer" ) ; } if ( rc == null && textBuffer == null ) { throw new BuildException ( "At least one resource must be provided, or some text." ) ; } if ( rc != null ) { if ( textBuffer != null ) { throw new BuildException ( "Cannot include inline text when using resources." ) ; } Restrict noexistRc = new Restrict ( ) ; noexistRc . add ( NOT_EXISTS ) ; noexistRc . add ( rc ) ; for ( Iterator i = noexistRc . iterator ( ) ; i . hasNext ( ) ; ) { log ( i . next ( ) + " does not exist." , Project . MSG_ERR ) ; } if ( destinationFile != null ) { for ( Iterator i = rc . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof FileResource ) { File f = ( ( FileResource ) o ) . getFile ( ) ; if ( FILE_UTILS . fileNameEquals ( f , destinationFile ) ) { throw new BuildException ( "Input file \"" + f + "\" is the same as the output file." ) ; } } } } Restrict existRc = new Restrict ( ) ; existRc . add ( EXISTS ) ; existRc . add ( rc ) ; boolean outofdate = destinationFile == null || forceOverwrite ; if ( ! outofdate ) { for ( Iterator i = existRc . iterator ( ) ; ! outofdate && i . hasNext ( ) ; ) { Resource r = ( Resource ) i . next ( ) ; outofdate = ( r . getLastModified ( ) == 0L || r . getLastModified ( ) > destinationFile . lastModified ( ) ) ; } } if ( ! outofdate ) { log ( destinationFile + " is up-to-date." , Project . MSG_VERBOSE ) ; return null ; } return existRc ; } else { StringResource s = new StringResource ( ) ; s . setProject ( getProject ( ) ) ; s . setValue ( textBuffer . toString ( ) ) ; return s ; } } public void execute ( ) { ResourceCollection c = validate ( ) ; if ( c == null ) { return ; } if ( c . size ( ) < 1 && header == null && footer == null ) { log ( "No existing resources and no nested text, doing nothing" , Project . MSG_INFO ) ; return ; } if ( binary ) { binaryCat ( c ) ; } else { cat ( c ) ; } } private void binaryCat ( ResourceCollection c ) { log ( "Binary concatenation of " + c . size ( ) + " resources to " + destinationFile ) ; FileOutputStream out = null ; InputStream in = null ; try { try { out = new FileOutputStream ( destinationFile ) ; } catch ( Exception t ) { throw new BuildException ( "Unable to open " + destinationFile + " for writing" , t ) ; } in = new ConcatResourceInputStream ( c ) ; ( ( ConcatResourceInputStream ) in ) . setManagingComponent ( this ) ; Thread t = new Thread ( new StreamPumper ( in , out ) ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { try { t . join ( ) ; } catch ( InterruptedException ee ) { } } } finally { FileUtils . close ( in ) ; if ( out != null ) { try { out . close ( ) ; } catch ( Exception ex ) { throw new BuildException ( "Unable to close " + destinationFile , ex ) ; } } } } private void cat ( ResourceCollection c ) { OutputStream os = null ; char [ ] buffer = new char [ BUFFER_SIZE ] ; try { PrintWriter writer = null ; if ( outputWriter != null ) { writer = new PrintWriter ( outputWriter ) ; } else { if ( destinationFile == null ) { os = new LogOutputStream ( this , Project . MSG_WARN ) ; } else { File parent = destinationFile . getParentFile ( ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } os = new FileOutputStream ( destinationFile . getAbsolutePath ( ) , append ) ; } if ( outputEncoding == null ) { writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( os ) ) ) ; } else { writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( os , outputEncoding ) ) ) ; } } if ( header != null ) { if ( header . getFiltering ( ) ) { concatenate ( buffer , writer , new StringReader ( header . getValue ( ) ) ) ; } else { writer . print ( header . getValue ( ) ) ; } } if ( c . size ( ) > 0 ) { concatenate ( buffer , writer , new MultiReader ( c ) ) ; } if ( footer != null ) { if ( footer . getFiltering ( ) ) { concatenate ( buffer , writer , new StringReader ( footer . getValue ( ) ) ) ; } else { writer . print ( footer . getValue ( ) ) ; } } writer . flush ( ) ; if ( os != null ) { os . flush ( ) ; } } catch ( IOException ioex ) { throw new BuildException ( "Error while concatenating: " + ioex . getMessage ( ) , ioex ) ; } finally { FileUtils . close ( os ) ; } } private void concatenate ( char [ ] buffer , Writer writer , Reader in ) throws IOException { if ( filterChains != null ) { ChainReaderHelper helper = new ChainReaderHelper ( ) ; helper . setBufferSize ( BUFFER_SIZE ) ; helper . setPrimaryReader ( in ) ; helper . setFilterChains ( filterChains ) ; helper . setProject ( getProject ( ) ) ; in = new BufferedReader ( helper . getAssembledReader ( ) ) ; } while ( true ) { int nRead = in . read ( buffer , 0 , buffer . length ) ; if ( nRead == - 1 ) { break ; } writer . write ( buffer , 0 , nRead ) ; } writer . flush ( ) ; } private void sanitizeText ( ) { if ( textBuffer != null ) { if ( textBuffer . substring ( 0 ) . trim ( ) . length ( ) == 0 ) { textBuffer = null ; } } } public static class TextElement extends ProjectComponent { private String value = "" ; private boolean trimLeading = false ; private boolean trim = false ; private boolean filtering = true ; private String encoding = null ; public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } private boolean getFiltering ( ) { return filtering ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setFile ( File file ) throws BuildException { if ( ! file . exists ( ) ) { throw new BuildException ( "File " + file + " does not exist." ) ; } BufferedReader reader = null ; try { if ( this . encoding == null ) { reader = new BufferedReader ( new FileReader ( file ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , this . encoding ) ) ; } value = FileUtils . readFully ( reader ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } finally { FileUtils . close ( reader ) ; } } public void addText ( String value ) { this . value += getProject ( ) . replaceProperties ( value ) ; } public void setTrimLeading ( boolean strip ) { this . trimLeading = strip ; } public void setTrim ( boolean trim ) { this . trim = trim ; } public String getValue ( ) { if ( value == null ) { value = "" ; } if ( value . trim ( ) . length ( ) == 0 ) { value = "" ; } if ( trimLeading ) { char [ ] current = value . toCharArray ( ) ; StringBuffer b = new StringBuffer ( current . length ) ; boolean startOfLine = true ; int pos = 0 ; while ( pos < current . length ) { char ch = current [ pos ++ ] ; if ( startOfLine ) { if ( ch == ' ' || ch == '\t' ) { continue ; } startOfLine = false ; } b . append ( ch ) ; if ( ch == '\n' || ch == '\r' ) { startOfLine = true ; } } value = b . toString ( ) ; } if ( trim ) { value = value . trim ( ) ; } return value ; } } private class MultiReader extends Reader { private Reader reader = null ; private int lastPos = 0 ; private char [ ] lastChars = new char [ eolString . length ( ) ] ; private boolean needAddSeparator = false ; private Iterator i ; private MultiReader ( ResourceCollection c ) { i = c . iterator ( ) ; } private Reader getReader ( ) throws IOException { if ( reader == null && i . hasNext ( ) ) { Resource r = ( Resource ) i . next ( ) ; log ( "Concating " + r . toLongString ( ) , Project . MSG_VERBOSE ) ; InputStream is = r . getInputStream ( ) ; reader = new BufferedReader ( encoding == null ? new InputStreamReader ( is ) : new InputStreamReader ( is , encoding ) ) ; Arrays . fill ( lastChars , ( char ) 0 ) ; } return reader ; } private void nextReader ( ) throws IOException { close ( ) ; reader = null ; } public int read ( ) throws IOException { if ( needAddSeparator ) { int ret = eolString . charAt ( lastPos ++ ) ; if ( lastPos >= eolString . length ( ) ) { lastPos = 0 ; needAddSeparator = false ; } return ret ; } while ( getReader ( ) != null ) { int ch = getReader ( ) . read ( ) ; if ( ch == - 1 ) { nextReader ( ) ; if ( fixLastLine && isMissingEndOfLine ( ) ) { needAddSeparator = true ; lastPos = 0 ; } } else { addLastChar ( ( char ) ch ) ; return ch ; } } return - 1 ; } public int read ( char [ ] cbuf , int off , int len ) throws IOException { int amountRead = 0 ; while ( getReader ( ) != null || needAddSeparator ) { if ( needAddSeparator ) { cbuf [ off ] = eolString . charAt ( lastPos ++ ) ; if ( lastPos >= eolString . length ( ) ) { lastPos = 0 ; needAddSeparator = false ; } len -- ; off ++ ; amountRead ++ ; if ( len == 0 ) { return amountRead ; } continue ; } int nRead = getReader ( ) . read ( cbuf , off , len ) ; if ( nRead == - 1 || nRead == 0 ) { nextReader ( ) ; if ( fixLastLine && isMissingEndOfLine ( ) ) { needAddSeparator = true ; lastPos = 0 ; } } else { if ( fixLastLine ) { for ( int i = nRead ; i > ( nRead - lastChars . length ) ; -- i ) { if ( i <= 0 ) { break ; } addLastChar ( cbuf [ off + i - 1 ] ) ; } } len -= nRead ; off += nRead ; amountRead += nRead ; if ( len == 0 ) { return amountRead ; } } } if ( amountRead == 0 ) { return - 1 ; } else { return amountRead ; } } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } private void addLastChar ( char ch ) { for ( int i = lastChars . length - 2 ; i >= 0 ; -- i ) { lastChars [ i ] = lastChars [ i + 1 ] ; } lastChars [ lastChars . length - 1 ] = ch ; } private boolean isMissingEndOfLine ( ) { for ( int i = 0 ; i < lastChars . length ; ++ i ) { if ( lastChars [ i ] != eolString . charAt ( i ) ) { return true ; } } return false ; } } } 	1
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class ScriptRunnerCreator { private static final String AUTO = "auto" ; private static final String OATAU = "org.apache.tools.ant.util" ; private static final String UTIL_OPT = OATAU + ".optional" ; private static final String BSF = "bsf" ; private static final String BSF_PACK = "org.apache.bsf" ; private static final String BSF_MANAGER = BSF_PACK + ".BSFManager" ; private static final String BSF_RUNNER = UTIL_OPT + ".ScriptRunner" ; private static final String JAVAX = "javax" ; private static final String JAVAX_MANAGER = "javax.script.ScriptEngineManager" ; private static final String JAVAX_RUNNER = UTIL_OPT + ".JavaxScriptRunner" ; private Project project ; private String manager ; private String language ; private ClassLoader scriptLoader = null ; public ScriptRunnerCreator ( Project project ) { this . project = project ; } public ScriptRunnerBase createRunner ( String manager , String language , ClassLoader classLoader ) { this . manager = manager ; this . language = language ; this . scriptLoader = classLoader ; if ( language == null ) { throw new BuildException ( "script language must be specified" ) ; } if ( ! manager . equals ( AUTO ) && ! manager . equals ( JAVAX ) && ! manager . equals ( BSF ) ) { throw new BuildException ( "Unsupported language prefix " + manager ) ; } ScriptRunnerBase ret = null ; ret = createRunner ( BSF , BSF_MANAGER , BSF_RUNNER ) ; if ( ret == null ) { ret = createRunner ( JAVAX , JAVAX_MANAGER , JAVAX_RUNNER ) ; } if ( ret != null ) { return ret ; } if ( JAVAX . equals ( manager ) ) { throw new BuildException ( "Unable to load the script engine manager " + "(" + JAVAX_MANAGER + ")" ) ; } else if ( BSF . equals ( manager ) ) { throw new BuildException ( "Unable to load the BSF script engine manager " + "(" + BSF_MANAGER + ")" ) ; } else { throw new BuildException ( "Unable to load a script engine manager " + "(" + BSF_MANAGER + " or " + JAVAX_MANAGER + ")" ) ; } } private ScriptRunnerBase createRunner ( String checkManager , String managerClass , String runnerClass ) { ScriptRunnerBase runner = null ; if ( ! manager . equals ( AUTO ) && ! manager . equals ( checkManager ) ) { return null ; } if ( scriptLoader . getResource ( LoaderUtils . classNameToResource ( managerClass ) ) == null ) { return null ; } try { runner = ( ScriptRunnerBase ) Class . forName ( runnerClass , true , scriptLoader ) . newInstance ( ) ; runner . setProject ( project ) ; } catch ( Exception ex ) { ReflectUtil . throwBuildException ( ex ) ; } runner . setLanguage ( language ) ; runner . setScriptClassLoader ( scriptLoader ) ; return runner ; } } 	0
package org . apache . tools . ant . types . resources . comparators ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . ResourceUtils ; public class Content extends ResourceComparator { private boolean binary = true ; public void setBinary ( boolean b ) { binary = b ; } public boolean isBinary ( ) { return binary ; } protected int resourceCompare ( Resource foo , Resource bar ) { try { return ResourceUtils . compareContent ( foo , bar , ! binary ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . UserInfo ; import com . jcraft . jsch . UIKeyboardInteractive ; public class SSHUserInfo implements UserInfo , UIKeyboardInteractive { private String name ; private String password = null ; private String keyfile ; private String passphrase = null ; private boolean trustAllCertificates ; public SSHUserInfo ( ) { super ( ) ; this . trustAllCertificates = false ; } public SSHUserInfo ( String password , boolean trustAllCertificates ) { super ( ) ; this . password = password ; this . trustAllCertificates = trustAllCertificates ; } public String getName ( ) { return name ; } public String getPassphrase ( String message ) { return passphrase ; } public String getPassword ( ) { return password ; } public boolean prompt ( String str ) { return false ; } public boolean retry ( ) { return false ; } public void setName ( String name ) { this . name = name ; } public void setPassphrase ( String passphrase ) { this . passphrase = passphrase ; } public void setPassword ( String password ) { this . password = password ; } public void setTrust ( boolean trust ) { this . trustAllCertificates = trust ; } public boolean getTrust ( ) { return this . trustAllCertificates ; } public String getPassphrase ( ) { return passphrase ; } public String getKeyfile ( ) { return keyfile ; } public void setKeyfile ( String keyfile ) { this . keyfile = keyfile ; } public boolean promptPassphrase ( String message ) { return true ; } public boolean promptPassword ( String passwordPrompt ) { return true ; } public boolean promptYesNo ( String message ) { return trustAllCertificates ; } public void showMessage ( String message ) { } public String [ ] promptKeyboardInteractive ( String destination , String name , String instruction , String [ ] prompt , boolean [ ] echo ) { if ( prompt . length != 1 || echo [ 0 ] || this . password == null ) { return null ; } String [ ] response = new String [ 1 ] ; response [ 0 ] = this . password ; return response ; } } 	0
package org . apache . tools . ant . util ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . io . BufferedWriter ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . condition . Os ; public final class JavaEnvUtils { private JavaEnvUtils ( ) { } private static final boolean IS_DOS = Os . isFamily ( "dos" ) ; private static final boolean IS_NETWARE = Os . isName ( "netware" ) ; private static final boolean IS_AIX = Os . isName ( "aix" ) ; private static final String JAVA_HOME = System . getProperty ( "java.home" ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static String javaVersion ; private static int javaVersionNumber ; public static final String JAVA_1_0 = "1.0" ; public static final String JAVA_1_1 = "1.1" ; public static final String JAVA_1_2 = "1.2" ; public static final String JAVA_1_3 = "1.3" ; public static final String JAVA_1_4 = "1.4" ; public static final String JAVA_1_5 = "1.5" ; public static final String JAVA_1_6 = "1.6" ; private static boolean kaffeDetected ; private static Vector jrePackages ; static { try { javaVersion = JAVA_1_0 ; javaVersionNumber = 10 ; Class . forName ( "java.lang.Void" ) ; javaVersion = JAVA_1_1 ; javaVersionNumber ++ ; Class . forName ( "java.lang.ThreadLocal" ) ; javaVersion = JAVA_1_2 ; javaVersionNumber ++ ; Class . forName ( "java.lang.StrictMath" ) ; javaVersion = JAVA_1_3 ; javaVersionNumber ++ ; Class . forName ( "java.lang.CharSequence" ) ; javaVersion = JAVA_1_4 ; javaVersionNumber ++ ; Class . forName ( "java.net.Proxy" ) ; javaVersion = JAVA_1_5 ; javaVersionNumber ++ ; Class . forName ( "java.util.ServiceLoader" ) ; javaVersion = JAVA_1_6 ; javaVersionNumber ++ ; } catch ( Throwable t ) { } kaffeDetected = false ; try { Class . forName ( "kaffe.util.NotImplemented" ) ; kaffeDetected = true ; } catch ( Throwable t ) { } } public static String getJavaVersion ( ) { return javaVersion ; } public static int getJavaVersionNumber ( ) { return javaVersionNumber ; } public static boolean isJavaVersion ( String version ) { return javaVersion . equals ( version ) ; } public static boolean isAtLeastJavaVersion ( String version ) { return javaVersion . compareTo ( version ) >= 0 ; } public static boolean isKaffe ( ) { return kaffeDetected ; } public static String getJreExecutable ( String command ) { if ( IS_NETWARE ) { return command ; } File jExecutable = null ; if ( IS_AIX ) { jExecutable = findInDir ( JAVA_HOME + "/sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( JAVA_HOME + "/bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return addExtension ( command ) ; } } public static String getJdkExecutable ( String command ) { if ( IS_NETWARE ) { return command ; } File jExecutable = null ; if ( IS_AIX ) { jExecutable = findInDir ( JAVA_HOME + "/../sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( JAVA_HOME + "/../bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return getJreExecutable ( command ) ; } } private static String addExtension ( String command ) { return command + ( IS_DOS ? ".exe" : "" ) ; } private static File findInDir ( String dirName , String commandName ) { File dir = FILE_UTILS . normalize ( dirName ) ; File executable = null ; if ( dir . exists ( ) ) { executable = new File ( dir , addExtension ( commandName ) ) ; if ( ! executable . exists ( ) ) { executable = null ; } } return executable ; } private static void buildJrePackages ( ) { jrePackages = new Vector ( ) ; switch ( javaVersionNumber ) { case 16 : case 15 : jrePackages . addElement ( "com.sun.org.apache" ) ; case 14 : if ( javaVersionNumber == 14 ) { jrePackages . addElement ( "org.apache.crimson" ) ; jrePackages . addElement ( "org.apache.xalan" ) ; jrePackages . addElement ( "org.apache.xml" ) ; jrePackages . addElement ( "org.apache.xpath" ) ; } jrePackages . addElement ( "org.ietf.jgss" ) ; jrePackages . addElement ( "org.w3c.dom" ) ; jrePackages . addElement ( "org.xml.sax" ) ; case 13 : jrePackages . addElement ( "org.omg" ) ; jrePackages . addElement ( "com.sun.corba" ) ; jrePackages . addElement ( "com.sun.jndi" ) ; jrePackages . addElement ( "com.sun.media" ) ; jrePackages . addElement ( "com.sun.naming" ) ; jrePackages . addElement ( "com.sun.org.omg" ) ; jrePackages . addElement ( "com.sun.rmi" ) ; jrePackages . addElement ( "sunw.io" ) ; jrePackages . addElement ( "sunw.util" ) ; case 12 : jrePackages . addElement ( "com.sun.java" ) ; jrePackages . addElement ( "com.sun.image" ) ; case 11 : default : jrePackages . addElement ( "sun" ) ; jrePackages . addElement ( "java" ) ; jrePackages . addElement ( "javax" ) ; break ; } } public static Vector getJrePackageTestCases ( ) { Vector tests = new Vector ( ) ; tests . addElement ( "java.lang.Object" ) ; switch ( javaVersionNumber ) { case 16 : case 15 : tests . addElement ( "com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl " ) ; case 14 : tests . addElement ( "sun.audio.AudioPlayer" ) ; if ( javaVersionNumber == 14 ) { tests . addElement ( "org.apache.crimson.parser.ContentModel" ) ; tests . addElement ( "org.apache.xalan.processor.ProcessorImport" ) ; tests . addElement ( "org.apache.xml.utils.URI" ) ; tests . addElement ( "org.apache.xpath.XPathFactory" ) ; } tests . addElement ( "org.ietf.jgss.Oid" ) ; tests . addElement ( "org.w3c.dom.Attr" ) ; tests . addElement ( "org.xml.sax.XMLReader" ) ; case 13 : tests . addElement ( "org.omg.CORBA.Any" ) ; tests . addElement ( "com.sun.corba.se.internal.corba.AnyImpl" ) ; tests . addElement ( "com.sun.jndi.ldap.LdapURL" ) ; tests . addElement ( "com.sun.media.sound.Printer" ) ; tests . addElement ( "com.sun.naming.internal.VersionHelper" ) ; tests . addElement ( "com.sun.org.omg.CORBA.Initializer" ) ; tests . addElement ( "sunw.io.Serializable" ) ; tests . addElement ( "sunw.util.EventListener" ) ; case 12 : tests . addElement ( "javax.accessibility.Accessible" ) ; tests . addElement ( "sun.misc.BASE64Encoder" ) ; tests . addElement ( "com.sun.image.codec.jpeg.JPEGCodec" ) ; case 11 : default : tests . addElement ( "sun.reflect.SerializationConstructorAccessorImpl" ) ; tests . addElement ( "sun.net.www.http.HttpClient" ) ; tests . addElement ( "sun.audio.AudioPlayer" ) ; break ; } return tests ; } public static Vector getJrePackages ( ) { if ( jrePackages == null ) { buildJrePackages ( ) ; } return jrePackages ; } public static File createVmsJavaOptionFile ( String [ ] cmd ) throws IOException { File script = FILE_UTILS . createTempFile ( "ANT" , ".JAVA_OPTS" , null ) ; PrintWriter out = null ; try { out = new PrintWriter ( new BufferedWriter ( new FileWriter ( script ) ) ) ; for ( int i = 0 ; i < cmd . length ; i ++ ) { out . println ( cmd [ i ] ) ; } } finally { FileUtils . close ( out ) ; } return script ; } public static String getJavaHome ( ) { return JAVA_HOME ; } } 	0
package org . apache . tools . ant . util ; public class XmlConstants { public static final String PROPERTY_SCHEMA_LOCATION = "http://apache.org/xml/properties/schema/external-schemaLocation" ; public static final String PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION = "http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation" ; public static final String FEATURE_XSD_FULL_VALIDATION = "http://apache.org/xml/features/validation/schema-full-checking" ; public static final String FEATURE_XSD = "http://apache.org/xml/features/validation/schema" ; public static final String FEATURE_VALIDATION = "http://xml.org/sax/features/validation" ; public static final String FEATURE_NAMESPACES = "http://xml.org/sax/features/namespaces" ; public static final String FEATURE_JAXP12_SCHEMA_LANGUAGE = "http://java.sun.com/xml/jaxp/properties/schemaLanguage" ; public static final String FEATURE_JAXP12_SCHEMA_SOURCE = "http://java.sun.com/xml/jaxp/properties/schemaSource" ; public static final String URI_XSD = "http://www.w3.org/2001/XMLSchema" ; public static final String FEATURE_EXTERNAL_ENTITIES = "http://xml.org/sax/features/external-general-entities" ; public static final String FEATURE_DISALLOW_DTD = "http://apache.org/xml/features/disallow-doctype-decl" ; } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; public abstract class Unpack extends Task { protected File source ; protected File dest ; protected Resource srcResource ; public void setSrc ( String src ) { log ( "DEPRECATED - The setSrc(String) method has been deprecated." + " Use setSrc(File) instead." ) ; setSrc ( getProject ( ) . resolveFile ( src ) ) ; } public void setDest ( String dest ) { log ( "DEPRECATED - The setDest(String) method has been deprecated." + " Use setDest(File) instead." ) ; setDest ( getProject ( ) . resolveFile ( dest ) ) ; } public void setSrc ( File src ) { setSrcResource ( new FileResource ( src ) ) ; } public void setSrcResource ( Resource src ) { if ( ! src . isExists ( ) ) { throw new BuildException ( "the archive doesn't exist" ) ; } if ( src . isDirectory ( ) ) { throw new BuildException ( "the archive can't be a directory" ) ; } if ( src instanceof FileResource ) { source = ( ( FileResource ) src ) . getFile ( ) ; } else if ( ! supportsNonFileResources ( ) ) { throw new BuildException ( "Only FileSystem resources are" + " supported." ) ; } srcResource = src ; } public void addConfigured ( ResourceCollection a ) { if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } setSrcResource ( ( Resource ) a . iterator ( ) . next ( ) ) ; } public void setDest ( File dest ) { this . dest = dest ; } private void validate ( ) throws BuildException { if ( srcResource == null ) { throw new BuildException ( "No Src specified" , getLocation ( ) ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String defaultExtension = getDefaultExtension ( ) ; createDestFile ( defaultExtension ) ; } } private void createDestFile ( String defaultExtension ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( defaultExtension != null && len > defaultExtension . length ( ) && defaultExtension . equalsIgnoreCase ( sourceName . substring ( len - defaultExtension . length ( ) ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - defaultExtension . length ( ) ) ) ; } else { dest = new File ( dest , sourceName ) ; } } public void execute ( ) throws BuildException { File savedDest = dest ; try { validate ( ) ; extract ( ) ; } finally { dest = savedDest ; } } protected abstract String getDefaultExtension ( ) ; protected abstract void extract ( ) ; protected boolean supportsNonFileResources ( ) { return false ; } } 	1
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public interface ExtensionResolver { File resolve ( Extension extension , Project project ) throws BuildException ; } 	0
package org . apache . tools . tar ; public class TarUtils { public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; } public static StringBuffer parseName ( byte [ ] header , int offset , int length ) { StringBuffer result = new StringBuffer ( length ) ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } result . append ( ( char ) header [ i ] ) ; } return result ; } public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 0 ; } return offset + length ; } public static int getOctalBytes ( long value , byte [ ] buf , int offset , int length ) { int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) '0' ; -- idx ; } else { for ( long val = value ; idx >= 0 && val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) '0' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx >= 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; } public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; } public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; buf [ offset + length - 1 ] = ( byte ) ' ' ; buf [ offset + length - 2 ] = 0 ; return offset + length ; } public static long computeCheckSum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++ i ) { sum += 255 & buf [ i ] ; } return sum ; } } 	0
package org . apache . tools . zip ; public interface UnixStat { int PERM_MASK = 07777 ; int LINK_FLAG = 0120000 ; int FILE_FLAG = 0100000 ; int DIR_FLAG = 040000 ; int DEFAULT_LINK_PERM = 0777 ; int DEFAULT_DIR_PERM = 0755 ; int DEFAULT_FILE_PERM = 0644 ; } 	0
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Type implements ResourceSelector { private static final String FILE_ATTR = "file" ; private static final String DIR_ATTR = "dir" ; public static final Type FILE = new Type ( new FileDir ( FILE_ATTR ) ) ; public static final Type DIR = new Type ( new FileDir ( DIR_ATTR ) ) ; public static class FileDir extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { FILE_ATTR , DIR_ATTR } ; public FileDir ( ) { } public FileDir ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } } private FileDir type = null ; public Type ( ) { } public Type ( FileDir fd ) { setType ( fd ) ; } public void setType ( FileDir fd ) { type = fd ; } public boolean isSelected ( Resource r ) { if ( type == null ) { throw new BuildException ( "The type attribute is required." ) ; } int i = type . getIndex ( ) ; return r . isDirectory ( ) ? i == 1 : i == 0 ; } } 	0
package org . apache . tools . ant . types ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . resources . FileResourceIterator ; public class FileList extends DataType implements ResourceCollection { private Vector filenames = new Vector ( ) ; private File dir ; public FileList ( ) { super ( ) ; } protected FileList ( FileList filelist ) { this . dir = filelist . dir ; this . filenames = filelist . filenames ; setProject ( filelist . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ( dir != null ) || ( filenames . size ( ) != 0 ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { checkAttributesAllowed ( ) ; this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public void setFiles ( String filenames ) { checkAttributesAllowed ( ) ; if ( filenames != null && filenames . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( filenames , ", \t\n\r\f" , false ) ; while ( tok . hasMoreTokens ( ) ) { this . filenames . addElement ( tok . nextToken ( ) ) ; } } } public String [ ] getFiles ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getFiles ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for filelist." ) ; } if ( filenames . size ( ) == 0 ) { throw new BuildException ( "No files specified for filelist." ) ; } String [ ] result = new String [ filenames . size ( ) ] ; filenames . copyInto ( result ) ; return result ; } protected FileList getRef ( Project p ) { return ( FileList ) getCheckedRef ( p ) ; } public static class FileName { private String name ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } public void addConfiguredFile ( FileName name ) { if ( name . getName ( ) == null ) { throw new BuildException ( "No name specified in nested file element" ) ; } filenames . addElement ( name . getName ( ) ) ; } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( FileList ) getRef ( getProject ( ) ) ) . iterator ( ) ; } return new FileResourceIterator ( dir , ( String [ ] ) ( filenames . toArray ( new String [ filenames . size ( ) ] ) ) ) ; } public int size ( ) { if ( isReference ( ) ) { return ( ( FileList ) getRef ( getProject ( ) ) ) . size ( ) ; } return filenames . size ( ) ; } public boolean isFilesystemOnly ( ) { return true ; } } 	0
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; import java . net . URL ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import javax . xml . transform . TransformerConfigurationException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . XSLTLiaison3 ; import org . apache . tools . ant . taskdefs . XSLTLogger ; import org . apache . tools . ant . taskdefs . XSLTLoggerAware ; import org . apache . tools . ant . taskdefs . XSLTProcess ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . URLResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class TraXLiaison implements XSLTLiaison3 , ErrorListener , XSLTLoggerAware { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private Project project ; private String factoryName = null ; private TransformerFactory tfactory = null ; private Resource stylesheet ; private XSLTLogger logger ; private EntityResolver entityResolver ; private Transformer transformer ; private Templates templates ; private long templatesModTime ; private URIResolver uriResolver ; private Vector outputProperties = new Vector ( ) ; private Hashtable params = new Hashtable ( ) ; private Vector attributes = new Vector ( ) ; public TraXLiaison ( ) throws Exception { } public void setStylesheet ( File stylesheet ) throws Exception { FileResource fr = new FileResource ( ) ; fr . setProject ( project ) ; fr . setFile ( stylesheet ) ; setStylesheet ( fr ) ; } public void setStylesheet ( Resource stylesheet ) throws Exception { if ( this . stylesheet != null ) { transformer = null ; if ( ! this . stylesheet . equals ( stylesheet ) || ( stylesheet . getLastModified ( ) != templatesModTime ) ) { templates = null ; } } this . stylesheet = stylesheet ; } public void transform ( File infile , File outfile ) throws Exception { if ( transformer == null ) { createTransformer ( ) ; } InputStream fis = null ; OutputStream fos = null ; try { fis = new BufferedInputStream ( new FileInputStream ( infile ) ) ; fos = new BufferedOutputStream ( new FileOutputStream ( outfile ) ) ; StreamResult res = new StreamResult ( fos ) ; res . setSystemId ( JAXPUtils . getSystemId ( outfile ) ) ; Source src = getSource ( fis , infile ) ; setTransformationParameters ( ) ; transformer . transform ( src , res ) ; } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } try { if ( fos != null ) { fos . close ( ) ; } } catch ( IOException ignored ) { } } } private Source getSource ( InputStream is , File infile ) throws ParserConfigurationException , SAXException { Source src = null ; if ( entityResolver != null ) { if ( getFactory ( ) . getFeature ( SAXSource . FEATURE ) ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; XMLReader reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; reader . setEntityResolver ( entityResolver ) ; src = new SAXSource ( reader , new InputSource ( is ) ) ; } else { throw new IllegalStateException ( "xcatalog specified, but " + "parser doesn't support SAX" ) ; } } else { src = new StreamSource ( is ) ; } src . setSystemId ( JAXPUtils . getSystemId ( infile ) ) ; return src ; } private Source getSource ( InputStream is , Resource resource ) throws ParserConfigurationException , SAXException { Source src = null ; if ( entityResolver != null ) { if ( getFactory ( ) . getFeature ( SAXSource . FEATURE ) ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; XMLReader reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; reader . setEntityResolver ( entityResolver ) ; src = new SAXSource ( reader , new InputSource ( is ) ) ; } else { throw new IllegalStateException ( "xcatalog specified, but " + "parser doesn't support SAX" ) ; } } else { src = new StreamSource ( is ) ; } src . setSystemId ( resourceToURI ( resource ) ) ; return src ; } private String resourceToURI ( Resource resource ) { if ( resource instanceof FileResource ) { File f = ( ( FileResource ) resource ) . getFile ( ) ; return FILE_UTILS . toURI ( f . getAbsolutePath ( ) ) ; } if ( resource instanceof URLResource ) { URL u = ( ( URLResource ) resource ) . getURL ( ) ; return String . valueOf ( u ) ; } else { return resource . getName ( ) ; } } private void readTemplates ( ) throws IOException , TransformerConfigurationException , ParserConfigurationException , SAXException { InputStream xslStream = null ; try { xslStream = new BufferedInputStream ( stylesheet . getInputStream ( ) ) ; templatesModTime = stylesheet . getLastModified ( ) ; Source src = getSource ( xslStream , stylesheet ) ; templates = getFactory ( ) . newTemplates ( src ) ; } finally { if ( xslStream != null ) { xslStream . close ( ) ; } } } private void createTransformer ( ) throws Exception { if ( templates == null ) { readTemplates ( ) ; } transformer = templates . newTransformer ( ) ; transformer . setErrorListener ( this ) ; if ( uriResolver != null ) { transformer . setURIResolver ( uriResolver ) ; } for ( int i = 0 ; i < outputProperties . size ( ) ; i ++ ) { final String [ ] pair = ( String [ ] ) outputProperties . elementAt ( i ) ; transformer . setOutputProperty ( pair [ 0 ] , pair [ 1 ] ) ; } } private void setTransformationParameters ( ) { for ( final Enumeration enumeration = params . keys ( ) ; enumeration . hasMoreElements ( ) ; ) { final String name = ( String ) enumeration . nextElement ( ) ; final String value = ( String ) params . get ( name ) ; transformer . setParameter ( name , value ) ; } } private TransformerFactory getFactory ( ) throws BuildException { if ( tfactory != null ) { return tfactory ; } if ( factoryName == null ) { tfactory = TransformerFactory . newInstance ( ) ; } else { try { Class clazz = Class . forName ( factoryName ) ; tfactory = ( TransformerFactory ) clazz . newInstance ( ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } tfactory . setErrorListener ( this ) ; for ( int i = 0 ; i < attributes . size ( ) ; i ++ ) { final Object [ ] pair = ( Object [ ] ) attributes . elementAt ( i ) ; tfactory . setAttribute ( ( String ) pair [ 0 ] , pair [ 1 ] ) ; } if ( uriResolver != null ) { tfactory . setURIResolver ( uriResolver ) ; } return tfactory ; } public void setFactory ( String name ) { factoryName = name ; } public void setAttribute ( String name , Object value ) { final Object [ ] pair = new Object [ ] { name , value } ; attributes . addElement ( pair ) ; } public void setOutputProperty ( String name , String value ) { final String [ ] pair = new String [ ] { name , value } ; outputProperties . addElement ( pair ) ; } public void setEntityResolver ( EntityResolver aResolver ) { entityResolver = aResolver ; } public void setURIResolver ( URIResolver aResolver ) { uriResolver = aResolver ; } public void addParam ( String name , String value ) { params . put ( name , value ) ; } public void setLogger ( XSLTLogger l ) { logger = l ; } public void error ( TransformerException e ) { logError ( e , "Error" ) ; } public void fatalError ( TransformerException e ) { logError ( e , "Fatal Error" ) ; throw new BuildException ( "Fatal error during transformation" , e ) ; } public void warning ( TransformerException e ) { logError ( e , "Warning" ) ; } private void logError ( TransformerException e , String type ) { if ( logger == null ) { return ; } StringBuffer msg = new StringBuffer ( ) ; SourceLocator locator = e . getLocator ( ) ; if ( locator != null ) { String systemid = locator . getSystemId ( ) ; if ( systemid != null ) { String url = systemid ; if ( url . startsWith ( "file:" ) ) { url = FileUtils . getFileUtils ( ) . fromURI ( url ) ; } msg . append ( url ) ; } else { msg . append ( "Unknown file" ) ; } int line = locator . getLineNumber ( ) ; if ( line != - 1 ) { msg . append ( ":" ) ; msg . append ( line ) ; int column = locator . getColumnNumber ( ) ; if ( column != - 1 ) { msg . append ( ":" ) ; msg . append ( column ) ; } } } msg . append ( ": " ) ; msg . append ( type ) ; msg . append ( "! " ) ; msg . append ( e . getMessage ( ) ) ; if ( e . getCause ( ) != null ) { msg . append ( " Cause: " ) ; msg . append ( e . getCause ( ) ) ; } logger . log ( msg . toString ( ) ) ; } protected String getSystemId ( File file ) { return JAXPUtils . getSystemId ( file ) ; } public void configure ( XSLTProcess xsltTask ) { project = xsltTask . getProject ( ) ; XSLTProcess . Factory factory = xsltTask . getFactory ( ) ; if ( factory != null ) { setFactory ( factory . getName ( ) ) ; for ( Enumeration attrs = factory . getAttributes ( ) ; attrs . hasMoreElements ( ) ; ) { XSLTProcess . Factory . Attribute attr = ( XSLTProcess . Factory . Attribute ) attrs . nextElement ( ) ; setAttribute ( attr . getName ( ) , attr . getValue ( ) ) ; } } XMLCatalog xmlCatalog = xsltTask . getXMLCatalog ( ) ; if ( xmlCatalog != null ) { setEntityResolver ( xmlCatalog ) ; setURIResolver ( xmlCatalog ) ; } for ( Enumeration props = xsltTask . getOutputProperties ( ) ; props . hasMoreElements ( ) ; ) { XSLTProcess . OutputProperty prop = ( XSLTProcess . OutputProperty ) props . nextElement ( ) ; setOutputProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } } } 	1
package org . apache . tools . ant ; public class ExitException extends SecurityException { private int status ; public ExitException ( int status ) { super ( "ExitException: status " + status ) ; this . status = status ; } public ExitException ( String msg , int status ) { super ( msg ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	0
package org . apache . tools . ant . taskdefs . optional . net ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . email . EmailTask ; public class MimeMail extends EmailTask { public void execute ( ) throws BuildException { log ( "DEPRECATED - The " + getTaskName ( ) + " task is deprecated. " + "Use the mail task instead." ) ; super . execute ( ) ; } } 	0
package org . apache . tools . ant . launch ; import java . net . MalformedURLException ; import java . net . URL ; import java . io . File ; import java . io . FilenameFilter ; import java . io . ByteArrayOutputStream ; import java . io . UnsupportedEncodingException ; import java . text . CharacterIterator ; import java . text . StringCharacterIterator ; import java . util . Locale ; public final class Locator { public static final String URI_ENCODING = "UTF-8" ; private static boolean [ ] gNeedEscaping = new boolean [ 128 ] ; private static char [ ] gAfterEscaping1 = new char [ 128 ] ; private static char [ ] gAfterEscaping2 = new char [ 128 ] ; private static char [ ] gHexChs = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; static { for ( int i = 0 ; i <= 0x1f ; i ++ ) { gNeedEscaping [ i ] = true ; gAfterEscaping1 [ i ] = gHexChs [ i > > 4 ] ; gAfterEscaping2 [ i ] = gHexChs [ i & 0xf ] ; } gNeedEscaping [ 0x7f ] = true ; gAfterEscaping1 [ 0x7f ] = '7' ; gAfterEscaping2 [ 0x7f ] = 'F' ; char [ ] escChs = { ' ' , '<' , '>' , '#' , '%' , '"' , '{' , '}' , '|' , '\\' , '^' , '~' , '[' , ']' , '`' } ; int len = escChs . length ; char ch ; for ( int i = 0 ; i < len ; i ++ ) { ch = escChs [ i ] ; gNeedEscaping [ ch ] = true ; gAfterEscaping1 [ ch ] = gHexChs [ ch > > 4 ] ; gAfterEscaping2 [ ch ] = gHexChs [ ch & 0xf ] ; } } private Locator ( ) { } public static File getClassSource ( Class c ) { String classResource = c . getName ( ) . replace ( '.' , '/' ) + ".class" ; return getResourceSource ( c . getClassLoader ( ) , classResource ) ; } public static File getResourceSource ( ClassLoader c , String resource ) { if ( c == null ) { c = Locator . class . getClassLoader ( ) ; } URL url = null ; if ( c == null ) { url = ClassLoader . getSystemResource ( resource ) ; } else { url = c . getResource ( resource ) ; } if ( url != null ) { String u = url . toString ( ) ; if ( u . startsWith ( "jar:file:" ) ) { int pling = u . indexOf ( "!" ) ; String jarName = u . substring ( 4 , pling ) ; return new File ( fromURI ( jarName ) ) ; } else if ( u . startsWith ( "file:" ) ) { int tail = u . indexOf ( resource ) ; String dirName = u . substring ( 0 , tail ) ; return new File ( fromURI ( dirName ) ) ; } } return null ; } public static String fromURI ( String uri ) { Class uriClazz = null ; try { uriClazz = Class . forName ( "java.net.URI" ) ; } catch ( ClassNotFoundException cnfe ) { } if ( uriClazz != null && uri . startsWith ( "file:/" ) ) { try { java . lang . reflect . Method createMethod = uriClazz . getMethod ( "create" , new Class [ ] { String . class } ) ; Object uriObj = createMethod . invoke ( null , new Object [ ] { uri } ) ; java . lang . reflect . Constructor fileConst = File . class . getConstructor ( new Class [ ] { uriClazz } ) ; File f = ( File ) fileConst . newInstance ( new Object [ ] { uriObj } ) ; return f . getAbsolutePath ( ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { Throwable e2 = e . getTargetException ( ) ; if ( e2 instanceof IllegalArgumentException ) { throw ( IllegalArgumentException ) e2 ; } else { e2 . printStackTrace ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } URL url = null ; try { url = new URL ( uri ) ; } catch ( MalformedURLException emYouEarlEx ) { } if ( url == null || ! ( "file" . equals ( url . getProtocol ( ) ) ) ) { throw new IllegalArgumentException ( "Can only handle valid file: URIs" ) ; } StringBuffer buf = new StringBuffer ( url . getHost ( ) ) ; if ( buf . length ( ) > 0 ) { buf . insert ( 0 , File . separatorChar ) . insert ( 0 , File . separatorChar ) ; } String file = url . getFile ( ) ; int queryPos = file . indexOf ( '?' ) ; buf . append ( ( queryPos < 0 ) ? file : file . substring ( 0 , queryPos ) ) ; uri = buf . toString ( ) . replace ( '/' , File . separatorChar ) ; if ( File . pathSeparatorChar == ';' && uri . startsWith ( "\\" ) && uri . length ( ) > 2 && Character . isLetter ( uri . charAt ( 1 ) ) && uri . lastIndexOf ( ':' ) > - 1 ) { uri = uri . substring ( 1 ) ; } String path = null ; try { path = decodeUri ( uri ) ; String cwd = System . getProperty ( "user.dir" ) ; int posi = cwd . indexOf ( ":" ) ; if ( ( posi > 0 ) && path . startsWith ( File . separator ) ) { path = cwd . substring ( 0 , posi + 1 ) + path ; } } catch ( UnsupportedEncodingException exc ) { throw new IllegalStateException ( "Could not convert URI to path: " + exc . getMessage ( ) ) ; } return path ; } public static String decodeUri ( String uri ) throws UnsupportedEncodingException { if ( uri . indexOf ( '%' ) == - 1 ) { return uri ; } ByteArrayOutputStream sb = new ByteArrayOutputStream ( uri . length ( ) ) ; CharacterIterator iter = new StringCharacterIterator ( uri ) ; for ( char c = iter . first ( ) ; c != CharacterIterator . DONE ; c = iter . next ( ) ) { if ( c == '%' ) { char c1 = iter . next ( ) ; if ( c1 != CharacterIterator . DONE ) { int i1 = Character . digit ( c1 , 16 ) ; char c2 = iter . next ( ) ; if ( c2 != CharacterIterator . DONE ) { int i2 = Character . digit ( c2 , 16 ) ; sb . write ( ( char ) ( ( i1 << 4 ) + i2 ) ) ; } } } else { sb . write ( c ) ; } } return sb . toString ( URI_ENCODING ) ; } public static String encodeURI ( String path ) throws UnsupportedEncodingException { int i = 0 ; int len = path . length ( ) ; int ch = 0 ; StringBuffer sb = null ; for ( ; i < len ; i ++ ) { ch = path . charAt ( i ) ; if ( ch >= 128 ) { break ; } if ( gNeedEscaping [ ch ] ) { if ( sb == null ) { sb = new StringBuffer ( path . substring ( 0 , i ) ) ; } sb . append ( '%' ) ; sb . append ( gAfterEscaping1 [ ch ] ) ; sb . append ( gAfterEscaping2 [ ch ] ) ; } else if ( sb != null ) { sb . append ( ( char ) ch ) ; } } if ( i < len ) { if ( sb == null ) { sb = new StringBuffer ( path . substring ( 0 , i ) ) ; } byte [ ] bytes = null ; byte b ; bytes = path . substring ( i ) . getBytes ( URI_ENCODING ) ; len = bytes . length ; for ( i = 0 ; i < len ; i ++ ) { b = bytes [ i ] ; if ( b < 0 ) { ch = b + 256 ; sb . append ( '%' ) ; sb . append ( gHexChs [ ch > > 4 ] ) ; sb . append ( gHexChs [ ch & 0xf ] ) ; } else if ( gNeedEscaping [ b ] ) { sb . append ( '%' ) ; sb . append ( gAfterEscaping1 [ b ] ) ; sb . append ( gAfterEscaping2 [ b ] ) ; } else { sb . append ( ( char ) b ) ; } } } return sb == null ? path : sb . toString ( ) ; } public static URL fileToURL ( File file ) throws MalformedURLException { try { return new URL ( encodeURI ( file . toURL ( ) . toString ( ) ) ) ; } catch ( UnsupportedEncodingException ex ) { throw new MalformedURLException ( ex . toString ( ) ) ; } } public static File getToolsJar ( ) { boolean toolsJarAvailable = false ; try { Class . forName ( "com.sun.tools.javac.Main" ) ; toolsJarAvailable = true ; } catch ( Exception e ) { try { Class . forName ( "sun.tools.javac.Main" ) ; toolsJarAvailable = true ; } catch ( Exception e2 ) { } } if ( toolsJarAvailable ) { return null ; } String javaHome = System . getProperty ( "java.home" ) ; File toolsJar = new File ( javaHome + "/lib/tools.jar" ) ; if ( toolsJar . exists ( ) ) { return toolsJar ; } if ( javaHome . toLowerCase ( Locale . US ) . endsWith ( File . separator + "jre" ) ) { javaHome = javaHome . substring ( 0 , javaHome . length ( ) - 4 ) ; toolsJar = new File ( javaHome + "/lib/tools.jar" ) ; } if ( ! toolsJar . exists ( ) ) { System . out . println ( "Unable to locate tools.jar. " + "Expected to find it in " + toolsJar . getPath ( ) ) ; return null ; } return toolsJar ; } public static URL [ ] getLocationURLs ( File location ) throws MalformedURLException { return getLocationURLs ( location , new String [ ] { ".jar" } ) ; } public static URL [ ] getLocationURLs ( File location , final String [ ] extensions ) throws MalformedURLException { URL [ ] urls = new URL [ 0 ] ; if ( ! location . exists ( ) ) { return urls ; } if ( ! location . isDirectory ( ) ) { urls = new URL [ 1 ] ; String path = location . getPath ( ) ; for ( int i = 0 ; i < extensions . length ; ++ i ) { if ( path . toLowerCase ( ) . endsWith ( extensions [ i ] ) ) { urls [ 0 ] = fileToURL ( location ) ; break ; } } return urls ; } File [ ] matches = location . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { for ( int i = 0 ; i < extensions . length ; ++ i ) { if ( name . toLowerCase ( ) . endsWith ( extensions [ i ] ) ) { return true ; } } return false ; } } ) ; urls = new URL [ matches . length ] ; for ( int i = 0 ; i < matches . length ; ++ i ) { urls [ i ] = fileToURL ( matches [ i ] ) ; } return urls ; } } 	1
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class IntegerCPInfo extends ConstantCPInfo { public IntegerCPInfo ( ) { super ( CONSTANT_INTEGER , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Integer ( cpStream . readInt ( ) ) ) ; } public String toString ( ) { return "Integer Constant Pool Entry: " + getValue ( ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; public class P4Labelsync extends P4Base { protected String name ; private boolean add ; private boolean delete ; private boolean simulationmode ; public boolean isAdd ( ) { return add ; } public void setAdd ( boolean add ) { this . add = add ; } public boolean isDelete ( ) { return delete ; } public void setDelete ( boolean delete ) { this . delete = delete ; } public void setName ( String name ) { this . name = name ; } public boolean isSimulationmode ( ) { return simulationmode ; } public void setSimulationmode ( boolean simulationmode ) { this . simulationmode = simulationmode ; } public void execute ( ) throws BuildException { log ( "P4Labelsync exec:" , Project . MSG_INFO ) ; if ( P4View != null && P4View . length ( ) >= 1 ) { P4View = StringUtils . replace ( P4View , ":" , "\n\t" ) ; P4View = StringUtils . replace ( P4View , ";" , "\n\t" ) ; } if ( P4View == null ) { P4View = "" ; } if ( name == null || name . length ( ) < 1 ) { throw new BuildException ( "name attribute is compulsory for labelsync" ) ; } if ( this . isSimulationmode ( ) ) { P4CmdOpts = P4CmdOpts + " -n" ; } if ( this . isDelete ( ) ) { P4CmdOpts = P4CmdOpts + " -d" ; } if ( this . isAdd ( ) ) { P4CmdOpts = P4CmdOpts + " -a" ; } execP4Command ( "-s labelsync -l " + name + " " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . BuildException ; public class VisualBasicCompile extends DotnetCompile { private boolean removeIntChecks = false ; private boolean optionExplicit = false ; private boolean optionStrict = false ; private String optionCompare ; private String rootNamespace ; private String imports ; public VisualBasicCompile ( ) { clear ( ) ; } public void clear ( ) { super . clear ( ) ; imports = null ; rootNamespace = null ; optionCompare = null ; optionExplicit = false ; optionStrict = false ; removeIntChecks = false ; setExecutable ( "vbc" ) ; } protected String getWin32ResParameter ( ) { if ( getWin32Res ( ) != null ) { return "/win32resource:" + getWin32Res ( ) . toString ( ) ; } else { return null ; } } public void setRemoveIntChecks ( boolean flag ) { removeIntChecks = flag ; } public boolean getRemoveIntChecks ( ) { return removeIntChecks ; } public String getRemoveIntChecksParameter ( ) { return "/removeintchecks" + ( removeIntChecks ? "+" : "-" ) ; } public void setOptionExplicit ( boolean flag ) { optionExplicit = flag ; } public boolean getOptionExplicit ( ) { return optionExplicit ; } public String getOptionExplicitParameter ( ) { return "/optionexplicit" + ( optionExplicit ? "+" : "-" ) ; } public void setOptionStrict ( boolean flag ) { optionStrict = flag ; } public boolean getOptionStrict ( ) { return optionStrict ; } public String getOptionStrictParameter ( ) { return "/optionstrict" + ( optionStrict ? "+" : "-" ) ; } public void setRootNamespace ( String rootNamespace ) { this . rootNamespace = rootNamespace ; } public String getRootNamespace ( ) { return this . rootNamespace ; } protected String getRootNamespaceParameter ( ) { if ( rootNamespace != null && rootNamespace . length ( ) != 0 ) { return "/rootnamespace:" + rootNamespace ; } else { return null ; } } public void setImports ( String imports ) { this . imports = imports ; } public String getImports ( ) { return this . imports ; } protected String getImportsParameter ( ) { if ( imports != null && imports . length ( ) != 0 ) { return "/imports:" + imports ; } else { return null ; } } public void setOptionCompare ( String optionCompare ) { if ( "text" . equalsIgnoreCase ( optionCompare ) ) { this . optionCompare = "text" ; } else { this . optionCompare = "binary" ; } } public String getOptionCompare ( ) { return this . optionCompare ; } protected String getOptionCompareParameter ( ) { if ( optionCompare != null && "text" . equalsIgnoreCase ( optionCompare ) ) { return "/optioncompare:text" ; } else { return "/optioncompare:binary" ; } } protected void addCompilerSpecificOptions ( NetCommand command ) { command . addArgument ( getRemoveIntChecksParameter ( ) ) ; command . addArgument ( getImportsParameter ( ) ) ; command . addArgument ( getOptionExplicitParameter ( ) ) ; command . addArgument ( getOptionStrictParameter ( ) ) ; command . addArgument ( getRootNamespaceParameter ( ) ) ; command . addArgument ( getOptionCompareParameter ( ) ) ; } public String getReferenceDelimiter ( ) { return "," ; } public String getFileExtension ( ) { return "vb" ; } protected void createResourceParameter ( NetCommand command , DotnetResource resource ) { resource . getParameters ( getProject ( ) , command , false ) ; } protected void validate ( ) throws BuildException { super . validate ( ) ; if ( getDestFile ( ) == null ) { throw new BuildException ( "DestFile was not specified" ) ; } } } 	0
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . util . Iterator ; import java . util . Vector ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class JarLibAvailableTask extends Task { private File libraryFile ; private final Vector extensionFileSets = new Vector ( ) ; private String propertyName ; private ExtensionAdapter requiredExtension ; public void setProperty ( final String property ) { this . propertyName = property ; } public void setFile ( final File file ) { this . libraryFile = file ; } public void addConfiguredExtension ( final ExtensionAdapter extension ) { if ( null != requiredExtension ) { final String message = "Can not specify extension to " + "search for multiple times." ; throw new BuildException ( message ) ; } requiredExtension = extension ; } public void addConfiguredExtensionSet ( final ExtensionSet extensionSet ) { extensionFileSets . addElement ( extensionSet ) ; } public void execute ( ) throws BuildException { validate ( ) ; final Extension test = requiredExtension . toExtension ( ) ; if ( ! extensionFileSets . isEmpty ( ) ) { final Iterator iterator = extensionFileSets . iterator ( ) ; while ( iterator . hasNext ( ) ) { final ExtensionSet extensionSet = ( ExtensionSet ) iterator . next ( ) ; final Extension [ ] extensions = extensionSet . toExtensions ( getProject ( ) ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final Extension extension = extensions [ i ] ; if ( extension . isCompatibleWith ( test ) ) { getProject ( ) . setNewProperty ( propertyName , "true" ) ; } } } } else { final Manifest manifest = ExtensionUtil . getManifest ( libraryFile ) ; final Extension [ ] extensions = Extension . getAvailable ( manifest ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final Extension extension = extensions [ i ] ; if ( extension . isCompatibleWith ( test ) ) { getProject ( ) . setNewProperty ( propertyName , "true" ) ; } } } } private void validate ( ) throws BuildException { if ( null == requiredExtension ) { final String message = "Extension element must be specified." ; throw new BuildException ( message ) ; } if ( null == libraryFile && extensionFileSets . isEmpty ( ) ) { final String message = "File attribute not specified." ; throw new BuildException ( message ) ; } if ( null != libraryFile && ! libraryFile . exists ( ) ) { final String message = "File '" + libraryFile + "' does not exist." ; throw new BuildException ( message ) ; } if ( null != libraryFile && ! libraryFile . isFile ( ) ) { final String message = "\'" + libraryFile + "\' is not a file." ; throw new BuildException ( message ) ; } } } 	0
package org . apache . tools . ant ; public interface DynamicElement { Object createDynamicElement ( String name ) throws BuildException ; } 	0
package org . apache . tools . ant . taskdefs . email ; public class Header { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import java . util . TimeZone ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; private String prefix = "" ; public void setPrefix ( String prefix ) { this . prefix = prefix ; if ( ! this . prefix . endsWith ( "." ) ) { this . prefix += "." ; } } public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { CustomFormat cts = ( CustomFormat ) i . nextElement ( ) ; cts . execute ( getProject ( ) , d , getLocation ( ) ) ; } SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; setProperty ( "DSTAMP" , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; setProperty ( "TSTAMP" , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM d yyyy" , Locale . US ) ; setProperty ( "TODAY" , today . format ( d ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public CustomFormat createFormat ( ) { CustomFormat cts = new CustomFormat ( ) ; customFormats . addElement ( cts ) ; return cts ; } private void setProperty ( String name , String value ) { getProject ( ) . setNewProperty ( prefix + name , value ) ; } public class CustomFormat { private TimeZone timeZone ; private String propertyName ; private String pattern ; private String language ; private String country ; private String variant ; private int offset = 0 ; private int field = Calendar . DATE ; public CustomFormat ( ) { } public void setProperty ( String propertyName ) { this . propertyName = propertyName ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setLocale ( String locale ) { StringTokenizer st = new StringTokenizer ( locale , " \t\n\r\f," ) ; try { language = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { country = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { variant = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { throw new BuildException ( "bad locale format" , getLocation ( ) ) ; } } } else { country = "" ; } } catch ( NoSuchElementException e ) { throw new BuildException ( "bad locale format" , e , getLocation ( ) ) ; } } public void setTimezone ( String id ) { timeZone = TimeZone . getTimeZone ( id ) ; } public void setOffset ( int offset ) { this . offset = offset ; } public void setUnit ( String unit ) { log ( "DEPRECATED - The setUnit(String) method has been deprecated." + " Use setUnit(Tstamp.Unit) instead." ) ; Unit u = new Unit ( ) ; u . setValue ( unit ) ; field = u . getCalendarField ( ) ; } public void setUnit ( Unit unit ) { field = unit . getCalendarField ( ) ; } public void execute ( Project project , Date date , Location location ) { if ( propertyName == null ) { throw new BuildException ( "property attribute must be provided" , location ) ; } if ( pattern == null ) { throw new BuildException ( "pattern attribute must be provided" , location ) ; } SimpleDateFormat sdf ; if ( language == null ) { sdf = new SimpleDateFormat ( pattern ) ; } else if ( variant == null ) { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country ) ) ; } else { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country , variant ) ) ; } if ( offset != 0 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . add ( field , offset ) ; date = calendar . getTime ( ) ; } if ( timeZone != null ) { sdf . setTimeZone ( timeZone ) ; } Tstamp . this . setProperty ( propertyName , sdf . format ( date ) ) ; } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String MONTH = "month" ; private static final String YEAR = "year" ; private static final String [ ] UNITS = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , YEAR } ; private Map calendarFields = new HashMap ( ) ; public Unit ( ) { calendarFields . put ( MILLISECOND , new Integer ( Calendar . MILLISECOND ) ) ; calendarFields . put ( SECOND , new Integer ( Calendar . SECOND ) ) ; calendarFields . put ( MINUTE , new Integer ( Calendar . MINUTE ) ) ; calendarFields . put ( HOUR , new Integer ( Calendar . HOUR_OF_DAY ) ) ; calendarFields . put ( DAY , new Integer ( Calendar . DATE ) ) ; calendarFields . put ( WEEK , new Integer ( Calendar . WEEK_OF_YEAR ) ) ; calendarFields . put ( MONTH , new Integer ( Calendar . MONTH ) ) ; calendarFields . put ( YEAR , new Integer ( Calendar . YEAR ) ) ; } public int getCalendarField ( ) { String key = getValue ( ) . toLowerCase ( ) ; Integer i = ( Integer ) calendarFields . get ( key ) ; return i . intValue ( ) ; } public String [ ] getValues ( ) { return UNITS ; } } } 	0
package org . apache . tools . ant . taskdefs . optional . sound ; import java . io . File ; import java . util . Random ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class SoundTask extends Task { private BuildAlert success = null ; private BuildAlert fail = null ; public BuildAlert createSuccess ( ) { success = new BuildAlert ( ) ; return success ; } public BuildAlert createFail ( ) { fail = new BuildAlert ( ) ; return fail ; } public SoundTask ( ) { } public void init ( ) { } public void execute ( ) { AntSoundPlayer soundPlayer = new AntSoundPlayer ( ) ; if ( success == null ) { log ( "No nested success element found." , Project . MSG_WARN ) ; } else { soundPlayer . addBuildSuccessfulSound ( success . getSource ( ) , success . getLoops ( ) , success . getDuration ( ) ) ; } if ( fail == null ) { log ( "No nested failure element found." , Project . MSG_WARN ) ; } else { soundPlayer . addBuildFailedSound ( fail . getSource ( ) , fail . getLoops ( ) , fail . getDuration ( ) ) ; } getProject ( ) . addBuildListener ( soundPlayer ) ; } public class BuildAlert { private File source = null ; private int loops = 0 ; private Long duration = null ; public void setDuration ( Long duration ) { this . duration = duration ; } public void setSource ( File source ) { this . source = source ; } public void setLoops ( int loops ) { this . loops = loops ; } public File getSource ( ) { File nofile = null ; if ( source . exists ( ) ) { if ( source . isDirectory ( ) ) { String [ ] entries = source . list ( ) ; Vector files = new Vector ( ) ; for ( int i = 0 ; i < entries . length ; i ++ ) { File f = new File ( source , entries [ i ] ) ; if ( f . isFile ( ) ) { files . addElement ( f ) ; } } if ( files . size ( ) < 1 ) { throw new BuildException ( "No files found in directory " + source ) ; } int numfiles = files . size ( ) ; Random rn = new Random ( ) ; int x = rn . nextInt ( numfiles ) ; this . source = ( File ) files . elementAt ( x ) ; } } else { log ( source + ": invalid path." , Project . MSG_WARN ) ; this . source = nofile ; } return this . source ; } public int getLoops ( ) { return this . loops ; } public Long getDuration ( ) { return this . duration ; } } } 	0
package org . apache . tools . ant . taskdefs . optional . javacc ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; public class JJDoc extends Task { private static final String OUTPUT_FILE = "OUTPUT_FILE" ; private static final String TEXT = "TEXT" ; private static final String ONE_TABLE = "ONE_TABLE" ; private final Hashtable optionalAttrs = new Hashtable ( ) ; private String outputFile = null ; private boolean plainText = false ; private static final String DEFAULT_SUFFIX_HTML = ".html" ; private static final String DEFAULT_SUFFIX_TEXT = ".txt" ; private File targetFile = null ; private File javaccHome = null ; private CommandlineJava cmdl = new CommandlineJava ( ) ; public void setText ( boolean plainText ) { optionalAttrs . put ( TEXT , plainText ? Boolean . TRUE : Boolean . FALSE ) ; this . plainText = plainText ; } public void setOnetable ( boolean oneTable ) { optionalAttrs . put ( ONE_TABLE , oneTable ? Boolean . TRUE : Boolean . FALSE ) ; } public void setOutputfile ( String outputFile ) { this . outputFile = outputFile ; } public void setTarget ( File target ) { this . targetFile = target ; } public void setJavacchome ( File javaccHome ) { this . javaccHome = javaccHome ; } public JJDoc ( ) { cmdl . setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; } public void execute ( ) throws BuildException { Enumeration iter = optionalAttrs . keys ( ) ; while ( iter . hasMoreElements ( ) ) { String name = ( String ) iter . nextElement ( ) ; Object value = optionalAttrs . get ( name ) ; cmdl . createArgument ( ) . setValue ( "-" + name + ":" + value . toString ( ) ) ; } if ( targetFile == null || ! targetFile . isFile ( ) ) { throw new BuildException ( "Invalid target: " + targetFile ) ; } if ( outputFile != null ) { cmdl . createArgument ( ) . setValue ( "-" + OUTPUT_FILE + ":" + outputFile . replace ( '\\' , '/' ) ) ; } File javaFile = new File ( createOutputFileName ( targetFile , outputFile , plainText ) ) ; if ( javaFile . exists ( ) && targetFile . lastModified ( ) < javaFile . lastModified ( ) ) { log ( "Target is already built - skipping (" + targetFile + ")" , Project . MSG_VERBOSE ) ; return ; } cmdl . createArgument ( ) . setValue ( targetFile . getAbsolutePath ( ) ) ; final Path classpath = cmdl . createClasspath ( getProject ( ) ) ; final File javaccJar = JavaCC . getArchiveFile ( javaccHome ) ; classpath . createPathElement ( ) . setPath ( javaccJar . getAbsolutePath ( ) ) ; classpath . addJavaRuntime ( ) ; cmdl . setClassname ( JavaCC . getMainClass ( classpath , JavaCC . TASKDEF_TYPE_JJDOC ) ) ; final Commandline . Argument arg = cmdl . createVmArgument ( ) ; arg . setValue ( "-mx140M" ) ; arg . setValue ( "-Dinstall.root=" + javaccHome . getAbsolutePath ( ) ) ; final Execute process = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_INFO ) , null ) ; log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; process . setCommandline ( cmdl . getCommandline ( ) ) ; try { if ( process . execute ( ) != 0 ) { throw new BuildException ( "JJDoc failed." ) ; } } catch ( IOException e ) { throw new BuildException ( "Failed to launch JJDoc" , e ) ; } } private String createOutputFileName ( File destFile , String optionalOutputFile , boolean plain ) { String suffix = DEFAULT_SUFFIX_HTML ; String javaccFile = destFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; if ( plain ) { suffix = DEFAULT_SUFFIX_TEXT ; } if ( ( optionalOutputFile == null ) || optionalOutputFile . equals ( "" ) ) { int filePos = javaccFile . lastIndexOf ( "/" ) ; if ( filePos >= 0 ) { javaccFile = javaccFile . substring ( filePos + 1 ) ; } int suffixPos = javaccFile . lastIndexOf ( '.' ) ; if ( suffixPos == - 1 ) { optionalOutputFile = javaccFile + suffix ; } else { String currentSuffix = javaccFile . substring ( suffixPos ) ; if ( currentSuffix . equals ( suffix ) ) { optionalOutputFile = javaccFile + suffix ; } else { optionalOutputFile = javaccFile . substring ( 0 , suffixPos ) + suffix ; } } } else { optionalOutputFile = optionalOutputFile . replace ( '\\' , '/' ) ; } return ( getProject ( ) . getBaseDir ( ) + "/" + optionalOutputFile ) . replace ( '\\' , '/' ) ; } } 	0
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Iterator ; public interface Cache { boolean isValid ( ) ; void delete ( ) ; void load ( ) ; void save ( ) ; Object get ( Object key ) ; void put ( Object key , Object value ) ; Iterator iterator ( ) ; } 	0
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class TarFileSet extends ArchiveFileSet { private boolean userNameSet ; private boolean groupNameSet ; private boolean userIdSet ; private boolean groupIdSet ; private String userName = "" ; private String groupName = "" ; private int uid ; private int gid ; public TarFileSet ( ) { super ( ) ; } protected TarFileSet ( FileSet fileset ) { super ( fileset ) ; } protected TarFileSet ( TarFileSet fileset ) { super ( fileset ) ; } public void setUserName ( String userName ) { checkTarFileSetAttributesAllowed ( ) ; userNameSet = true ; this . userName = userName ; } public String getUserName ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getUserName ( ) ; } return userName ; } public boolean hasUserNameBeenSet ( ) { return userNameSet ; } public void setUid ( int uid ) { checkTarFileSetAttributesAllowed ( ) ; userIdSet = true ; this . uid = uid ; } public int getUid ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getUid ( ) ; } return uid ; } public boolean hasUserIdBeenSet ( ) { return userIdSet ; } public void setGroup ( String groupName ) { checkTarFileSetAttributesAllowed ( ) ; groupNameSet = true ; this . groupName = groupName ; } public String getGroup ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getGroup ( ) ; } return groupName ; } public boolean hasGroupBeenSet ( ) { return groupNameSet ; } public void setGid ( int gid ) { checkTarFileSetAttributesAllowed ( ) ; groupIdSet = true ; this . gid = gid ; } public int getGid ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getGid ( ) ; } return gid ; } public boolean hasGroupIdBeenSet ( ) { return groupIdSet ; } protected ArchiveScanner newArchiveScanner ( ) { TarScanner zs = new TarScanner ( ) ; return zs ; } public void setRefid ( Reference r ) throws BuildException { if ( userNameSet || userIdSet || groupNameSet || groupIdSet ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } protected AbstractFileSet getRef ( Project p ) { dieOnCircularReference ( p ) ; Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( o instanceof TarFileSet ) { return ( AbstractFileSet ) o ; } else if ( o instanceof FileSet ) { TarFileSet zfs = new TarFileSet ( ( FileSet ) o ) ; configureFileSet ( zfs ) ; return zfs ; } else { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a tarfileset or a fileset" ; throw new BuildException ( msg ) ; } } protected void configureFileSet ( ArchiveFileSet zfs ) { super . configureFileSet ( zfs ) ; if ( zfs instanceof TarFileSet ) { TarFileSet tfs = ( TarFileSet ) zfs ; tfs . setUserName ( userName ) ; tfs . setGroup ( groupName ) ; tfs . setUid ( uid ) ; tfs . setGid ( gid ) ; } } public Object clone ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } private void checkTarFileSetAttributesAllowed ( ) { if ( getProject ( ) == null || ( isReference ( ) && ( getRefid ( ) . getReferencedObject ( getProject ( ) ) instanceof TarFileSet ) ) ) { checkAttributesAllowed ( ) ; } } } 	0
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import javax . xml . parsers . SAXParser ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Path ; public class JonasDeploymentTool extends GenericDeploymentTool { protected static final String EJB_JAR_1_1_PUBLIC_ID = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN" ; protected static final String EJB_JAR_2_0_PUBLIC_ID = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN" ; protected static final String JONAS_EJB_JAR_2_4_PUBLIC_ID = "-//ObjectWeb//DTD JOnAS 2.4//EN" ; protected static final String JONAS_EJB_JAR_2_5_PUBLIC_ID = "-//ObjectWeb//DTD JOnAS 2.5//EN" ; protected static final String RMI_ORB = "RMI" ; protected static final String JEREMIE_ORB = "JEREMIE" ; protected static final String DAVID_ORB = "DAVID" ; protected static final String EJB_JAR_1_1_DTD = "ejb-jar_1_1.dtd" ; protected static final String EJB_JAR_2_0_DTD = "ejb-jar_2_0.dtd" ; protected static final String JONAS_EJB_JAR_2_4_DTD = "jonas-ejb-jar_2_4.dtd" ; protected static final String JONAS_EJB_JAR_2_5_DTD = "jonas-ejb-jar_2_5.dtd" ; protected static final String JONAS_DD = "jonas-ejb-jar.xml" ; protected static final String GENIC_CLASS = "org.objectweb.jonas_ejb.genic.GenIC" ; protected static final String OLD_GENIC_CLASS_1 = "org.objectweb.jonas_ejb.tools.GenWholeIC" ; protected static final String OLD_GENIC_CLASS_2 = "org.objectweb.jonas_ejb.tools.GenIC" ; private String descriptorName ; private String jonasDescriptorName ; private File outputdir ; private boolean keepgenerated = false ; private boolean nocompil = false ; private boolean novalidation = false ; private String javac ; private String javacopts ; private String rmicopts ; private boolean secpropag = false ; private boolean verbose = false ; private String additionalargs ; private File jonasroot ; private boolean keepgeneric = false ; private String suffix = ".jar" ; private String orb ; private boolean nogenic = false ; public void setKeepgenerated ( boolean aBoolean ) { keepgenerated = aBoolean ; } public void setAdditionalargs ( String aString ) { additionalargs = aString ; } public void setNocompil ( boolean aBoolean ) { nocompil = aBoolean ; } public void setNovalidation ( boolean aBoolean ) { novalidation = aBoolean ; } public void setJavac ( String aString ) { javac = aString ; } public void setJavacopts ( String aString ) { javacopts = aString ; } public void setRmicopts ( String aString ) { rmicopts = aString ; } public void setSecpropag ( boolean aBoolean ) { secpropag = aBoolean ; } public void setVerbose ( boolean aBoolean ) { verbose = aBoolean ; } public void setJonasroot ( File aFile ) { jonasroot = aFile ; } public void setKeepgeneric ( boolean aBoolean ) { keepgeneric = aBoolean ; } public void setJarsuffix ( String aString ) { suffix = aString ; } public void setOrb ( String aString ) { orb = aString ; } public void setNogenic ( boolean aBoolean ) { nogenic = aBoolean ; } public void processDescriptor ( String aDescriptorName , SAXParser saxParser ) { descriptorName = aDescriptorName ; log ( "JOnAS Deployment Tool processing: " + descriptorName , Project . MSG_VERBOSE ) ; super . processDescriptor ( descriptorName , saxParser ) ; if ( outputdir != null ) { log ( "Deleting temp output directory '" + outputdir + "'." , Project . MSG_VERBOSE ) ; deleteAllFiles ( outputdir ) ; } } protected void writeJar ( String baseName , File jarfile , Hashtable ejbFiles , String publicId ) throws BuildException { File genericJarFile = super . getVendorOutputJarFile ( baseName ) ; super . writeJar ( baseName , genericJarFile , ejbFiles , publicId ) ; addGenICGeneratedFiles ( genericJarFile , ejbFiles ) ; super . writeJar ( baseName , getVendorOutputJarFile ( baseName ) , ejbFiles , publicId ) ; if ( ! keepgeneric ) { log ( "Deleting generic JAR " + genericJarFile . toString ( ) , Project . MSG_VERBOSE ) ; genericJarFile . delete ( ) ; } } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { jonasDescriptorName = getJonasDescriptorName ( ) ; File jonasDD = new File ( getConfig ( ) . descriptorDir , jonasDescriptorName ) ; if ( jonasDD . exists ( ) ) { ejbFiles . put ( META_DIR + JONAS_DD , jonasDD ) ; } else { log ( "Unable to locate the JOnAS deployment descriptor. It was expected to be in: " + jonasDD . getPath ( ) + "." , Project . MSG_WARN ) ; } } protected File getVendorOutputJarFile ( String baseName ) { return new File ( getDestDir ( ) , baseName + suffix ) ; } private String getJonasDescriptorName ( ) { String jonasDN ; boolean jonasConvention = false ; String path ; String fileName ; String baseName ; String remainder ; int startOfFileName = descriptorName . lastIndexOf ( File . separatorChar ) ; if ( startOfFileName != - 1 ) { path = descriptorName . substring ( 0 , startOfFileName + 1 ) ; fileName = descriptorName . substring ( startOfFileName + 1 ) ; } else { path = "" ; fileName = descriptorName ; } if ( fileName . startsWith ( EJB_DD ) ) { return path + JONAS_DD ; } int endOfBaseName = descriptorName . indexOf ( getConfig ( ) . baseNameTerminator , startOfFileName ) ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . lastIndexOf ( '.' ) - 1 ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . length ( ) - 1 ; } jonasConvention = true ; } baseName = descriptorName . substring ( startOfFileName + 1 , endOfBaseName + 1 ) ; remainder = descriptorName . substring ( endOfBaseName + 1 ) ; if ( jonasConvention ) { jonasDN = path + "jonas-" + baseName + ".xml" ; } else { jonasDN = path + baseName + "jonas-" + remainder ; } log ( "Standard EJB descriptor name: " + descriptorName , Project . MSG_VERBOSE ) ; log ( "JOnAS-specific descriptor name: " + jonasDN , Project . MSG_VERBOSE ) ; return jonasDN ; } protected String getJarBaseName ( String descriptorFileName ) { String baseName = null ; if ( getConfig ( ) . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DESCRIPTOR ) ) { if ( descriptorFileName . indexOf ( getConfig ( ) . baseNameTerminator ) == - 1 ) { String aCanonicalDescriptor = descriptorFileName . replace ( '\\' , '/' ) ; int lastSeparatorIndex = aCanonicalDescriptor . lastIndexOf ( '/' ) ; int endOfBaseName ; if ( lastSeparatorIndex != - 1 ) { endOfBaseName = descriptorFileName . indexOf ( ".xml" , lastSeparatorIndex ) ; } else { endOfBaseName = descriptorFileName . indexOf ( ".xml" ) ; } if ( endOfBaseName != - 1 ) { baseName = descriptorFileName . substring ( 0 , endOfBaseName ) ; } } } if ( baseName == null ) { baseName = super . getJarBaseName ( descriptorFileName ) ; } log ( "JAR base name: " + baseName , Project . MSG_VERBOSE ) ; return baseName ; } protected void registerKnownDTDs ( DescriptorHandler handler ) { handler . registerDTD ( EJB_JAR_1_1_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + EJB_JAR_1_1_DTD ) ; handler . registerDTD ( EJB_JAR_2_0_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + EJB_JAR_2_0_DTD ) ; handler . registerDTD ( JONAS_EJB_JAR_2_4_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + JONAS_EJB_JAR_2_4_DTD ) ; handler . registerDTD ( JONAS_EJB_JAR_2_5_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + JONAS_EJB_JAR_2_5_DTD ) ; } private void addGenICGeneratedFiles ( File genericJarFile , Hashtable ejbFiles ) { Java genicTask = null ; String genicClass = null ; if ( nogenic ) { return ; } genicTask = new Java ( getTask ( ) ) ; genicTask . setTaskName ( "genic" ) ; genicTask . setFork ( true ) ; genicTask . createJvmarg ( ) . setValue ( "-Dinstall.root=" + jonasroot ) ; String jonasConfigDir = jonasroot + File . separator + "config" ; File javaPolicyFile = new File ( jonasConfigDir , "java.policy" ) ; if ( javaPolicyFile . exists ( ) ) { genicTask . createJvmarg ( ) . setValue ( "-Djava.security.policy=" + javaPolicyFile . toString ( ) ) ; } try { outputdir = createTempDir ( ) ; } catch ( IOException aIOException ) { String msg = "Cannot create temp dir: " + aIOException . getMessage ( ) ; throw new BuildException ( msg , aIOException ) ; } log ( "Using temporary output directory: " + outputdir , Project . MSG_VERBOSE ) ; genicTask . createArg ( ) . setValue ( "-d" ) ; genicTask . createArg ( ) . setFile ( outputdir ) ; String key ; File f ; Enumeration keys = ejbFiles . keys ( ) ; while ( keys . hasMoreElements ( ) ) { key = ( String ) keys . nextElement ( ) ; f = new File ( outputdir + File . separator + key ) ; f . getParentFile ( ) . mkdirs ( ) ; } log ( "Worked around a bug of GenIC 2.5." , Project . MSG_VERBOSE ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath == null ) { classpath = new Path ( getTask ( ) . getProject ( ) ) ; } classpath . append ( new Path ( classpath . getProject ( ) , jonasConfigDir ) ) ; classpath . append ( new Path ( classpath . getProject ( ) , outputdir . toString ( ) ) ) ; if ( orb != null ) { String orbJar = jonasroot + File . separator + "lib" + File . separator + orb + "_jonas.jar" ; classpath . append ( new Path ( classpath . getProject ( ) , orbJar ) ) ; } log ( "Using classpath: " + classpath . toString ( ) , Project . MSG_VERBOSE ) ; genicTask . setClasspath ( classpath ) ; genicClass = getGenicClassName ( classpath ) ; if ( genicClass == null ) { log ( "Cannot find GenIC class in classpath." , Project . MSG_ERR ) ; throw new BuildException ( "GenIC class not found, please check the classpath." ) ; } else { log ( "Using '" + genicClass + "' GenIC class." , Project . MSG_VERBOSE ) ; genicTask . setClassname ( genicClass ) ; } if ( keepgenerated ) { genicTask . createArg ( ) . setValue ( "-keepgenerated" ) ; } if ( nocompil ) { genicTask . createArg ( ) . setValue ( "-nocompil" ) ; } if ( novalidation ) { genicTask . createArg ( ) . setValue ( "-novalidation" ) ; } if ( javac != null ) { genicTask . createArg ( ) . setValue ( "-javac" ) ; genicTask . createArg ( ) . setLine ( javac ) ; } if ( javacopts != null && ! javacopts . equals ( "" ) ) { genicTask . createArg ( ) . setValue ( "-javacopts" ) ; genicTask . createArg ( ) . setLine ( javacopts ) ; } if ( rmicopts != null && ! rmicopts . equals ( "" ) ) { genicTask . createArg ( ) . setValue ( "-rmicopts" ) ; genicTask . createArg ( ) . setLine ( rmicopts ) ; } if ( secpropag ) { genicTask . createArg ( ) . setValue ( "-secpropag" ) ; } if ( verbose ) { genicTask . createArg ( ) . setValue ( "-verbose" ) ; } if ( additionalargs != null ) { genicTask . createArg ( ) . setValue ( additionalargs ) ; } genicTask . createArg ( ) . setValue ( "-noaddinjar" ) ; genicTask . createArg ( ) . setValue ( genericJarFile . getPath ( ) ) ; log ( "Calling " + genicClass + " for " + getConfig ( ) . descriptorDir + File . separator + descriptorName + "." , Project . MSG_VERBOSE ) ; if ( genicTask . executeJava ( ) != 0 ) { log ( "Deleting temp output directory '" + outputdir + "'." , Project . MSG_VERBOSE ) ; deleteAllFiles ( outputdir ) ; if ( ! keepgeneric ) { log ( "Deleting generic JAR " + genericJarFile . toString ( ) , Project . MSG_VERBOSE ) ; genericJarFile . delete ( ) ; } throw new BuildException ( "GenIC reported an error." ) ; } addAllFiles ( outputdir , "" , ejbFiles ) ; } String getGenicClassName ( Path classpath ) { log ( "Looking for GenIC class in classpath: " + classpath . toString ( ) , Project . MSG_VERBOSE ) ; AntClassLoader cl = classpath . getProject ( ) . createClassLoader ( classpath ) ; try { cl . loadClass ( JonasDeploymentTool . GENIC_CLASS ) ; log ( "Found GenIC class '" + JonasDeploymentTool . GENIC_CLASS + "' in classpath." , Project . MSG_VERBOSE ) ; return JonasDeploymentTool . GENIC_CLASS ; } catch ( ClassNotFoundException cnf1 ) { log ( "GenIC class '" + JonasDeploymentTool . GENIC_CLASS + "' not found in classpath." , Project . MSG_VERBOSE ) ; } try { cl . loadClass ( JonasDeploymentTool . OLD_GENIC_CLASS_1 ) ; log ( "Found GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_1 + "' in classpath." , Project . MSG_VERBOSE ) ; return JonasDeploymentTool . OLD_GENIC_CLASS_1 ; } catch ( ClassNotFoundException cnf2 ) { log ( "GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_1 + "' not found in classpath." , Project . MSG_VERBOSE ) ; } try { cl . loadClass ( JonasDeploymentTool . OLD_GENIC_CLASS_2 ) ; log ( "Found GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_2 + "' in classpath." , Project . MSG_VERBOSE ) ; return JonasDeploymentTool . OLD_GENIC_CLASS_2 ; } catch ( ClassNotFoundException cnf3 ) { log ( "GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_2 + "' not found in classpath." , Project . MSG_VERBOSE ) ; } return null ; } protected void checkConfiguration ( String descriptorFileName , SAXParser saxParser ) throws BuildException { if ( jonasroot == null ) { throw new BuildException ( "The jonasroot attribut is not set." ) ; } else if ( ! jonasroot . isDirectory ( ) ) { throw new BuildException ( "The jonasroot attribut '" + jonasroot + "' is not a valid directory." ) ; } if ( orb != null && ! orb . equals ( RMI_ORB ) && ! orb . equals ( JEREMIE_ORB ) && ! orb . equals ( DAVID_ORB ) ) { throw new BuildException ( "The orb attribut '" + orb + "' is not valid (must be either " + RMI_ORB + ", " + JEREMIE_ORB + " or " + DAVID_ORB + ")." ) ; } if ( additionalargs != null && additionalargs . equals ( "" ) ) { throw new BuildException ( "Empty additionalargs attribut." ) ; } if ( javac != null && javac . equals ( "" ) ) { throw new BuildException ( "Empty javac attribut." ) ; } } private File createTempDir ( ) throws IOException { File tmpDir = File . createTempFile ( "genic" , null , null ) ; tmpDir . delete ( ) ; if ( ! tmpDir . mkdir ( ) ) { throw new IOException ( "Cannot create the temporary directory '" + tmpDir + "'." ) ; } return tmpDir ; } private void deleteAllFiles ( File aFile ) { if ( aFile . isDirectory ( ) ) { File [ ] someFiles = aFile . listFiles ( ) ; for ( int i = 0 ; i < someFiles . length ; i ++ ) { deleteAllFiles ( someFiles [ i ] ) ; } } aFile . delete ( ) ; } private void addAllFiles ( File file , String rootDir , Hashtable hashtable ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( ) ; } String newRootDir ; if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( rootDir . length ( ) > 0 ) { newRootDir = rootDir + File . separator + files [ i ] . getName ( ) ; } else { newRootDir = files [ i ] . getName ( ) ; } addAllFiles ( files [ i ] , newRootDir , hashtable ) ; } } else { hashtable . put ( rootDir , file ) ; } } } 	0
package org . apache . tools . tar ; public interface TarConstants { int NAMELEN = 100 ; int MODELEN = 8 ; int UIDLEN = 8 ; int GIDLEN = 8 ; int CHKSUMLEN = 8 ; int SIZELEN = 12 ; long MAXSIZE = 077777777777L ; int MAGICLEN = 8 ; int MODTIMELEN = 12 ; int UNAMELEN = 32 ; int GNAMELEN = 32 ; int DEVLEN = 8 ; byte LF_OLDNORM = 0 ; byte LF_NORMAL = ( byte ) '0' ; byte LF_LINK = ( byte ) '1' ; byte LF_SYMLINK = ( byte ) '2' ; byte LF_CHR = ( byte ) '3' ; byte LF_BLK = ( byte ) '4' ; byte LF_DIR = ( byte ) '5' ; byte LF_FIFO = ( byte ) '6' ; byte LF_CONTIG = ( byte ) '7' ; String TMAGIC = "ustar" ; String GNU_TMAGIC = "ustar  " ; String GNU_LONGLINK = "././@LongLink" ; byte LF_GNUTYPE_LONGNAME = ( byte ) 'L' ; } 	0
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class Sj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using symantec java compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "sj" : exec ) ; int firstFileName = cmd . size ( ) - compileList . length ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } protected String getNoDebugArgument ( ) { return null ; } } 	0
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Delete extends P4Base { public String change = null ; public void setChange ( String change ) { this . change = change ; } public void execute ( ) throws BuildException { if ( change != null ) { P4CmdOpts = "-c " + change ; } if ( P4View == null ) { throw new BuildException ( "No view specified to delete" ) ; } execP4Command ( "-s delete " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import java . util . List ; import java . util . ArrayList ; import java . util . Comparator ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import java . util . Collections ; import java . util . Iterator ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . util . CollectionUtils ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class EchoProperties extends Task { private static final String PROPERTIES = "properties" ; private static final String PROPERTY = "property" ; private static final String ATTR_NAME = "name" ; private static final String ATTR_VALUE = "value" ; private File inFile = null ; private File destfile = null ; private boolean failonerror = true ; private Vector propertySets = new Vector ( ) ; private String format = "text" ; private String prefix ; private String regex ; public void setSrcfile ( File file ) { inFile = file ; } public void setDestfile ( File destfile ) { this . destfile = destfile ; } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void setPrefix ( String prefix ) { if ( prefix != null && prefix . length ( ) != 0 ) { this . prefix = prefix ; PropertySet ps = new PropertySet ( ) ; ps . setProject ( getProject ( ) ) ; ps . appendPrefix ( prefix ) ; addPropertyset ( ps ) ; } } public void setRegex ( String regex ) { if ( regex != null && regex . length ( ) != 0 ) { this . regex = regex ; PropertySet ps = new PropertySet ( ) ; ps . setProject ( getProject ( ) ) ; ps . appendRegex ( regex ) ; addPropertyset ( ps ) ; } } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void setFormat ( FormatAttribute ea ) { format = ea . getValue ( ) ; } public static class FormatAttribute extends EnumeratedAttribute { private String [ ] formats = new String [ ] { "xml" , "text" } ; public String [ ] getValues ( ) { return formats ; } } public void execute ( ) throws BuildException { if ( prefix != null && regex != null ) { throw new BuildException ( "Please specify either prefix" + " or regex, but not both" , getLocation ( ) ) ; } Hashtable allProps = new Hashtable ( ) ; if ( inFile == null && propertySets . size ( ) == 0 ) { allProps . putAll ( getProject ( ) . getProperties ( ) ) ; } else if ( inFile != null ) { if ( inFile . exists ( ) && inFile . isDirectory ( ) ) { String message = "srcfile is a directory!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } if ( inFile . exists ( ) && ! inFile . canRead ( ) ) { String message = "Can not read from the specified srcfile!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } FileInputStream in = null ; try { in = new FileInputStream ( inFile ) ; Properties props = new Properties ( ) ; props . load ( in ) ; allProps . putAll ( props ) ; } catch ( FileNotFoundException fnfe ) { String message = "Could not find file " + inFile . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message , fnfe , getLocation ( ) ) ; } else { log ( message , Project . MSG_WARN ) ; } return ; } catch ( IOException ioe ) { String message = "Could not read file " + inFile . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message , ioe , getLocation ( ) ) ; } else { log ( message , Project . MSG_WARN ) ; } return ; } finally { FileUtils . close ( in ) ; } } Enumeration e = propertySets . elements ( ) ; while ( e . hasMoreElements ( ) ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; allProps . putAll ( ps . getProperties ( ) ) ; } OutputStream os = null ; try { if ( destfile == null ) { os = new ByteArrayOutputStream ( ) ; saveProperties ( allProps , os ) ; log ( os . toString ( ) , Project . MSG_INFO ) ; } else { if ( destfile . exists ( ) && destfile . isDirectory ( ) ) { String message = "destfile is a directory!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } if ( destfile . exists ( ) && ! destfile . canWrite ( ) ) { String message = "Can not write to the specified destfile!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } os = new FileOutputStream ( this . destfile ) ; saveProperties ( allProps , os ) ; } } catch ( IOException ioe ) { if ( failonerror ) { throw new BuildException ( ioe , getLocation ( ) ) ; } else { log ( ioe . getMessage ( ) , Project . MSG_INFO ) ; } } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException ex ) { } } } } protected void saveProperties ( Hashtable allProps , OutputStream os ) throws IOException , BuildException { final List keyList = new ArrayList ( allProps . keySet ( ) ) ; Collections . sort ( keyList ) ; Properties props = new Properties ( ) { public Enumeration keys ( ) { return CollectionUtils . asEnumeration ( keyList . iterator ( ) ) ; } public Set entrySet ( ) { Set result = super . entrySet ( ) ; if ( JavaEnvUtils . isKaffe ( ) ) { TreeSet t = new TreeSet ( new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { String key1 = ( String ) ( ( Map . Entry ) o1 ) . getKey ( ) ; String key2 = ( String ) ( ( Map . Entry ) o2 ) . getKey ( ) ; return key1 . compareTo ( key2 ) ; } } ) ; t . addAll ( result ) ; result = t ; } return result ; } } ; for ( int i = 0 ; i < keyList . size ( ) ; i ++ ) { String name = keyList . get ( i ) . toString ( ) ; String value = allProps . get ( name ) . toString ( ) ; props . setProperty ( name , value ) ; } if ( "text" . equals ( format ) ) { jdkSaveProperties ( props , os , "Ant properties" ) ; } else if ( "xml" . equals ( format ) ) { xmlSaveProperties ( props , os ) ; } } private static class Tuple implements Comparable { private String key ; private String value ; private Tuple ( String key , String value ) { this . key = key ; this . value = value ; } public int compareTo ( Object o ) { Tuple that = ( Tuple ) o ; return key . compareTo ( that . key ) ; } } private List sortProperties ( Properties props ) { List sorted = new ArrayList ( props . size ( ) ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; sorted . add ( new Tuple ( name , props . getProperty ( name ) ) ) ; } Collections . sort ( sorted ) ; return sorted ; } protected void xmlSaveProperties ( Properties props , OutputStream os ) throws IOException { Document doc = getDocumentBuilder ( ) . newDocument ( ) ; Element rootElement = doc . createElement ( PROPERTIES ) ; List sorted = sortProperties ( props ) ; Iterator iten = sorted . iterator ( ) ; while ( iten . hasNext ( ) ) { Tuple tuple = ( Tuple ) iten . next ( ) ; Element propElement = doc . createElement ( PROPERTY ) ; propElement . setAttribute ( ATTR_NAME , tuple . key ) ; propElement . setAttribute ( ATTR_VALUE , tuple . value ) ; rootElement . appendChild ( propElement ) ; } Writer wri = null ; try { wri = new OutputStreamWriter ( os , "UTF8" ) ; wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; ( new DOMElementWriter ( ) ) . write ( rootElement , wri , 0 , "\t" ) ; wri . flush ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Unable to write XML file" , ioe ) ; } finally { FileUtils . close ( wri ) ; } } protected void jdkSaveProperties ( Properties props , OutputStream os , String header ) throws IOException { try { props . store ( os , header ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , getLocation ( ) ) ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException ioex ) { log ( "Failed to close output stream" ) ; } } } } private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception e ) { throw new ExceptionInInitializerError ( e ) ; } } } 	0
package org . apache . tools . ant . taskdefs . condition ; import java . net . HttpURLConnection ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public class Http extends ProjectComponent implements Condition { private static final int ERROR_BEGINS = 400 ; private String spec = null ; public void setUrl ( String url ) { spec = url ; } private int errorsBeginAt = ERROR_BEGINS ; public void setErrorsBeginAt ( int errorsBeginAt ) { this . errorsBeginAt = errorsBeginAt ; } public boolean eval ( ) throws BuildException { if ( spec == null ) { throw new BuildException ( "No url specified in http condition" ) ; } log ( "Checking for " + spec , Project . MSG_VERBOSE ) ; try { URL url = new URL ( spec ) ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpURLConnection ) { HttpURLConnection http = ( HttpURLConnection ) conn ; int code = http . getResponseCode ( ) ; log ( "Result code for " + spec + " was " + code , Project . MSG_VERBOSE ) ; if ( code > 0 && code < errorsBeginAt ) { return true ; } return false ; } } catch ( java . io . IOException e ) { return false ; } } catch ( MalformedURLException e ) { throw new BuildException ( "Badly formed URL: " + spec , e ) ; } return true ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; public class Rename extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File src ; private File dest ; private boolean replace = true ; public void setSrc ( File src ) { this . src = src ; } public void setDest ( File dest ) { this . dest = dest ; } public void setReplace ( String replace ) { this . replace = Project . toBoolean ( replace ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The rename task is deprecated.  Use move instead." ) ; if ( dest == null ) { throw new BuildException ( "dest attribute is required" , getLocation ( ) ) ; } if ( src == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( ! replace && dest . exists ( ) ) { throw new BuildException ( dest + " already exists." ) ; } try { FILE_UTILS . rename ( src , dest ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to rename " + src + " to " + dest , e , getLocation ( ) ) ; } } } 	0
package org . apache . tools . ant . taskdefs . optional . depend ; public interface ClassFileIterator { ClassFile getNextClassFile ( ) ; } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Random ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public class Jikes { protected JikesOutputParser jop ; protected String command ; protected Project project ; protected Jikes ( JikesOutputParser jop , String command , Project project ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Jikes class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . jop = jop ; this . command = command ; this . project = project ; } protected void compile ( String [ ] args ) { String [ ] commandArray = null ; File tmpFile = null ; try { String myos = System . getProperty ( "os.name" ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 && args . length > 250 ) { PrintWriter out = null ; try { String tempFileName = "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ; tmpFile = new File ( tempFileName ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = 0 ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ ] { command , "@" + tmpFile . getAbsolutePath ( ) } ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e ) ; } finally { FileUtils . close ( out ) ; } } else { commandArray = new String [ args . length + 1 ] ; commandArray [ 0 ] = command ; System . arraycopy ( args , 0 , commandArray , 1 , args . length ) ; } try { Execute exe = new Execute ( jop ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running Jikes compiler" , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } } 	0
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public abstract class ConstantPoolEntry { public static final int CONSTANT_UTF8 = 1 ; public static final int CONSTANT_INTEGER = 3 ; public static final int CONSTANT_FLOAT = 4 ; public static final int CONSTANT_LONG = 5 ; public static final int CONSTANT_DOUBLE = 6 ; public static final int CONSTANT_CLASS = 7 ; public static final int CONSTANT_STRING = 8 ; public static final int CONSTANT_FIELDREF = 9 ; public static final int CONSTANT_METHODREF = 10 ; public static final int CONSTANT_INTERFACEMETHODREF = 11 ; public static final int CONSTANT_NAMEANDTYPE = 12 ; private int tag ; private int numEntries ; private boolean resolved ; public ConstantPoolEntry ( int tagValue , int entries ) { tag = tagValue ; numEntries = entries ; resolved = false ; } public static ConstantPoolEntry readEntry ( DataInputStream cpStream ) throws IOException { ConstantPoolEntry cpInfo = null ; int cpTag = cpStream . readUnsignedByte ( ) ; switch ( cpTag ) { case CONSTANT_UTF8 : cpInfo = new Utf8CPInfo ( ) ; break ; case CONSTANT_INTEGER : cpInfo = new IntegerCPInfo ( ) ; break ; case CONSTANT_FLOAT : cpInfo = new FloatCPInfo ( ) ; break ; case CONSTANT_LONG : cpInfo = new LongCPInfo ( ) ; break ; case CONSTANT_DOUBLE : cpInfo = new DoubleCPInfo ( ) ; break ; case CONSTANT_CLASS : cpInfo = new ClassCPInfo ( ) ; break ; case CONSTANT_STRING : cpInfo = new StringCPInfo ( ) ; break ; case CONSTANT_FIELDREF : cpInfo = new FieldRefCPInfo ( ) ; break ; case CONSTANT_METHODREF : cpInfo = new MethodRefCPInfo ( ) ; break ; case CONSTANT_INTERFACEMETHODREF : cpInfo = new InterfaceMethodRefCPInfo ( ) ; break ; case CONSTANT_NAMEANDTYPE : cpInfo = new NameAndTypeCPInfo ( ) ; break ; default : throw new ClassFormatError ( "Invalid Constant Pool entry Type " + cpTag ) ; } cpInfo . read ( cpStream ) ; return cpInfo ; } public boolean isResolved ( ) { return resolved ; } public void resolve ( ConstantPool constantPool ) { resolved = true ; } public abstract void read ( DataInputStream cpStream ) throws IOException ; public int getTag ( ) { return tag ; } public final int getNumEntries ( ) { return numEntries ; } } 	0
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . OutputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; public class P4OutputStream extends OutputStream { private P4Handler handler ; private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; private boolean skip = false ; public P4OutputStream ( P4Handler handler ) { this . handler = handler ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) { processBuffer ( ) ; } } else { buffer . write ( cc ) ; } skip = ( c == '\r' ) ; } protected void processBuffer ( ) { handler . process ( buffer . toString ( ) ) ; buffer . reset ( ) ; } public void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) { processBuffer ( ) ; } super . close ( ) ; } } 	0
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . regexp . Regexp ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; public class Matches extends ProjectComponent implements Condition { private String string ; private boolean caseSensitive = true ; private boolean multiLine = false ; private boolean singleLine = false ; private RegularExpression regularExpression ; public void setString ( String string ) { this . string = string ; } public void setPattern ( String pattern ) { if ( regularExpression != null ) { throw new BuildException ( "Only one regular expression is allowed." ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( pattern ) ; } public void addRegexp ( RegularExpression regularExpression ) { if ( this . regularExpression != null ) { throw new BuildException ( "Only one regular expression is allowed." ) ; } this . regularExpression = regularExpression ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public void setMultiline ( boolean b ) { multiLine = b ; } public void setSingleLine ( boolean b ) { singleLine = b ; } public boolean eval ( ) throws BuildException { if ( string == null ) { throw new BuildException ( "Parameter string is required in matches." ) ; } if ( regularExpression == null ) { throw new BuildException ( "Missing pattern in matches." ) ; } int options = RegexpMatcher . MATCH_DEFAULT ; if ( ! caseSensitive ) { options = options | RegexpMatcher . MATCH_CASE_INSENSITIVE ; } if ( multiLine ) { options = options | RegexpMatcher . MATCH_MULTILINE ; } if ( singleLine ) { options = options | RegexpMatcher . MATCH_SINGLELINE ; } Regexp regexp = regularExpression . getRegexp ( getProject ( ) ) ; return regexp . matches ( string , options ) ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Exec extends Task { private String os ; private String out ; private File dir ; private String command ; protected PrintWriter fos = null ; private boolean failOnError = false ; public Exec ( ) { System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Exec class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; } public void execute ( ) throws BuildException { run ( command ) ; } protected int run ( String command ) throws BuildException { int err = - 1 ; String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return 0 ; } if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 ) { if ( ! dir . equals ( getProject ( ) . resolveFile ( "." ) ) ) { if ( myos . toLowerCase ( ) . indexOf ( "nt" ) >= 0 ) { command = "cmd /c cd " + dir + " && " + command ; } else { String ant = getProject ( ) . getProperty ( MagicNames . ANT_HOME ) ; if ( ant == null ) { throw new BuildException ( "Property '" + MagicNames . ANT_HOME + "' not " + "found" , getLocation ( ) ) ; } String antRun = getProject ( ) . resolveFile ( ant + "/bin/antRun.bat" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } } } else { String ant = getProject ( ) . getProperty ( MagicNames . ANT_HOME ) ; if ( ant == null ) { throw new BuildException ( "Property '" + MagicNames . ANT_HOME + "' not found" , getLocation ( ) ) ; } String antRun = getProject ( ) . resolveFile ( ant + "/bin/antRun" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } try { log ( command , Project . MSG_VERBOSE ) ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; if ( out != null ) { fos = new PrintWriter ( new FileWriter ( out ) ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } StreamPumper inputPumper = new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO ) ; StreamPumper errorPumper = new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN ) ; inputPumper . start ( ) ; errorPumper . start ( ) ; proc . waitFor ( ) ; inputPumper . join ( ) ; errorPumper . join ( ) ; proc . destroy ( ) ; logFlush ( ) ; err = proc . exitValue ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , getLocation ( ) ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error exec: " + command , ioe , getLocation ( ) ) ; } catch ( InterruptedException ex ) { } return err ; } public void setDir ( String d ) { this . dir = getProject ( ) . resolveFile ( d ) ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( String command ) { this . command = command ; } public void setOutput ( String out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } protected void outputLog ( String line , int messageLevel ) { if ( fos == null ) { log ( line , messageLevel ) ; } else { fos . println ( line ) ; } } protected void logFlush ( ) { if ( fos != null ) { fos . close ( ) ; } } class StreamPumper extends Thread { private BufferedReader din ; private int messageLevel ; private boolean endOfStream = false ; private static final int SLEEP_TIME = 5 ; public StreamPumper ( InputStream is , int messageLevel ) { this . din = new BufferedReader ( new InputStreamReader ( is ) ) ; this . messageLevel = messageLevel ; } public void pumpStream ( ) throws IOException { if ( ! endOfStream ) { String line = din . readLine ( ) ; if ( line != null ) { outputLog ( line , messageLevel ) ; } else { endOfStream = true ; } } } public void run ( ) { try { try { while ( ! endOfStream ) { pumpStream ( ) ; sleep ( SLEEP_TIME ) ; } } catch ( InterruptedException ie ) { } din . close ( ) ; } catch ( IOException ioe ) { } } } } 	0
package org . apache . tools . ant . taskdefs . optional . jsp . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . optional . jsp . JspC ; import org . apache . tools . ant . taskdefs . optional . jsp . JspMangler ; public interface JspCompilerAdapter { void setJspc ( JspC attributes ) ; boolean execute ( ) throws BuildException ; JspMangler createMangler ( ) ; boolean implementsOwnDependencyChecking ( ) ; } 	0
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public final class TaskLogger { private Task task ; public TaskLogger ( final Task task ) { this . task = task ; } public void info ( final String message ) { task . log ( message , Project . MSG_INFO ) ; } public void error ( final String message ) { task . log ( message , Project . MSG_ERR ) ; } public void warning ( final String message ) { task . log ( message , Project . MSG_WARN ) ; } public void verbose ( final String message ) { task . log ( message , Project . MSG_VERBOSE ) ; } public void debug ( final String message ) { task . log ( message , Project . MSG_DEBUG ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . text . NumberFormat ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class BriefJUnitResultFormatter implements JUnitResultFormatter { private OutputStream out ; private PrintWriter output ; private StringWriter results ; private PrintWriter resultWriter ; private NumberFormat numberFormat = NumberFormat . getInstance ( ) ; private String systemOutput = null ; private String systemError = null ; public BriefJUnitResultFormatter ( ) { results = new StringWriter ( ) ; resultWriter = new PrintWriter ( results ) ; } public void setOutput ( OutputStream out ) { this . out = out ; output = new PrintWriter ( out ) ; } public void setSystemOutput ( String out ) { systemOutput = out ; } public void setSystemError ( String err ) { systemError = err ; } public void startTestSuite ( JUnitTest suite ) { if ( output == null ) { return ; } StringBuffer sb = new StringBuffer ( "Testsuite: " ) ; sb . append ( suite . getName ( ) ) ; sb . append ( StringUtils . LINE_SEP ) ; output . write ( sb . toString ( ) ) ; output . flush ( ) ; } public void endTestSuite ( JUnitTest suite ) { StringBuffer sb = new StringBuffer ( "Tests run: " ) ; sb . append ( suite . runCount ( ) ) ; sb . append ( ", Failures: " ) ; sb . append ( suite . failureCount ( ) ) ; sb . append ( ", Errors: " ) ; sb . append ( suite . errorCount ( ) ) ; sb . append ( ", Time elapsed: " ) ; sb . append ( numberFormat . format ( suite . getRunTime ( ) / 1000.0 ) ) ; sb . append ( " sec" ) ; sb . append ( StringUtils . LINE_SEP ) ; sb . append ( StringUtils . LINE_SEP ) ; if ( systemOutput != null && systemOutput . length ( ) > 0 ) { sb . append ( "------------- Standard Output ---------------" ) . append ( StringUtils . LINE_SEP ) . append ( systemOutput ) . append ( "------------- ---------------- ---------------" ) . append ( StringUtils . LINE_SEP ) ; } if ( systemError != null && systemError . length ( ) > 0 ) { sb . append ( "------------- Standard Error -----------------" ) . append ( StringUtils . LINE_SEP ) . append ( systemError ) . append ( "------------- ---------------- ---------------" ) . append ( StringUtils . LINE_SEP ) ; } if ( output != null ) { try { output . write ( sb . toString ( ) ) ; resultWriter . close ( ) ; output . write ( results . toString ( ) ) ; output . flush ( ) ; } finally { if ( out != System . out && out != System . err ) { FileUtils . close ( out ) ; } } } } public void startTest ( Test test ) { } public void endTest ( Test test ) { } public void addFailure ( Test test , Throwable t ) { formatError ( "\tFAILED" , test , t ) ; } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable error ) { formatError ( "\tCaused an ERROR" , test , error ) ; } protected String formatTest ( Test test ) { if ( test == null ) { return "Null Test: " ; } else { return "Testcase: " + test . toString ( ) + ":" ; } } protected synchronized void formatError ( String type , Test test , Throwable error ) { if ( test != null ) { endTest ( test ) ; } resultWriter . println ( formatTest ( test ) + type ) ; resultWriter . println ( error . getMessage ( ) ) ; String strace = JUnitTestRunner . getFilteredTrace ( error ) ; resultWriter . println ( strace ) ; resultWriter . println ( ) ; } } 	0
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class FilesMatch implements Condition { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File file1 , file2 ; private boolean textfile = false ; public void setFile1 ( File file1 ) { this . file1 = file1 ; } public void setFile2 ( File file2 ) { this . file2 = file2 ; } public void setTextfile ( boolean textfile ) { this . textfile = textfile ; } public boolean eval ( ) throws BuildException { if ( file1 == null || file2 == null ) { throw new BuildException ( "both file1 and file2 are required in " + "filesmatch" ) ; } boolean matches = false ; try { matches = FILE_UTILS . contentEquals ( file1 , file2 , textfile ) ; } catch ( IOException ioe ) { throw new BuildException ( "when comparing files: " + ioe . getMessage ( ) , ioe ) ; } return matches ; } } 	0
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCRmtype extends ClearCase { private String mTypeKind = null ; private String mTypeName = null ; private String mVOB = null ; private String mComment = null ; private String mCfile = null ; private boolean mRmall = false ; private boolean mIgnore = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; int result = 0 ; if ( getTypeKind ( ) == null ) { throw new BuildException ( "Required attribute TypeKind not specified" ) ; } if ( getTypeName ( ) == null ) { throw new BuildException ( "Required attribute TypeName not specified" ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_RMTYPE ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getTypeSpecifier ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getIgnore ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_IGNORE ) ; } if ( getRmAll ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RMALL ) ; cmd . createArgument ( ) . setValue ( FLAG_FORCE ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } cmd . createArgument ( ) . setValue ( getTypeSpecifier ( ) ) ; } public void setIgnore ( boolean ignore ) { mIgnore = ignore ; } public boolean getIgnore ( ) { return mIgnore ; } public void setRmAll ( boolean rmall ) { mRmall = rmall ; } public boolean getRmAll ( ) { return mRmall ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setTypeKind ( String tk ) { mTypeKind = tk ; } public String getTypeKind ( ) { return mTypeKind ; } public void setTypeName ( String tn ) { mTypeName = tn ; } public String getTypeName ( ) { return mTypeName ; } public void setVOB ( String vob ) { mVOB = vob ; } public String getVOB ( ) { return mVOB ; } private String getTypeSpecifier ( ) { String tkind = getTypeKind ( ) ; String tname = getTypeName ( ) ; String typeSpec = null ; typeSpec = tkind + ":" + tname ; if ( getVOB ( ) != null ) { typeSpec += "@" + getVOB ( ) ; } return typeSpec ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_IGNORE = "-ignore" ; public static final String FLAG_RMALL = "-rmall" ; public static final String FLAG_FORCE = "-force" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0
package org . apache . tools . ant . util ; import java . io . File ; public class PackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( File . separatorChar , '.' ) ; } } 	0
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . FileUtils ; public final class SelectorUtils { private static SelectorUtils instance = new SelectorUtils ( ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private SelectorUtils ( ) { } public static SelectorUtils getInstance ( ) { return instance ; } public static boolean matchPatternStart ( String pattern , String str ) { return matchPatternStart ( pattern , str , true ) ; } public static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } String [ ] patDirs = tokenizePathAsArray ( pattern ) ; String [ ] strDirs = tokenizePathAsArray ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . length - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxStart ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxStart ] , isCaseSensitive ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } public static boolean matchPath ( String pattern , String str ) { return matchPath ( pattern , str , true ) ; } public static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { String [ ] patDirs = tokenizePathAsArray ( pattern ) ; String [ ] strDirs = tokenizePathAsArray ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . length - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxStart ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxStart ] , isCaseSensitive ) ) { patDirs = null ; strDirs = null ; return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { patDirs = null ; strDirs = null ; return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxEnd ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxEnd ] , isCaseSensitive ) ) { patDirs = null ; strDirs = null ; return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs [ i ] . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = patDirs [ patIdxStart + j + 1 ] ; String subStr = strDirs [ strIdxStart + i + j ] ; if ( ! match ( subPat , subStr , isCaseSensitive ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { patDirs = null ; strDirs = null ; return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } public static boolean match ( String pattern , String str ) { return match ( pattern , str , true ) ; } public static boolean match ( String pattern , String str , boolean isCaseSensitive ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ i ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ i ] ) ) { return false ; } } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart ] ) ) { return false ; } } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxEnd ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxEnd ] ) ) { return false ; } } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart + i + j ] ) ) { continue strLoop ; } } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public static Vector tokenizePath ( String path ) { return tokenizePath ( path , File . separator ) ; } public static Vector tokenizePath ( String path , String separator ) { Vector ret = new Vector ( ) ; if ( FileUtils . isAbsolutePath ( path ) ) { String [ ] s = FILE_UTILS . dissect ( path ) ; ret . add ( s [ 0 ] ) ; path = s [ 1 ] ; } StringTokenizer st = new StringTokenizer ( path , separator ) ; while ( st . hasMoreTokens ( ) ) { ret . addElement ( st . nextToken ( ) ) ; } return ret ; } private static String [ ] tokenizePathAsArray ( String path ) { String root = null ; if ( FileUtils . isAbsolutePath ( path ) ) { String [ ] s = FILE_UTILS . dissect ( path ) ; root = s [ 0 ] ; path = s [ 1 ] ; } char sep = File . separatorChar ; int start = 0 ; int len = path . length ( ) ; int count = 0 ; for ( int pos = 0 ; pos < len ; pos ++ ) { if ( path . charAt ( pos ) == sep ) { if ( pos != start ) { count ++ ; } start = pos + 1 ; } } if ( len != start ) { count ++ ; } String [ ] l = new String [ count + ( ( root == null ) ? 0 : 1 ) ] ; if ( root != null ) { l [ 0 ] = root ; count = 1 ; } else { count = 0 ; } start = 0 ; for ( int pos = 0 ; pos < len ; pos ++ ) { if ( path . charAt ( pos ) == sep ) { if ( pos != start ) { String tok = path . substring ( start , pos ) ; l [ count ++ ] = tok ; } start = pos + 1 ; } } if ( len != start ) { String tok = path . substring ( start ) ; l [ count ] = tok ; } return l ; } public static boolean isOutOfDate ( File src , File target , int granularity ) { if ( ! src . exists ( ) ) { return false ; } if ( ! target . exists ( ) ) { return true ; } if ( ( src . lastModified ( ) - granularity ) > target . lastModified ( ) ) { return true ; } return false ; } public static boolean isOutOfDate ( Resource src , Resource target , int granularity ) { return isOutOfDate ( src , target , ( long ) granularity ) ; } public static boolean isOutOfDate ( Resource src , Resource target , long granularity ) { if ( ! src . isExists ( ) ) { return false ; } if ( ! target . isExists ( ) ) { return true ; } if ( ( src . getLastModified ( ) - granularity ) > target . getLastModified ( ) ) { return true ; } return false ; } public static String removeWhitespace ( String input ) { StringBuffer result = new StringBuffer ( ) ; if ( input != null ) { StringTokenizer st = new StringTokenizer ( input ) ; while ( st . hasMoreTokens ( ) ) { result . append ( st . nextToken ( ) ) ; } } return result . toString ( ) ; } public static boolean hasWildcards ( String input ) { return ( input . indexOf ( '*' ) != - 1 || input . indexOf ( '?' ) != - 1 ) ; } public static String rtrimWildcardTokens ( String input ) { String [ ] tokens = tokenizePathAsArray ( input ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < tokens . length ; i ++ ) { if ( hasWildcards ( tokens [ i ] ) ) { break ; } if ( i > 0 && sb . charAt ( sb . length ( ) - 1 ) != File . separatorChar ) { sb . append ( File . separator ) ; } sb . append ( tokens [ i ] ) ; } return sb . toString ( ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . optional . javah . JavahAdapter ; import org . apache . tools . ant . taskdefs . optional . javah . JavahAdapterFactory ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; import org . apache . tools . ant . util . facade . ImplementationSpecificArgument ; public class Javah extends Task { private Vector classes = new Vector ( 2 ) ; private String cls ; private File destDir ; private Path classpath = null ; private File outputFile = null ; private boolean verbose = false ; private boolean force = false ; private boolean old = false ; private boolean stubs = false ; private Path bootclasspath ; private static String lSep = System . getProperty ( "line.separator" ) ; private FacadeTaskHelper facade = null ; public Javah ( ) { facade = new FacadeTaskHelper ( JavahAdapterFactory . getDefault ( ) ) ; } public void setClass ( String cls ) { this . cls = cls ; } public ClassArgument createClass ( ) { ClassArgument ga = new ClassArgument ( ) ; classes . addElement ( ga ) ; return ga ; } public class ClassArgument { private String name ; public ClassArgument ( ) { } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } public String [ ] getClasses ( ) { ArrayList al = new ArrayList ( ) ; if ( cls != null ) { StringTokenizer tok = new StringTokenizer ( cls , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { al . add ( tok . nextToken ( ) . trim ( ) ) ; } } Enumeration e = classes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ClassArgument arg = ( ClassArgument ) e . nextElement ( ) ; al . add ( arg . getName ( ) ) ; } return ( String [ ] ) al . toArray ( new String [ al . size ( ) ] ) ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setClasspath ( Path src ) { if ( classpath == null ) { classpath = src ; } else { classpath . append ( src ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return classpath ; } public void setBootclasspath ( Path src ) { if ( bootclasspath == null ) { bootclasspath = src ; } else { bootclasspath . append ( src ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public Path getBootclasspath ( ) { return bootclasspath ; } public void setOutputFile ( File outputFile ) { this . outputFile = outputFile ; } public File getOutputfile ( ) { return outputFile ; } public void setForce ( boolean force ) { this . force = force ; } public boolean getForce ( ) { return force ; } public void setOld ( boolean old ) { this . old = old ; } public boolean getOld ( ) { return old ; } public void setStubs ( boolean stubs ) { this . stubs = stubs ; } public boolean getStubs ( ) { return stubs ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setImplementation ( String impl ) { if ( "default" . equals ( impl ) ) { facade . setImplementation ( JavahAdapterFactory . getDefault ( ) ) ; } else { facade . setImplementation ( impl ) ; } } public ImplementationSpecificArgument createArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentArgs ( ) { return facade . getArgs ( ) ; } public void execute ( ) throws BuildException { if ( ( cls == null ) && ( classes . size ( ) == 0 ) ) { throw new BuildException ( "class attribute must be set!" , getLocation ( ) ) ; } if ( ( cls != null ) && ( classes . size ( ) > 0 ) ) { throw new BuildException ( "set class attribute or class element, " + "not both." , getLocation ( ) ) ; } if ( destDir != null ) { if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist or is not a directory" , getLocation ( ) ) ; } if ( outputFile != null ) { throw new BuildException ( "destdir and outputFile are mutually " + "exclusive" , getLocation ( ) ) ; } } if ( classpath == null ) { classpath = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } else { classpath = classpath . concatSystemClasspath ( "ignore" ) ; } JavahAdapter ad = JavahAdapterFactory . getAdapter ( facade . getImplementation ( ) , this ) ; if ( ! ad . compile ( this ) ) { throw new BuildException ( "compilation failed" ) ; } } public void logAndAddFiles ( Commandline cmd ) { logAndAddFilesToCompile ( cmd ) ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceClassList = new StringBuffer ( ) ; String [ ] c = getClasses ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { cmd . createArgument ( ) . setValue ( c [ i ] ) ; niceClassList . append ( "    " ) ; niceClassList . append ( c [ i ] ) ; niceClassList . append ( lSep ) ; } StringBuffer prefix = new StringBuffer ( "Class" ) ; if ( c . length > 1 ) { prefix . append ( "es" ) ; } prefix . append ( " to be compiled:" ) ; prefix . append ( lSep ) ; log ( prefix . toString ( ) + niceClassList . toString ( ) , Project . MSG_VERBOSE ) ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . types . resources . FileResource ; public class LoadFile extends LoadResource { public final void setSrcFile ( final File srcFile ) { addConfigured ( new FileResource ( srcFile ) ) ; } } 	0
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import java . lang . reflect . Method ; import java . lang . reflect . Field ; public class HasMethod extends ProjectComponent implements Condition { private String classname ; private String method ; private String field ; private Path classpath ; private AntClassLoader loader ; private boolean ignoreSystemClasses = false ; public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setClassname ( String classname ) { this . classname = classname ; } public void setMethod ( String method ) { this . method = method ; } public void setField ( String field ) { this . field = field ; } public void setIgnoreSystemClasses ( boolean ignoreSystemClasses ) { this . ignoreSystemClasses = ignoreSystemClasses ; } private Class loadClass ( String classname ) { try { if ( ignoreSystemClasses ) { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; if ( loader != null ) { try { return loader . findClass ( classname ) ; } catch ( SecurityException se ) { return null ; } } else { return null ; } } else if ( loader != null ) { return loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { return Class . forName ( classname , true , l ) ; } else { return Class . forName ( classname ) ; } } } catch ( ClassNotFoundException e ) { throw new BuildException ( "class \"" + classname + "\" was not found" ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Could not load dependent class \"" + e . getMessage ( ) + "\" for class \"" + classname + "\"" ) ; } } public boolean eval ( ) throws BuildException { if ( classname == null ) { throw new BuildException ( "No classname defined" ) ; } Class clazz = loadClass ( classname ) ; if ( method != null ) { return isMethodFound ( clazz ) ; } if ( field != null ) { return isFieldFound ( clazz ) ; } throw new BuildException ( "Neither method nor field defined" ) ; } private boolean isFieldFound ( Class clazz ) { Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Field fieldEntry = fields [ i ] ; if ( fieldEntry . getName ( ) . equals ( field ) ) { return true ; } } return false ; } private boolean isMethodFound ( Class clazz ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method methodEntry = methods [ i ] ; if ( methodEntry . getName ( ) . equals ( method ) ) { return true ; } } return false ; } } 	0
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import java . net . URL ; public class WhichResource extends Task { private Path classpath ; private String classname ; private String resource ; private String property ; public void setClasspath ( Path cp ) { if ( classpath == null ) { classpath = cp ; } else { classpath . append ( cp ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } private void validate ( ) { int setcount = 0 ; if ( classname != null ) { setcount ++ ; } if ( resource != null ) { setcount ++ ; } if ( setcount == 0 ) { throw new BuildException ( "One of classname or resource must be specified" ) ; } if ( setcount > 1 ) { throw new BuildException ( "Only one of classname or resource can be specified" ) ; } if ( property == null ) { throw new BuildException ( "No property defined" ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( classpath != null ) { getProject ( ) . log ( "using user supplied classpath: " + classpath , Project . MSG_DEBUG ) ; classpath = classpath . concatSystemClasspath ( "ignore" ) ; } else { classpath = new Path ( getProject ( ) ) ; classpath = classpath . concatSystemClasspath ( "only" ) ; getProject ( ) . log ( "using system classpath: " + classpath , Project . MSG_DEBUG ) ; } AntClassLoader loader ; loader = new AntClassLoader ( getProject ( ) . getCoreLoader ( ) , getProject ( ) , classpath , false ) ; String loc = null ; if ( classname != null ) { resource = classname . replace ( '.' , '/' ) + ".class" ; } if ( resource == null ) { throw new BuildException ( "One of class or resource is required" ) ; } if ( resource . startsWith ( "/" ) ) { resource = resource . substring ( 1 ) ; } log ( "Searching for " + resource , Project . MSG_VERBOSE ) ; URL url ; url = loader . getResource ( resource ) ; if ( url != null ) { loc = url . toExternalForm ( ) ; getProject ( ) . setNewProperty ( property , loc ) ; } } public void setResource ( String resource ) { this . resource = resource ; } public void setClass ( String classname ) { this . classname = classname ; } public void setProperty ( String property ) { this . property = property ; } } 	0
package org . apache . tools . ant . types . resources ; import java . util . List ; import java . util . HashSet ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . ResourceCollection ; public class Difference extends BaseResourceCollectionContainer { protected Collection getCollection ( ) { List rc = getResourceCollections ( ) ; int size = rc . size ( ) ; if ( size < 2 ) { throw new BuildException ( "The difference of " + size + " resource collection" + ( ( size == 1 ) ? "" : "s" ) + " is undefined." ) ; } HashSet hs = new HashSet ( ) ; ArrayList al = new ArrayList ( ) ; for ( Iterator rcIter = rc . iterator ( ) ; rcIter . hasNext ( ) ; ) { for ( Iterator r = nextRC ( rcIter ) . iterator ( ) ; r . hasNext ( ) ; ) { Object next = r . next ( ) ; if ( hs . add ( next ) ) { al . add ( next ) ; } else { al . remove ( next ) ; } } } return al ; } private static ResourceCollection nextRC ( Iterator i ) { return ( ResourceCollection ) i . next ( ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . sound ; import java . io . File ; import java . io . IOException ; import javax . sound . sampled . AudioFormat ; import javax . sound . sampled . AudioInputStream ; import javax . sound . sampled . AudioSystem ; import javax . sound . sampled . Clip ; import javax . sound . sampled . DataLine ; import javax . sound . sampled . Line ; import javax . sound . sampled . LineEvent ; import javax . sound . sampled . LineListener ; import javax . sound . sampled . LineUnavailableException ; import javax . sound . sampled . UnsupportedAudioFileException ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . Project ; public class AntSoundPlayer implements LineListener , BuildListener { private File fileSuccess = null ; private int loopsSuccess = 0 ; private Long durationSuccess = null ; private File fileFail = null ; private int loopsFail = 0 ; private Long durationFail = null ; public AntSoundPlayer ( ) { } public void addBuildSuccessfulSound ( File file , int loops , Long duration ) { this . fileSuccess = file ; this . loopsSuccess = loops ; this . durationSuccess = duration ; } public void addBuildFailedSound ( File fileFail , int loopsFail , Long durationFail ) { this . fileFail = fileFail ; this . loopsFail = loopsFail ; this . durationFail = durationFail ; } private void play ( Project project , File file , int loops , Long duration ) { Clip audioClip = null ; AudioInputStream audioInputStream = null ; try { audioInputStream = AudioSystem . getAudioInputStream ( file ) ; } catch ( UnsupportedAudioFileException uafe ) { project . log ( "Audio format is not yet supported: " + uafe . getMessage ( ) ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } if ( audioInputStream != null ) { AudioFormat format = audioInputStream . getFormat ( ) ; DataLine . Info info = new DataLine . Info ( Clip . class , format , AudioSystem . NOT_SPECIFIED ) ; try { audioClip = ( Clip ) AudioSystem . getLine ( info ) ; audioClip . addLineListener ( this ) ; audioClip . open ( audioInputStream ) ; } catch ( LineUnavailableException e ) { project . log ( "The sound device is currently unavailable" ) ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( duration != null ) { playClip ( audioClip , duration . longValue ( ) ) ; } else { playClip ( audioClip , loops ) ; } audioClip . drain ( ) ; audioClip . close ( ) ; } else { project . log ( "Can't get data from file " + file . getName ( ) ) ; } } private void playClip ( Clip clip , int loops ) { clip . loop ( loops ) ; while ( clip . isRunning ( ) ) { } } private void playClip ( Clip clip , long duration ) { clip . loop ( Clip . LOOP_CONTINUOUSLY ) ; try { Thread . sleep ( duration ) ; } catch ( InterruptedException e ) { } } public void update ( LineEvent event ) { if ( event . getType ( ) . equals ( LineEvent . Type . STOP ) ) { Line line = event . getLine ( ) ; line . close ( ) ; } else if ( event . getType ( ) . equals ( LineEvent . Type . CLOSE ) ) { } } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { if ( event . getException ( ) == null && fileSuccess != null ) { play ( event . getProject ( ) , fileSuccess , loopsSuccess , durationSuccess ) ; } else if ( event . getException ( ) != null && fileFail != null ) { play ( event . getProject ( ) , fileFail , loopsFail , durationFail ) ; } } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } } 	0
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Commandline ; public class GenericHotDeploymentTool extends AbstractHotDeploymentTool { private Java java ; private String className ; private static final String [ ] VALID_ACTIONS = { ACTION_DEPLOY } ; public Commandline . Argument createArg ( ) { return java . createArg ( ) ; } public Commandline . Argument createJvmarg ( ) { return java . createJvmarg ( ) ; } protected boolean isActionValid ( ) { return ( getTask ( ) . getAction ( ) . equals ( VALID_ACTIONS [ 0 ] ) ) ; } public void setTask ( ServerDeploy task ) { super . setTask ( task ) ; java = new Java ( task ) ; } public void deploy ( ) throws BuildException { java . setClassname ( className ) ; java . setClasspath ( getClasspath ( ) ) ; java . setFork ( true ) ; java . setFailonerror ( true ) ; java . execute ( ) ; } public void validateAttributes ( ) throws BuildException { super . validateAttributes ( ) ; if ( className == null ) { throw new BuildException ( "The classname attribute must be set" ) ; } } public void setClassName ( String className ) { this . className = className ; } public Java getJava ( ) { return java ; } public String getClassName ( ) { return className ; } } 	0
package org . apache . tools . ant . util . facade ; import org . apache . tools . ant . types . Commandline ; public class ImplementationSpecificArgument extends Commandline . Argument { private String impl ; public ImplementationSpecificArgument ( ) { super ( ) ; } public void setImplementation ( String impl ) { this . impl = impl ; } public final String [ ] getParts ( String chosenImpl ) { if ( impl == null || impl . equals ( chosenImpl ) ) { return super . getParts ( ) ; } else { return new String [ 0 ] ; } } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; public class Move extends Copy { public Move ( ) { super ( ) ; setOverwrite ( true ) ; } protected void validateAttributes ( ) throws BuildException { if ( file != null && file . isDirectory ( ) ) { if ( ( destFile != null && destDir != null ) || ( destFile == null && destDir == null ) ) { throw new BuildException ( "One and only one of tofile and todir " + "must be set." ) ; } destFile = ( destFile == null ) ? new File ( destDir , file . getName ( ) ) : destFile ; destDir = ( destDir == null ) ? destFile . getParentFile ( ) : destDir ; completeDirMap . put ( file , destFile ) ; file = null ; } else { super . validateAttributes ( ) ; } } protected void doFileOperations ( ) { if ( completeDirMap . size ( ) > 0 ) { Enumeration e = completeDirMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { File fromDir = ( File ) e . nextElement ( ) ; File toDir = ( File ) completeDirMap . get ( fromDir ) ; boolean renamed = false ; try { log ( "Attempting to rename dir: " + fromDir + " to " + toDir , verbosity ) ; renamed = renameFile ( fromDir , toDir , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename dir " + fromDir + " to " + toDir + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } if ( ! renamed ) { FileSet fs = new FileSet ( ) ; fs . setProject ( getProject ( ) ) ; fs . setDir ( fromDir ) ; addFileset ( fs ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; scan ( fromDir , toDir , files , dirs ) ; } } } int moveCount = fileCopyMap . size ( ) ; if ( moveCount > 0 ) { log ( "Moving " + moveCount + " file" + ( ( moveCount == 1 ) ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; File f = new File ( fromFile ) ; boolean selfMove = false ; if ( f . exists ( ) ) { String [ ] toFiles = ( String [ ] ) fileCopyMap . get ( fromFile ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = ( String ) toFiles [ i ] ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-move of " + fromFile , verbosity ) ; selfMove = true ; continue ; } File d = new File ( toFile ) ; if ( ( i + 1 ) == toFiles . length && ! selfMove ) { moveFile ( f , d , filtering , forceOverwrite ) ; } else { copyFile ( f , d , filtering , forceOverwrite ) ; } } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . keys ( ) ; int createCount = 0 ; while ( e . hasMoreElements ( ) ) { String fromDirName = ( String ) e . nextElement ( ) ; String [ ] toDirNames = ( String [ ] ) dirCopyMap . get ( fromDirName ) ; boolean selfMove = false ; for ( int i = 0 ; i < toDirNames . length ; i ++ ) { if ( fromDirName . equals ( toDirNames [ i ] ) ) { log ( "Skipping self-move of " + fromDirName , verbosity ) ; selfMove = true ; continue ; } File d = new File ( toDirNames [ i ] ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { createCount ++ ; } } } File fromDir = new File ( fromDirName ) ; if ( ! selfMove && okToDelete ( fromDir ) ) { deleteDir ( fromDir ) ; } } if ( createCount > 0 ) { log ( "Moved " + dirCopyMap . size ( ) + " empty director" + ( dirCopyMap . size ( ) == 1 ? "y" : "ies" ) + " to " + createCount + " empty director" + ( createCount == 1 ? "y" : "ies" ) + " under " + destDir . getAbsolutePath ( ) ) ; } } } private void moveFile ( File fromFile , File toFile , boolean filtering , boolean overwrite ) { boolean moved = false ; try { log ( "Attempting to rename: " + fromFile + " to " + toFile , verbosity ) ; moved = renameFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } if ( ! moved ) { copyFile ( fromFile , toFile , filtering , overwrite ) ; if ( ! fromFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + "file " + fromFile . getAbsolutePath ( ) ) ; } } } private void copyFile ( File fromFile , File toFile , boolean filtering , boolean overwrite ) { try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = getFilterSets ( ) . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } getFileUtils ( ) . copyFile ( fromFile , toFile , executionFilters , getFilterChains ( ) , forceOverwrite , getPreserveLastModified ( ) , getEncoding ( ) , getOutputEncoding ( ) , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } protected boolean okToDelete ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { return false ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { if ( ! okToDelete ( f ) ) { return false ; } } else { return false ; } } return true ; } protected void deleteDir ( File d ) { deleteDir ( d , false ) ; } protected void deleteDir ( File d , boolean deleteFiles ) { String [ ] list = d . list ( ) ; if ( list == null ) { return ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { deleteDir ( f ) ; } else if ( deleteFiles && ! ( f . delete ( ) ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } else { throw new BuildException ( "UNEXPECTED ERROR - The file " + f . getAbsolutePath ( ) + " should not exist!" ) ; } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + d . getAbsolutePath ( ) ) ; } } protected boolean renameFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException , BuildException { boolean renamed = false ; if ( ( getFilterSets ( ) . size ( ) + getFilterChains ( ) . size ( ) == 0 ) && ! ( filtering || destFile . isDirectory ( ) ) ) { File parent = destFile . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) { parent . mkdirs ( ) ; } if ( destFile . isFile ( ) && ! destFile . equals ( sourceFile ) && ! destFile . delete ( ) ) { throw new BuildException ( "Unable to remove existing " + "file " + destFile ) ; } renamed = sourceFile . renameTo ( destFile ) ; } return renamed ; } } 	1
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Equals implements Condition { private String arg1 , arg2 ; private boolean trim = false ; private boolean caseSensitive = true ; public void setArg1 ( String a1 ) { arg1 = a1 ; } public void setArg2 ( String a2 ) { arg2 = a2 ; } public void setTrim ( boolean b ) { trim = b ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( arg1 == null || arg2 == null ) { throw new BuildException ( "both arg1 and arg2 are required in " + "equals" ) ; } if ( trim ) { arg1 = arg1 . trim ( ) ; arg2 = arg2 . trim ( ) ; } return caseSensitive ? arg1 . equals ( arg2 ) : arg1 . equalsIgnoreCase ( arg2 ) ; } } 	0
package org . apache . tools . ant . types ; import java . util . Arrays ; import org . apache . tools . ant . BuildException ; public class Comparison extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "equal" , "greater" , "less" , "ne" , "ge" , "le" , "eq" , "gt" , "lt" , "more" } ; public static final Comparison EQUAL = new Comparison ( "equal" ) ; public static final Comparison NOT_EQUAL = new Comparison ( "ne" ) ; public static final Comparison GREATER = new Comparison ( "greater" ) ; public static final Comparison LESS = new Comparison ( "less" ) ; public static final Comparison GREATER_EQUAL = new Comparison ( "ge" ) ; public static final Comparison LESS_EQUAL = new Comparison ( "le" ) ; private static final int [ ] EQUAL_INDEX = { 0 , 4 , 5 , 6 } ; private static final int [ ] LESS_INDEX = { 2 , 3 , 5 , 8 } ; private static final int [ ] GREATER_INDEX = { 1 , 3 , 4 , 7 , 9 } ; public Comparison ( ) { } public Comparison ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } public boolean evaluate ( int comparisonResult ) { if ( getIndex ( ) == - 1 ) { throw new BuildException ( "Comparison value not set." ) ; } int [ ] i = comparisonResult < 0 ? LESS_INDEX : comparisonResult > 0 ? GREATER_INDEX : EQUAL_INDEX ; return Arrays . binarySearch ( i , getIndex ( ) ) >= 0 ; } } 	0
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import junit . framework . TestResult ; import org . apache . tools . ant . AntClassLoader ; public final class JUnitTaskMirrorImpl implements JUnitTaskMirror { private final JUnitTask task ; public JUnitTaskMirrorImpl ( JUnitTask task ) { this . task = task ; } public void addVmExit ( JUnitTest test , JUnitTaskMirror . JUnitResultFormatterMirror aFormatter , OutputStream out , String message , String testCase ) { JUnitResultFormatter formatter = ( JUnitResultFormatter ) aFormatter ; formatter . setOutput ( out ) ; formatter . startTestSuite ( test ) ; TestCase t = new VmExitErrorTest ( message , test , testCase ) ; formatter . startTest ( t ) ; formatter . addError ( t , new AssertionFailedError ( message ) ) ; formatter . endTestSuite ( test ) ; } public JUnitTaskMirror . JUnitTestRunnerMirror newJUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filterTrace , boolean haltOnFailure , boolean showOutput , boolean logTestListenerEvents , AntClassLoader classLoader ) { return new JUnitTestRunner ( test , haltOnError , filterTrace , haltOnFailure , showOutput , logTestListenerEvents , classLoader ) ; } public JUnitTaskMirror . SummaryJUnitResultFormatterMirror newSummaryJUnitResultFormatter ( ) { return new SummaryJUnitResultFormatter ( ) ; } static class VmExitErrorTest extends TestCase { private String message ; private JUnitTest test ; private String testCase ; VmExitErrorTest ( String aMessage , JUnitTest anOriginalTest , String aTestCase ) { message = aMessage ; test = anOriginalTest ; testCase = aTestCase ; } public int countTestCases ( ) { return 1 ; } public void run ( TestResult r ) { throw new AssertionFailedError ( message ) ; } public String getName ( ) { return testCase ; } String getClassName ( ) { return test . getName ( ) ; } public String toString ( ) { return test . getName ( ) + ":" + testCase ; } } } 	0
package org . apache . tools . ant ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . taskdefs . PreSetDef ; public final class IntrospectionHelper { private static final Map EMPTY_MAP = Collections . unmodifiableMap ( new HashMap ( 0 ) ) ; private static final Map HELPERS = new Hashtable ( ) ; private static final Map PRIMITIVE_TYPE_MAP = new HashMap ( 8 ) ; static { Class [ ] primitives = { Boolean . TYPE , Byte . TYPE , Character . TYPE , Short . TYPE , Integer . TYPE , Long . TYPE , Float . TYPE , Double . TYPE } ; Class [ ] wrappers = { Boolean . class , Byte . class , Character . class , Short . class , Integer . class , Long . class , Float . class , Double . class } ; for ( int i = 0 ; i < primitives . length ; i ++ ) { PRIMITIVE_TYPE_MAP . put ( primitives [ i ] , wrappers [ i ] ) ; } } private static final int MAX_REPORT_NESTED_TEXT = 20 ; private static final String ELLIPSIS = "..." ; private Hashtable attributeTypes = new Hashtable ( ) ; private Hashtable attributeSetters = new Hashtable ( ) ; private Hashtable nestedTypes = new Hashtable ( ) ; private Hashtable nestedCreators = new Hashtable ( ) ; private List addTypeMethods = new ArrayList ( ) ; private Method addText = null ; private Class bean ; private IntrospectionHelper ( final Class bean ) { this . bean = bean ; Method [ ] methods = bean . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final Method m = methods [ i ] ; final String name = m . getName ( ) ; Class returnType = m . getReturnType ( ) ; Class [ ] args = m . getParameterTypes ( ) ; if ( args . length == 1 && java . lang . Void . TYPE . equals ( returnType ) && ( "add" . equals ( name ) || "addConfigured" . equals ( name ) ) ) { insertAddTypeMethod ( m ) ; continue ; } if ( org . apache . tools . ant . ProjectComponent . class . isAssignableFrom ( bean ) && args . length == 1 && isHiddenSetMethod ( name , args [ 0 ] ) ) { continue ; } if ( isContainer ( ) && args . length == 1 && "addTask" . equals ( name ) && org . apache . tools . ant . Task . class . equals ( args [ 0 ] ) ) { continue ; } if ( "addText" . equals ( name ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && java . lang . String . class . equals ( args [ 0 ] ) ) { addText = methods [ i ] ; } else if ( name . startsWith ( "set" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! args [ 0 ] . isArray ( ) ) { String propName = getPropertyName ( name , "set" ) ; if ( attributeSetters . get ( propName ) != null ) { if ( java . lang . String . class . equals ( args [ 0 ] ) ) { continue ; } } AttributeSetter as = createAttributeSetter ( m , args [ 0 ] , propName ) ; if ( as != null ) { attributeTypes . put ( propName , args [ 0 ] ) ; attributeSetters . put ( propName , as ) ; } } else if ( name . startsWith ( "create" ) && ! returnType . isArray ( ) && ! returnType . isPrimitive ( ) && args . length == 0 ) { String propName = getPropertyName ( name , "create" ) ; if ( nestedCreators . get ( propName ) == null ) { nestedTypes . put ( propName , returnType ) ; nestedCreators . put ( propName , new CreateNestedCreator ( m ) ) ; } } else if ( name . startsWith ( "addConfigured" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { Constructor constructor = null ; try { constructor = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; } catch ( NoSuchMethodException ex ) { constructor = args [ 0 ] . getConstructor ( new Class [ ] { Project . class } ) ; } String propName = getPropertyName ( name , "addConfigured" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new AddNestedCreator ( m , constructor , AddNestedCreator . ADD_CONFIGURED ) ) ; } catch ( NoSuchMethodException nse ) { } } else if ( name . startsWith ( "add" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { Constructor constructor = null ; try { constructor = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; } catch ( NoSuchMethodException ex ) { constructor = args [ 0 ] . getConstructor ( new Class [ ] { Project . class } ) ; } String propName = getPropertyName ( name , "add" ) ; if ( nestedTypes . get ( propName ) != null ) { continue ; } nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new AddNestedCreator ( m , constructor , AddNestedCreator . ADD ) ) ; } catch ( NoSuchMethodException nse ) { } } } } private boolean isHiddenSetMethod ( String name , Class type ) { if ( "setLocation" . equals ( name ) && org . apache . tools . ant . Location . class . equals ( type ) ) { return true ; } if ( "setTaskType" . equals ( name ) && java . lang . String . class . equals ( type ) ) { return true ; } return false ; } public static synchronized IntrospectionHelper getHelper ( Class c ) { return getHelper ( null , c ) ; } public static IntrospectionHelper getHelper ( Project p , Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) HELPERS . get ( c . getName ( ) ) ; if ( ih == null || ih . bean != c ) { ih = new IntrospectionHelper ( c ) ; if ( p != null ) { HELPERS . put ( c . getName ( ) , ih ) ; } } return ih ; } public void setAttribute ( Project p , Object element , String attributeName , String value ) throws BuildException { AttributeSetter as = ( AttributeSetter ) attributeSetters . get ( attributeName . toLowerCase ( Locale . US ) ) ; if ( as == null ) { if ( element instanceof DynamicAttributeNS ) { DynamicAttributeNS dc = ( DynamicAttributeNS ) element ; String uriPlusPrefix = ProjectHelper . extractUriFromComponentName ( attributeName ) ; String uri = ProjectHelper . extractUriFromComponentName ( uriPlusPrefix ) ; String localName = ProjectHelper . extractNameFromComponentName ( attributeName ) ; String qName = ( "" . equals ( uri ) ? localName : ( uri + ":" + localName ) ) ; dc . setDynamicAttribute ( uri , localName , qName , value ) ; return ; } else if ( element instanceof DynamicAttribute ) { DynamicAttribute dc = ( DynamicAttribute ) element ; dc . setDynamicAttribute ( attributeName . toLowerCase ( Locale . US ) , value ) ; return ; } else { if ( attributeName . indexOf ( ':' ) != - 1 ) { return ; } String msg = getElementName ( p , element ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new UnsupportedAttributeException ( msg , attributeName ) ; } } try { as . set ( p , element , value ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void addText ( Project project , Object element , String text ) throws BuildException { if ( addText == null ) { text = text . trim ( ) ; if ( text . length ( ) == 0 ) { return ; } else { String msg = project . getElementName ( element ) + " doesn't support nested text data (\"" + condenseText ( text ) + "\")." ; throw new BuildException ( msg ) ; } } try { addText . invoke ( element , new Object [ ] { text } ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void throwNotSupported ( Project project , Object parent , String elementName ) { String msg = project . getElementName ( parent ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new UnsupportedElementException ( msg , elementName ) ; } private NestedCreator getNestedCreator ( Project project , String parentUri , Object parent , String elementName , UnknownElement child ) throws BuildException { String uri = ProjectHelper . extractUriFromComponentName ( elementName ) ; String name = ProjectHelper . extractNameFromComponentName ( elementName ) ; if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } if ( parentUri . equals ( ProjectHelper . ANT_CORE_URI ) ) { parentUri = "" ; } NestedCreator nc = null ; if ( uri . equals ( parentUri ) || uri . equals ( "" ) ) { nc = ( NestedCreator ) nestedCreators . get ( name . toLowerCase ( Locale . US ) ) ; } if ( nc == null ) { nc = createAddTypeCreator ( project , parent , elementName ) ; } if ( nc == null && parent instanceof DynamicElementNS ) { DynamicElementNS dc = ( DynamicElementNS ) parent ; String qName = ( child == null ? name : child . getQName ( ) ) ; final Object nestedElement = dc . createDynamicElement ( ( child == null ? "" : child . getNamespace ( ) ) , name , qName ) ; if ( nestedElement != null ) { nc = new NestedCreator ( null ) { Object create ( Project project , Object parent , Object ignore ) { return nestedElement ; } } ; } } if ( nc == null && parent instanceof DynamicElement ) { DynamicElement dc = ( DynamicElement ) parent ; final Object nestedElement = dc . createDynamicElement ( name . toLowerCase ( Locale . US ) ) ; if ( nestedElement != null ) { nc = new NestedCreator ( null ) { Object create ( Project project , Object parent , Object ignore ) { return nestedElement ; } } ; } } if ( nc == null ) { throwNotSupported ( project , parent , elementName ) ; } return nc ; } public Object createElement ( Project project , Object parent , String elementName ) throws BuildException { NestedCreator nc = getNestedCreator ( project , "" , parent , elementName , null ) ; try { Object nestedElement = nc . create ( project , parent , null ) ; if ( project != null ) { project . setProjectReference ( nestedElement ) ; } return nestedElement ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Creator getElementCreator ( Project project , String parentUri , Object parent , String elementName , UnknownElement ue ) { NestedCreator nc = getNestedCreator ( project , parentUri , parent , elementName , ue ) ; return new Creator ( project , parent , nc ) ; } public boolean isDynamic ( ) { return DynamicElement . class . isAssignableFrom ( bean ) || DynamicElementNS . class . isAssignableFrom ( bean ) ; } public boolean isContainer ( ) { return TaskContainer . class . isAssignableFrom ( bean ) ; } public boolean supportsNestedElement ( String elementName ) { return nestedCreators . containsKey ( elementName . toLowerCase ( Locale . US ) ) || isDynamic ( ) || addTypeMethods . size ( ) != 0 ; } public boolean supportsNestedElement ( String parentUri , String elementName ) { if ( parentUri . equals ( ProjectHelper . ANT_CORE_URI ) ) { parentUri = "" ; } String uri = ProjectHelper . extractUriFromComponentName ( elementName ) ; if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } String name = ProjectHelper . extractNameFromComponentName ( elementName ) ; return ( nestedCreators . containsKey ( name . toLowerCase ( Locale . US ) ) && ( uri . equals ( parentUri ) || "" . equals ( uri ) ) ) || isDynamic ( ) || addTypeMethods . size ( ) != 0 ; } public void storeElement ( Project project , Object parent , Object child , String elementName ) throws BuildException { if ( elementName == null ) { return ; } NestedCreator ns = ( NestedCreator ) nestedCreators . get ( elementName . toLowerCase ( Locale . US ) ) ; if ( ns == null ) { return ; } try { ns . store ( parent , child ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Class getElementType ( String elementName ) throws BuildException { Class nt = ( Class ) nestedTypes . get ( elementName ) ; if ( nt == null ) { throw new UnsupportedElementException ( "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." , elementName ) ; } return nt ; } public Class getAttributeType ( String attributeName ) throws BuildException { Class at = ( Class ) attributeTypes . get ( attributeName ) ; if ( at == null ) { throw new UnsupportedAttributeException ( "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." , attributeName ) ; } return at ; } public Method getAddTextMethod ( ) throws BuildException { if ( ! supportsCharacters ( ) ) { throw new BuildException ( "Class " + bean . getName ( ) + " doesn't support nested text data." ) ; } return addText ; } public Method getElementMethod ( String elementName ) throws BuildException { Object creator = nestedCreators . get ( elementName ) ; if ( creator == null ) { throw new UnsupportedElementException ( "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." , elementName ) ; } return ( ( NestedCreator ) creator ) . method ; } public Method getAttributeMethod ( String attributeName ) throws BuildException { Object setter = attributeSetters . get ( attributeName ) ; if ( setter == null ) { throw new UnsupportedAttributeException ( "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." , attributeName ) ; } return ( ( AttributeSetter ) setter ) . method ; } public boolean supportsCharacters ( ) { return addText != null ; } public Enumeration getAttributes ( ) { return attributeSetters . keys ( ) ; } public Map getAttributeMap ( ) { return ( attributeTypes . size ( ) < 1 ) ? EMPTY_MAP : Collections . unmodifiableMap ( attributeTypes ) ; } public Enumeration getNestedElements ( ) { return nestedTypes . keys ( ) ; } public Map getNestedElementMap ( ) { return ( nestedTypes . size ( ) < 1 ) ? EMPTY_MAP : Collections . unmodifiableMap ( nestedTypes ) ; } public List getExtensionPoints ( ) { return ( addTypeMethods . size ( ) < 1 ) ? Collections . EMPTY_LIST : Collections . unmodifiableList ( addTypeMethods ) ; } private AttributeSetter createAttributeSetter ( final Method m , Class arg , final String attrName ) { final Class reflectedArg = PRIMITIVE_TYPE_MAP . containsKey ( arg ) ? ( Class ) PRIMITIVE_TYPE_MAP . get ( arg ) : arg ; if ( java . lang . String . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , ( Object [ ] ) ( new String [ ] { value } ) ) ; } } ; } else if ( java . lang . Character . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { if ( value . length ( ) == 0 ) { throw new BuildException ( "The value \"\" is not a " + "legal value for attribute \"" + attrName + "\"" ) ; } m . invoke ( parent , ( Object [ ] ) ( new Character [ ] { new Character ( value . charAt ( 0 ) ) } ) ) ; } } ; } else if ( java . lang . Boolean . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , ( Object [ ] ) ( new Boolean [ ] { Project . toBoolean ( value ) ? Boolean . TRUE : Boolean . FALSE } ) ) ; } } ; } else if ( java . lang . Class . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Object [ ] { Class . forName ( value ) } ) ; } catch ( ClassNotFoundException ce ) { throw new BuildException ( ce ) ; } } } ; } else if ( java . io . File . class . equals ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Object [ ] { p . resolveFile ( value ) } ) ; } } ; } else if ( EnumeratedAttribute . class . isAssignableFrom ( reflectedArg ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) reflectedArg . newInstance ( ) ; ea . setValue ( value ) ; m . invoke ( parent , new Object [ ] { ea } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } else if ( reflectedArg . getSuperclass ( ) != null && reflectedArg . getSuperclass ( ) . getName ( ) . equals ( "java.lang.Enum" ) ) { return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Object [ ] { reflectedArg . getMethod ( "valueOf" , new Class [ ] { String . class } ) . invoke ( null , new Object [ ] { value } ) } ) ; } catch ( InvocationTargetException x ) { if ( x . getTargetException ( ) instanceof IllegalArgumentException ) { throw new BuildException ( "'" + value + "' is not a permitted value for " + reflectedArg . getName ( ) ) ; } else { throw new BuildException ( x . getTargetException ( ) ) ; } } catch ( Exception x ) { throw new BuildException ( x ) ; } } } ; } else { boolean includeProject ; Constructor c ; try { c = reflectedArg . getConstructor ( new Class [ ] { Project . class , String . class } ) ; includeProject = true ; } catch ( NoSuchMethodException nme ) { try { c = reflectedArg . getConstructor ( new Class [ ] { String . class } ) ; includeProject = false ; } catch ( NoSuchMethodException nme2 ) { return null ; } } final boolean finalIncludeProject = includeProject ; final Constructor finalConstructor = c ; return new AttributeSetter ( m ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { Object [ ] args = ( finalIncludeProject ) ? new Object [ ] { p , value } : new Object [ ] { value } ; Object attribute = finalConstructor . newInstance ( args ) ; if ( p != null ) { p . setProjectReference ( attribute ) ; } m . invoke ( parent , new Object [ ] { attribute } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } } protected String getElementName ( Project project , Object element ) { return project . getElementName ( element ) ; } private String getPropertyName ( String methodName , String prefix ) { return methodName . substring ( prefix . length ( ) ) . toLowerCase ( Locale . US ) ; } public static final class Creator { private NestedCreator nestedCreator ; private Object parent ; private Project project ; private Object nestedObject ; private String polyType ; private Creator ( Project project , Object parent , NestedCreator nestedCreator ) { this . project = project ; this . parent = parent ; this . nestedCreator = nestedCreator ; } public void setPolyType ( String polyType ) { this . polyType = polyType ; } public Object create ( ) { if ( polyType != null ) { if ( ! nestedCreator . isPolyMorphic ( ) ) { throw new BuildException ( "Not allowed to use the polymorphic form" + " for this element" ) ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; nestedObject = helper . createComponent ( polyType ) ; if ( nestedObject == null ) { throw new BuildException ( "Unable to create object of type " + polyType ) ; } } try { nestedObject = nestedCreator . create ( project , parent , nestedObject ) ; if ( project != null ) { project . setProjectReference ( nestedObject ) ; } return nestedObject ; } catch ( IllegalAccessException ex ) { throw new BuildException ( ex ) ; } catch ( InstantiationException ex ) { throw new BuildException ( ex ) ; } catch ( IllegalArgumentException ex ) { if ( polyType != null ) { throw new BuildException ( "Invalid type used " + polyType ) ; } throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Object getRealObject ( ) { return nestedCreator . getRealObject ( ) ; } public void store ( ) { try { nestedCreator . store ( parent , nestedObject ) ; } catch ( IllegalAccessException ex ) { throw new BuildException ( ex ) ; } catch ( InstantiationException ex ) { throw new BuildException ( ex ) ; } catch ( IllegalArgumentException ex ) { if ( polyType != null ) { throw new BuildException ( "Invalid type used " + polyType ) ; } throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } } private abstract static class NestedCreator { private Method method ; NestedCreator ( Method m ) { this . method = m ; } Method getMethod ( ) { return method ; } boolean isPolyMorphic ( ) { return false ; } Object getRealObject ( ) { return null ; } abstract Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { } } private class CreateNestedCreator extends NestedCreator { CreateNestedCreator ( Method m ) { super ( m ) ; } Object create ( Project project , Object parent , Object ignore ) throws InvocationTargetException , IllegalAccessException { return getMethod ( ) . invoke ( parent , new Object [ ] { } ) ; } } private class AddNestedCreator extends NestedCreator { static final int ADD = 1 ; static final int ADD_CONFIGURED = 2 ; private Constructor constructor ; private int behavior ; AddNestedCreator ( Method m , Constructor c , int behavior ) { super ( m ) ; this . constructor = c ; this . behavior = behavior ; } boolean isPolyMorphic ( ) { return true ; } Object create ( Project project , Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( child == null ) { child = constructor . newInstance ( ( constructor . getParameterTypes ( ) . length == 0 ) ? new Object [ ] { } : new Object [ ] { project } ) ; } if ( child instanceof PreSetDef . PreSetDefinition ) { child = ( ( PreSetDef . PreSetDefinition ) child ) . createObject ( project ) ; } if ( behavior == ADD ) { istore ( parent , child ) ; } return child ; } void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( behavior == ADD_CONFIGURED ) { istore ( parent , child ) ; } } private void istore ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { getMethod ( ) . invoke ( parent , new Object [ ] { child } ) ; } } private abstract static class AttributeSetter { private Method method ; AttributeSetter ( Method m ) { this . method = m ; } abstract void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException ; } public static void clearCache ( ) { HELPERS . clear ( ) ; } private NestedCreator createAddTypeCreator ( Project project , Object parent , String elementName ) throws BuildException { if ( addTypeMethods . size ( ) == 0 ) { return null ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; Object addedObject = null ; Method addMethod = null ; Class clazz = helper . getComponentClass ( elementName ) ; if ( clazz == null ) { return null ; } addMethod = findMatchingMethod ( clazz , addTypeMethods ) ; if ( addMethod == null ) { return null ; } addedObject = helper . createComponent ( elementName ) ; if ( addedObject == null ) { return null ; } Object rObject = addedObject ; if ( addedObject instanceof PreSetDef . PreSetDefinition ) { rObject = ( ( PreSetDef . PreSetDefinition ) addedObject ) . createObject ( project ) ; } final Object nestedObject = addedObject ; final Object realObject = rObject ; return new NestedCreator ( addMethod ) { Object create ( Project project , Object parent , Object ignore ) throws InvocationTargetException , IllegalAccessException { if ( ! getMethod ( ) . getName ( ) . endsWith ( "Configured" ) ) { getMethod ( ) . invoke ( parent , new Object [ ] { realObject } ) ; } return nestedObject ; } Object getRealObject ( ) { return realObject ; } void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( getMethod ( ) . getName ( ) . endsWith ( "Configured" ) ) { getMethod ( ) . invoke ( parent , new Object [ ] { realObject } ) ; } } } ; } private void insertAddTypeMethod ( Method method ) { Class argClass = method . getParameterTypes ( ) [ 0 ] ; for ( int c = 0 ; c < addTypeMethods . size ( ) ; ++ c ) { Method current = ( Method ) addTypeMethods . get ( c ) ; if ( current . getParameterTypes ( ) [ 0 ] . equals ( argClass ) ) { if ( method . getName ( ) . equals ( "addConfigured" ) ) { addTypeMethods . set ( c , method ) ; } return ; } if ( current . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( argClass ) ) { addTypeMethods . add ( c , method ) ; return ; } } addTypeMethods . add ( method ) ; } private Method findMatchingMethod ( Class paramClass , List methods ) { Class matchedClass = null ; Method matchedMethod = null ; for ( int i = 0 ; i < methods . size ( ) ; ++ i ) { Method method = ( Method ) methods . get ( i ) ; Class methodClass = method . getParameterTypes ( ) [ 0 ] ; if ( methodClass . isAssignableFrom ( paramClass ) ) { if ( matchedClass == null ) { matchedClass = methodClass ; matchedMethod = method ; } else { if ( ! methodClass . isAssignableFrom ( matchedClass ) ) { throw new BuildException ( "ambiguous: types " + matchedClass . getName ( ) + " and " + methodClass . getName ( ) + " match " + paramClass . getName ( ) ) ; } } } } return matchedMethod ; } private String condenseText ( final String text ) { if ( text . length ( ) <= MAX_REPORT_NESTED_TEXT ) { return text ; } int ends = ( MAX_REPORT_NESTED_TEXT - ELLIPSIS . length ( ) ) / 2 ; return new StringBuffer ( text ) . replace ( ends , text . length ( ) - ends , ELLIPSIS ) . toString ( ) ; } } 	1
package org . apache . tools . ant . taskdefs ; public interface XSLTLoggerAware { void setLogger ( XSLTLogger l ) ; } 	0
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileUtils ; public class ChangeLogTask extends AbstractCvsTask { private File usersFile ; private Vector cvsUsers = new Vector ( ) ; private File inputDir ; private File destFile ; private Date startDate ; private Date endDate ; private final Vector filesets = new Vector ( ) ; public void setDir ( final File inputDir ) { this . inputDir = inputDir ; } public void setDestfile ( final File destFile ) { this . destFile = destFile ; } public void setUsersfile ( final File usersFile ) { this . usersFile = usersFile ; } public void addUser ( final CvsUser user ) { cvsUsers . addElement ( user ) ; } public void setStart ( final Date start ) { this . startDate = start ; } public void setEnd ( final Date endDate ) { this . endDate = endDate ; } public void setDaysinpast ( final int days ) { final long time = System . currentTimeMillis ( ) - ( long ) days * 24 * 60 * 60 * 1000 ; setStart ( new Date ( time ) ) ; } public void addFileset ( final FileSet fileSet ) { filesets . addElement ( fileSet ) ; } public void execute ( ) throws BuildException { File savedDir = inputDir ; try { validate ( ) ; final Properties userList = new Properties ( ) ; loadUserlist ( userList ) ; for ( int i = 0 , size = cvsUsers . size ( ) ; i < size ; i ++ ) { final CvsUser user = ( CvsUser ) cvsUsers . get ( i ) ; user . validate ( ) ; userList . put ( user . getUserID ( ) , user . getDisplayname ( ) ) ; } setCommand ( "log" ) ; if ( getTag ( ) != null ) { CvsVersion myCvsVersion = new CvsVersion ( ) ; myCvsVersion . setProject ( getProject ( ) ) ; myCvsVersion . setTaskName ( "cvsversion" ) ; myCvsVersion . setCvsRoot ( getCvsRoot ( ) ) ; myCvsVersion . setCvsRsh ( getCvsRsh ( ) ) ; myCvsVersion . setPassfile ( getPassFile ( ) ) ; myCvsVersion . setDest ( inputDir ) ; myCvsVersion . execute ( ) ; if ( myCvsVersion . supportsCvsLogWithSOption ( ) ) { addCommandArgument ( "-S" ) ; } } if ( null != startDate ) { final SimpleDateFormat outputDate = new SimpleDateFormat ( "yyyy-MM-dd" ) ; final String dateRange = ">=" + outputDate . format ( startDate ) ; addCommandArgument ( "-d" ) ; addCommandArgument ( dateRange ) ; } if ( ! filesets . isEmpty ( ) ) { final Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { final FileSet fileSet = ( FileSet ) e . nextElement ( ) ; final DirectoryScanner scanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; final String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { addCommandArgument ( files [ i ] ) ; } } } final ChangeLogParser parser = new ChangeLogParser ( ) ; final RedirectingStreamHandler handler = new RedirectingStreamHandler ( parser ) ; log ( getCommand ( ) , Project . MSG_VERBOSE ) ; setDest ( inputDir ) ; setExecuteStreamHandler ( handler ) ; try { super . execute ( ) ; } finally { final String errors = handler . getErrors ( ) ; if ( null != errors ) { log ( errors , Project . MSG_ERR ) ; } } final CVSEntry [ ] entrySet = parser . getEntrySetAsArray ( ) ; final CVSEntry [ ] filteredEntrySet = filterEntrySet ( entrySet ) ; replaceAuthorIdWithName ( userList , filteredEntrySet ) ; writeChangeLog ( filteredEntrySet ) ; } finally { inputDir = savedDir ; } } private void validate ( ) throws BuildException { if ( null == inputDir ) { inputDir = getProject ( ) . getBaseDir ( ) ; } if ( null == destFile ) { final String message = "Destfile must be set." ; throw new BuildException ( message ) ; } if ( ! inputDir . exists ( ) ) { final String message = "Cannot find base dir " + inputDir . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } if ( null != usersFile && ! usersFile . exists ( ) ) { final String message = "Cannot find user lookup list " + usersFile . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } } private void loadUserlist ( final Properties userList ) throws BuildException { if ( null != usersFile ) { try { userList . load ( new FileInputStream ( usersFile ) ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } } } private CVSEntry [ ] filterEntrySet ( final CVSEntry [ ] entrySet ) { final Vector results = new Vector ( ) ; for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry cvsEntry = entrySet [ i ] ; final Date date = cvsEntry . getDate ( ) ; if ( null == date ) { continue ; } if ( null != startDate && startDate . after ( date ) ) { continue ; } if ( null != endDate && endDate . before ( date ) ) { continue ; } results . addElement ( cvsEntry ) ; } final CVSEntry [ ] resultArray = new CVSEntry [ results . size ( ) ] ; results . copyInto ( resultArray ) ; return resultArray ; } private void replaceAuthorIdWithName ( final Properties userList , final CVSEntry [ ] entrySet ) { for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry entry = entrySet [ i ] ; if ( userList . containsKey ( entry . getAuthor ( ) ) ) { entry . setAuthor ( userList . getProperty ( entry . getAuthor ( ) ) ) ; } } } private void writeChangeLog ( final CVSEntry [ ] entrySet ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( destFile ) ; final PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; final ChangeLogWriter serializer = new ChangeLogWriter ( ) ; serializer . printChangeLog ( writer , entrySet ) ; } catch ( final UnsupportedEncodingException uee ) { getProject ( ) . log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { FileUtils . close ( output ) ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class FieldRefCPInfo extends ConstantPoolEntry { private String fieldClassName ; private String fieldName ; private String fieldType ; private int classIndex ; private int nameAndTypeIndex ; public FieldRefCPInfo ( ) { super ( CONSTANT_FIELDREF , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { classIndex = cpStream . readUnsignedShort ( ) ; nameAndTypeIndex = cpStream . readUnsignedShort ( ) ; } public void resolve ( ConstantPool constantPool ) { ClassCPInfo fieldClass = ( ClassCPInfo ) constantPool . getEntry ( classIndex ) ; fieldClass . resolve ( constantPool ) ; fieldClassName = fieldClass . getClassName ( ) ; NameAndTypeCPInfo nt = ( NameAndTypeCPInfo ) constantPool . getEntry ( nameAndTypeIndex ) ; nt . resolve ( constantPool ) ; fieldName = nt . getName ( ) ; fieldType = nt . getType ( ) ; super . resolve ( constantPool ) ; } public String toString ( ) { String value ; if ( isResolved ( ) ) { value = "Field : Class = " + fieldClassName + ", name = " + fieldName + ", type = " + fieldType ; } else { value = "Field : Class index = " + classIndex + ", name and type index = " + nameAndTypeIndex ; } return value ; } public String getFieldClassName ( ) { return fieldClassName ; } public String getFieldName ( ) { return fieldName ; } public String getFieldType ( ) { return fieldType ; } } 	0
package org . apache . tools . ant . taskdefs . cvslib ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . TimeZone ; class ChangeLogParser { private static final int GET_FILE = 1 ; private static final int GET_DATE = 2 ; private static final int GET_COMMENT = 3 ; private static final int GET_REVISION = 4 ; private static final int GET_PREVIOUS_REV = 5 ; private static final SimpleDateFormat INPUT_DATE = new SimpleDateFormat ( "yyyy/MM/dd HH:mm:ss" , Locale . US ) ; private static final SimpleDateFormat CVS1129_INPUT_DATE = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss Z" , Locale . US ) ; static { TimeZone utc = TimeZone . getTimeZone ( "UTC" ) ; INPUT_DATE . setTimeZone ( utc ) ; CVS1129_INPUT_DATE . setTimeZone ( utc ) ; } private String file ; private String date ; private String author ; private String comment ; private String revision ; private String previousRevision ; private int status = GET_FILE ; private final Hashtable entries = new Hashtable ( ) ; public CVSEntry [ ] getEntrySetAsArray ( ) { final CVSEntry [ ] array = new CVSEntry [ entries . size ( ) ] ; int i = 0 ; for ( Enumeration e = entries . elements ( ) ; e . hasMoreElements ( ) ; ) { array [ i ++ ] = ( CVSEntry ) e . nextElement ( ) ; } return array ; } public void stdout ( final String line ) { switch ( status ) { case GET_FILE : reset ( ) ; processFile ( line ) ; break ; case GET_REVISION : processRevision ( line ) ; break ; case GET_DATE : processDate ( line ) ; break ; case GET_COMMENT : processComment ( line ) ; break ; case GET_PREVIOUS_REV : processGetPreviousRevision ( line ) ; break ; default : break ; } } private void processComment ( final String line ) { final String lineSeparator = System . getProperty ( "line.separator" ) ; if ( line . equals ( "=============================================================================" ) ) { final int end = comment . length ( ) - lineSeparator . length ( ) ; comment = comment . substring ( 0 , end ) ; saveEntry ( ) ; status = GET_FILE ; } else if ( line . equals ( "----------------------------" ) ) { final int end = comment . length ( ) - lineSeparator . length ( ) ; comment = comment . substring ( 0 , end ) ; status = GET_PREVIOUS_REV ; } else { comment += line + lineSeparator ; } } private void processFile ( final String line ) { if ( line . startsWith ( "Working file:" ) ) { file = line . substring ( 14 , line . length ( ) ) ; status = GET_REVISION ; } } private void processRevision ( final String line ) { if ( line . startsWith ( "revision" ) ) { revision = line . substring ( 9 ) ; status = GET_DATE ; } else if ( line . startsWith ( "======" ) ) { status = GET_FILE ; } } private void processDate ( final String line ) { if ( line . startsWith ( "date:" ) ) { int endOfDateIndex = line . indexOf ( ';' ) ; date = line . substring ( "date: " . length ( ) , endOfDateIndex ) ; int startOfAuthorIndex = line . indexOf ( "author: " , endOfDateIndex + 1 ) ; int endOfAuthorIndex = line . indexOf ( ';' , startOfAuthorIndex + 1 ) ; author = line . substring ( "author: " . length ( ) + startOfAuthorIndex , endOfAuthorIndex ) ; status = GET_COMMENT ; comment = "" ; } } private void processGetPreviousRevision ( final String line ) { if ( ! line . startsWith ( "revision " ) ) { throw new IllegalStateException ( "Unexpected line from CVS: " + line ) ; } previousRevision = line . substring ( "revision " . length ( ) ) ; saveEntry ( ) ; revision = previousRevision ; status = GET_DATE ; } private void saveEntry ( ) { final String entryKey = date + author + comment ; CVSEntry entry ; if ( ! entries . containsKey ( entryKey ) ) { Date dateObject = parseDate ( date ) ; entry = new CVSEntry ( dateObject , author , comment ) ; entries . put ( entryKey , entry ) ; } else { entry = ( CVSEntry ) entries . get ( entryKey ) ; } entry . addFile ( file , revision , previousRevision ) ; } private Date parseDate ( final String date ) { try { return INPUT_DATE . parse ( date ) ; } catch ( ParseException e ) { try { return CVS1129_INPUT_DATE . parse ( date ) ; } catch ( ParseException e2 ) { throw new IllegalStateException ( "Invalid date format: " + date ) ; } } } public void reset ( ) { this . file = null ; this . date = null ; this . author = null ; this . comment = null ; this . revision = null ; this . previousRevision = null ; } } 	1
package org . apache . tools . ant . dispatch ; public interface Dispatchable { String getActionParameterName ( ) ; } 	0
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . DOMUtils ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class CvsTagDiff extends AbstractCvsTask { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final DOMElementWriter DOM_WRITER = new DOMElementWriter ( ) ; static final String FILE_STRING = "File " ; static final String TO_STRING = " to " ; static final String FILE_IS_NEW = " is new;" ; static final String REVISION = "revision " ; static final String FILE_HAS_CHANGED = " changed from revision " ; static final String FILE_WAS_REMOVED = " is removed" ; private String mypackage ; private String mystartTag ; private String myendTag ; private String mystartDate ; private String myendDate ; private File mydestfile ; public void setPackage ( String p ) { mypackage = p ; } public void setStartTag ( String s ) { mystartTag = s ; } public void setStartDate ( String s ) { mystartDate = s ; } public void setEndTag ( String s ) { myendTag = s ; } public void setEndDate ( String s ) { myendDate = s ; } public void setDestFile ( File f ) { mydestfile = f ; } public void execute ( ) throws BuildException { validate ( ) ; addCommandArgument ( "rdiff" ) ; addCommandArgument ( "-s" ) ; if ( mystartTag != null ) { addCommandArgument ( "-r" ) ; addCommandArgument ( mystartTag ) ; } else { addCommandArgument ( "-D" ) ; addCommandArgument ( mystartDate ) ; } if ( myendTag != null ) { addCommandArgument ( "-r" ) ; addCommandArgument ( myendTag ) ; } else { addCommandArgument ( "-D" ) ; addCommandArgument ( myendDate ) ; } StringTokenizer myTokenizer = new StringTokenizer ( mypackage ) ; while ( myTokenizer . hasMoreTokens ( ) ) { addCommandArgument ( myTokenizer . nextToken ( ) ) ; } setCommand ( "" ) ; File tmpFile = null ; try { tmpFile = FILE_UTILS . createTempFile ( "cvstagdiff" , ".log" , null ) ; tmpFile . deleteOnExit ( ) ; setOutput ( tmpFile ) ; super . execute ( ) ; CvsTagEntry [ ] entries = parseRDiff ( tmpFile ) ; writeTagDiff ( entries ) ; } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private CvsTagEntry [ ] parseRDiff ( File tmpFile ) throws BuildException { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( tmpFile ) ) ; String toBeRemoved = FILE_STRING + mypackage + "/" ; int headerLength = toBeRemoved . length ( ) ; Vector entries = new Vector ( ) ; String line = reader . readLine ( ) ; int index ; CvsTagEntry entry = null ; while ( null != line ) { if ( line . length ( ) > headerLength ) { if ( line . startsWith ( toBeRemoved ) ) { line = line . substring ( headerLength ) ; } else { line = line . substring ( FILE_STRING . length ( ) ) ; } if ( ( index = line . indexOf ( FILE_IS_NEW ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = null ; int indexrev = - 1 ; if ( ( indexrev = line . indexOf ( REVISION , index ) ) != - 1 ) { rev = line . substring ( indexrev + REVISION . length ( ) ) ; } entry = new CvsTagEntry ( filename , rev ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_HAS_CHANGED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; int revSeparator = line . indexOf ( " to " , index ) ; String prevRevision = line . substring ( index + FILE_HAS_CHANGED . length ( ) , revSeparator ) ; String revision = line . substring ( revSeparator + TO_STRING . length ( ) ) ; entry = new CvsTagEntry ( filename , revision , prevRevision ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_WAS_REMOVED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = null ; int indexrev = - 1 ; if ( ( indexrev = line . indexOf ( REVISION , index ) ) != - 1 ) { rev = line . substring ( indexrev + REVISION . length ( ) ) ; } entry = new CvsTagEntry ( filename , null , rev ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } } line = reader . readLine ( ) ; } CvsTagEntry [ ] array = new CvsTagEntry [ entries . size ( ) ] ; entries . copyInto ( array ) ; return array ; } catch ( IOException e ) { throw new BuildException ( "Error in parsing" , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; } } } } private void writeTagDiff ( CvsTagEntry [ ] entries ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( mydestfile ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; writer . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; Document doc = DOMUtils . newDocument ( ) ; Element root = doc . createElement ( "tagdiff" ) ; if ( mystartTag != null ) { root . setAttribute ( "startTag" , mystartTag ) ; } else { root . setAttribute ( "startDate" , mystartDate ) ; } if ( myendTag != null ) { root . setAttribute ( "endTag" , myendTag ) ; } else { root . setAttribute ( "endDate" , myendDate ) ; } root . setAttribute ( "cvsroot" , getCvsRoot ( ) ) ; root . setAttribute ( "package" , mypackage ) ; DOM_WRITER . openElement ( root , writer , 0 , "\t" ) ; writer . println ( ) ; for ( int i = 0 , c = entries . length ; i < c ; i ++ ) { writeTagEntry ( doc , writer , entries [ i ] ) ; } DOM_WRITER . closeElement ( root , writer , 0 , "\t" , true ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( UnsupportedEncodingException uee ) { log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( IOException ioe ) { log ( ioe . toString ( ) , Project . MSG_ERR ) ; } } } } private void writeTagEntry ( Document doc , PrintWriter writer , CvsTagEntry entry ) throws IOException { Element ent = doc . createElement ( "entry" ) ; Element f = DOMUtils . createChildElement ( ent , "file" ) ; DOMUtils . appendCDATAElement ( f , "name" , entry . getFile ( ) ) ; if ( entry . getRevision ( ) != null ) { DOMUtils . appendTextElement ( f , "revision" , entry . getRevision ( ) ) ; } if ( entry . getPreviousRevision ( ) != null ) { DOMUtils . appendTextElement ( f , "prevrevision" , entry . getPreviousRevision ( ) ) ; } DOM_WRITER . write ( ent , writer , 1 , "\t" ) ; } private void validate ( ) throws BuildException { if ( null == mypackage ) { throw new BuildException ( "Package/module must be set." ) ; } if ( null == mydestfile ) { throw new BuildException ( "Destfile must be set." ) ; } if ( null == mystartTag && null == mystartDate ) { throw new BuildException ( "Start tag or start date must be set." ) ; } if ( null != mystartTag && null != mystartDate ) { throw new BuildException ( "Only one of start tag and start date " + "must be set." ) ; } if ( null == myendTag && null == myendDate ) { throw new BuildException ( "End tag or end date must be set." ) ; } if ( null != myendTag && null != myendDate ) { throw new BuildException ( "Only one of end tag and end date must " + "be set." ) ; } } } 	1
package org . apache . tools . bzip2 ; import java . io . OutputStream ; import java . io . IOException ; public class CBZip2OutputStream extends OutputStream implements BZip2Constants { public static final int MIN_BLOCKSIZE = 1 ; public static final int MAX_BLOCKSIZE = 9 ; protected static final int SETMASK = ( 1 << 21 ) ; protected static final int CLEARMASK = ( ~ SETMASK ) ; protected static final int GREATER_ICOST = 15 ; protected static final int LESSER_ICOST = 0 ; protected static final int SMALL_THRESH = 20 ; protected static final int DEPTH_THRESH = 10 ; protected static final int WORK_FACTOR = 30 ; protected static final int QSORT_STACK_SIZE = 1000 ; private static final int [ ] INCS = { 1 , 4 , 13 , 40 , 121 , 364 , 1093 , 3280 , 9841 , 29524 , 88573 , 265720 , 797161 , 2391484 } ; protected static void hbMakeCodeLengths ( char [ ] len , int [ ] freq , int alphaSize , int maxLen ) { final int [ ] heap = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] weight = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] parent = new int [ MAX_ALPHA_SIZE * 2 ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { weight [ i + 1 ] = ( freq [ i ] == 0 ? 1 : freq [ i ] ) << 8 ; } for ( boolean tooLong = true ; tooLong ; ) { tooLong = false ; int nNodes = alphaSize ; int nHeap = 0 ; heap [ 0 ] = 0 ; weight [ 0 ] = 0 ; parent [ 0 ] = - 2 ; for ( int i = 1 ; i <= alphaSize ; i ++ ) { parent [ i ] = - 1 ; nHeap ++ ; heap [ nHeap ] = i ; int zz = nHeap ; int tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } while ( nHeap > 1 ) { int n1 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; int yy = 0 ; int zz = 1 ; int tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; int n2 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; yy = 0 ; zz = 1 ; tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; nNodes ++ ; parent [ n1 ] = parent [ n2 ] = nNodes ; final int weight_n1 = weight [ n1 ] ; final int weight_n2 = weight [ n2 ] ; weight [ nNodes ] = ( ( ( weight_n1 & 0xffffff00 ) + ( weight_n2 & 0xffffff00 ) ) | ( 1 + ( ( ( weight_n1 & 0x000000ff ) > ( weight_n2 & 0x000000ff ) ) ? ( weight_n1 & 0x000000ff ) : ( weight_n2 & 0x000000ff ) ) ) ) ; parent [ nNodes ] = - 1 ; nHeap ++ ; heap [ nHeap ] = nNodes ; tmp = 0 ; zz = nHeap ; tmp = heap [ zz ] ; final int weight_tmp = weight [ tmp ] ; while ( weight_tmp < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } for ( int i = 1 ; i <= alphaSize ; i ++ ) { int j = 0 ; int k = i ; for ( int parent_k ; ( parent_k = parent [ k ] ) >= 0 ; ) { k = parent_k ; j ++ ; } len [ i - 1 ] = ( char ) j ; if ( j > maxLen ) { tooLong = true ; } } if ( tooLong ) { for ( int i = 1 ; i < alphaSize ; i ++ ) { int j = weight [ i ] > > 8 ; j = 1 + ( j > > 1 ) ; weight [ i ] = j << 8 ; } } } } private static void hbMakeCodeLengths ( final byte [ ] len , final int [ ] freq , final Data dat , final int alphaSize , final int maxLen ) { final int [ ] heap = dat . heap ; final int [ ] weight = dat . weight ; final int [ ] parent = dat . parent ; for ( int i = alphaSize ; -- i >= 0 ; ) { weight [ i + 1 ] = ( freq [ i ] == 0 ? 1 : freq [ i ] ) << 8 ; } for ( boolean tooLong = true ; tooLong ; ) { tooLong = false ; int nNodes = alphaSize ; int nHeap = 0 ; heap [ 0 ] = 0 ; weight [ 0 ] = 0 ; parent [ 0 ] = - 2 ; for ( int i = 1 ; i <= alphaSize ; i ++ ) { parent [ i ] = - 1 ; nHeap ++ ; heap [ nHeap ] = i ; int zz = nHeap ; int tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } while ( nHeap > 1 ) { int n1 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; int yy = 0 ; int zz = 1 ; int tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; int n2 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; yy = 0 ; zz = 1 ; tmp = heap [ 1 ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( ( yy < nHeap ) && ( weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; nNodes ++ ; parent [ n1 ] = parent [ n2 ] = nNodes ; final int weight_n1 = weight [ n1 ] ; final int weight_n2 = weight [ n2 ] ; weight [ nNodes ] = ( ( weight_n1 & 0xffffff00 ) + ( weight_n2 & 0xffffff00 ) ) | ( 1 + ( ( ( weight_n1 & 0x000000ff ) > ( weight_n2 & 0x000000ff ) ) ? ( weight_n1 & 0x000000ff ) : ( weight_n2 & 0x000000ff ) ) ) ; parent [ nNodes ] = - 1 ; nHeap ++ ; heap [ nHeap ] = nNodes ; tmp = 0 ; zz = nHeap ; tmp = heap [ zz ] ; final int weight_tmp = weight [ tmp ] ; while ( weight_tmp < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } for ( int i = 1 ; i <= alphaSize ; i ++ ) { int j = 0 ; int k = i ; for ( int parent_k ; ( parent_k = parent [ k ] ) >= 0 ; ) { k = parent_k ; j ++ ; } len [ i - 1 ] = ( byte ) j ; if ( j > maxLen ) { tooLong = true ; } } if ( tooLong ) { for ( int i = 1 ; i < alphaSize ; i ++ ) { int j = weight [ i ] > > 8 ; j = 1 + ( j > > 1 ) ; weight [ i ] = j << 8 ; } } } } private int last ; private int origPtr ; private final int blockSize100k ; private boolean blockRandomised ; private int bsBuff ; private int bsLive ; private final CRC crc = new CRC ( ) ; private int nInUse ; private int nMTF ; private int workDone ; private int workLimit ; private boolean firstAttempt ; private int currentChar = - 1 ; private int runLength = 0 ; private int blockCRC ; private int combinedCRC ; private int allowableBlockSize ; private CBZip2OutputStream . Data data ; private OutputStream out ; public static int chooseBlockSize ( long inputLength ) { return ( inputLength > 0 ) ? ( int ) Math . min ( ( inputLength / 132000 ) + 1 , 9 ) : MAX_BLOCKSIZE ; } public CBZip2OutputStream ( final OutputStream out ) throws IOException { this ( out , MAX_BLOCKSIZE ) ; } public CBZip2OutputStream ( final OutputStream out , final int blockSize ) throws IOException { super ( ) ; if ( blockSize < 1 ) { throw new IllegalArgumentException ( "blockSize(" + blockSize + ") < 1" ) ; } if ( blockSize > 9 ) { throw new IllegalArgumentException ( "blockSize(" + blockSize + ") > 9" ) ; } this . blockSize100k = blockSize ; this . out = out ; init ( ) ; } public void write ( final int b ) throws IOException { if ( this . out != null ) { write0 ( b ) ; } else { throw new IOException ( "closed" ) ; } } private void writeRun ( ) throws IOException { final int lastShadow = this . last ; if ( lastShadow < this . allowableBlockSize ) { final int currentCharShadow = this . currentChar ; final Data dataShadow = this . data ; dataShadow . inUse [ currentCharShadow ] = true ; final byte ch = ( byte ) currentCharShadow ; int runLengthShadow = this . runLength ; this . crc . updateCRC ( currentCharShadow , runLengthShadow ) ; switch ( runLengthShadow ) { case 1 : dataShadow . block [ lastShadow + 2 ] = ch ; this . last = lastShadow + 1 ; break ; case 2 : dataShadow . block [ lastShadow + 2 ] = ch ; dataShadow . block [ lastShadow + 3 ] = ch ; this . last = lastShadow + 2 ; break ; case 3 : { final byte [ ] block = dataShadow . block ; block [ lastShadow + 2 ] = ch ; block [ lastShadow + 3 ] = ch ; block [ lastShadow + 4 ] = ch ; this . last = lastShadow + 3 ; } break ; default : { runLengthShadow -= 4 ; dataShadow . inUse [ runLengthShadow ] = true ; final byte [ ] block = dataShadow . block ; block [ lastShadow + 2 ] = ch ; block [ lastShadow + 3 ] = ch ; block [ lastShadow + 4 ] = ch ; block [ lastShadow + 5 ] = ch ; block [ lastShadow + 6 ] = ( byte ) runLengthShadow ; this . last = lastShadow + 5 ; } break ; } } else { endBlock ( ) ; initBlock ( ) ; writeRun ( ) ; } } protected void finalize ( ) throws Throwable { close ( ) ; super . finalize ( ) ; } public void close ( ) throws IOException { OutputStream outShadow = this . out ; if ( outShadow != null ) { try { if ( this . runLength > 0 ) { writeRun ( ) ; } this . currentChar = - 1 ; endBlock ( ) ; endCompression ( ) ; outShadow . close ( ) ; } finally { this . out = null ; this . data = null ; } } } public void flush ( ) throws IOException { OutputStream outShadow = this . out ; if ( outShadow != null ) { outShadow . flush ( ) ; } } private void init ( ) throws IOException { this . data = new Data ( this . blockSize100k ) ; bsPutUByte ( 'h' ) ; bsPutUByte ( '0' + this . blockSize100k ) ; this . combinedCRC = 0 ; initBlock ( ) ; } private void initBlock ( ) { this . crc . initialiseCRC ( ) ; this . last = - 1 ; boolean [ ] inUse = this . data . inUse ; for ( int i = 256 ; -- i >= 0 ; ) { inUse [ i ] = false ; } this . allowableBlockSize = ( this . blockSize100k * BZip2Constants . baseBlockSize ) - 20 ; } private void endBlock ( ) throws IOException { this . blockCRC = this . crc . getFinalCRC ( ) ; this . combinedCRC = ( this . combinedCRC << 1 ) | ( this . combinedCRC > > > 31 ) ; this . combinedCRC ^= this . blockCRC ; if ( this . last == - 1 ) { return ; } blockSort ( ) ; bsPutUByte ( 0x31 ) ; bsPutUByte ( 0x41 ) ; bsPutUByte ( 0x59 ) ; bsPutUByte ( 0x26 ) ; bsPutUByte ( 0x53 ) ; bsPutUByte ( 0x59 ) ; bsPutInt ( this . blockCRC ) ; if ( this . blockRandomised ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } moveToFrontCodeAndSend ( ) ; } private void endCompression ( ) throws IOException { bsPutUByte ( 0x17 ) ; bsPutUByte ( 0x72 ) ; bsPutUByte ( 0x45 ) ; bsPutUByte ( 0x38 ) ; bsPutUByte ( 0x50 ) ; bsPutUByte ( 0x90 ) ; bsPutInt ( this . combinedCRC ) ; bsFinishedWithStream ( ) ; } public final int getBlockSize ( ) { return this . blockSize100k ; } public void write ( final byte [ ] buf , int offs , final int len ) throws IOException { if ( offs < 0 ) { throw new IndexOutOfBoundsException ( "offs(" + offs + ") < 0." ) ; } if ( len < 0 ) { throw new IndexOutOfBoundsException ( "len(" + len + ") < 0." ) ; } if ( offs + len > buf . length ) { throw new IndexOutOfBoundsException ( "offs(" + offs + ") + len(" + len + ") > buf.length(" + buf . length + ")." ) ; } if ( this . out == null ) { throw new IOException ( "stream closed" ) ; } for ( int hi = offs + len ; offs < hi ; ) { write0 ( buf [ offs ++ ] ) ; } } private void write0 ( int b ) throws IOException { if ( this . currentChar != - 1 ) { b &= 0xff ; if ( this . currentChar == b ) { if ( ++ this . runLength > 254 ) { writeRun ( ) ; this . currentChar = - 1 ; this . runLength = 0 ; } } else { writeRun ( ) ; this . runLength = 1 ; this . currentChar = b ; } } else { this . currentChar = b & 0xff ; this . runLength ++ ; } } private static void hbAssignCodes ( final int [ ] code , final byte [ ] length , final int minLen , final int maxLen , final int alphaSize ) { int vec = 0 ; for ( int n = minLen ; n <= maxLen ; n ++ ) { for ( int i = 0 ; i < alphaSize ; i ++ ) { if ( ( length [ i ] & 0xff ) == n ) { code [ i ] = vec ; vec ++ ; } } vec <<= 1 ; } } private void bsFinishedWithStream ( ) throws IOException { while ( this . bsLive > 0 ) { int ch = this . bsBuff > > 24 ; this . out . write ( ch ) ; this . bsBuff <<= 8 ; this . bsLive -= 8 ; } } private void bsW ( final int n , final int v ) throws IOException { final OutputStream outShadow = this . out ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } this . bsBuff = bsBuffShadow | ( v << ( 32 - bsLiveShadow - n ) ) ; this . bsLive = bsLiveShadow + n ; } private void bsPutUByte ( final int c ) throws IOException { bsW ( 8 , c ) ; } private void bsPutInt ( final int u ) throws IOException { bsW ( 8 , ( u > > 24 ) & 0xff ) ; bsW ( 8 , ( u > > 16 ) & 0xff ) ; bsW ( 8 , ( u > > 8 ) & 0xff ) ; bsW ( 8 , u & 0xff ) ; } private void sendMTFValues ( ) throws IOException { final byte [ ] [ ] len = this . data . sendMTFValues_len ; final int alphaSize = this . nInUse + 2 ; for ( int t = N_GROUPS ; -- t >= 0 ; ) { byte [ ] len_t = len [ t ] ; for ( int v = alphaSize ; -- v >= 0 ; ) { len_t [ v ] = GREATER_ICOST ; } } final int nGroups = ( this . nMTF < 200 ) ? 2 : ( this . nMTF < 600 ) ? 3 : ( this . nMTF < 1200 ) ? 4 : ( this . nMTF < 2400 ) ? 5 : 6 ; sendMTFValues0 ( nGroups , alphaSize ) ; final int nSelectors = sendMTFValues1 ( nGroups , alphaSize ) ; sendMTFValues2 ( nGroups , nSelectors ) ; sendMTFValues3 ( nGroups , alphaSize ) ; sendMTFValues4 ( ) ; sendMTFValues5 ( nGroups , nSelectors ) ; sendMTFValues6 ( nGroups , alphaSize ) ; sendMTFValues7 ( nSelectors ) ; } private void sendMTFValues0 ( final int nGroups , final int alphaSize ) { final byte [ ] [ ] len = this . data . sendMTFValues_len ; final int [ ] mtfFreq = this . data . mtfFreq ; int remF = this . nMTF ; int gs = 0 ; for ( int nPart = nGroups ; nPart > 0 ; nPart -- ) { final int tFreq = remF / nPart ; int ge = gs - 1 ; int aFreq = 0 ; for ( final int a = alphaSize - 1 ; ( aFreq < tFreq ) && ( ge < a ) ; ) { aFreq += mtfFreq [ ++ ge ] ; } if ( ( ge > gs ) && ( nPart != nGroups ) && ( nPart != 1 ) && ( ( ( nGroups - nPart ) & 1 ) != 0 ) ) { aFreq -= mtfFreq [ ge -- ] ; } final byte [ ] len_np = len [ nPart - 1 ] ; for ( int v = alphaSize ; -- v >= 0 ; ) { if ( ( v >= gs ) && ( v <= ge ) ) { len_np [ v ] = LESSER_ICOST ; } else { len_np [ v ] = GREATER_ICOST ; } } gs = ge + 1 ; remF -= aFreq ; } } private int sendMTFValues1 ( final int nGroups , final int alphaSize ) { final Data dataShadow = this . data ; final int [ ] [ ] rfreq = dataShadow . sendMTFValues_rfreq ; final int [ ] fave = dataShadow . sendMTFValues_fave ; final short [ ] cost = dataShadow . sendMTFValues_cost ; final char [ ] sfmap = dataShadow . sfmap ; final byte [ ] selector = dataShadow . selector ; final byte [ ] [ ] len = dataShadow . sendMTFValues_len ; final byte [ ] len_0 = len [ 0 ] ; final byte [ ] len_1 = len [ 1 ] ; final byte [ ] len_2 = len [ 2 ] ; final byte [ ] len_3 = len [ 3 ] ; final byte [ ] len_4 = len [ 4 ] ; final byte [ ] len_5 = len [ 5 ] ; final int nMTFShadow = this . nMTF ; int nSelectors = 0 ; for ( int iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( int t = nGroups ; -- t >= 0 ; ) { fave [ t ] = 0 ; int [ ] rfreqt = rfreq [ t ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { rfreqt [ i ] = 0 ; } } nSelectors = 0 ; for ( int gs = 0 ; gs < this . nMTF ; ) { final int ge = Math . min ( gs + G_SIZE - 1 , nMTFShadow - 1 ) ; if ( nGroups == N_GROUPS ) { short cost0 = 0 ; short cost1 = 0 ; short cost2 = 0 ; short cost3 = 0 ; short cost4 = 0 ; short cost5 = 0 ; for ( int i = gs ; i <= ge ; i ++ ) { final int icv = sfmap [ i ] ; cost0 += len_0 [ icv ] & 0xff ; cost1 += len_1 [ icv ] & 0xff ; cost2 += len_2 [ icv ] & 0xff ; cost3 += len_3 [ icv ] & 0xff ; cost4 += len_4 [ icv ] & 0xff ; cost5 += len_5 [ icv ] & 0xff ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( int t = nGroups ; -- t >= 0 ; ) { cost [ t ] = 0 ; } for ( int i = gs ; i <= ge ; i ++ ) { final int icv = sfmap [ i ] ; for ( int t = nGroups ; -- t >= 0 ; ) { cost [ t ] += len [ t ] [ icv ] & 0xff ; } } } int bt = - 1 ; for ( int t = nGroups , bc = 999999999 ; -- t >= 0 ; ) { final int cost_t = cost [ t ] ; if ( cost_t < bc ) { bc = cost_t ; bt = t ; } } fave [ bt ] ++ ; selector [ nSelectors ] = ( byte ) bt ; nSelectors ++ ; final int [ ] rfreq_bt = rfreq [ bt ] ; for ( int i = gs ; i <= ge ; i ++ ) { rfreq_bt [ sfmap [ i ] ] ++ ; } gs = ge + 1 ; } for ( int t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , this . data , alphaSize , 20 ) ; } } return nSelectors ; } private void sendMTFValues2 ( final int nGroups , final int nSelectors ) { final Data dataShadow = this . data ; byte [ ] pos = dataShadow . sendMTFValues2_pos ; for ( int i = nGroups ; -- i >= 0 ; ) { pos [ i ] = ( byte ) i ; } for ( int i = 0 ; i < nSelectors ; i ++ ) { final byte ll_i = dataShadow . selector [ i ] ; byte tmp = pos [ 0 ] ; int j = 0 ; while ( ll_i != tmp ) { j ++ ; byte tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; dataShadow . selectorMtf [ i ] = ( byte ) j ; } } private void sendMTFValues3 ( final int nGroups , final int alphaSize ) { int [ ] [ ] code = this . data . sendMTFValues_code ; byte [ ] [ ] len = this . data . sendMTFValues_len ; for ( int t = 0 ; t < nGroups ; t ++ ) { int minLen = 32 ; int maxLen = 0 ; final byte [ ] len_t = len [ t ] ; for ( int i = alphaSize ; -- i >= 0 ; ) { final int l = len_t [ i ] & 0xff ; if ( l > maxLen ) { maxLen = l ; } if ( l < minLen ) { minLen = l ; } } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } } private void sendMTFValues4 ( ) throws IOException { final boolean [ ] inUse = this . data . inUse ; final boolean [ ] inUse16 = this . data . sentMTFValues4_inUse16 ; for ( int i = 16 ; -- i >= 0 ; ) { inUse16 [ i ] = false ; final int i16 = i * 16 ; for ( int j = 16 ; -- j >= 0 ; ) { if ( inUse [ i16 + j ] ) { inUse16 [ i ] = true ; } } } for ( int i = 0 ; i < 16 ; i ++ ) { bsW ( 1 , inUse16 [ i ] ? 1 : 0 ) ; } final OutputStream outShadow = this . out ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { final int i16 = i * 16 ; for ( int j = 0 ; j < 16 ; j ++ ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } if ( inUse [ i16 + j ] ) { bsBuffShadow |= 1 << ( 32 - bsLiveShadow - 1 ) ; } bsLiveShadow ++ ; } } } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void sendMTFValues5 ( final int nGroups , final int nSelectors ) throws IOException { bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; final OutputStream outShadow = this . out ; final byte [ ] selectorMtf = this . data . selectorMtf ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int i = 0 ; i < nSelectors ; i ++ ) { for ( int j = 0 , hj = selectorMtf [ i ] & 0xff ; j < hj ; j ++ ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= 1 << ( 32 - bsLiveShadow - 1 ) ; bsLiveShadow ++ ; } while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsLiveShadow ++ ; } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void sendMTFValues6 ( final int nGroups , final int alphaSize ) throws IOException { final byte [ ] [ ] len = this . data . sendMTFValues_len ; final OutputStream outShadow = this . out ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int t = 0 ; t < nGroups ; t ++ ) { byte [ ] len_t = len [ t ] ; int curr = len_t [ 0 ] & 0xff ; while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= curr << ( 32 - bsLiveShadow - 5 ) ; bsLiveShadow += 5 ; for ( int i = 0 ; i < alphaSize ; i ++ ) { int lti = len_t [ i ] & 0xff ; while ( curr < lti ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= 2 << ( 32 - bsLiveShadow - 2 ) ; bsLiveShadow += 2 ; curr ++ ; } while ( curr > lti ) { while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsBuffShadow |= 3 << ( 32 - bsLiveShadow - 2 ) ; bsLiveShadow += 2 ; curr -- ; } while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } bsLiveShadow ++ ; } } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void sendMTFValues7 ( final int nSelectors ) throws IOException { final Data dataShadow = this . data ; final byte [ ] [ ] len = dataShadow . sendMTFValues_len ; final int [ ] [ ] code = dataShadow . sendMTFValues_code ; final OutputStream outShadow = this . out ; final byte [ ] selector = dataShadow . selector ; final char [ ] sfmap = dataShadow . sfmap ; final int nMTFShadow = this . nMTF ; int selCtr = 0 ; int bsLiveShadow = this . bsLive ; int bsBuffShadow = this . bsBuff ; for ( int gs = 0 ; gs < nMTFShadow ; ) { final int ge = Math . min ( gs + G_SIZE - 1 , nMTFShadow - 1 ) ; final int selector_selCtr = selector [ selCtr ] & 0xff ; final int [ ] code_selCtr = code [ selector_selCtr ] ; final byte [ ] len_selCtr = len [ selector_selCtr ] ; while ( gs <= ge ) { final int sfmap_i = sfmap [ gs ] ; while ( bsLiveShadow >= 8 ) { outShadow . write ( bsBuffShadow > > 24 ) ; bsBuffShadow <<= 8 ; bsLiveShadow -= 8 ; } final int n = len_selCtr [ sfmap_i ] & 0xFF ; bsBuffShadow |= code_selCtr [ sfmap_i ] << ( 32 - bsLiveShadow - n ) ; bsLiveShadow += n ; gs ++ ; } gs = ge + 1 ; selCtr ++ ; } this . bsBuff = bsBuffShadow ; this . bsLive = bsLiveShadow ; } private void moveToFrontCodeAndSend ( ) throws IOException { bsW ( 24 , this . origPtr ) ; generateMTFValues ( ) ; sendMTFValues ( ) ; } private boolean mainSimpleSort ( final Data dataShadow , final int lo , final int hi , final int d ) { final int bigN = hi - lo + 1 ; if ( bigN < 2 ) { return this . firstAttempt && ( this . workDone > this . workLimit ) ; } int hp = 0 ; while ( INCS [ hp ] < bigN ) { hp ++ ; } final int [ ] fmap = dataShadow . fmap ; final char [ ] quadrant = dataShadow . quadrant ; final byte [ ] block = dataShadow . block ; final int lastShadow = this . last ; final int lastPlus1 = lastShadow + 1 ; final boolean firstAttemptShadow = this . firstAttempt ; final int workLimitShadow = this . workLimit ; int workDoneShadow = this . workDone ; HP : while ( -- hp >= 0 ) { final int h = INCS [ hp ] ; final int mj = lo + h - 1 ; for ( int i = lo + h ; i <= hi ; ) { for ( int k = 3 ; ( i <= hi ) && ( -- k >= 0 ) ; i ++ ) { final int v = fmap [ i ] ; final int vd = v + d ; int j = i ; boolean onceRunned = false ; int a = 0 ; HAMMER : while ( true ) { if ( onceRunned ) { fmap [ j ] = a ; if ( ( j -= h ) <= mj ) { break HAMMER ; } } else { onceRunned = true ; } a = fmap [ j - h ] ; int i1 = a + d ; int i2 = vd ; if ( block [ i1 + 1 ] == block [ i2 + 1 ] ) { if ( block [ i1 + 2 ] == block [ i2 + 2 ] ) { if ( block [ i1 + 3 ] == block [ i2 + 3 ] ) { if ( block [ i1 + 4 ] == block [ i2 + 4 ] ) { if ( block [ i1 + 5 ] == block [ i2 + 5 ] ) { if ( block [ ( i1 += 6 ) ] == block [ ( i2 += 6 ) ] ) { int x = lastShadow ; X : while ( x > 0 ) { x -= 4 ; if ( block [ i1 + 1 ] == block [ i2 + 1 ] ) { if ( quadrant [ i1 ] == quadrant [ i2 ] ) { if ( block [ i1 + 2 ] == block [ i2 + 2 ] ) { if ( quadrant [ i1 + 1 ] == quadrant [ i2 + 1 ] ) { if ( block [ i1 + 3 ] == block [ i2 + 3 ] ) { if ( quadrant [ i1 + 2 ] == quadrant [ i2 + 2 ] ) { if ( block [ i1 + 4 ] == block [ i2 + 4 ] ) { if ( quadrant [ i1 + 3 ] == quadrant [ i2 + 3 ] ) { if ( ( i1 += 4 ) >= lastPlus1 ) { i1 -= lastPlus1 ; } if ( ( i2 += 4 ) >= lastPlus1 ) { i2 -= lastPlus1 ; } workDoneShadow ++ ; continue X ; } else if ( ( quadrant [ i1 + 3 ] > quadrant [ i2 + 3 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 4 ] & 0xff ) > ( block [ i2 + 4 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( quadrant [ i1 + 2 ] > quadrant [ i2 + 2 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 3 ] & 0xff ) > ( block [ i2 + 3 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( quadrant [ i1 + 1 ] > quadrant [ i2 + 1 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 2 ] & 0xff ) > ( block [ i2 + 2 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( quadrant [ i1 ] > quadrant [ i2 ] ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 1 ] & 0xff ) > ( block [ i2 + 1 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } break HAMMER ; } else { if ( ( block [ i1 ] & 0xff ) > ( block [ i2 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } } else if ( ( block [ i1 + 5 ] & 0xff ) > ( block [ i2 + 5 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 4 ] & 0xff ) > ( block [ i2 + 4 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 3 ] & 0xff ) > ( block [ i2 + 3 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 2 ] & 0xff ) > ( block [ i2 + 2 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } else if ( ( block [ i1 + 1 ] & 0xff ) > ( block [ i2 + 1 ] & 0xff ) ) { continue HAMMER ; } else { break HAMMER ; } } fmap [ j ] = v ; } if ( firstAttemptShadow && ( i <= hi ) && ( workDoneShadow > workLimitShadow ) ) { break HP ; } } } this . workDone = workDoneShadow ; return firstAttemptShadow && ( workDoneShadow > workLimitShadow ) ; } private static void vswap ( int [ ] fmap , int p1 , int p2 , int n ) { n += p1 ; while ( p1 < n ) { int t = fmap [ p1 ] ; fmap [ p1 ++ ] = fmap [ p2 ] ; fmap [ p2 ++ ] = t ; } } private static byte med3 ( byte a , byte b , byte c ) { return ( a < b ) ? ( b < c ? b : a < c ? c : a ) : ( b > c ? b : a > c ? c : a ) ; } private void blockSort ( ) { this . workLimit = WORK_FACTOR * this . last ; this . workDone = 0 ; this . blockRandomised = false ; this . firstAttempt = true ; mainSort ( ) ; if ( this . firstAttempt && ( this . workDone > this . workLimit ) ) { randomiseBlock ( ) ; this . workLimit = this . workDone = 0 ; this . firstAttempt = false ; mainSort ( ) ; } int [ ] fmap = this . data . fmap ; this . origPtr = - 1 ; for ( int i = 0 , lastShadow = this . last ; i <= lastShadow ; i ++ ) { if ( fmap [ i ] == 0 ) { this . origPtr = i ; break ; } } } private void mainQSort3 ( final Data dataShadow , final int loSt , final int hiSt , final int dSt ) { final int [ ] stack_ll = dataShadow . stack_ll ; final int [ ] stack_hh = dataShadow . stack_hh ; final int [ ] stack_dd = dataShadow . stack_dd ; final int [ ] fmap = dataShadow . fmap ; final byte [ ] block = dataShadow . block ; stack_ll [ 0 ] = loSt ; stack_hh [ 0 ] = hiSt ; stack_dd [ 0 ] = dSt ; for ( int sp = 1 ; -- sp >= 0 ; ) { final int lo = stack_ll [ sp ] ; final int hi = stack_hh [ sp ] ; final int d = stack_dd [ sp ] ; if ( ( hi - lo < SMALL_THRESH ) || ( d > DEPTH_THRESH ) ) { if ( mainSimpleSort ( dataShadow , lo , hi , d ) ) { return ; } } else { final int d1 = d + 1 ; final int med = med3 ( block [ fmap [ lo ] + d1 ] , block [ fmap [ hi ] + d1 ] , block [ fmap [ ( lo + hi ) > > 1 ] + d1 ] ) & 0xff ; int unLo = lo ; int unHi = hi ; int ltLo = lo ; int gtHi = hi ; while ( true ) { while ( unLo <= unHi ) { final int n = ( ( int ) block [ fmap [ unLo ] + d1 ] & 0xff ) - med ; if ( n == 0 ) { final int temp = fmap [ unLo ] ; fmap [ unLo ++ ] = fmap [ ltLo ] ; fmap [ ltLo ++ ] = temp ; } else if ( n < 0 ) { unLo ++ ; } else { break ; } } while ( unLo <= unHi ) { final int n = ( ( int ) block [ fmap [ unHi ] + d1 ] & 0xff ) - med ; if ( n == 0 ) { final int temp = fmap [ unHi ] ; fmap [ unHi -- ] = fmap [ gtHi ] ; fmap [ gtHi -- ] = temp ; } else if ( n > 0 ) { unHi -- ; } else { break ; } } if ( unLo <= unHi ) { final int temp = fmap [ unLo ] ; fmap [ unLo ++ ] = fmap [ unHi ] ; fmap [ unHi -- ] = temp ; } else { break ; } } if ( gtHi < ltLo ) { stack_ll [ sp ] = lo ; stack_hh [ sp ] = hi ; stack_dd [ sp ] = d1 ; sp ++ ; } else { int n = ( ( ltLo - lo ) < ( unLo - ltLo ) ) ? ( ltLo - lo ) : ( unLo - ltLo ) ; vswap ( fmap , lo , unLo - n , n ) ; int m = ( ( hi - gtHi ) < ( gtHi - unHi ) ) ? ( hi - gtHi ) : ( gtHi - unHi ) ; vswap ( fmap , unLo , hi - m + 1 , m ) ; n = lo + unLo - ltLo - 1 ; m = hi - ( gtHi - unHi ) + 1 ; stack_ll [ sp ] = lo ; stack_hh [ sp ] = n ; stack_dd [ sp ] = d ; sp ++ ; stack_ll [ sp ] = n + 1 ; stack_hh [ sp ] = m - 1 ; stack_dd [ sp ] = d1 ; sp ++ ; stack_ll [ sp ] = m ; stack_hh [ sp ] = hi ; stack_dd [ sp ] = d ; sp ++ ; } } } } private void mainSort ( ) { final Data dataShadow = this . data ; final int [ ] runningOrder = dataShadow . mainSort_runningOrder ; final int [ ] copy = dataShadow . mainSort_copy ; final boolean [ ] bigDone = dataShadow . mainSort_bigDone ; final int [ ] ftab = dataShadow . ftab ; final byte [ ] block = dataShadow . block ; final int [ ] fmap = dataShadow . fmap ; final char [ ] quadrant = dataShadow . quadrant ; final int lastShadow = this . last ; final int workLimitShadow = this . workLimit ; final boolean firstAttemptShadow = this . firstAttempt ; for ( int i = 65537 ; -- i >= 0 ; ) { ftab [ i ] = 0 ; } for ( int i = 0 ; i < NUM_OVERSHOOT_BYTES ; i ++ ) { block [ lastShadow + i + 2 ] = block [ ( i % ( lastShadow + 1 ) ) + 1 ] ; } for ( int i = lastShadow + NUM_OVERSHOOT_BYTES ; -- i >= 0 ; ) { quadrant [ i ] = 0 ; } block [ 0 ] = block [ lastShadow + 1 ] ; int c1 = block [ 0 ] & 0xff ; for ( int i = 0 ; i <= lastShadow ; i ++ ) { final int c2 = block [ i + 1 ] & 0xff ; ftab [ ( c1 << 8 ) + c2 ] ++ ; c1 = c2 ; } for ( int i = 1 ; i <= 65536 ; i ++ ) ftab [ i ] += ftab [ i - 1 ] ; c1 = block [ 1 ] & 0xff ; for ( int i = 0 ; i < lastShadow ; i ++ ) { final int c2 = block [ i + 2 ] & 0xff ; fmap [ -- ftab [ ( c1 << 8 ) + c2 ] ] = i ; c1 = c2 ; } fmap [ -- ftab [ ( ( block [ lastShadow + 1 ] & 0xff ) << 8 ) + ( block [ 1 ] & 0xff ) ] ] = lastShadow ; for ( int i = 256 ; -- i >= 0 ; ) { bigDone [ i ] = false ; runningOrder [ i ] = i ; } for ( int h = 364 ; h != 1 ; ) { h /= 3 ; for ( int i = h ; i <= 255 ; i ++ ) { final int vv = runningOrder [ i ] ; final int a = ftab [ ( vv + 1 ) << 8 ] - ftab [ vv << 8 ] ; final int b = h - 1 ; int j = i ; for ( int ro = runningOrder [ j - h ] ; ( ftab [ ( ro + 1 ) << 8 ] - ftab [ ro << 8 ] ) > a ; ro = runningOrder [ j - h ] ) { runningOrder [ j ] = ro ; j -= h ; if ( j <= b ) { break ; } } runningOrder [ j ] = vv ; } } for ( int i = 0 ; i <= 255 ; i ++ ) { final int ss = runningOrder [ i ] ; for ( int j = 0 ; j <= 255 ; j ++ ) { final int sb = ( ss << 8 ) + j ; final int ftab_sb = ftab [ sb ] ; if ( ( ftab_sb & SETMASK ) != SETMASK ) { final int lo = ftab_sb & CLEARMASK ; final int hi = ( ftab [ sb + 1 ] & CLEARMASK ) - 1 ; if ( hi > lo ) { mainQSort3 ( dataShadow , lo , hi , 2 ) ; if ( firstAttemptShadow && ( this . workDone > workLimitShadow ) ) { return ; } } ftab [ sb ] = ftab_sb | SETMASK ; } } for ( int j = 0 ; j <= 255 ; j ++ ) { copy [ j ] = ftab [ ( j << 8 ) + ss ] & CLEARMASK ; } for ( int j = ftab [ ss << 8 ] & CLEARMASK , hj = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) ; j < hj ; j ++ ) { final int fmap_j = fmap [ j ] ; c1 = block [ fmap_j ] & 0xff ; if ( ! bigDone [ c1 ] ) { fmap [ copy [ c1 ] ] = ( fmap_j == 0 ) ? lastShadow : ( fmap_j - 1 ) ; copy [ c1 ] ++ ; } } for ( int j = 256 ; -- j >= 0 ; ) ftab [ ( j << 8 ) + ss ] |= SETMASK ; bigDone [ ss ] = true ; if ( i < 255 ) { final int bbStart = ftab [ ss << 8 ] & CLEARMASK ; final int bbSize = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart ; int shifts = 0 ; while ( ( bbSize > > shifts ) > 65534 ) { shifts ++ ; } for ( int j = 0 ; j < bbSize ; j ++ ) { final int a2update = fmap [ bbStart + j ] ; final char qVal = ( char ) ( j > > shifts ) ; quadrant [ a2update ] = qVal ; if ( a2update < NUM_OVERSHOOT_BYTES ) { quadrant [ a2update + lastShadow + 1 ] = qVal ; } } } } } private void randomiseBlock ( ) { final boolean [ ] inUse = this . data . inUse ; final byte [ ] block = this . data . block ; final int lastShadow = this . last ; for ( int i = 256 ; -- i >= 0 ; ) inUse [ i ] = false ; int rNToGo = 0 ; int rTPos = 0 ; for ( int i = 0 , j = 1 ; i <= lastShadow ; i = j , j ++ ) { if ( rNToGo == 0 ) { rNToGo = ( char ) BZip2Constants . rNums [ rTPos ] ; if ( ++ rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; block [ j ] ^= ( ( rNToGo == 1 ) ? 1 : 0 ) ; inUse [ block [ j ] & 0xff ] = true ; } this . blockRandomised = true ; } private void generateMTFValues ( ) { final int lastShadow = this . last ; final Data dataShadow = this . data ; final boolean [ ] inUse = dataShadow . inUse ; final byte [ ] block = dataShadow . block ; final int [ ] fmap = dataShadow . fmap ; final char [ ] sfmap = dataShadow . sfmap ; final int [ ] mtfFreq = dataShadow . mtfFreq ; final byte [ ] unseqToSeq = dataShadow . unseqToSeq ; final byte [ ] yy = dataShadow . generateMTFValues_yy ; int nInUseShadow = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) { unseqToSeq [ i ] = ( byte ) nInUseShadow ; nInUseShadow ++ ; } } this . nInUse = nInUseShadow ; final int eob = nInUseShadow + 1 ; for ( int i = eob ; i >= 0 ; i -- ) { mtfFreq [ i ] = 0 ; } for ( int i = nInUseShadow ; -- i >= 0 ; ) { yy [ i ] = ( byte ) i ; } int wr = 0 ; int zPend = 0 ; for ( int i = 0 ; i <= lastShadow ; i ++ ) { final byte ll_i = unseqToSeq [ block [ fmap [ i ] ] & 0xff ] ; byte tmp = yy [ 0 ] ; int j = 0 ; while ( ll_i != tmp ) { j ++ ; byte tmp2 = tmp ; tmp = yy [ j ] ; yy [ j ] = tmp2 ; } yy [ 0 ] = tmp ; if ( j == 0 ) { zPend ++ ; } else { if ( zPend > 0 ) { zPend -- ; while ( true ) { if ( ( zPend & 1 ) == 0 ) { sfmap [ wr ] = RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; } else { sfmap [ wr ] = RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; } if ( zPend >= 2 ) { zPend = ( zPend - 2 ) > > 1 ; } else { break ; } } zPend = 0 ; } sfmap [ wr ] = ( char ) ( j + 1 ) ; wr ++ ; mtfFreq [ j + 1 ] ++ ; } } if ( zPend > 0 ) { zPend -- ; while ( true ) { if ( ( zPend & 1 ) == 0 ) { sfmap [ wr ] = RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; } else { sfmap [ wr ] = RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; } if ( zPend >= 2 ) { zPend = ( zPend - 2 ) > > 1 ; } else { break ; } } } sfmap [ wr ] = ( char ) eob ; mtfFreq [ eob ] ++ ; this . nMTF = wr + 1 ; } private static final class Data extends Object { final boolean [ ] inUse = new boolean [ 256 ] ; final byte [ ] unseqToSeq = new byte [ 256 ] ; final int [ ] mtfFreq = new int [ MAX_ALPHA_SIZE ] ; final byte [ ] selector = new byte [ MAX_SELECTORS ] ; final byte [ ] selectorMtf = new byte [ MAX_SELECTORS ] ; final byte [ ] generateMTFValues_yy = new byte [ 256 ] ; final byte [ ] [ ] sendMTFValues_len = new byte [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] [ ] sendMTFValues_rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final int [ ] sendMTFValues_fave = new int [ N_GROUPS ] ; final short [ ] sendMTFValues_cost = new short [ N_GROUPS ] ; final int [ ] [ ] sendMTFValues_code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; final byte [ ] sendMTFValues2_pos = new byte [ N_GROUPS ] ; final boolean [ ] sentMTFValues4_inUse16 = new boolean [ 16 ] ; final int [ ] stack_ll = new int [ QSORT_STACK_SIZE ] ; final int [ ] stack_hh = new int [ QSORT_STACK_SIZE ] ; final int [ ] stack_dd = new int [ QSORT_STACK_SIZE ] ; final int [ ] mainSort_runningOrder = new int [ 256 ] ; final int [ ] mainSort_copy = new int [ 256 ] ; final boolean [ ] mainSort_bigDone = new boolean [ 256 ] ; final int [ ] heap = new int [ MAX_ALPHA_SIZE + 2 ] ; final int [ ] weight = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] parent = new int [ MAX_ALPHA_SIZE * 2 ] ; final int [ ] ftab = new int [ 65537 ] ; final byte [ ] block ; final int [ ] fmap ; final char [ ] sfmap ; final char [ ] quadrant ; Data ( int blockSize100k ) { super ( ) ; final int n = blockSize100k * BZip2Constants . baseBlockSize ; this . block = new byte [ ( n + 1 + NUM_OVERSHOOT_BYTES ) ] ; this . fmap = new int [ n ] ; this . sfmap = new char [ 2 * n ] ; this . quadrant = this . sfmap ; } } } 	1
package org . apache . tools . ant . taskdefs . condition ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; public class Os implements Condition { private static final String OS_NAME = System . getProperty ( "os.name" ) . toLowerCase ( Locale . US ) ; private static final String OS_ARCH = System . getProperty ( "os.arch" ) . toLowerCase ( Locale . US ) ; private static final String OS_VERSION = System . getProperty ( "os.version" ) . toLowerCase ( Locale . US ) ; private static final String PATH_SEP = System . getProperty ( "path.separator" ) ; private String family ; private String name ; private String version ; private String arch ; public static final String FAMILY_WINDOWS = "windows" ; public static final String FAMILY_9X = "win9x" ; public static final String FAMILY_NT = "winnt" ; public static final String FAMILY_OS2 = "os/2" ; public static final String FAMILY_NETWARE = "netware" ; public static final String FAMILY_DOS = "dos" ; public static final String FAMILY_MAC = "mac" ; public static final String FAMILY_TANDEM = "tandem" ; public static final String FAMILY_UNIX = "unix" ; public static final String FAMILY_VMS = "openvms" ; public static final String FAMILY_ZOS = "z/os" ; public static final String FAMILY_OS400 = "os/400" ; public Os ( ) { } public Os ( String family ) { setFamily ( family ) ; } public void setFamily ( String f ) { family = f . toLowerCase ( Locale . US ) ; } public void setName ( String name ) { this . name = name . toLowerCase ( Locale . US ) ; } public void setArch ( String arch ) { this . arch = arch . toLowerCase ( Locale . US ) ; } public void setVersion ( String version ) { this . version = version . toLowerCase ( Locale . US ) ; } public boolean eval ( ) throws BuildException { return isOs ( family , name , arch , version ) ; } public static boolean isFamily ( String family ) { return isOs ( family , null , null , null ) ; } public static boolean isName ( String name ) { return isOs ( null , name , null , null ) ; } public static boolean isArch ( String arch ) { return isOs ( null , null , arch , null ) ; } public static boolean isVersion ( String version ) { return isOs ( null , null , null , version ) ; } public static boolean isOs ( String family , String name , String arch , String version ) { boolean retValue = false ; if ( family != null || name != null || arch != null || version != null ) { boolean isFamily = true ; boolean isName = true ; boolean isArch = true ; boolean isVersion = true ; if ( family != null ) { boolean isWindows = OS_NAME . indexOf ( FAMILY_WINDOWS ) > - 1 ; boolean is9x = false ; boolean isNT = false ; if ( isWindows ) { is9x = ( OS_NAME . indexOf ( "95" ) >= 0 || OS_NAME . indexOf ( "98" ) >= 0 || OS_NAME . indexOf ( "me" ) >= 0 || OS_NAME . indexOf ( "ce" ) >= 0 ) ; isNT = ! is9x ; } if ( family . equals ( FAMILY_WINDOWS ) ) { isFamily = isWindows ; } else if ( family . equals ( FAMILY_9X ) ) { isFamily = isWindows && is9x ; } else if ( family . equals ( FAMILY_NT ) ) { isFamily = isWindows && isNT ; } else if ( family . equals ( FAMILY_OS2 ) ) { isFamily = OS_NAME . indexOf ( FAMILY_OS2 ) > - 1 ; } else if ( family . equals ( FAMILY_NETWARE ) ) { isFamily = OS_NAME . indexOf ( FAMILY_NETWARE ) > - 1 ; } else if ( family . equals ( FAMILY_DOS ) ) { isFamily = PATH_SEP . equals ( ";" ) && ! isFamily ( FAMILY_NETWARE ) ; } else if ( family . equals ( FAMILY_MAC ) ) { isFamily = OS_NAME . indexOf ( FAMILY_MAC ) > - 1 ; } else if ( family . equals ( FAMILY_TANDEM ) ) { isFamily = OS_NAME . indexOf ( "nonstop_kernel" ) > - 1 ; } else if ( family . equals ( FAMILY_UNIX ) ) { isFamily = PATH_SEP . equals ( ":" ) && ! isFamily ( FAMILY_VMS ) && ( ! isFamily ( FAMILY_MAC ) || OS_NAME . endsWith ( "x" ) ) ; } else if ( family . equals ( FAMILY_ZOS ) ) { isFamily = OS_NAME . indexOf ( FAMILY_ZOS ) > - 1 || OS_NAME . indexOf ( "os/390" ) > - 1 ; } else if ( family . equals ( FAMILY_OS400 ) ) { isFamily = OS_NAME . indexOf ( FAMILY_OS400 ) > - 1 ; } else if ( family . equals ( FAMILY_VMS ) ) { isFamily = OS_NAME . indexOf ( FAMILY_VMS ) > - 1 ; } else { throw new BuildException ( "Don\'t know how to detect os family \"" + family + "\"" ) ; } } if ( name != null ) { isName = name . equals ( OS_NAME ) ; } if ( arch != null ) { isArch = arch . equals ( OS_ARCH ) ; } if ( version != null ) { isVersion = version . equals ( OS_VERSION ) ; } retValue = isFamily && isName && isArch && isVersion ; } return retValue ; } } 	1
package org . apache . tools . ant . util ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Path ; import java . io . File ; import org . apache . tools . ant . types . Reference ; public class ScriptRunnerHelper { private ClasspathUtils . Delegate cpDelegate = null ; private File srcFile ; private String manager = "auto" ; private String language ; private String text ; private boolean setBeans = true ; private ProjectComponent projectComponent ; private ClassLoader scriptLoader = null ; public void setProjectComponent ( ProjectComponent component ) { this . projectComponent = component ; } public ScriptRunnerBase getScriptRunner ( ) { ScriptRunnerBase runner = getRunner ( ) ; if ( srcFile != null ) { runner . setSrc ( srcFile ) ; } if ( text != null ) { runner . addText ( text ) ; } if ( setBeans ) { runner . bindToComponent ( projectComponent ) ; } else { runner . bindToComponentMinimum ( projectComponent ) ; } return runner ; } public Path createClasspath ( ) { return getClassPathDelegate ( ) . createClasspath ( ) ; } public void setClasspath ( Path classpath ) { getClassPathDelegate ( ) . setClasspath ( classpath ) ; } public void setClasspathRef ( Reference r ) { getClassPathDelegate ( ) . setClasspathref ( r ) ; } public void setSrc ( File file ) { this . srcFile = file ; } public void addText ( String text ) { this . text = text ; } public void setManager ( String manager ) { this . manager = manager ; } public void setLanguage ( String language ) { this . language = language ; } public String getLanguage ( ) { return language ; } public void setSetBeans ( boolean setBeans ) { this . setBeans = setBeans ; } public void setClassLoader ( ClassLoader loader ) { scriptLoader = loader ; } private ClassLoader generateClassLoader ( ) { if ( scriptLoader != null ) { return scriptLoader ; } if ( cpDelegate == null ) { scriptLoader = getClass ( ) . getClassLoader ( ) ; return scriptLoader ; } scriptLoader = cpDelegate . getClassLoader ( ) ; return scriptLoader ; } private ClasspathUtils . Delegate getClassPathDelegate ( ) { if ( cpDelegate == null ) { cpDelegate = ClasspathUtils . getDelegate ( projectComponent ) ; } return cpDelegate ; } private ScriptRunnerBase getRunner ( ) { return new ScriptRunnerCreator ( projectComponent . getProject ( ) ) . createRunner ( manager , language , generateClassLoader ( ) ) ; } } 	0
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitStatusException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; public class Exit extends Task { private static class NestedCondition extends ConditionBase implements Condition { public boolean eval ( ) { if ( countConditions ( ) != 1 ) { throw new BuildException ( "A single nested condition is required." ) ; } return ( ( Condition ) ( getConditions ( ) . nextElement ( ) ) ) . eval ( ) ; } } private String message ; private String ifCondition , unlessCondition ; private NestedCondition nestedCondition ; private Integer status ; public void setMessage ( String value ) { this . message = value ; } public void setIf ( String c ) { ifCondition = c ; } public void setUnless ( String c ) { unlessCondition = c ; } public void setStatus ( int i ) { status = new Integer ( i ) ; } public void execute ( ) throws BuildException { boolean fail = ( nestedConditionPresent ( ) ) ? testNestedCondition ( ) : ( testIfCondition ( ) && testUnlessCondition ( ) ) ; if ( fail ) { String text = null ; if ( message != null && message . trim ( ) . length ( ) > 0 ) { text = message . trim ( ) ; } else { if ( ifCondition != null && ifCondition . length ( ) > 0 && getProject ( ) . getProperty ( ifCondition ) != null ) { text = "if=" + ifCondition ; } if ( unlessCondition != null && unlessCondition . length ( ) > 0 && getProject ( ) . getProperty ( unlessCondition ) == null ) { if ( text == null ) { text = "" ; } else { text += " and " ; } text += "unless=" + unlessCondition ; } if ( nestedConditionPresent ( ) ) { text = "condition satisfied" ; } else { if ( text == null ) { text = "No message" ; } } } log ( "failing due to " + text , Project . MSG_DEBUG ) ; throw ( ( status == null ) ? new BuildException ( text ) : new ExitStatusException ( text , status . intValue ( ) ) ) ; } } public void addText ( String msg ) { if ( message == null ) { message = "" ; } message += getProject ( ) . replaceProperties ( msg ) ; } public ConditionBase createCondition ( ) { if ( nestedCondition != null ) { throw new BuildException ( "Only one nested condition is allowed." ) ; } nestedCondition = new NestedCondition ( ) ; return nestedCondition ; } private boolean testIfCondition ( ) { if ( ifCondition == null || "" . equals ( ifCondition ) ) { return true ; } return getProject ( ) . getProperty ( ifCondition ) != null ; } private boolean testUnlessCondition ( ) { if ( unlessCondition == null || "" . equals ( unlessCondition ) ) { return true ; } return getProject ( ) . getProperty ( unlessCondition ) == null ; } private boolean testNestedCondition ( ) { boolean result = nestedConditionPresent ( ) ; if ( result && ifCondition != null || unlessCondition != null ) { throw new BuildException ( "Nested conditions " + "not permitted in conjunction with if/unless attributes" ) ; } return result && nestedCondition . eval ( ) ; } private boolean nestedConditionPresent ( ) { return ( nestedCondition != null ) ; } } 	0
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Locale ; import java . util . HashMap ; import java . util . Iterator ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class MacroDef extends AntlibDefinition { private NestedSequential nestedSequential ; private String name ; private boolean backTrace = true ; private List attributes = new ArrayList ( ) ; private Map elements = new HashMap ( ) ; private String textName = null ; private Text text = null ; private boolean hasImplicitElement = false ; public void setName ( String name ) { this . name = name ; } public void addConfiguredText ( Text text ) { if ( this . text != null ) { throw new BuildException ( "Only one nested text element allowed" ) ; } if ( text . getName ( ) == null ) { throw new BuildException ( "the text nested element needed a \"name\" attribute" ) ; } for ( Iterator i = attributes . iterator ( ) ; i . hasNext ( ) ; ) { Attribute attribute = ( Attribute ) i . next ( ) ; if ( text . getName ( ) . equals ( attribute . getName ( ) ) ) { throw new BuildException ( "the name \"" + text . getName ( ) + "\" is already used as an attribute" ) ; } } this . text = text ; this . textName = text . getName ( ) ; } public Text getText ( ) { return text ; } public void setBackTrace ( boolean backTrace ) { this . backTrace = backTrace ; } public boolean getBackTrace ( ) { return backTrace ; } public NestedSequential createSequential ( ) { if ( this . nestedSequential != null ) { throw new BuildException ( "Only one sequential allowed" ) ; } this . nestedSequential = new NestedSequential ( ) ; return this . nestedSequential ; } public static class NestedSequential implements TaskContainer { private List nested = new ArrayList ( ) ; public void addTask ( Task task ) { nested . add ( task ) ; } public List getNested ( ) { return nested ; } public boolean similar ( NestedSequential other ) { if ( nested . size ( ) != other . nested . size ( ) ) { return false ; } for ( int i = 0 ; i < nested . size ( ) ; ++ i ) { UnknownElement me = ( UnknownElement ) nested . get ( i ) ; UnknownElement o = ( UnknownElement ) other . nested . get ( i ) ; if ( ! me . similar ( o ) ) { return false ; } } return true ; } } public UnknownElement getNestedTask ( ) { UnknownElement ret = new UnknownElement ( "sequential" ) ; ret . setTaskName ( "sequential" ) ; ret . setNamespace ( "" ) ; ret . setQName ( "sequential" ) ; new RuntimeConfigurable ( ret , "sequential" ) ; for ( int i = 0 ; i < nestedSequential . getNested ( ) . size ( ) ; ++ i ) { UnknownElement e = ( UnknownElement ) nestedSequential . getNested ( ) . get ( i ) ; ret . addChild ( e ) ; ret . getWrapper ( ) . addChild ( e . getWrapper ( ) ) ; } return ret ; } public List getAttributes ( ) { return attributes ; } public Map getElements ( ) { return elements ; } public static boolean isValidNameCharacter ( char c ) { return Character . isLetterOrDigit ( c ) || c == '.' || c == '-' ; } private static boolean isValidName ( String name ) { if ( name . length ( ) == 0 ) { return false ; } for ( int i = 0 ; i < name . length ( ) ; ++ i ) { if ( ! isValidNameCharacter ( name . charAt ( i ) ) ) { return false ; } } return true ; } public void addConfiguredAttribute ( Attribute attribute ) { if ( attribute . getName ( ) == null ) { throw new BuildException ( "the attribute nested element needed a \"name\" attribute" ) ; } if ( attribute . getName ( ) . equals ( textName ) ) { throw new BuildException ( "the name \"" + attribute . getName ( ) + "\" has already been used by the text element" ) ; } for ( int i = 0 ; i < attributes . size ( ) ; ++ i ) { Attribute att = ( Attribute ) attributes . get ( i ) ; if ( att . getName ( ) . equals ( attribute . getName ( ) ) ) { throw new BuildException ( "the name \"" + attribute . getName ( ) + "\" has already been used in " + "another attribute element" ) ; } } attributes . add ( attribute ) ; } public void addConfiguredElement ( TemplateElement element ) { if ( element . getName ( ) == null ) { throw new BuildException ( "the element nested element needed a \"name\" attribute" ) ; } if ( elements . get ( element . getName ( ) ) != null ) { throw new BuildException ( "the element " + element . getName ( ) + " has already been specified" ) ; } if ( hasImplicitElement || ( element . isImplicit ( ) && elements . size ( ) != 0 ) ) { throw new BuildException ( "Only one element allowed when using implicit elements" ) ; } hasImplicitElement = element . isImplicit ( ) ; elements . put ( element . getName ( ) , element ) ; } public void execute ( ) { if ( nestedSequential == null ) { throw new BuildException ( "Missing sequential element" ) ; } if ( name == null ) { throw new BuildException ( "Name not specified" ) ; } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; MyAntTypeDefinition def = new MyAntTypeDefinition ( this ) ; def . setName ( name ) ; def . setClass ( MacroInstance . class ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; helper . addDataTypeDefinition ( def ) ; log ( "creating macro  " + name , Project . MSG_VERBOSE ) ; } public static class Attribute { private String name ; private String defaultValue ; private String description ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name . toLowerCase ( Locale . US ) ; } public String getName ( ) { return name ; } public void setDefault ( String defaultValue ) { this . defaultValue = defaultValue ; } public String getDefault ( ) { return defaultValue ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } Attribute other = ( Attribute ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } if ( defaultValue == null ) { if ( other . defaultValue != null ) { return false ; } } else if ( ! defaultValue . equals ( other . defaultValue ) ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( defaultValue ) + objectHashCode ( name ) ; } } public static class Text { private String name ; private boolean optional ; private boolean trim ; private String description ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name . toLowerCase ( Locale . US ) ; } public String getName ( ) { return name ; } public void setOptional ( boolean optional ) { this . optional = optional ; } public boolean getOptional ( ) { return optional ; } public void setTrim ( boolean trim ) { this . trim = trim ; } public boolean getTrim ( ) { return trim ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } Text other = ( Text ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } if ( optional != other . optional ) { return false ; } if ( trim != other . trim ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( name ) ; } } public static class TemplateElement { private String name ; private String description ; private boolean optional = false ; private boolean implicit = false ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for macro element" ) ; } this . name = name . toLowerCase ( Locale . US ) ; } public String getName ( ) { return name ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void setOptional ( boolean optional ) { this . optional = optional ; } public boolean isOptional ( ) { return optional ; } public void setImplicit ( boolean implicit ) { this . implicit = implicit ; } public boolean isImplicit ( ) { return implicit ; } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj == null || ! obj . getClass ( ) . equals ( getClass ( ) ) ) { return false ; } TemplateElement t = ( TemplateElement ) obj ; return ( name == null ? t . name == null : name . equals ( t . name ) ) && optional == t . optional && implicit == t . implicit ; } public int hashCode ( ) { return objectHashCode ( name ) + ( optional ? 1 : 0 ) + ( implicit ? 1 : 0 ) ; } } private boolean sameOrSimilar ( Object obj , boolean same ) { if ( obj == this ) { return true ; } if ( obj == null ) { return false ; } if ( ! obj . getClass ( ) . equals ( getClass ( ) ) ) { return false ; } MacroDef other = ( MacroDef ) obj ; if ( name == null ) { return other . name == null ; } if ( ! name . equals ( other . name ) ) { return false ; } if ( other . getLocation ( ) != null && other . getLocation ( ) . equals ( getLocation ( ) ) && ! same ) { return true ; } if ( text == null ) { if ( other . text != null ) { return false ; } } else { if ( ! text . equals ( other . text ) ) { return false ; } } if ( getURI ( ) == null || getURI ( ) . equals ( "" ) || getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) { if ( ! ( other . getURI ( ) == null || other . getURI ( ) . equals ( "" ) || other . getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) ) { return false ; } } else { if ( ! getURI ( ) . equals ( other . getURI ( ) ) ) { return false ; } } if ( ! nestedSequential . similar ( other . nestedSequential ) ) { return false ; } if ( ! attributes . equals ( other . attributes ) ) { return false ; } if ( ! elements . equals ( other . elements ) ) { return false ; } return true ; } public boolean similar ( Object obj ) { return sameOrSimilar ( obj , false ) ; } public boolean sameDefinition ( Object obj ) { return sameOrSimilar ( obj , true ) ; } private static class MyAntTypeDefinition extends AntTypeDefinition { private MacroDef macroDef ; public MyAntTypeDefinition ( MacroDef macroDef ) { this . macroDef = macroDef ; } public Object create ( Project project ) { Object o = super . create ( project ) ; if ( o == null ) { return null ; } ( ( MacroInstance ) o ) . setMacroDef ( macroDef ) ; return o ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . sameDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . sameDefinition ( otherDef . macroDef ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . similarDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . similar ( otherDef . macroDef ) ; } } private static int objectHashCode ( Object o ) { if ( o == null ) { return 0 ; } else { return o . hashCode ( ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; public class TempFile extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String property ; private File destDir = null ; private String prefix ; private String suffix = "" ; private boolean deleteOnExit ; public void setProperty ( String property ) { this . property = property ; } public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void setDeleteOnExit ( boolean deleteOnExit ) { this . deleteOnExit = deleteOnExit ; } public boolean isDeleteOnExit ( ) { return deleteOnExit ; } public void execute ( ) throws BuildException { if ( property == null || property . length ( ) == 0 ) { throw new BuildException ( "no property specified" ) ; } if ( destDir == null ) { destDir = getProject ( ) . resolveFile ( "." ) ; } File tfile = FILE_UTILS . createTempFile ( prefix , suffix , destDir , deleteOnExit ) ; getProject ( ) . setNewProperty ( property , tfile . toString ( ) ) ; } } 	1
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import java . io . File ; import java . util . List ; import java . util . LinkedList ; import java . util . ListIterator ; public class MakeUrl extends Task { private String property ; private File file ; private String separator = " " ; private List filesets = new LinkedList ( ) ; private List paths = new LinkedList ( ) ; private boolean validate = true ; public static final String ERROR_MISSING_FILE = "A source file is missing :" ; public static final String ERROR_NO_PROPERTY = "No property defined" ; public static final String ERROR_NO_FILES = "No files defined" ; public void setProperty ( String property ) { this . property = property ; } public void setFile ( File file ) { this . file = file ; } public void addFileSet ( FileSet fileset ) { filesets . add ( fileset ) ; } public void setSeparator ( String separator ) { this . separator = separator ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public void addPath ( Path path ) { paths . add ( path ) ; } private String filesetsToURL ( ) { if ( filesets . isEmpty ( ) ) { return "" ; } int count = 0 ; StringBuffer urls = new StringBuffer ( ) ; ListIterator list = filesets . listIterator ( ) ; while ( list . hasNext ( ) ) { FileSet set = ( FileSet ) list . next ( ) ; DirectoryScanner scanner = set . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( scanner . getBasedir ( ) , files [ i ] ) ; validateFile ( f ) ; String asUrl = toURL ( f ) ; urls . append ( asUrl ) ; log ( asUrl , Project . MSG_DEBUG ) ; urls . append ( separator ) ; count ++ ; } } return stripTrailingSeparator ( urls , count ) ; } private String stripTrailingSeparator ( StringBuffer urls , int count ) { if ( count > 0 ) { urls . delete ( urls . length ( ) - separator . length ( ) , urls . length ( ) ) ; return new String ( urls ) ; } else { return "" ; } } private String pathsToURL ( ) { if ( paths . isEmpty ( ) ) { return "" ; } int count = 0 ; StringBuffer urls = new StringBuffer ( ) ; ListIterator list = paths . listIterator ( ) ; while ( list . hasNext ( ) ) { Path path = ( Path ) list . next ( ) ; String [ ] elements = path . list ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { File f = new File ( elements [ i ] ) ; validateFile ( f ) ; String asUrl = toURL ( f ) ; urls . append ( asUrl ) ; log ( asUrl , Project . MSG_DEBUG ) ; urls . append ( separator ) ; count ++ ; } } return stripTrailingSeparator ( urls , count ) ; } private void validateFile ( File fileToCheck ) { if ( validate && ! fileToCheck . exists ( ) ) { throw new BuildException ( ERROR_MISSING_FILE + fileToCheck . toString ( ) ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( getProject ( ) . getProperty ( property ) != null ) { return ; } String url ; String filesetURL = filesetsToURL ( ) ; if ( file != null ) { validateFile ( file ) ; url = toURL ( file ) ; if ( filesetURL . length ( ) > 0 ) { url = url + separator + filesetURL ; } } else { url = filesetURL ; } String pathURL = pathsToURL ( ) ; if ( pathURL . length ( ) > 0 ) { if ( url . length ( ) > 0 ) { url = url + separator + pathURL ; } else { url = pathURL ; } } log ( "Setting " + property + " to URL " + url , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , url ) ; } private void validate ( ) { if ( property == null ) { throw new BuildException ( ERROR_NO_PROPERTY ) ; } if ( file == null && filesets . isEmpty ( ) && paths . isEmpty ( ) ) { throw new BuildException ( ERROR_NO_FILES ) ; } } private String toURL ( File fileToConvert ) { String url ; url = FileUtils . getFileUtils ( ) . toURI ( fileToConvert . getAbsolutePath ( ) ) ; return url ; } } 	0
package org . apache . tools . ant . taskdefs . optional . sos ; public interface SOSCmd { String COMMAND_SOS_EXE = "soscmd" ; String COMMAND_GET_FILE = "GetFile" ; String COMMAND_GET_PROJECT = "GetProject" ; String COMMAND_CHECKOUT_FILE = "CheckOutFile" ; String COMMAND_CHECKOUT_PROJECT = "CheckOutProject" ; String COMMAND_CHECKIN_FILE = "CheckInFile" ; String COMMAND_CHECKIN_PROJECT = "CheckInProject" ; String COMMAND_HISTORY = "GetFileHistory" ; String COMMAND_LABEL = "AddLabel" ; String PROJECT_PREFIX = "$" ; String FLAG_COMMAND = "-command" ; String FLAG_VSS_SERVER = "-database" ; String FLAG_USERNAME = "-name" ; String FLAG_PASSWORD = "-password" ; String FLAG_COMMENT = "-log" ; String FLAG_WORKING_DIR = "-workdir" ; String FLAG_RECURSION = "-recursive" ; String FLAG_VERSION = "-revision" ; String FLAG_LABEL = "-label" ; String FLAG_NO_COMPRESSION = "-nocompress" ; String FLAG_NO_CACHE = "-nocache" ; String FLAG_SOS_SERVER = "-server" ; String FLAG_SOS_HOME = "-soshome" ; String FLAG_PROJECT = "-project" ; String FLAG_FILE = "-file" ; String FLAG_VERBOSE = "-verbose" ; } 	0
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . net . InetAddress ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . UnknownHostException ; public class IsReachable extends ProjectComponent implements Condition { private static final int SECOND = 1000 ; private String host ; private String url ; public static final int DEFAULT_TIMEOUT = 30 ; private int timeout = DEFAULT_TIMEOUT ; public static final String ERROR_NO_HOSTNAME = "No hostname defined" ; public static final String ERROR_BAD_TIMEOUT = "Invalid timeout value" ; private static final String WARN_UNKNOWN_HOST = "Unknown host: " ; public static final String ERROR_ON_NETWORK = "network error to " ; public static final String ERROR_BOTH_TARGETS = "Both url and host have been specified" ; public static final String MSG_NO_REACHABLE_TEST = "cannot do a proper reachability test on this Java version" ; public static final String ERROR_BAD_URL = "Bad URL " ; public static final String ERROR_NO_HOST_IN_URL = "No hostname in URL " ; public static final String METHOD_NAME = "isReachable" ; public void setHost ( String host ) { this . host = host ; } public void setUrl ( String url ) { this . url = url ; } public void setTimeout ( int timeout ) { this . timeout = timeout ; } private boolean empty ( String string ) { return string == null || string . length ( ) == 0 ; } private static Class [ ] parameterTypes = { Integer . TYPE } ; public boolean eval ( ) throws BuildException { if ( empty ( host ) && empty ( url ) ) { throw new BuildException ( ERROR_NO_HOSTNAME ) ; } if ( timeout < 0 ) { throw new BuildException ( ERROR_BAD_TIMEOUT ) ; } String target = host ; if ( ! empty ( url ) ) { if ( ! empty ( host ) ) { throw new BuildException ( ERROR_BOTH_TARGETS ) ; } try { URL realURL = new URL ( url ) ; target = realURL . getHost ( ) ; if ( empty ( target ) ) { throw new BuildException ( ERROR_NO_HOST_IN_URL + url ) ; } } catch ( MalformedURLException e ) { throw new BuildException ( ERROR_BAD_URL + url , e ) ; } } log ( "Probing host " + target , Project . MSG_VERBOSE ) ; InetAddress address ; try { address = InetAddress . getByName ( target ) ; } catch ( UnknownHostException e1 ) { log ( WARN_UNKNOWN_HOST + target ) ; return false ; } log ( "Host address = " + address . getHostAddress ( ) , Project . MSG_VERBOSE ) ; boolean reachable ; Method reachableMethod = null ; try { reachableMethod = InetAddress . class . getMethod ( METHOD_NAME , parameterTypes ) ; Object [ ] params = new Object [ 1 ] ; params [ 0 ] = new Integer ( timeout * SECOND ) ; try { reachable = ( ( Boolean ) reachableMethod . invoke ( address , params ) ) . booleanValue ( ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "When calling " + reachableMethod ) ; } catch ( InvocationTargetException e ) { Throwable nested = e . getTargetException ( ) ; log ( ERROR_ON_NETWORK + target + ": " + nested . toString ( ) ) ; reachable = false ; } } catch ( NoSuchMethodException e ) { log ( "Not found: InetAddress." + METHOD_NAME , Project . MSG_VERBOSE ) ; log ( MSG_NO_REACHABLE_TEST ) ; reachable = true ; } log ( "host is" + ( reachable ? "" : " not" ) + " reachable" , Project . MSG_VERBOSE ) ; return reachable ; } } 	0
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . util . StringUtils ; public class DefaultExcludes extends Task { private String add = "" ; private String remove = "" ; private boolean defaultrequested = false ; private boolean echo = false ; private int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( ! defaultrequested && add . equals ( "" ) && remove . equals ( "" ) && ! echo ) { throw new BuildException ( "<defaultexcludes> task must set " + "at least one attribute (echo=\"false\"" + " doesn't count since that is the default" ) ; } if ( defaultrequested ) { DirectoryScanner . resetDefaultExcludes ( ) ; } if ( ! add . equals ( "" ) ) { DirectoryScanner . addDefaultExclude ( add ) ; } if ( ! remove . equals ( "" ) ) { DirectoryScanner . removeDefaultExclude ( remove ) ; } if ( echo ) { StringBuffer message = new StringBuffer ( "Current Default Excludes:" ) ; message . append ( StringUtils . LINE_SEP ) ; String [ ] excludes = DirectoryScanner . getDefaultExcludes ( ) ; for ( int i = 0 ; i < excludes . length ; i ++ ) { message . append ( "  " ) ; message . append ( excludes [ i ] ) ; message . append ( StringUtils . LINE_SEP ) ; } log ( message . toString ( ) , logLevel ) ; } } public void setDefault ( boolean def ) { defaultrequested = def ; } public void setAdd ( String add ) { this . add = add ; } public void setRemove ( String remove ) { this . remove = remove ; } public void setEcho ( boolean echo ) { this . echo = echo ; } } 	0
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class StripLineBreaks extends BaseParamFilterReader implements ChainableReader { private static final String DEFAULT_LINE_BREAKS = "\r\n" ; private static final String LINE_BREAKS_KEY = "linebreaks" ; private String lineBreaks = DEFAULT_LINE_BREAKS ; public StripLineBreaks ( ) { super ( ) ; } public StripLineBreaks ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = in . read ( ) ; while ( ch != - 1 ) { if ( lineBreaks . indexOf ( ch ) == - 1 ) { break ; } else { ch = in . read ( ) ; } } return ch ; } public void setLineBreaks ( final String lineBreaks ) { this . lineBreaks = lineBreaks ; } private String getLineBreaks ( ) { return lineBreaks ; } public Reader chain ( final Reader rdr ) { StripLineBreaks newFilter = new StripLineBreaks ( rdr ) ; newFilter . setLineBreaks ( getLineBreaks ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { String userDefinedLineBreaks = null ; Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINE_BREAKS_KEY . equals ( params [ i ] . getName ( ) ) ) { userDefinedLineBreaks = params [ i ] . getValue ( ) ; break ; } } } if ( userDefinedLineBreaks != null ) { lineBreaks = userDefinedLineBreaks ; } } } 	0
package org . apache . tools . ant . taskdefs ; public class Transform extends ExecuteOn { } 	0
package org . apache . tools . ant ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . PrintStream ; import java . io . StringReader ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . StringUtils ; public class DefaultLogger implements BuildLogger { public static final int LEFT_COLUMN_SIZE = 12 ; protected PrintStream out ; protected PrintStream err ; protected int msgOutputLevel = Project . MSG_ERR ; private long startTime = System . currentTimeMillis ( ) ; protected static final String lSep = StringUtils . LINE_SEP ; protected boolean emacsMode = false ; public DefaultLogger ( ) { } public void setMessageOutputLevel ( int level ) { this . msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . out = new PrintStream ( output , true ) ; } public void setErrorPrintStream ( PrintStream err ) { this . err = new PrintStream ( err , true ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void buildStarted ( BuildEvent event ) { startTime = System . currentTimeMillis ( ) ; } public void buildFinished ( BuildEvent event ) { Throwable error = event . getException ( ) ; StringBuffer message = new StringBuffer ( ) ; if ( error == null ) { message . append ( StringUtils . LINE_SEP ) ; message . append ( getBuildSuccessfulMessage ( ) ) ; } else { message . append ( StringUtils . LINE_SEP ) ; message . append ( getBuildFailedMessage ( ) ) ; message . append ( StringUtils . LINE_SEP ) ; if ( Project . MSG_VERBOSE <= msgOutputLevel || ! ( error instanceof BuildException ) ) { message . append ( StringUtils . getStackTrace ( error ) ) ; } else { message . append ( error . toString ( ) ) . append ( lSep ) ; } } message . append ( StringUtils . LINE_SEP ) ; message . append ( "Total time: " ) ; message . append ( formatTime ( System . currentTimeMillis ( ) - startTime ) ) ; String msg = message . toString ( ) ; if ( error == null ) { printMessage ( msg , out , Project . MSG_VERBOSE ) ; } else { printMessage ( msg , err , Project . MSG_ERR ) ; } log ( msg ) ; } protected String getBuildFailedMessage ( ) { return "BUILD FAILED" ; } protected String getBuildSuccessfulMessage ( ) { return "BUILD SUCCESSFUL" ; } public void targetStarted ( BuildEvent event ) { if ( Project . MSG_INFO <= msgOutputLevel && ! event . getTarget ( ) . getName ( ) . equals ( "" ) ) { String msg = StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" ; printMessage ( msg , out , event . getPriority ( ) ) ; log ( msg ) ; } } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority <= msgOutputLevel ) { StringBuffer message = new StringBuffer ( ) ; if ( event . getTask ( ) != null && ! emacsMode ) { String name = event . getTask ( ) . getTaskName ( ) ; String label = "[" + name + "] " ; int size = LEFT_COLUMN_SIZE - label . length ( ) ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = 0 ; i < size ; i ++ ) { tmp . append ( " " ) ; } tmp . append ( label ) ; label = tmp . toString ( ) ; try { BufferedReader r = new BufferedReader ( new StringReader ( event . getMessage ( ) ) ) ; String line = r . readLine ( ) ; boolean first = true ; do { if ( first ) { if ( line == null ) { message . append ( label ) ; break ; } } else { message . append ( StringUtils . LINE_SEP ) ; } first = false ; message . append ( label ) . append ( line ) ; line = r . readLine ( ) ; } while ( line != null ) ; } catch ( IOException e ) { message . append ( label ) . append ( event . getMessage ( ) ) ; } } else { message . append ( event . getMessage ( ) ) ; } Throwable ex = event . getException ( ) ; if ( Project . MSG_DEBUG <= msgOutputLevel && ex != null ) { message . append ( StringUtils . getStackTrace ( ex ) ) ; } String msg = message . toString ( ) ; if ( priority != Project . MSG_ERR ) { printMessage ( msg , out , priority ) ; } else { printMessage ( msg , err , priority ) ; } log ( msg ) ; } } protected static String formatTime ( final long millis ) { return DateUtils . formatElapsedTime ( millis ) ; } protected void printMessage ( final String message , final PrintStream stream , final int priority ) { stream . println ( message ) ; } protected void log ( String message ) { } } 	1
package org . apache . tools . ant . util ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class ClasspathUtils { public static final String REUSE_LOADER_REF = MagicNames . REFID_CLASSPATH_REUSE_LOADER ; public static ClassLoader getClassLoaderForPath ( Project p , Reference ref ) { return getClassLoaderForPath ( p , ref , false ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Reference ref , boolean reverseLoader ) { String pathId = ref . getRefId ( ) ; Object path = p . getReference ( pathId ) ; if ( ! ( path instanceof Path ) ) { throw new BuildException ( "The specified classpathref " + pathId + " does not reference a Path." ) ; } String loaderId = MagicNames . REFID_CLASSPATH_LOADER_PREFIX + pathId ; return getClassLoaderForPath ( p , ( Path ) path , loaderId , reverseLoader ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId ) { return getClassLoaderForPath ( p , path , loaderId , false ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId , boolean reverseLoader ) { return getClassLoaderForPath ( p , path , loaderId , reverseLoader , isMagicPropertySet ( p ) ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId , boolean reverseLoader , boolean reuseLoader ) { ClassLoader cl = null ; if ( loaderId != null && reuseLoader ) { Object reusedLoader = p . getReference ( loaderId ) ; if ( reusedLoader != null && ! ( reusedLoader instanceof ClassLoader ) ) { throw new BuildException ( "The specified loader id " + loaderId + " does not reference a class loader" ) ; } cl = ( ClassLoader ) reusedLoader ; } if ( cl == null ) { cl = getUniqueClassLoaderForPath ( p , path , reverseLoader ) ; if ( loaderId != null && reuseLoader ) { p . addReference ( loaderId , cl ) ; } } return cl ; } public static ClassLoader getUniqueClassLoaderForPath ( Project p , Path path , boolean reverseLoader ) { AntClassLoader acl = p . createClassLoader ( path ) ; if ( reverseLoader ) { acl . setParentFirst ( false ) ; acl . addJavaLibraries ( ) ; } return acl ; } public static Object newInstance ( String className , ClassLoader userDefinedLoader ) { return newInstance ( className , userDefinedLoader , Object . class ) ; } public static Object newInstance ( String className , ClassLoader userDefinedLoader , Class expectedType ) { try { Class clazz = Class . forName ( className , true , userDefinedLoader ) ; Object o = clazz . newInstance ( ) ; if ( ! expectedType . isInstance ( o ) ) { throw new BuildException ( "Class of unexpected Type: " + className + " expected :" + expectedType ) ; } return o ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class not found: " + className , e ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Could not instantiate " + className + ". Specified class should have a no " + "argument constructor." , e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Could not instantiate " + className + ". Specified class should have a " + "public constructor." , e ) ; } catch ( LinkageError e ) { throw new BuildException ( "Class " + className + " could not be loaded because of an invalid dependency." , e ) ; } } public static Delegate getDelegate ( ProjectComponent component ) { return new Delegate ( component ) ; } private static boolean isMagicPropertySet ( Project p ) { return p . getProperty ( REUSE_LOADER_REF ) != null ; } public static class Delegate { private final ProjectComponent component ; private Path classpath ; private String classpathId ; private String className ; private String loaderId ; private boolean reverseLoader = false ; Delegate ( ProjectComponent component ) { this . component = component ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( component . getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClassname ( String fcqn ) { this . className = fcqn ; } public void setClasspathref ( Reference r ) { this . classpathId = r . getRefId ( ) ; createClasspath ( ) . setRefid ( r ) ; } public void setReverseLoader ( boolean reverseLoader ) { this . reverseLoader = reverseLoader ; } public void setLoaderRef ( Reference r ) { this . loaderId = r . getRefId ( ) ; } public ClassLoader getClassLoader ( ) { return getClassLoaderForPath ( getContextProject ( ) , this . classpath , getClassLoadId ( ) , this . reverseLoader , loaderId != null || isMagicPropertySet ( getContextProject ( ) ) ) ; } private Project getContextProject ( ) { return this . component . getProject ( ) ; } public String getClassLoadId ( ) { return this . loaderId == null && this . classpathId != null ? MagicNames . REFID_CLASSPATH_LOADER_PREFIX + this . classpathId : this . loaderId ; } public Object newInstance ( ) { return ClasspathUtils . newInstance ( this . className , getClassLoader ( ) ) ; } public Path getClasspath ( ) { return classpath ; } public boolean isReverseLoader ( ) { return reverseLoader ; } } } 	0
package org . apache . tools . ant . types . resources ; import java . util . Stack ; import java . util . TreeMap ; import java . util . Iterator ; import java . util . Collection ; import java . util . Comparator ; import java . util . Collections ; import java . util . AbstractCollection ; import java . util . NoSuchElementException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; import org . apache . tools . ant . types . resources . comparators . DelegatedResourceComparator ; public class Sort extends BaseResourceCollectionWrapper { private static class SortedBag extends AbstractCollection { private class MutableInt { private int value = 0 ; } private class MyIterator implements Iterator { private Iterator keyIter = t . keySet ( ) . iterator ( ) ; private Object current ; private int occurrence ; public synchronized boolean hasNext ( ) { return occurrence > 0 || keyIter . hasNext ( ) ; } public synchronized Object next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } if ( occurrence == 0 ) { current = keyIter . next ( ) ; occurrence = ( ( MutableInt ) t . get ( current ) ) . value ; } -- occurrence ; return current ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } private TreeMap t ; private int size ; SortedBag ( Comparator c ) { t = new TreeMap ( c ) ; } public synchronized Iterator iterator ( ) { return new MyIterator ( ) ; } public synchronized boolean add ( Object o ) { if ( size < Integer . MAX_VALUE ) { ++ size ; } MutableInt m = ( MutableInt ) ( t . get ( o ) ) ; if ( m == null ) { m = new MutableInt ( ) ; t . put ( o , m ) ; } m . value ++ ; return true ; } public synchronized int size ( ) { return size ; } } private DelegatedResourceComparator comp = new DelegatedResourceComparator ( ) ; protected synchronized Collection getCollection ( ) { ResourceCollection rc = getResourceCollection ( ) ; Iterator iter = rc . iterator ( ) ; if ( ! ( iter . hasNext ( ) ) ) { return Collections . EMPTY_SET ; } SortedBag b = new SortedBag ( comp ) ; while ( iter . hasNext ( ) ) { b . add ( iter . next ( ) ) ; } return b ; } public synchronized void add ( ResourceComparator c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } comp . add ( c ) ; FailFast . invalidate ( this ) ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { DataType . invokeCircularReferenceCheck ( comp , stk , p ) ; setChecked ( true ) ; } } } 	1
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , getLocation ( ) ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , getLocation ( ) ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , getLocation ( ) ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; try { String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = filecopyList . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { getProject ( ) . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } finally { filecopyList . clear ( ) ; } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0
package org . apache . tools . ant . types ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class PatternSet extends DataType implements Cloneable { private Vector includeList = new Vector ( ) ; private Vector excludeList = new Vector ( ) ; private Vector includesFileList = new Vector ( ) ; private Vector excludesFileList = new Vector ( ) ; public class NameEntry { private String name ; private String ifCond ; private String unlessCond ; public void setName ( String name ) { this . name = name ; } public void setIf ( String cond ) { ifCond = cond ; } public void setUnless ( String cond ) { unlessCond = cond ; } public String getName ( ) { return name ; } public String evalName ( Project p ) { return valid ( p ) ? name : null ; } private boolean valid ( Project p ) { if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( name == null ) { buf . append ( "noname" ) ; } else { buf . append ( name ) ; } if ( ( ifCond != null ) || ( unlessCond != null ) ) { buf . append ( ":" ) ; String connector = "" ; if ( ifCond != null ) { buf . append ( "if->" ) ; buf . append ( ifCond ) ; connector = ";" ; } if ( unlessCond != null ) { buf . append ( connector ) ; buf . append ( "unless->" ) ; buf . append ( unlessCond ) ; } } return buf . toString ( ) ; } } public PatternSet ( ) { super ( ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! includeList . isEmpty ( ) || ! excludeList . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void addConfiguredPatternset ( PatternSet p ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } String [ ] nestedIncludes = p . getIncludePatterns ( getProject ( ) ) ; String [ ] nestedExcludes = p . getExcludePatterns ( getProject ( ) ) ; if ( nestedIncludes != null ) { for ( int i = 0 ; i < nestedIncludes . length ; i ++ ) { createInclude ( ) . setName ( nestedIncludes [ i ] ) ; } } if ( nestedExcludes != null ) { for ( int i = 0 ; i < nestedExcludes . length ; i ++ ) { createExclude ( ) . setName ( nestedExcludes [ i ] ) ; } } } public NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includeList ) ; } public NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includesFileList ) ; } public NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludeList ) ; } public NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludesFileList ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( includes != null && includes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( includes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createInclude ( ) . setName ( tok . nextToken ( ) ) ; } } } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( excludes != null && excludes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( excludes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( tok . nextToken ( ) ) ; } } } private NameEntry addPatternToList ( Vector list ) { NameEntry result = new NameEntry ( ) ; list . addElement ( result ) ; return result ; } public void setIncludesfile ( File includesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createIncludesFile ( ) . setName ( includesFile . getAbsolutePath ( ) ) ; } public void setExcludesfile ( File excludesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createExcludesFile ( ) . setName ( excludesFile . getAbsolutePath ( ) ) ; } private void readPatterns ( File patternfile , Vector patternlist , Project p ) throws BuildException { BufferedReader patternReader = null ; try { patternReader = new BufferedReader ( new FileReader ( patternfile ) ) ; String line = patternReader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) > 0 ) { line = p . replaceProperties ( line ) ; addPatternToList ( patternlist ) . setName ( line ) ; } line = patternReader . readLine ( ) ; } } catch ( IOException ioe ) { String msg = "An error occurred while reading from pattern file: " + patternfile ; throw new BuildException ( msg , ioe ) ; } finally { if ( null != patternReader ) { try { patternReader . close ( ) ; } catch ( IOException ioe ) { } } } } public void append ( PatternSet other , Project p ) { if ( isReference ( ) ) { throw new BuildException ( "Cannot append to a reference" ) ; } String [ ] incl = other . getIncludePatterns ( p ) ; if ( incl != null ) { for ( int i = 0 ; i < incl . length ; i ++ ) { createInclude ( ) . setName ( incl [ i ] ) ; } } String [ ] excl = other . getExcludePatterns ( p ) ; if ( excl != null ) { for ( int i = 0 ; i < excl . length ; i ++ ) { createExclude ( ) . setName ( excl [ i ] ) ; } } } public String [ ] getIncludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getIncludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( includeList , p ) ; } } public String [ ] getExcludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExcludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( excludeList , p ) ; } } public boolean hasPatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . hasPatterns ( p ) ; } else { return includesFileList . size ( ) > 0 || excludesFileList . size ( ) > 0 || includeList . size ( ) > 0 || excludeList . size ( ) > 0 ; } } private PatternSet getRef ( Project p ) { return ( PatternSet ) getCheckedRef ( p ) ; } private String [ ] makeArray ( Vector list , Project p ) { if ( list . size ( ) == 0 ) { return null ; } Vector tmpNames = new Vector ( ) ; for ( Enumeration e = list . elements ( ) ; e . hasMoreElements ( ) ; ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String pattern = ne . evalName ( p ) ; if ( pattern != null && pattern . length ( ) > 0 ) { tmpNames . addElement ( pattern ) ; } } String [ ] result = new String [ tmpNames . size ( ) ] ; tmpNames . copyInto ( result ) ; return result ; } private void readFiles ( Project p ) { if ( includesFileList . size ( ) > 0 ) { Enumeration e = includesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File inclFile = p . resolveFile ( fileName ) ; if ( ! inclFile . exists ( ) ) { throw new BuildException ( "Includesfile " + inclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( inclFile , includeList , p ) ; } } includesFileList . removeAllElements ( ) ; } if ( excludesFileList . size ( ) > 0 ) { Enumeration e = excludesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File exclFile = p . resolveFile ( fileName ) ; if ( ! exclFile . exists ( ) ) { throw new BuildException ( "Excludesfile " + exclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( exclFile , excludeList , p ) ; } } excludesFileList . removeAllElements ( ) ; } } public String toString ( ) { return "patternSet{ includes: " + includeList + " excludes: " + excludeList + " }" ; } public Object clone ( ) { try { PatternSet ps = ( PatternSet ) super . clone ( ) ; ps . includeList = ( Vector ) includeList . clone ( ) ; ps . excludeList = ( Vector ) excludeList . clone ( ) ; ps . includesFileList = ( Vector ) includesFileList . clone ( ) ; ps . excludesFileList = ( Vector ) excludesFileList . clone ( ) ; return ps ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } } 	0
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public class Environment { protected Vector variables ; public static class Variable { private String key , value ; public Variable ( ) { super ( ) ; } public void setKey ( String key ) { this . key = key ; } public void setValue ( String value ) { this . value = value ; } public String getKey ( ) { return this . key ; } public String getValue ( ) { return this . value ; } public void setPath ( Path path ) { this . value = path . toString ( ) ; } public void setFile ( java . io . File file ) { this . value = file . getAbsolutePath ( ) ; } public String getContent ( ) throws BuildException { validate ( ) ; StringBuffer sb = new StringBuffer ( key . trim ( ) ) ; sb . append ( "=" ) . append ( value . trim ( ) ) ; return sb . toString ( ) ; } public void validate ( ) { if ( key == null || value == null ) { throw new BuildException ( "key and value must be specified " + "for environment variables." ) ; } } } public Environment ( ) { variables = new Vector ( ) ; } public void addVariable ( Variable var ) { variables . addElement ( var ) ; } public String [ ] getVariables ( ) throws BuildException { if ( variables . size ( ) == 0 ) { return null ; } String [ ] result = new String [ variables . size ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( ( Variable ) variables . elementAt ( i ) ) . getContent ( ) ; } return result ; } public Vector getVariablesVector ( ) { return variables ; } } 	0
package org . apache . tools . ant . helper ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TypeAdapter ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . AttributeList ; import org . xml . sax . DocumentHandler ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . XMLReaderAdapter ; public class ProjectHelperImpl extends ProjectHelper { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private org . xml . sax . Parser parser ; private Project project ; private File buildFile ; private File buildFileParent ; private Locator locator ; private Target implicitTarget = new Target ( ) ; public ProjectHelperImpl ( ) { implicitTarget . setName ( "" ) ; } public void parse ( Project project , Object source ) throws BuildException { if ( ! ( source instanceof File ) ) { throw new BuildException ( "Only File source supported by " + "default plugin" ) ; } File bFile = ( File ) source ; FileInputStream inputStream = null ; InputSource inputSource = null ; this . project = project ; this . buildFile = new File ( bFile . getAbsolutePath ( ) ) ; buildFileParent = new File ( this . buildFile . getParent ( ) ) ; try { try { parser = JAXPUtils . getParser ( ) ; } catch ( BuildException e ) { parser = new XMLReaderAdapter ( JAXPUtils . getXMLReader ( ) ) ; } String uri = FILE_UTILS . toURI ( bFile . getAbsolutePath ( ) ) ; inputStream = new FileInputStream ( bFile ) ; inputSource = new InputSource ( inputStream ) ; inputSource . setSystemId ( uri ) ; project . log ( "parsing buildfile " + bFile + " with URI = " + uri , Project . MSG_VERBOSE ) ; HandlerBase hb = new RootHandler ( this ) ; parser . setDocumentHandler ( hb ) ; parser . setEntityResolver ( hb ) ; parser . setErrorHandler ( hb ) ; parser . setDTDHandler ( hb ) ; parser . parse ( inputSource ) ; } catch ( SAXParseException exc ) { Location location = new Location ( exc . getSystemId ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( "Encoding of project file is invalid." , exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file: " + exc . getMessage ( ) , exc ) ; } finally { FileUtils . close ( inputStream ) ; } } static class AbstractHandler extends HandlerBase { protected DocumentHandler parentHandler ; ProjectHelperImpl helperImpl ; public AbstractHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { this . parentHandler = parentHandler ; this . helperImpl = helperImpl ; helperImpl . parser . setDocumentHandler ( this ) ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + tag + "\"" , helperImpl . locator ) ; } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { String s = new String ( buf , start , count ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , helperImpl . locator ) ; } } public void endElement ( String name ) throws SAXException { helperImpl . parser . setDocumentHandler ( parentHandler ) ; } } static class RootHandler extends HandlerBase { ProjectHelperImpl helperImpl ; public RootHandler ( ProjectHelperImpl helperImpl ) { this . helperImpl = helperImpl ; } public InputSource resolveEntity ( String publicId , String systemId ) { helperImpl . project . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = FILE_UTILS . fromURI ( systemId ) ; File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = FILE_UTILS . resolveFile ( helperImpl . buildFileParent , path ) ; helperImpl . project . log ( "Warning: '" + systemId + "' in " + helperImpl . buildFile + " should be expressed simply as '" + path . replace ( '\\' , '/' ) + "' for compliance with other XML tools" , Project . MSG_WARN ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( FILE_UTILS . toURI ( file . getAbsolutePath ( ) ) ) ; return inputSource ; } catch ( FileNotFoundException fne ) { helperImpl . project . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { if ( tag . equals ( "project" ) ) { new ProjectHandler ( helperImpl , this ) . init ( tag , attrs ) ; } else { throw new SAXParseException ( "Config file is not of expected " + "XML type" , helperImpl . locator ) ; } } public void setDocumentLocator ( Locator locator ) { helperImpl . locator = locator ; } } static class ProjectHandler extends AbstractHandler { public ProjectHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String def = null ; String name = null ; String id = null ; String baseDir = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { def = value ; } else if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "basedir" ) ) { baseDir = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getName ( i ) + "\"" , helperImpl . locator ) ; } } if ( def != null && ! def . equals ( "" ) ) { helperImpl . project . setDefaultTarget ( def ) ; } else { throw new BuildException ( "The default attribute is required" ) ; } if ( name != null ) { helperImpl . project . setName ( name ) ; helperImpl . project . addReference ( name , helperImpl . project ) ; } if ( id != null ) { helperImpl . project . addReference ( id , helperImpl . project ) ; } if ( helperImpl . project . getProperty ( "basedir" ) != null ) { helperImpl . project . setBasedir ( helperImpl . project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { helperImpl . project . setBasedir ( helperImpl . buildFileParent . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { helperImpl . project . setBasedir ( baseDir ) ; } else { File resolvedBaseDir = FILE_UTILS . resolveFile ( helperImpl . buildFileParent , baseDir ) ; helperImpl . project . setBaseDir ( resolvedBaseDir ) ; } } } helperImpl . project . addTarget ( "" , helperImpl . implicitTarget ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( name . equals ( "target" ) ) { handleTarget ( name , attrs ) ; } else { handleElement ( helperImpl , this , helperImpl . implicitTarget , name , attrs ) ; } } private void handleTarget ( String tag , AttributeList attrs ) throws SAXParseException { new TargetHandler ( helperImpl , this ) . init ( tag , attrs ) ; } } static class TargetHandler extends AbstractHandler { private Target target ; public TargetHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String name = null ; String depends = "" ; String ifCond = null ; String unlessCond = null ; String id = null ; String description = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; if ( name . equals ( "" ) ) { throw new BuildException ( "name attribute must not" + " be empty" , new Location ( helperImpl . locator ) ) ; } } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , helperImpl . locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without a name attribute" , helperImpl . locator ) ; } target = new Target ( ) ; target . addDependency ( "" ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; helperImpl . project . addTarget ( name , target ) ; if ( id != null && ! id . equals ( "" ) ) { helperImpl . project . addReference ( id , target ) ; } if ( depends . length ( ) > 0 ) { target . setDepends ( depends ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { handleElement ( helperImpl , this , target , name , attrs ) ; } } private static void handleElement ( ProjectHelperImpl helperImpl , DocumentHandler parent , Target target , String elementName , AttributeList attrs ) throws SAXParseException { if ( elementName . equals ( "description" ) ) { new DescriptionHandler ( helperImpl , parent ) ; } else if ( helperImpl . project . getDataTypeDefinitions ( ) . get ( elementName ) != null ) { new DataTypeHandler ( helperImpl , parent , target ) . init ( elementName , attrs ) ; } else { new TaskHandler ( helperImpl , parent , target , null , target ) . init ( elementName , attrs ) ; } } static class DescriptionHandler extends AbstractHandler { public DescriptionHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void characters ( char [ ] buf , int start , int count ) { String text = new String ( buf , start , count ) ; String currentDescription = helperImpl . project . getDescription ( ) ; if ( currentDescription == null ) { helperImpl . project . setDescription ( text ) ; } else { helperImpl . project . setDescription ( currentDescription + text ) ; } } } static class TaskHandler extends AbstractHandler { private Target target ; private TaskContainer container ; private Task task ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , TaskContainer container , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; this . container = container ; this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = helperImpl . project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( task == null ) { task = new UnknownElement ( tag ) ; task . setProject ( helperImpl . project ) ; task . setTaskName ( tag ) ; } task . setLocation ( new Location ( helperImpl . locator ) ) ; helperImpl . configureId ( task , attrs ) ; task . setOwningTarget ( target ) ; container . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; if ( parentWrapper != null ) { parentWrapper . addChild ( wrapper ) ; } } public void characters ( char [ ] buf , int start , int count ) { wrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( task instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) task , wrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , task , wrapper , target ) . init ( name , attrs ) ; } } } static class NestedElementHandler extends AbstractHandler { private Object parent ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; private Target target ; public NestedElementHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Object parent , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; if ( parent instanceof TypeAdapter ) { this . parent = ( ( TypeAdapter ) parent ) . getProxy ( ) ; } else { this . parent = parent ; } this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( helperImpl . project , parentClass ) ; try { String elementName = propType . toLowerCase ( Locale . US ) ; if ( parent instanceof UnknownElement ) { UnknownElement uc = new UnknownElement ( elementName ) ; uc . setProject ( helperImpl . project ) ; ( ( UnknownElement ) parent ) . addChild ( uc ) ; child = uc ; } else { child = ih . createElement ( helperImpl . project , parent , elementName ) ; } helperImpl . configureId ( child , attrs ) ; childWrapper = new RuntimeConfigurable ( child , propType ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { childWrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( child instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) child , childWrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , child , childWrapper , target ) . init ( name , attrs ) ; } } } static class DataTypeHandler extends AbstractHandler { private Target target ; private Object element ; private RuntimeConfigurable wrapper = null ; public DataTypeHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Target target ) { super ( helperImpl , parentHandler ) ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = helperImpl . project . createDataType ( propType ) ; if ( element == null ) { throw new BuildException ( "Unknown data type " + propType ) ; } wrapper = new RuntimeConfigurable ( element , propType ) ; wrapper . setAttributes ( attrs ) ; target . addDataType ( wrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { wrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( helperImpl , this , element , wrapper , target ) . init ( name , attrs ) ; } } private void configureId ( Object target , AttributeList attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , target ) ; } } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Date ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class Expand extends Task { private File dest ; private File source ; private boolean overwrite = true ; private Mapper mapperElement = null ; private Vector patternsets = new Vector ( ) ; private Union resources = new Union ( ) ; private boolean resourcesSpecified = false ; private static final String NATIVE_ENCODING = "native-encoding" ; private String encoding = "UTF8" ; public static final String ERROR_MULTIPLE_MAPPERS = "Cannot define more than one mapper" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public void execute ( ) throws BuildException { if ( "expand" . equals ( getTaskType ( ) ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } if ( source == null && ! resourcesSpecified ) { throw new BuildException ( "src attribute and/or resources must be " + "specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( dest . exists ( ) && ! dest . isDirectory ( ) ) { throw new BuildException ( "Dest must be a directory." , getLocation ( ) ) ; } if ( source != null ) { if ( source . isDirectory ( ) ) { throw new BuildException ( "Src must not be a directory." + " Use nested filesets instead." , getLocation ( ) ) ; } else { expandFile ( FILE_UTILS , source , dest ) ; } } Iterator iter = resources . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } if ( r instanceof FileResource ) { expandFile ( FILE_UTILS , ( ( FileResource ) r ) . getFile ( ) , dest ) ; } else { expandResource ( r , dest ) ; } } } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; ZipFile zf = null ; FileNameMapper mapper = getMapper ( ) ; try { zf = new ZipFile ( srcF , encoding ) ; Enumeration e = zf . getEntries ( ) ; while ( e . hasMoreElements ( ) ) { ZipEntry ze = ( ZipEntry ) e . nextElement ( ) ; extractFile ( fileUtils , srcF , dir , zf . getInputStream ( ze ) , ze . getName ( ) , new Date ( ze . getTime ( ) ) , ze . isDirectory ( ) , mapper ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { ZipFile . closeQuietly ( zf ) ; } } protected void expandResource ( Resource srcR , File dir ) { throw new BuildException ( "only filesystem based resources are" + " supported by this task." ) ; } protected FileNameMapper getMapper ( ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else { mapper = new IdentityMapper ( ) ; } return mapper ; } protected void extractFile ( FileUtils fileUtils , File srcF , File dir , InputStream compressedInputStream , String entryName , Date entryDate , boolean isDirectory , FileNameMapper mapper ) throws IOException { if ( patternsets != null && patternsets . size ( ) > 0 ) { String name = entryName . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; boolean included = false ; Set includePatterns = new HashSet ( ) ; Set excludePatterns = new HashSet ( ) ; for ( int v = 0 , size = patternsets . size ( ) ; v < size ; v ++ ) { PatternSet p = ( PatternSet ) patternsets . elementAt ( v ) ; String [ ] incls = p . getIncludePatterns ( getProject ( ) ) ; if ( incls == null || incls . length == 0 ) { incls = new String [ ] { "**" } ; } for ( int w = 0 ; w < incls . length ; w ++ ) { String pattern = incls [ w ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } includePatterns . add ( pattern ) ; } String [ ] excls = p . getExcludePatterns ( getProject ( ) ) ; if ( excls != null ) { for ( int w = 0 ; w < excls . length ; w ++ ) { String pattern = excls [ w ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } excludePatterns . add ( pattern ) ; } } } for ( Iterator iter = includePatterns . iterator ( ) ; ! included && iter . hasNext ( ) ; ) { String pattern = ( String ) iter . next ( ) ; included = SelectorUtils . matchPath ( pattern , name ) ; } for ( Iterator iter = excludePatterns . iterator ( ) ; included && iter . hasNext ( ) ; ) { String pattern = ( String ) iter . next ( ) ; included = ! SelectorUtils . matchPath ( pattern , name ) ; } if ( ! included ) { return ; } } String [ ] mappedNames = mapper . mapFileName ( entryName ) ; if ( mappedNames == null || mappedNames . length == 0 ) { mappedNames = new String [ ] { entryName } ; } File f = fileUtils . resolveFile ( dir , mappedNames [ 0 ] ) ; try { if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= entryDate . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; return ; } log ( "expanding " + entryName + " to " + f , Project . MSG_VERBOSE ) ; File dirF = f . getParentFile ( ) ; if ( dirF != null ) { dirF . mkdirs ( ) ; } if ( isDirectory ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; while ( ( length = compressedInputStream . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; fos = null ; } finally { FileUtils . close ( fos ) ; } } fileUtils . setFileLastModified ( f , entryDate . getTime ( ) ) ; } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } public void addPatternset ( PatternSet set ) { patternsets . addElement ( set ) ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection rc ) { resourcesSpecified = true ; resources . add ( rc ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( ERROR_MULTIPLE_MAPPERS , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public void setEncoding ( String encoding ) { if ( NATIVE_ENCODING . equals ( encoding ) ) { encoding = null ; } this . encoding = encoding ; } } 	1
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class BaseSelectorContainer extends BaseSelector implements SelectorContainer { private Vector selectorsList = new Vector ( ) ; public BaseSelectorContainer ( ) { } public boolean hasSelectors ( ) { return ! ( selectorsList . isEmpty ( ) ) ; } public int selectorCount ( ) { return selectorsList . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { FileSelector [ ] result = new FileSelector [ selectorsList . size ( ) ] ; selectorsList . copyInto ( result ) ; return result ; } public Enumeration selectorElements ( ) { return selectorsList . elements ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = selectorElements ( ) ; if ( e . hasMoreElements ( ) ) { while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) . toString ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } } return buf . toString ( ) ; } public void appendSelector ( FileSelector selector ) { selectorsList . addElement ( selector ) ; } public void validate ( ) { verifySettings ( ) ; String errmsg = getError ( ) ; if ( errmsg != null ) { throw new BuildException ( errmsg ) ; } Enumeration e = selectorElements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof BaseSelector ) { ( ( BaseSelector ) o ) . validate ( ) ; } } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { appendSelector ( selector ) ; } public void addType ( TypeSelector selector ) { appendSelector ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { appendSelector ( selector ) ; } public void addModified ( ModifiedSelector selector ) { appendSelector ( selector ) ; } public void add ( FileSelector selector ) { appendSelector ( selector ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . javah ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . optional . Javah ; public interface JavahAdapter { boolean compile ( Javah javah ) throws BuildException ; } 	0
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; public class PresentSelector extends BaseSelector { private File targetdir = null ; private Mapper mapperElement = null ; private FileNameMapper map = null ; private boolean destmustexist = true ; public PresentSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{presentselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " present: " ) ; if ( destmustexist ) { buf . append ( "both" ) ; } else { buf . append ( "srconly" ) ; } if ( map != null ) { buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void setPresent ( FilePresence fp ) { if ( fp . getIndex ( ) == 0 ) { destmustexist = false ; } } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; return destfile . exists ( ) == destmustexist ; } public static class FilePresence extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "srconly" , "both" } ; } } } 	0
package org . apache . tools . ant . input ; import java . util . Vector ; public class MultipleChoiceInputRequest extends InputRequest { private Vector choices = new Vector ( ) ; public MultipleChoiceInputRequest ( String prompt , Vector choices ) { super ( prompt ) ; if ( choices == null ) { throw new IllegalArgumentException ( "choices must not be null" ) ; } this . choices = choices ; } public Vector getChoices ( ) { return choices ; } public boolean isInputValid ( ) { return choices . contains ( getInput ( ) ) || ( "" . equals ( getInput ( ) ) && getDefaultValue ( ) != null ) ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . OutputStream ; import java . io . FileOutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . XMLFragment ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Node ; import org . w3c . dom . Element ; public class EchoXML extends XMLFragment { private File file ; private boolean append ; private static final String ERROR_NO_XML = "No nested XML specified" ; public void setFile ( File f ) { file = f ; } public void setAppend ( boolean b ) { append = b ; } public void execute ( ) { DOMElementWriter writer = new DOMElementWriter ( ! append ) ; OutputStream os = null ; try { if ( file != null ) { os = new FileOutputStream ( file . getAbsolutePath ( ) , append ) ; } else { os = new LogOutputStream ( this , Project . MSG_INFO ) ; } Node n = getFragment ( ) . getFirstChild ( ) ; if ( n == null ) { throw new BuildException ( ERROR_NO_XML ) ; } writer . write ( ( Element ) n , os ) ; } catch ( BuildException e ) { throw e ; } catch ( Exception e ) { throw new BuildException ( e ) ; } finally { FileUtils . close ( os ) ; } } } 	1
package org . apache . tools . mail ; import java . io . IOException ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . OutputStream ; import java . net . Socket ; import java . net . InetAddress ; import java . util . Vector ; import java . util . Enumeration ; public class MailMessage { public static final String DEFAULT_HOST = "localhost" ; public static final int DEFAULT_PORT = 25 ; private String host ; private int port = DEFAULT_PORT ; private String from ; private Vector replyto ; private Vector to ; private Vector cc ; private Vector headersKeys ; private Vector headersValues ; private MailPrintStream out ; private SmtpResponseReader in ; private Socket socket ; private static final int OK_READY = 220 ; private static final int OK_HELO = 250 ; private static final int OK_FROM = 250 ; private static final int OK_RCPT_1 = 250 ; private static final int OK_RCPT_2 = 251 ; private static final int OK_DATA = 354 ; private static final int OK_DOT = 250 ; private static final int OK_QUIT = 221 ; public MailMessage ( ) throws IOException { this ( DEFAULT_HOST , DEFAULT_PORT ) ; } public MailMessage ( String host ) throws IOException { this ( host , DEFAULT_PORT ) ; } public MailMessage ( String host , int port ) throws IOException { this . port = port ; this . host = host ; replyto = new Vector ( ) ; to = new Vector ( ) ; cc = new Vector ( ) ; headersKeys = new Vector ( ) ; headersValues = new Vector ( ) ; connect ( ) ; sendHelo ( ) ; } public void setPort ( int port ) { this . port = port ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void replyto ( String rto ) { this . replyto . addElement ( rto ) ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { setHeader ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headersKeys . add ( name ) ; headersValues . add ( value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setReplyToHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (ant.apache.org)" ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setReplyToHeader ( ) { if ( ! replyto . isEmpty ( ) ) { setHeader ( "Reply-To" , vectorToList ( replyto ) ) ; } } void setToHeader ( ) { if ( ! to . isEmpty ( ) ) { setHeader ( "To" , vectorToList ( to ) ) ; } } void setCcHeader ( ) { if ( ! cc . isEmpty ( ) ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { for ( int i = 0 ; i < headersKeys . size ( ) ; i ++ ) { String name = ( String ) headersKeys . elementAt ( i ) ; String value = ( String ) headersValues . elementAt ( i ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { try { sendDot ( ) ; sendQuit ( ) ; } finally { disconnect ( ) ; } } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , port ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { OK_READY } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { OK_HELO } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { OK_FROM } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { OK_RCPT_1 , OK_RCPT_2 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { OK_DATA } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { OK_DOT } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { OK_QUIT } ; try { send ( "QUIT" , ok ) ; } catch ( IOException e ) { throw new ErrorInQuitException ( e ) ; } } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) { out . close ( ) ; } if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } if ( socket != null ) { try { socket . close ( ) ; } catch ( IOException e ) { } } } } class MailPrintStream extends PrintStream { private int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte [ ] buf , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class DoubleCPInfo extends ConstantCPInfo { public DoubleCPInfo ( ) { super ( CONSTANT_DOUBLE , 2 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Double ( cpStream . readDouble ( ) ) ) ; } public String toString ( ) { return "Double Constant Pool Entry: " + getValue ( ) ; } } 	0
package org . apache . tools . ant . taskdefs . condition ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public class Socket extends ProjectComponent implements Condition { private String server = null ; private int port = 0 ; public void setServer ( String server ) { this . server = server ; } public void setPort ( int port ) { this . port = port ; } public boolean eval ( ) throws BuildException { if ( server == null ) { throw new BuildException ( "No server specified in socket " + "condition" ) ; } if ( port == 0 ) { throw new BuildException ( "No port specified in socket condition" ) ; } log ( "Checking for listener at " + server + ":" + port , Project . MSG_VERBOSE ) ; java . net . Socket s = null ; try { s = new java . net . Socket ( server , port ) ; } catch ( IOException e ) { return false ; } finally { if ( s != null ) { try { s . close ( ) ; } catch ( IOException ioe ) { } } } return true ; } } 	0
package org . apache . tools . ant ; public class ExitStatusException extends BuildException { private int status ; public ExitStatusException ( int status ) { super ( ) ; this . status = status ; } public ExitStatusException ( String msg , int status ) { super ( msg ) ; this . status = status ; } public ExitStatusException ( String message , int status , Location location ) { super ( message , location ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	0
package org . apache . tools . ant ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . List ; import java . util . StringTokenizer ; import org . apache . tools . ant . util . CollectionUtils ; public class Target implements TaskContainer { private String name ; private String ifCondition = "" ; private String unlessCondition = "" ; private List dependencies = null ; private List children = new ArrayList ( ) ; private Location location = Location . UNKNOWN_LOCATION ; private Project project ; private String description = null ; public Target ( ) { } public Target ( Target other ) { this . name = other . name ; this . ifCondition = other . ifCondition ; this . unlessCondition = other . unlessCondition ; this . dependencies = other . dependencies ; this . location = other . location ; this . project = other . project ; this . description = other . description ; this . children = other . children ; } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void setDepends ( String depS ) { if ( depS . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depS , "," , true ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; if ( "" . equals ( token ) || "," . equals ( token ) ) { throw new BuildException ( "Syntax Error: depends " + "attribute of target \"" + getName ( ) + "\" has an empty string as dependency." ) ; } addDependency ( token ) ; if ( tok . hasMoreTokens ( ) ) { token = tok . nextToken ( ) ; if ( ! tok . hasMoreTokens ( ) || ! "," . equals ( token ) ) { throw new BuildException ( "Syntax Error: Depend " + "attribute for target \"" + getName ( ) + "\" ends with a , character" ) ; } } } } } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void addTask ( Task task ) { children . add ( task ) ; } public void addDataType ( RuntimeConfigurable r ) { children . add ( r ) ; } public Task [ ] getTasks ( ) { List tasks = new ArrayList ( children . size ( ) ) ; Iterator it = children . iterator ( ) ; while ( it . hasNext ( ) ) { Object o = it . next ( ) ; if ( o instanceof Task ) { tasks . add ( o ) ; } } return ( Task [ ] ) tasks . toArray ( new Task [ tasks . size ( ) ] ) ; } public void addDependency ( String dependency ) { if ( dependencies == null ) { dependencies = new ArrayList ( 2 ) ; } dependencies . add ( dependency ) ; } public Enumeration getDependencies ( ) { return ( dependencies != null ? Collections . enumeration ( dependencies ) : new CollectionUtils . EmptyEnumeration ( ) ) ; } public boolean dependsOn ( String other ) { Project p = getProject ( ) ; Hashtable t = ( p == null ) ? null : p . getTargets ( ) ; return ( p != null && p . topoSort ( getName ( ) , t , false ) . contains ( t . get ( other ) ) ) ; } public void setIf ( String property ) { ifCondition = ( property == null ) ? "" : property ; } public String getIf ( ) { return ( "" . equals ( ifCondition ) ? null : ifCondition ) ; } public void setUnless ( String property ) { unlessCondition = ( property == null ) ? "" : property ; } public String getUnless ( ) { return ( "" . equals ( unlessCondition ) ? null : unlessCondition ) ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public String toString ( ) { return name ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { for ( int taskPosition = 0 ; taskPosition < children . size ( ) ; ++ taskPosition ) { Object o = children . get ( taskPosition ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . perform ( ) ; } else { RuntimeConfigurable r = ( RuntimeConfigurable ) o ; r . maybeConfigure ( project ) ; } } } else if ( ! testIfCondition ( ) ) { project . log ( this , "Skipped because property '" + project . replaceProperties ( ifCondition ) + "' not set." , Project . MSG_VERBOSE ) ; } else { project . log ( this , "Skipped because property '" + project . replaceProperties ( unlessCondition ) + "' set." , Project . MSG_VERBOSE ) ; } } public final void performTasks ( ) { RuntimeException thrown = null ; project . fireTargetStarted ( this ) ; try { execute ( ) ; } catch ( RuntimeException exc ) { thrown = exc ; throw exc ; } finally { project . fireTargetFinished ( this , thrown ) ; } } void replaceChild ( Task el , RuntimeConfigurable o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . set ( index , o ) ; } } void replaceChild ( Task el , Task o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . set ( index , o ) ; } } private boolean testIfCondition ( ) { if ( "" . equals ( ifCondition ) ) { return true ; } String test = project . replaceProperties ( ifCondition ) ; return project . getProperty ( test ) != null ; } private boolean testUnlessCondition ( ) { if ( "" . equals ( unlessCondition ) ) { return true ; } String test = project . replaceProperties ( unlessCondition ) ; return project . getProperty ( test ) == null ; } } 	1
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . selectors . SelectorUtils ; public class Name implements ResourceSelector { private String pattern ; private boolean cs = true ; public void setName ( String n ) { pattern = n ; } public String getName ( ) { return pattern ; } public void setCaseSensitive ( boolean b ) { cs = b ; } public boolean isCaseSensitive ( ) { return cs ; } public boolean isSelected ( Resource r ) { String n = r . getName ( ) ; if ( SelectorUtils . match ( pattern , n , cs ) ) { return true ; } String s = r . toString ( ) ; return s . equals ( n ) ? false : SelectorUtils . match ( pattern , s , cs ) ; } } 	0
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Contains implements Condition { private String string , subString ; private boolean caseSensitive = true ; public void setString ( String string ) { this . string = string ; } public void setSubstring ( String subString ) { this . subString = subString ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( string == null || subString == null ) { throw new BuildException ( "both string and substring are required " + "in contains" ) ; } return caseSensitive ? string . indexOf ( subString ) > - 1 : string . toLowerCase ( ) . indexOf ( subString . toLowerCase ( ) ) > - 1 ; } } 	0
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . types . Permissions ; public interface JUnitTaskMirror { void addVmExit ( JUnitTest test , JUnitResultFormatterMirror formatter , OutputStream out , String message , String testCase ) ; JUnitTestRunnerMirror newJUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filterTrace , boolean haltOnFailure , boolean showOutput , boolean logTestListenerEvents , AntClassLoader classLoader ) ; SummaryJUnitResultFormatterMirror newSummaryJUnitResultFormatter ( ) ; public interface JUnitResultFormatterMirror { void setOutput ( OutputStream outputStream ) ; } public interface SummaryJUnitResultFormatterMirror extends JUnitResultFormatterMirror { void setWithOutAndErr ( boolean value ) ; } public interface JUnitTestRunnerMirror { String IGNORED_FILE_NAME = "IGNORETHIS" ; int SUCCESS = 0 ; int FAILURES = 1 ; int ERRORS = 2 ; void setPermissions ( Permissions perm ) ; void run ( ) ; void addFormatter ( JUnitResultFormatterMirror formatter ) ; int getRetCode ( ) ; void handleErrorFlush ( String output ) ; void handleErrorOutput ( String output ) ; void handleOutput ( String output ) ; int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException ; void handleFlush ( String output ) ; } } 	0
package org . apache . tools . ant ; public abstract class ProjectComponent implements Cloneable { protected Project project ; protected Location location = Location . UNKNOWN_LOCATION ; protected String description ; public ProjectComponent ( ) { } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { if ( getProject ( ) != null ) { getProject ( ) . log ( msg , msgLevel ) ; } else { if ( msgLevel <= Project . MSG_INFO ) { System . err . println ( msg ) ; } } } public Object clone ( ) throws CloneNotSupportedException { ProjectComponent pc = ( ProjectComponent ) super . clone ( ) ; pc . setLocation ( getLocation ( ) ) ; pc . setProject ( getProject ( ) ) ; return pc ; } } 	0
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; public final class StripLineComments extends BaseParamFilterReader implements ChainableReader { private static final String COMMENTS_KEY = "comment" ; private Vector comments = new Vector ( ) ; private String line = null ; public StripLineComments ( ) { super ( ) ; } public StripLineComments ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int commentsSize = comments . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < commentsSize ; i ++ ) { String comment = ( String ) comments . elementAt ( i ) ; if ( line . startsWith ( comment ) ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public void addConfiguredComment ( final Comment comment ) { comments . addElement ( comment . getValue ( ) ) ; } private void setComments ( final Vector comments ) { this . comments = comments ; } private Vector getComments ( ) { return comments ; } public Reader chain ( final Reader rdr ) { StripLineComments newFilter = new StripLineComments ( rdr ) ; newFilter . setComments ( getComments ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( COMMENTS_KEY . equals ( params [ i ] . getType ( ) ) ) { comments . addElement ( params [ i ] . getValue ( ) ) ; } } } } public static class Comment { private String value ; public final void setValue ( String comment ) { value = comment ; } public final String getValue ( ) { return value ; } } } 	0
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; public class CSharp extends DotnetCompile { String definitions ; private File docFile ; private int fileAlign = 0 ; private boolean fullpaths = false ; private boolean incremental ; protected boolean unsafe ; private boolean noconfig = false ; public CSharp ( ) { clear ( ) ; } public void clear ( ) { super . clear ( ) ; docFile = null ; fileAlign = 0 ; fullpaths = true ; incremental = false ; unsafe = false ; noconfig = false ; definitions = null ; setExecutable ( isWindows ? "csc" : "mcs" ) ; } public void setDocFile ( File f ) { docFile = f ; } protected String getDocFileParameter ( ) { if ( docFile != null ) { return "/doc:" + docFile . toString ( ) ; } else { return null ; } } public void setFileAlign ( int fileAlign ) { this . fileAlign = fileAlign ; } protected String getFileAlignParameter ( ) { if ( fileAlign != 0 && ! "mcs" . equals ( getExecutable ( ) ) ) { return "/filealign:" + fileAlign ; } else { return null ; } } public void setFullPaths ( boolean enabled ) { fullpaths = enabled ; } protected String getFullPathsParameter ( ) { return fullpaths ? "/fullpaths" : null ; } public void setIncremental ( boolean incremental ) { this . incremental = incremental ; } public boolean getIncremental ( ) { return incremental ; } protected String getIncrementalParameter ( ) { return "/incremental" + ( incremental ? "+" : "-" ) ; } public void setOutputFile ( File params ) { setDestFile ( params ) ; } public void setUnsafe ( boolean unsafe ) { this . unsafe = unsafe ; } public boolean getUnsafe ( ) { return this . unsafe ; } protected String getUnsafeParameter ( ) { return unsafe ? "/unsafe" : null ; } public void setNoConfig ( boolean enabled ) { noconfig = enabled ; } protected String getNoConfigParameter ( ) { return noconfig ? "/noconfig" : null ; } public void setDefinitions ( String params ) { definitions = params ; } protected String getDefinitionsParameter ( ) { String predecessors = super . getDefinitionsParameter ( ) ; if ( notEmpty ( definitions ) ) { if ( predecessors == null ) { predecessors = "/define:" ; } return predecessors + definitions ; } else { return predecessors ; } } public void addCompilerSpecificOptions ( NetCommand command ) { command . addArgument ( getIncludeDefaultReferencesParameter ( ) ) ; command . addArgument ( getWarnLevelParameter ( ) ) ; command . addArgument ( getDocFileParameter ( ) ) ; command . addArgument ( getFullPathsParameter ( ) ) ; command . addArgument ( getFileAlignParameter ( ) ) ; command . addArgument ( getIncrementalParameter ( ) ) ; command . addArgument ( getNoConfigParameter ( ) ) ; command . addArgument ( getUnsafeParameter ( ) ) ; } public String getReferenceDelimiter ( ) { return ";" ; } public String getFileExtension ( ) { return "cs" ; } protected void createResourceParameter ( NetCommand command , DotnetResource resource ) { resource . getParameters ( getProject ( ) , command , true ) ; } } 	0
package org . apache . tools . ant . types ; public interface ResourceFactory { Resource getResource ( String name ) ; } 	0
package org . apache . tools . ant ; public interface DynamicConfiguratorNS extends DynamicAttributeNS , DynamicElementNS { } 	0
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class TimeComparison extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "before" , "after" , "equal" } ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public static final TimeComparison BEFORE = new TimeComparison ( "before" ) ; public static final TimeComparison AFTER = new TimeComparison ( "after" ) ; public static final TimeComparison EQUAL = new TimeComparison ( "equal" ) ; public TimeComparison ( ) { } public TimeComparison ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } public boolean evaluate ( long t1 , long t2 ) { return evaluate ( t1 , t2 , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public boolean evaluate ( long t1 , long t2 , long g ) { int cmp = getIndex ( ) ; if ( cmp == - 1 ) { throw new BuildException ( "TimeComparison value not set." ) ; } if ( cmp == 0 ) { return t1 - g < t2 ; } if ( cmp == 1 ) { return t1 + g > t2 ; } return Math . abs ( t1 - t2 ) <= g ; } public static int compare ( long t1 , long t2 ) { return compare ( t1 , t2 , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public static int compare ( long t1 , long t2 , long g ) { long diff = t1 - t2 ; long abs = Math . abs ( diff ) ; return abs > Math . abs ( g ) ? ( int ) ( diff / abs ) : 0 ; } } 	0
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; public class MSVSSCREATE extends MSVSS { Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CREATE ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getQuiet ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; return commandLine ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } public final void setQuiet ( boolean quiet ) { super . setInternalQuiet ( quiet ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } } 	0
package org . apache . tools . tar ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; import java . util . Arrays ; public class TarBuffer { public static final int DEFAULT_RCDSIZE = ( 512 ) ; public static final int DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 ) ; private InputStream inStream ; private OutputStream outStream ; private byte [ ] blockBuffer ; private int currBlkIdx ; private int currRecIdx ; private int blockSize ; private int recordSize ; private int recsPerBlock ; private boolean debug ; public TarBuffer ( InputStream inStream ) { this ( inStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize ) { this ( inStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize , int recordSize ) { this . inStream = inStream ; this . outStream = null ; this . initialize ( blockSize , recordSize ) ; } public TarBuffer ( OutputStream outStream ) { this ( outStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize ) { this ( outStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize , int recordSize ) { this . inStream = null ; this . outStream = outStream ; this . initialize ( blockSize , recordSize ) ; } private void initialize ( int blockSize , int recordSize ) { this . debug = false ; this . blockSize = blockSize ; this . recordSize = recordSize ; this . recsPerBlock = ( this . blockSize / this . recordSize ) ; this . blockBuffer = new byte [ this . blockSize ] ; if ( this . inStream != null ) { this . currBlkIdx = - 1 ; this . currRecIdx = this . recsPerBlock ; } else { this . currBlkIdx = 0 ; this . currRecIdx = 0 ; } } public int getBlockSize ( ) { return this . blockSize ; } public int getRecordSize ( ) { return this . recordSize ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean isEOFRecord ( byte [ ] record ) { for ( int i = 0 , sz = this . getRecordSize ( ) ; i < sz ; ++ i ) { if ( record [ i ] != 0 ) { return false ; } } return true ; } public void skipRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "SkipRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading (via skip) from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return ; } } this . currRecIdx ++ ; } public byte [ ] readRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ this . recordSize ] ; System . arraycopy ( this . blockBuffer , ( this . currRecIdx * this . recordSize ) , result , 0 , this . recordSize ) ; this . currRecIdx ++ ; return result ; } private boolean readBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } this . currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = this . blockSize ; while ( bytesNeeded > 0 ) { long numBytes = this . inStream . read ( this . blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { if ( offset == 0 ) { return false ; } Arrays . fill ( blockBuffer , offset , offset + bytesNeeded , ( byte ) 0 ) ; break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != this . blockSize ) { if ( this . debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + this . blockSize + " bytes read." ) ; } } } this . currBlkIdx ++ ; return true ; } public int getCurrentBlockNum ( ) { return this . currBlkIdx ; } public int getCurrentRecordNum ( ) { return this . currRecIdx - 1 ; } public void writeRecord ( byte [ ] record ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( record . length != this . recordSize ) { throw new IOException ( "record to write has length '" + record . length + "' which is not the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( record , 0 , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( ( offset + this . recordSize ) > buf . length ) { throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( buf , offset , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } private void writeBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "WriteBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } this . outStream . write ( this . blockBuffer , 0 , this . blockSize ) ; this . outStream . flush ( ) ; this . currRecIdx = 0 ; this . currBlkIdx ++ ; } private void flushBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.flushBlock() called." ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( this . currRecIdx > 0 ) { this . writeBlock ( ) ; } } public void close ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.closeBuffer()." ) ; } if ( this . outStream != null ) { this . flushBlock ( ) ; if ( this . outStream != System . out && this . outStream != System . err ) { this . outStream . close ( ) ; this . outStream = null ; } } else if ( this . inStream != null ) { if ( this . inStream != System . in ) { this . inStream . close ( ) ; this . inStream = null ; } } } } 	1
package org . apache . tools . ant . types . selectors ; public class NotSelector extends NoneSelector { public NotSelector ( ) { } public NotSelector ( FileSelector other ) { this ( ) ; appendSelector ( other ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{notselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void verifySettings ( ) { if ( selectorCount ( ) != 1 ) { setError ( "One and only one selector is allowed within the " + "<not> tag" ) ; } } } 	0
package org . apache . tools . ant . util . depend . bcel ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . JavaClass ; import org . apache . tools . ant . util . depend . AbstractAnalyzer ; public class AncestorAnalyzer extends AbstractAnalyzer { public AncestorAnalyzer ( ) { try { new ClassParser ( "force" ) ; } catch ( IOException e ) { } } protected void determineDependencies ( Vector files , Vector classes ) { Hashtable dependencies = new Hashtable ( ) ; Hashtable containers = new Hashtable ( ) ; Hashtable toAnalyze = new Hashtable ( ) ; Hashtable nextAnalyze = new Hashtable ( ) ; for ( Enumeration e = getRootClasses ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; toAnalyze . put ( classname , classname ) ; } int count = 0 ; int maxCount = isClosureRequired ( ) ? MAX_LOOPS : 2 ; while ( toAnalyze . size ( ) != 0 && count ++ < maxCount ) { nextAnalyze . clear ( ) ; for ( Enumeration e = toAnalyze . keys ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; dependencies . put ( classname , classname ) ; try { File container = getClassContainer ( classname ) ; if ( container == null ) { continue ; } containers . put ( container , container ) ; ClassParser parser = null ; if ( container . getName ( ) . endsWith ( ".class" ) ) { parser = new ClassParser ( container . getPath ( ) ) ; } else { parser = new ClassParser ( container . getPath ( ) , classname . replace ( '.' , '/' ) + ".class" ) ; } JavaClass javaClass = parser . parse ( ) ; String [ ] interfaces = javaClass . getInterfaceNames ( ) ; for ( int i = 0 ; i < interfaces . length ; ++ i ) { String interfaceName = interfaces [ i ] ; if ( ! dependencies . containsKey ( interfaceName ) ) { nextAnalyze . put ( interfaceName , interfaceName ) ; } } if ( javaClass . isClass ( ) ) { String superClass = javaClass . getSuperclassName ( ) ; if ( ! dependencies . containsKey ( superClass ) ) { nextAnalyze . put ( superClass , superClass ) ; } } } catch ( IOException ioe ) { } } Hashtable temp = toAnalyze ; toAnalyze = nextAnalyze ; nextAnalyze = temp ; } files . removeAllElements ( ) ; for ( Enumeration e = containers . keys ( ) ; e . hasMoreElements ( ) ; ) { files . addElement ( ( File ) e . nextElement ( ) ) ; } classes . removeAllElements ( ) ; for ( Enumeration e = dependencies . keys ( ) ; e . hasMoreElements ( ) ; ) { classes . addElement ( ( String ) e . nextElement ( ) ) ; } } protected boolean supportsFileDependencies ( ) { return true ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . TimeComparison ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Sort ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . Restrict ; import org . apache . tools . ant . types . resources . Resources ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . Not ; import org . apache . tools . ant . types . resources . selectors . Exists ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . resources . comparators . Reverse ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; public class DependSet extends MatchingTask { private static final ResourceSelector NOT_EXISTS = new Not ( new Exists ( ) ) ; private static final ResourceComparator DATE_ASC = new org . apache . tools . ant . types . resources . comparators . Date ( ) ; private static final ResourceComparator DATE_DESC = new Reverse ( DATE_ASC ) ; private static class NonExistent extends Restrict { private NonExistent ( ResourceCollection rc ) { super . add ( rc ) ; super . add ( NOT_EXISTS ) ; } } private static class Xest extends Sort { private Xest ( ResourceCollection rc , ResourceComparator c ) { super . add ( c ) ; super . add ( rc ) ; } } private static class Oldest extends Xest { private Oldest ( ResourceCollection rc ) { super ( rc , DATE_ASC ) ; } } private static class Newest extends Xest { private Newest ( ResourceCollection rc ) { super ( rc , DATE_DESC ) ; } } private static class HideMissingBasedir implements ResourceCollection { private FileSet fs ; private HideMissingBasedir ( FileSet fs ) { this . fs = fs ; } public Iterator iterator ( ) { return basedirExists ( ) ? fs . iterator ( ) : Resources . EMPTY_ITERATOR ; } public int size ( ) { return basedirExists ( ) ? fs . size ( ) : 0 ; } public boolean isFilesystemOnly ( ) { return true ; } private boolean basedirExists ( ) { File basedir = fs . getDir ( ) ; return basedir == null || basedir . exists ( ) ; } } private Union sources = null ; private Path targets = null ; public synchronized Union createSources ( ) { sources = ( sources == null ) ? new Union ( ) : sources ; return sources ; } public void addSrcfileset ( FileSet fs ) { createSources ( ) . add ( fs ) ; } public void addSrcfilelist ( FileList fl ) { createSources ( ) . add ( fl ) ; } public synchronized Path createTargets ( ) { targets = ( targets == null ) ? new Path ( getProject ( ) ) : targets ; return targets ; } public void addTargetfileset ( FileSet fs ) { createTargets ( ) . add ( new HideMissingBasedir ( fs ) ) ; } public void addTargetfilelist ( FileList fl ) { createTargets ( ) . add ( fl ) ; } public void execute ( ) throws BuildException { if ( sources == null ) { throw new BuildException ( "At least one set of source resources must be specified" ) ; } if ( targets == null ) { throw new BuildException ( "At least one set of target files must be specified" ) ; } if ( sources . size ( ) > 0 && targets . size ( ) > 0 && ! uptodate ( sources , targets ) ) { log ( "Deleting all target files." , Project . MSG_VERBOSE ) ; Delete delete = new Delete ( ) ; delete . bindToOwner ( this ) ; delete . add ( targets ) ; delete . perform ( ) ; } } private boolean uptodate ( ResourceCollection src , ResourceCollection target ) { org . apache . tools . ant . types . resources . selectors . Date datesel = new org . apache . tools . ant . types . resources . selectors . Date ( ) ; datesel . setMillis ( System . currentTimeMillis ( ) ) ; datesel . setWhen ( TimeComparison . AFTER ) ; logFuture ( targets , datesel ) ; int neTargets = new NonExistent ( targets ) . size ( ) ; if ( neTargets > 0 ) { log ( neTargets + " nonexistent targets" , Project . MSG_VERBOSE ) ; return false ; } FileResource oldestTarget = ( FileResource ) ( new Oldest ( targets ) . iterator ( ) . next ( ) ) ; log ( oldestTarget + " is oldest target file" , Project . MSG_VERBOSE ) ; logFuture ( sources , datesel ) ; int neSources = new NonExistent ( sources ) . size ( ) ; if ( neSources > 0 ) { log ( neSources + " nonexistent sources" , Project . MSG_VERBOSE ) ; return false ; } Resource newestSource = ( Resource ) ( new Newest ( sources ) . iterator ( ) . next ( ) ) ; log ( newestSource . toLongString ( ) + " is newest source" , Project . MSG_VERBOSE ) ; return oldestTarget . getLastModified ( ) >= newestSource . getLastModified ( ) ; } private void logFuture ( ResourceCollection rc , ResourceSelector rsel ) { Restrict r = new Restrict ( ) ; r . add ( rsel ) ; r . add ( rc ) ; for ( Iterator i = r . iterator ( ) ; i . hasNext ( ) ; ) { log ( "Warning: " + i . next ( ) + " modified in the future." , Project . MSG_WARN ) ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; public class Ilasm extends DotnetBaseMatchingTask { protected static final String exe_name = "ilasm" ; protected static final String file_ext = "il" ; protected static final String file_pattern = "**/*." + file_ext ; protected static final String exe_title = "ilasm" ; protected String targetType ; protected boolean verbose ; protected boolean listing ; protected File resourceFile ; protected boolean failOnError ; protected boolean debug ; private File keyfile ; protected String extraOptions ; protected Vector referenceFilesets = new Vector ( ) ; private boolean isMono = ! Os . isFamily ( "windows" ) ; public Ilasm ( ) { Clear ( ) ; setIncludes ( file_pattern ) ; } public void Clear ( ) { targetType = null ; srcDir = null ; listing = false ; verbose = false ; debug = true ; outputFile = null ; failOnError = true ; resourceFile = null ; extraOptions = null ; } public void setTargetType ( String targetType ) throws BuildException { this . targetType = targetType . toLowerCase ( ) ; if ( ! targetType . equals ( "exe" ) && ! targetType . equals ( "library" ) ) { throw new BuildException ( "targetType " + targetType + " is not a valid type" ) ; } } public String getTargetType ( ) { return targetType ; } protected String getTargetTypeParameter ( ) { if ( ! notEmpty ( targetType ) ) { return null ; } if ( targetType . equals ( "exe" ) ) { return "/exe" ; } else if ( targetType . equals ( "library" ) ) { return "/dll" ; } else { return null ; } } public void setOwner ( String s ) { log ( "This option is not supported by ILASM as of Beta-2, " + "and will be ignored" , Project . MSG_WARN ) ; } protected boolean notEmpty ( String s ) { return s != null && s . length ( ) != 0 ; } public void setVerbose ( boolean b ) { verbose = b ; } protected String getVerboseParameter ( ) { return verbose ? null : "/quiet" ; } public void setListing ( boolean b ) { listing = b ; } protected String getListingParameter ( ) { if ( ! isMono ) { return listing ? "/listing" : "/nolisting" ; } return null ; } public void setOutputFile ( File params ) { outputFile = params ; } protected String getOutputFileParameter ( ) { if ( outputFile == null ) { return null ; } return "/output=" + outputFile . toString ( ) ; } public void setResourceFile ( File fileName ) { resourceFile = fileName ; } protected String getResourceFileParameter ( ) { if ( resourceFile != null ) { return "/resource=" + resourceFile . toString ( ) ; } else { return null ; } } public void setFailOnError ( boolean b ) { failOnError = b ; } public boolean getFailOnError ( ) { return failOnError ; } public void setDebug ( boolean f ) { debug = f ; } public boolean getDebug ( ) { return debug ; } protected String getDebugParameter ( ) { return debug ? "/debug" : null ; } public void setKeyfile ( File keyfile ) { this . keyfile = keyfile ; } protected String getKeyfileParameter ( ) { if ( keyfile != null ) { return "/keyfile:" + keyfile . toString ( ) ; } else { return null ; } } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } public String getExtraOptions ( ) { return this . extraOptions ; } protected String getExtraOptionsParameter ( ) { if ( extraOptions != null && extraOptions . length ( ) != 0 ) { return extraOptions ; } else { return null ; } } public void setTargetType ( TargetTypes targetType ) { this . targetType = targetType . getValue ( ) ; } public void setMono ( boolean b ) { isMono = b ; } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; NetCommand command = buildIlasmCommand ( ) ; addFilesAndExecute ( command , false ) ; } private NetCommand buildIlasmCommand ( ) { NetCommand command = new NetCommand ( this , exe_title , exe_name ) ; command . setFailOnError ( getFailOnError ( ) ) ; command . addArgument ( getDebugParameter ( ) ) ; command . addArgument ( getTargetTypeParameter ( ) ) ; command . addArgument ( getListingParameter ( ) ) ; command . addArgument ( getOutputFileParameter ( ) ) ; command . addArgument ( getResourceFileParameter ( ) ) ; command . addArgument ( getVerboseParameter ( ) ) ; command . addArgument ( getKeyfileParameter ( ) ) ; command . addArgument ( getExtraOptionsParameter ( ) ) ; return command ; } public void addReference ( FileSet reference ) { referenceFilesets . add ( reference ) ; } protected static boolean isFileManagedBinary ( File file ) { String filename = file . toString ( ) . toLowerCase ( ) ; return filename . endsWith ( ".exe" ) || filename . endsWith ( ".dll" ) || filename . endsWith ( ".netmodule" ) ; } public static class TargetTypes extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "exe" , "library" , } ; } } } 	0
package org . apache . tools . ant . types . selectors ; import java . io . File ; public class DependSelector extends MappingSelector { public DependSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dependselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " granularity: " ) ; buf . append ( granularity ) ; if ( map != null ) { buf . append ( " mapper: " ) ; buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( " mapper: " ) ; buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public boolean selectionTest ( File srcfile , File destfile ) { boolean selected = SelectorUtils . isOutOfDate ( srcfile , destfile , granularity ) ; return selected ; } } 	0
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarInputStream ; public class TarResource extends ArchiveResource { private String userName = "" ; private String groupName = "" ; private int uid ; private int gid ; public TarResource ( ) { } public TarResource ( File a , TarEntry e ) { super ( a , true ) ; setEntry ( e ) ; } public TarResource ( Resource a , TarEntry e ) { super ( a , true ) ; setEntry ( e ) ; } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } Resource archive = getArchive ( ) ; final TarInputStream i = new TarInputStream ( archive . getInputStream ( ) ) ; TarEntry te = null ; while ( ( te = i . getNextEntry ( ) ) != null ) { if ( te . getName ( ) . equals ( getName ( ) ) ) { return i ; } } FileUtils . close ( i ) ; throw new BuildException ( "no entry " + getName ( ) + " in " + getArchive ( ) ) ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } throw new UnsupportedOperationException ( "Use the tar task for tar output." ) ; } public String getUserName ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getUserName ( ) ; } return userName ; } public String getGroup ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getGroup ( ) ; } return groupName ; } public int getUid ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getUid ( ) ; } return uid ; } public int getGid ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getGid ( ) ; } return uid ; } protected void fetchEntry ( ) { Resource archive = getArchive ( ) ; TarInputStream i = null ; try { i = new TarInputStream ( archive . getInputStream ( ) ) ; TarEntry te = null ; while ( ( te = i . getNextEntry ( ) ) != null ) { if ( te . getName ( ) . equals ( getName ( ) ) ) { setEntry ( te ) ; return ; } } } catch ( IOException e ) { log ( e . getMessage ( ) , Project . MSG_DEBUG ) ; throw new BuildException ( e ) ; } finally { if ( i != null ) { FileUtils . close ( i ) ; } } setEntry ( null ) ; } private void setEntry ( TarEntry e ) { if ( e == null ) { setExists ( false ) ; return ; } setName ( e . getName ( ) ) ; setExists ( true ) ; setLastModified ( e . getModTime ( ) . getTime ( ) ) ; setDirectory ( e . isDirectory ( ) ) ; setSize ( e . getSize ( ) ) ; setMode ( e . getMode ( ) ) ; userName = e . getUserName ( ) ; groupName = e . getGroupName ( ) ; uid = e . getUserId ( ) ; gid = e . getGroupId ( ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . util . Vector ; public class P4Submit extends P4Base { public String change ; private String changeProperty ; private String needsResolveProperty ; public void setChange ( String change ) { this . change = change ; } public void setChangeProperty ( String changeProperty ) { this . changeProperty = changeProperty ; } public void setNeedsResolveProperty ( String needsResolveProperty ) { this . needsResolveProperty = needsResolveProperty ; } public void execute ( ) throws BuildException { if ( change != null ) { execP4Command ( "submit -c " + change , ( P4HandlerAdapter ) new P4SubmitAdapter ( this ) ) ; } else { throw new BuildException ( "No change specified (no support for default change yet...." ) ; } } public class P4SubmitAdapter extends SimpleP4OutputHandler { public P4SubmitAdapter ( P4Base parent ) { super ( parent ) ; } public void process ( String line ) { super . process ( line ) ; getProject ( ) . setProperty ( "p4.needsresolve" , "0" ) ; if ( util . match ( "/renamed/" , line ) ) { try { Vector myarray = new Vector ( ) ; util . split ( myarray , line ) ; boolean found = false ; for ( int counter = 0 ; counter < myarray . size ( ) ; counter ++ ) { if ( found ) { String chnum = ( String ) myarray . elementAt ( counter + 1 ) ; int changenumber = Integer . parseInt ( chnum ) ; log ( "Perforce change renamed " + changenumber , Project . MSG_INFO ) ; getProject ( ) . setProperty ( "p4.change" , "" + changenumber ) ; if ( changeProperty != null ) { getProject ( ) . setNewProperty ( changeProperty , chnum ) ; } found = false ; } if ( ( ( myarray . elementAt ( counter ) ) ) . equals ( "renamed" ) ) { found = true ; } } } catch ( Exception e ) { String msg = "Failed to parse " + line + "\n" + " due to " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } } if ( util . match ( "/p4 submit -c/" , line ) ) { getProject ( ) . setProperty ( "p4.needsresolve" , "1" ) ; if ( needsResolveProperty != null ) { getProject ( ) . setNewProperty ( needsResolveProperty , "true" ) ; } } } } } 	0
package org . apache . tools . ant . types ; public interface Parameterizable { void setParameters ( Parameter [ ] parameters ) ; } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Vector ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . ResourceUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . FlatFileNameMapper ; public class Copy extends Task { static final File NULL_FILE_PLACEHOLDER = new File ( "/NULL_FILE" ) ; static final String LINE_SEPARATOR = System . getProperty ( "line.separator" ) ; protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector rcs = new Vector ( ) ; private boolean enableMultipleMappings = false ; protected boolean filtering = false ; protected boolean preserveLastModified = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; protected boolean failonerror = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; protected Hashtable completeDirMap = new Hashtable ( ) ; protected Mapper mapperElement = null ; protected FileUtils fileUtils ; private Vector filterChains = new Vector ( ) ; private Vector filterSets = new Vector ( ) ; private String inputEncoding = null ; private String outputEncoding = null ; private long granularity = 0 ; public Copy ( ) { fileUtils = FileUtils . getFileUtils ( ) ; granularity = fileUtils . getFileTimestampGranularity ( ) ; } protected FileUtils getFileUtils ( ) { return fileUtils ; } public void setFile ( File file ) { this . file = file ; } public void setTofile ( File destFile ) { this . destFile = destFile ; } public void setTodir ( File destDir ) { this . destDir = destDir ; } public FilterChain createFilterChain ( ) { FilterChain filterChain = new FilterChain ( ) ; filterChains . addElement ( filterChain ) ; return filterChain ; } public FilterSet createFilterSet ( ) { FilterSet filterSet = new FilterSet ( ) ; filterSets . addElement ( filterSet ) ; return filterSet ; } public void setPreserveLastModified ( String preserve ) { setPreserveLastModified ( Project . toBoolean ( preserve ) ) ; } public void setPreserveLastModified ( boolean preserve ) { preserveLastModified = preserve ; } public boolean getPreserveLastModified ( ) { return preserveLastModified ; } protected Vector getFilterSets ( ) { return filterSets ; } protected Vector getFilterChains ( ) { return filterChains ; } public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } public void setOverwrite ( boolean overwrite ) { this . forceOverwrite = overwrite ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setVerbose ( boolean verbose ) { this . verbosity = verbose ? Project . MSG_INFO : Project . MSG_VERBOSE ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void setEnableMultipleMappings ( boolean enableMultipleMappings ) { this . enableMultipleMappings = enableMultipleMappings ; } public boolean isEnableMultipleMapping ( ) { return enableMultipleMappings ; } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void addFileset ( FileSet set ) { add ( set ) ; } public void add ( ResourceCollection res ) { rcs . add ( res ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public void setEncoding ( String encoding ) { this . inputEncoding = encoding ; if ( outputEncoding == null ) { outputEncoding = encoding ; } } public String getEncoding ( ) { return inputEncoding ; } public void setOutputEncoding ( String encoding ) { this . outputEncoding = encoding ; } public String getOutputEncoding ( ) { return outputEncoding ; } public void setGranularity ( long granularity ) { this . granularity = granularity ; } public void execute ( ) throws BuildException { File savedFile = file ; File savedDestFile = destFile ; File savedDestDir = destDir ; ResourceCollection savedRc = null ; if ( file == null && destFile != null && rcs . size ( ) == 1 ) { savedRc = ( ResourceCollection ) rcs . elementAt ( 0 ) ; } validateAttributes ( ) ; try { if ( file != null ) { if ( file . exists ( ) ) { if ( destFile == null ) { destFile = new File ( destDir , file . getName ( ) ) ; } if ( forceOverwrite || ! destFile . exists ( ) || ( file . lastModified ( ) - granularity > destFile . lastModified ( ) ) ) { fileCopyMap . put ( file . getAbsolutePath ( ) , new String [ ] { destFile . getAbsolutePath ( ) } ) ; } else { log ( file + " omitted as " + destFile + " is up to date." , Project . MSG_VERBOSE ) ; } } else { String message = "Warning: Could not find file " + file . getAbsolutePath ( ) + " to copy." ; if ( ! failonerror ) { log ( message , Project . MSG_ERR ) ; } else { throw new BuildException ( message ) ; } } } HashMap filesByBasedir = new HashMap ( ) ; HashMap dirsByBasedir = new HashMap ( ) ; HashSet baseDirs = new HashSet ( ) ; ArrayList nonFileResources = new ArrayList ( ) ; for ( int i = 0 ; i < rcs . size ( ) ; i ++ ) { ResourceCollection rc = ( ResourceCollection ) rcs . elementAt ( i ) ; if ( rc instanceof FileSet && rc . isFilesystemOnly ( ) ) { FileSet fs = ( FileSet ) rc ; DirectoryScanner ds = null ; try { ds = fs . getDirectoryScanner ( getProject ( ) ) ; } catch ( BuildException e ) { if ( failonerror || ! getMessage ( e ) . endsWith ( " not found." ) ) { throw e ; } else { log ( "Warning: " + getMessage ( e ) , Project . MSG_ERR ) ; continue ; } } File fromDir = fs . getDir ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; if ( ! flatten && mapperElement == null && ds . isEverythingIncluded ( ) && ! fs . hasPatterns ( ) ) { completeDirMap . put ( fromDir , destDir ) ; } add ( fromDir , srcFiles , filesByBasedir ) ; add ( fromDir , srcDirs , dirsByBasedir ) ; baseDirs . add ( fromDir ) ; } else { if ( ! rc . isFilesystemOnly ( ) && ! supportsNonFileResources ( ) ) { throw new BuildException ( "Only FileSystem resources are supported." ) ; } Iterator resources = rc . iterator ( ) ; while ( resources . hasNext ( ) ) { Resource r = ( Resource ) resources . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } File baseDir = NULL_FILE_PLACEHOLDER ; String name = r . getName ( ) ; if ( r instanceof FileResource ) { FileResource fr = ( FileResource ) r ; baseDir = getKeyFile ( fr . getBaseDir ( ) ) ; if ( fr . getBaseDir ( ) == null ) { name = fr . getFile ( ) . getAbsolutePath ( ) ; } } if ( r . isDirectory ( ) || r instanceof FileResource ) { add ( baseDir , name , r . isDirectory ( ) ? dirsByBasedir : filesByBasedir ) ; baseDirs . add ( baseDir ) ; } else { nonFileResources . add ( r ) ; } } } } Iterator iter = baseDirs . iterator ( ) ; while ( iter . hasNext ( ) ) { File f = ( File ) iter . next ( ) ; List files = ( List ) filesByBasedir . get ( f ) ; List dirs = ( List ) dirsByBasedir . get ( f ) ; String [ ] srcFiles = new String [ 0 ] ; if ( files != null ) { srcFiles = ( String [ ] ) files . toArray ( srcFiles ) ; } String [ ] srcDirs = new String [ 0 ] ; if ( dirs != null ) { srcDirs = ( String [ ] ) dirs . toArray ( srcDirs ) ; } scan ( f == NULL_FILE_PLACEHOLDER ? null : f , destDir , srcFiles , srcDirs ) ; } try { doFileOperations ( ) ; } catch ( BuildException e ) { if ( ! failonerror ) { log ( "Warning: " + getMessage ( e ) , Project . MSG_ERR ) ; } else { throw e ; } } if ( nonFileResources . size ( ) > 0 ) { Resource [ ] nonFiles = ( Resource [ ] ) nonFileResources . toArray ( new Resource [ nonFileResources . size ( ) ] ) ; Map map = scan ( nonFiles , destDir ) ; try { doResourceOperations ( map ) ; } catch ( BuildException e ) { if ( ! failonerror ) { log ( "Warning: " + getMessage ( e ) , Project . MSG_ERR ) ; } else { throw e ; } } } } finally { file = savedFile ; destFile = savedDestFile ; destDir = savedDestDir ; if ( savedRc != null ) { rcs . insertElementAt ( savedRc , 0 ) ; } fileCopyMap . clear ( ) ; dirCopyMap . clear ( ) ; completeDirMap . clear ( ) ; } } protected void validateAttributes ( ) throws BuildException { if ( file == null && rcs . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source--a file or a resource collection." ) ; } if ( destFile != null && destDir != null ) { throw new BuildException ( "Only one of tofile and todir may be set." ) ; } if ( destFile == null && destDir == null ) { throw new BuildException ( "One of tofile or todir must be set." ) ; } if ( file != null && file . isDirectory ( ) ) { throw new BuildException ( "Use a resource collection to copy directories." ) ; } if ( destFile != null && rcs . size ( ) > 0 ) { if ( rcs . size ( ) > 1 ) { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } else { ResourceCollection rc = ( ResourceCollection ) rcs . elementAt ( 0 ) ; if ( ! rc . isFilesystemOnly ( ) ) { throw new BuildException ( "Only FileSystem resources are" + " supported when concatenating" + " files." ) ; } if ( rc . size ( ) == 0 ) { throw new BuildException ( "Cannot perform operation from directory to file." ) ; } else if ( rc . size ( ) == 1 ) { FileResource r = ( FileResource ) rc . iterator ( ) . next ( ) ; if ( file == null ) { file = r . getFile ( ) ; rcs . removeElementAt ( 0 ) ; } else { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } } else { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } } } if ( destFile != null ) { destDir = destFile . getParentFile ( ) ; } } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { FileNameMapper mapper = getMapper ( ) ; buildMap ( fromDir , toDir , files , mapper , fileCopyMap ) ; if ( includeEmpty ) { buildMap ( fromDir , toDir , dirs , mapper , dirCopyMap ) ; } } protected Map scan ( Resource [ ] fromResources , File toDir ) { return buildMap ( fromResources , toDir , getMapper ( ) ) ; } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( mapper . mapFileName ( names [ i ] ) != null ) { v . addElement ( names [ i ] ) ; } } toCopy = new String [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { SourceFileScanner ds = new SourceFileScanner ( this ) ; toCopy = ds . restrict ( names , fromDir , toDir , mapper , granularity ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; String [ ] mappedFiles = mapper . mapFileName ( toCopy [ i ] ) ; if ( ! enableMultipleMappings ) { map . put ( src . getAbsolutePath ( ) , new String [ ] { new File ( toDir , mappedFiles [ 0 ] ) . getAbsolutePath ( ) } ) ; } else { for ( int k = 0 ; k < mappedFiles . length ; k ++ ) { mappedFiles [ k ] = new File ( toDir , mappedFiles [ k ] ) . getAbsolutePath ( ) ; } map . put ( src . getAbsolutePath ( ) , mappedFiles ) ; } } } protected Map buildMap ( Resource [ ] fromResources , final File toDir , FileNameMapper mapper ) { HashMap map = new HashMap ( ) ; Resource [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < fromResources . length ; i ++ ) { if ( mapper . mapFileName ( fromResources [ i ] . getName ( ) ) != null ) { v . addElement ( fromResources [ i ] ) ; } } toCopy = new Resource [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { toCopy = ResourceUtils . selectOutOfDateSources ( this , fromResources , mapper , new ResourceFactory ( ) { public Resource getResource ( String name ) { return new FileResource ( toDir , name ) ; } } , granularity ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { String [ ] mappedFiles = mapper . mapFileName ( toCopy [ i ] . getName ( ) ) ; if ( ! enableMultipleMappings ) { map . put ( toCopy [ i ] , new String [ ] { new File ( toDir , mappedFiles [ 0 ] ) . getAbsolutePath ( ) } ) ; } else { for ( int k = 0 ; k < mappedFiles . length ; k ++ ) { mappedFiles [ k ] = new File ( toDir , mappedFiles [ k ] ) . getAbsolutePath ( ) ; } map . put ( toCopy [ i ] , mappedFiles ) ; } } return map ; } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Copying " + fileCopyMap . size ( ) + " file" + ( fileCopyMap . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String [ ] toFiles = ( String [ ] ) fileCopyMap . get ( fromFile ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = toFiles [ i ] ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-copy of " + fromFile , verbosity ) ; continue ; } try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } fileUtils . copyFile ( fromFile , toFile , executionFilters , filterChains , forceOverwrite , preserveLastModified , inputEncoding , outputEncoding , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + getDueTo ( ioe ) ; File targetFile = new File ( toFile ) ; if ( targetFile . exists ( ) && ! targetFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + toFile ; } if ( failonerror ) { throw new BuildException ( msg , ioe , getLocation ( ) ) ; } log ( msg , Project . MSG_ERR ) ; } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int createCount = 0 ; while ( e . hasMoreElements ( ) ) { String [ ] dirs = ( String [ ] ) e . nextElement ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File d = new File ( dirs [ i ] ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { createCount ++ ; } } } } if ( createCount > 0 ) { log ( "Copied " + dirCopyMap . size ( ) + " empty director" + ( dirCopyMap . size ( ) == 1 ? "y" : "ies" ) + " to " + createCount + " empty director" + ( createCount == 1 ? "y" : "ies" ) + " under " + destDir . getAbsolutePath ( ) ) ; } } } protected void doResourceOperations ( Map map ) { if ( map . size ( ) > 0 ) { log ( "Copying " + map . size ( ) + " resource" + ( map . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Iterator iter = map . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Resource fromResource = ( Resource ) iter . next ( ) ; String [ ] toFiles = ( String [ ] ) map . get ( fromResource ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = toFiles [ i ] ; try { log ( "Copying " + fromResource + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } ResourceUtils . copyResource ( fromResource , new FileResource ( destDir , toFile ) , executionFilters , filterChains , forceOverwrite , preserveLastModified , inputEncoding , outputEncoding , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromResource + " to " + toFile + " due to " + getDueTo ( ioe ) ; File targetFile = new File ( toFile ) ; if ( targetFile . exists ( ) && ! targetFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + toFile ; } if ( failonerror ) { throw new BuildException ( msg , ioe , getLocation ( ) ) ; } log ( msg , Project . MSG_ERR ) ; } } } } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( Copy . class ) ; } private static void add ( File baseDir , String [ ] names , Map m ) { if ( names != null ) { baseDir = getKeyFile ( baseDir ) ; List l = ( List ) m . get ( baseDir ) ; if ( l == null ) { l = new ArrayList ( names . length ) ; m . put ( baseDir , l ) ; } l . addAll ( java . util . Arrays . asList ( names ) ) ; } } private static void add ( File baseDir , String name , Map m ) { if ( name != null ) { add ( baseDir , new String [ ] { name } , m ) ; } } private static File getKeyFile ( File f ) { return f == null ? NULL_FILE_PLACEHOLDER : f ; } private FileNameMapper getMapper ( ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else if ( flatten ) { mapper = new FlatFileNameMapper ( ) ; } else { mapper = new IdentityMapper ( ) ; } return mapper ; } private String getMessage ( Exception ex ) { return ex . getMessage ( ) == null ? ex . toString ( ) : ex . getMessage ( ) ; } private String getDueTo ( Exception ex ) { boolean baseIOException = ex . getClass ( ) == IOException . class ; StringBuffer message = new StringBuffer ( ) ; if ( ! baseIOException || ex . getMessage ( ) == null ) { message . append ( ex . getClass ( ) . getName ( ) ) ; } if ( ex . getMessage ( ) != null ) { if ( ! baseIOException ) { message . append ( " " ) ; } message . append ( ex . getMessage ( ) ) ; } if ( ex . getClass ( ) . getName ( ) . indexOf ( "MalformedInput" ) != - 1 ) { message . append ( LINE_SEPARATOR ) ; message . append ( "This is normally due to the input file containing invalid" ) ; message . append ( LINE_SEPARATOR ) ; message . append ( "bytes for the character encoding used : " ) ; message . append ( ( inputEncoding == null ? fileUtils . getDefaultEncoding ( ) : inputEncoding ) ) ; message . append ( LINE_SEPARATOR ) ; } return message . toString ( ) ; } } 	1
package org . apache . tools . ant . util ; import java . lang . ref . WeakReference ; public class WeakishReference { private WeakReference weakref ; WeakishReference ( Object reference ) { this . weakref = new WeakReference ( reference ) ; } public Object get ( ) { return weakref . get ( ) ; } public static WeakishReference createReference ( Object object ) { return new WeakishReference ( object ) ; } public static class HardReference extends WeakishReference { public HardReference ( Object object ) { super ( object ) ; } } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . StringUtils ; public class CVSPass extends Task { private String cvsRoot = null ; private File passFile = null ; private String password = null ; private final char [ ] shifts = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 114 , 120 , 53 , 79 , 96 , 109 , 72 , 108 , 70 , 64 , 76 , 67 , 116 , 74 , 68 , 87 , 111 , 52 , 75 , 119 , 49 , 34 , 82 , 81 , 95 , 65 , 112 , 86 , 118 , 110 , 122 , 105 , 41 , 57 , 83 , 43 , 46 , 102 , 40 , 89 , 38 , 103 , 45 , 50 , 42 , 123 , 91 , 35 , 125 , 55 , 54 , 66 , 124 , 126 , 59 , 47 , 92 , 71 , 115 , 78 , 88 , 107 , 106 , 56 , 36 , 121 , 117 , 104 , 101 , 100 , 69 , 73 , 99 , 63 , 94 , 93 , 39 , 37 , 61 , 48 , 58 , 113 , 32 , 90 , 44 , 98 , 60 , 51 , 33 , 97 , 62 , 77 , 84 , 80 , 85 , 223 , 225 , 216 , 187 , 166 , 229 , 189 , 222 , 188 , 141 , 249 , 148 , 200 , 184 , 136 , 248 , 190 , 199 , 170 , 181 , 204 , 138 , 232 , 218 , 183 , 255 , 234 , 220 , 247 , 213 , 203 , 226 , 193 , 174 , 172 , 228 , 252 , 217 , 201 , 131 , 230 , 197 , 211 , 145 , 238 , 161 , 179 , 160 , 212 , 207 , 221 , 254 , 173 , 202 , 146 , 224 , 151 , 140 , 196 , 205 , 130 , 135 , 133 , 143 , 246 , 192 , 159 , 244 , 239 , 185 , 168 , 215 , 144 , 139 , 165 , 180 , 157 , 147 , 186 , 214 , 176 , 227 , 231 , 219 , 169 , 175 , 156 , 206 , 198 , 129 , 164 , 150 , 210 , 154 , 177 , 134 , 127 , 182 , 128 , 158 , 208 , 162 , 132 , 167 , 209 , 149 , 241 , 153 , 251 , 237 , 236 , 171 , 195 , 243 , 233 , 253 , 240 , 194 , 250 , 191 , 155 , 142 , 137 , 245 , 235 , 163 , 242 , 178 , 152 } ; public CVSPass ( ) { passFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; } public final void execute ( ) throws BuildException { if ( cvsRoot == null ) { throw new BuildException ( "cvsroot is required" ) ; } if ( password == null ) { throw new BuildException ( "password is required" ) ; } log ( "cvsRoot: " + cvsRoot , Project . MSG_DEBUG ) ; log ( "password: " + password , Project . MSG_DEBUG ) ; log ( "passFile: " + passFile , Project . MSG_DEBUG ) ; BufferedReader reader = null ; PrintWriter writer = null ; try { StringBuffer buf = new StringBuffer ( ) ; if ( passFile . exists ( ) ) { reader = new BufferedReader ( new FileReader ( passFile ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( cvsRoot ) ) { buf . append ( line ) . append ( StringUtils . LINE_SEP ) ; } } } String pwdfile = buf . toString ( ) + cvsRoot + " A" + mangle ( password ) ; log ( "Writing -> " + pwdfile , Project . MSG_DEBUG ) ; writer = new PrintWriter ( new FileWriter ( passFile ) ) ; writer . println ( pwdfile ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( writer != null ) { writer . close ( ) ; } } } private final String mangle ( String password ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < password . length ( ) ; i ++ ) { buf . append ( shifts [ password . charAt ( i ) ] ) ; } return buf . toString ( ) ; } public void setCvsroot ( String cvsRoot ) { this . cvsRoot = cvsRoot ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public void setPassword ( String password ) { this . password = password ; } } 	0
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; public class LogLevel extends EnumeratedAttribute { public static final LogLevel ERR = new LogLevel ( "error" ) ; public static final LogLevel WARN = new LogLevel ( "warn" ) ; public static final LogLevel INFO = new LogLevel ( "info" ) ; public static final LogLevel VERBOSE = new LogLevel ( "verbose" ) ; public static final LogLevel DEBUG = new LogLevel ( "debug" ) ; public LogLevel ( ) { } private LogLevel ( String value ) { this ( ) ; setValue ( value ) ; } public String [ ] getValues ( ) { return new String [ ] { "error" , "warn" , "warning" , "info" , "verbose" , "debug" } ; } private static int [ ] levels = { Project . MSG_ERR , Project . MSG_WARN , Project . MSG_WARN , Project . MSG_INFO , Project . MSG_VERBOSE , Project . MSG_DEBUG } ; public int getLevel ( ) { return levels [ getIndex ( ) ] ; } } 	0
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; import java . util . Vector ; import java . util . Iterator ; import java . net . MalformedURLException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . util . FileUtils ; public class WsdlToDotnet extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File destFile = null ; private String language = "CS" ; private boolean server = false ; private String namespace = null ; private boolean failOnError = true ; protected String extraOptions = null ; private String protocol = null ; private boolean ideErrors = false ; private Vector schemas = new Vector ( ) ; private Schema wsdl = new Schema ( ) ; private Compiler compiler = null ; public static final String ERROR_DEST_FILE_IS_DIR = "destination file is a directory" ; public static final String ERROR_NO_DEST_FILE = "destination file must be specified" ; public void setDestFile ( File destFile ) { this . destFile = destFile ; } public void setUrl ( String url ) { wsdl . setUrl ( url ) ; } public void setSrcFile ( File srcFile ) { wsdl . setFile ( srcFile ) ; } public void setLanguage ( String language ) { this . language = language ; } public void setServer ( boolean server ) { this . server = server ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } public void setIdeErrors ( boolean ideErrors ) { this . ideErrors = ideErrors ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public void addSchema ( Schema source ) { schemas . add ( source ) ; } public void setMakeURL ( boolean b ) { wsdl . setMakeURL ( b ) ; } public void setCompiler ( Compiler compiler ) { this . compiler = compiler ; } protected void validate ( ) throws BuildException { if ( destFile == null ) { throw new BuildException ( ERROR_NO_DEST_FILE ) ; } if ( destFile . isDirectory ( ) ) { throw new BuildException ( ERROR_DEST_FILE_IS_DIR ) ; } wsdl . validate ( ) ; } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; if ( compiler == null ) { compiler = Compiler . createDefaultCompiler ( ) ; } validate ( ) ; NetCommand command = new NetCommand ( this , "WSDL" , compiler . getCommand ( ) ) ; command . setFailOnError ( failOnError ) ; compiler . applyExtraArgs ( command ) ; command . addArgument ( "/nologo" ) ; command . addArgument ( "/out:" + destFile ) ; command . addArgument ( "/language:" , language ) ; if ( server ) { command . addArgument ( "/server" ) ; } command . addArgument ( "/namespace:" , namespace ) ; if ( protocol != null ) { command . addArgument ( "/protocol:" + protocol ) ; } if ( ideErrors ) { command . addArgument ( "/parsableErrors" ) ; } command . addArgument ( extraOptions ) ; boolean rebuild = true ; long destLastModified = - 1 ; if ( destFile . exists ( ) ) { destLastModified = destFile . lastModified ( ) ; rebuild = isRebuildNeeded ( wsdl , destLastModified ) ; } String path ; path = wsdl . evaluate ( ) ; if ( ! compiler . supportsAbsoluteFiles ( ) && wsdl . getFile ( ) != null ) { File f = wsdl . getFile ( ) ; command . setDirectory ( f . getParentFile ( ) ) ; path = f . getName ( ) ; } command . addArgument ( path ) ; Iterator it = schemas . iterator ( ) ; while ( it . hasNext ( ) ) { Schema schema = ( Schema ) it . next ( ) ; rebuild |= isRebuildNeeded ( schema , destLastModified ) ; command . addArgument ( schema . evaluate ( ) ) ; } if ( rebuild ) { command . runCommand ( ) ; } } private boolean isRebuildNeeded ( Schema schema , long destLastModified ) { if ( destLastModified == - 1 ) { return true ; } return ! FILE_UTILS . isUpToDate ( schema . getTimestamp ( ) , destLastModified ) ; } public static class Schema { private File file ; private String url ; private boolean makeURL = false ; public static final String ERROR_NONE_DECLARED = "One of file and url must be set" ; public static final String ERROR_BOTH_DECLARED = "Only one of file or url can be set" ; public static final String ERROR_FILE_NOT_FOUND = "Not found: " ; public static final String ERROR_FILE_IS_DIR = "File is a directory: " ; public static final String ERROR_NO_URL_CONVERT = "Could not URL convert " ; public void validate ( ) { if ( file != null ) { if ( ! file . exists ( ) ) { throw new BuildException ( ERROR_FILE_NOT_FOUND + file . toString ( ) ) ; } if ( file . isDirectory ( ) ) { throw new BuildException ( ERROR_FILE_IS_DIR + file . toString ( ) ) ; } } if ( file != null && url != null ) { throw new BuildException ( ERROR_BOTH_DECLARED ) ; } if ( file == null && url == null ) { throw new BuildException ( ERROR_NONE_DECLARED ) ; } } public String evaluate ( ) { validate ( ) ; if ( url != null ) { return getUrl ( ) ; } if ( makeURL ) { try { return file . toURL ( ) . toExternalForm ( ) ; } catch ( MalformedURLException e ) { throw new BuildException ( ERROR_NO_URL_CONVERT + file ) ; } } return file . toString ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public boolean isMakeURL ( ) { return makeURL ; } public void setMakeURL ( boolean makeURL ) { this . makeURL = makeURL ; } public long getTimestamp ( ) { if ( file != null ) { return file . lastModified ( ) ; } else { return - 1 ; } } } public static class Compiler extends EnumeratedAttribute { public static final String COMPILER_MS = "microsoft" ; public static final String COMPILER_MONO = "mono" ; public static final String COMPILER_MS_ON_MONO = "microsoft-on-mono" ; String [ ] compilers = { COMPILER_MS , COMPILER_MONO , COMPILER_MS_ON_MONO } ; public static final String EXE_WSDL = "wsdl" ; public static final String EXE_MONO = "mono" ; String [ ] compilerExecutables = { EXE_WSDL , EXE_WSDL , EXE_MONO } ; String [ ] [ ] extraCompilerArgs = { { } , { } , { EXE_WSDL + ".exe" } } ; boolean [ ] absoluteFiles = { true , false , true } ; public String [ ] getValues ( ) { return compilers ; } public static Compiler createDefaultCompiler ( ) { Compiler c = new Compiler ( ) ; String compilerName ; compilerName = Os . isFamily ( "windows" ) ? COMPILER_MS : COMPILER_MONO ; c . setValue ( compilerName ) ; return c ; } public String getCommand ( ) { return compilerExecutables [ getIndex ( ) ] ; } public String [ ] getExtraArgs ( ) { return extraCompilerArgs [ getIndex ( ) ] ; } public boolean supportsAbsoluteFiles ( ) { return absoluteFiles [ getIndex ( ) ] ; } public void applyExtraArgs ( NetCommand command ) { String [ ] args = getExtraArgs ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { command . addArgument ( args [ i ] ) ; } } } } 	0
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Size extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { return ( int ) ( foo . getSize ( ) - bar . getSize ( ) ) ; } } 	0
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . Map ; import java . util . HashSet ; import java . util . Set ; import java . util . TreeMap ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . resources . PropertyResource ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; public class PropertySet extends DataType implements ResourceCollection { private boolean dynamic = true ; private boolean negate = false ; private Set cachedNames ; private Vector ptyRefs = new Vector ( ) ; private Vector setRefs = new Vector ( ) ; private Mapper mapper ; public static class PropertyRef { private int count ; private String name ; private String regex ; private String prefix ; private String builtin ; public void setName ( String name ) { assertValid ( "name" , name ) ; this . name = name ; } public void setRegex ( String regex ) { assertValid ( "regex" , regex ) ; this . regex = regex ; } public void setPrefix ( String prefix ) { assertValid ( "prefix" , prefix ) ; this . prefix = prefix ; } public void setBuiltin ( BuiltinPropertySetName b ) { String pBuiltIn = b . getValue ( ) ; assertValid ( "builtin" , pBuiltIn ) ; this . builtin = pBuiltIn ; } private void assertValid ( String attr , String value ) { if ( value == null || value . length ( ) < 1 ) { throw new BuildException ( "Invalid attribute: " + attr ) ; } if ( ++ count != 1 ) { throw new BuildException ( "Attributes name, regex, and " + "prefix are mutually exclusive" ) ; } } public String toString ( ) { return "name=" + name + ", regex=" + regex + ", prefix=" + prefix + ", builtin=" + builtin ; } } public void appendName ( String name ) { PropertyRef r = new PropertyRef ( ) ; r . setName ( name ) ; addPropertyref ( r ) ; } public void appendRegex ( String regex ) { PropertyRef r = new PropertyRef ( ) ; r . setRegex ( regex ) ; addPropertyref ( r ) ; } public void appendPrefix ( String prefix ) { PropertyRef r = new PropertyRef ( ) ; r . setPrefix ( prefix ) ; addPropertyref ( r ) ; } public void appendBuiltin ( BuiltinPropertySetName b ) { PropertyRef r = new PropertyRef ( ) ; r . setBuiltin ( b ) ; addPropertyref ( r ) ; } public void setMapper ( String type , String from , String to ) { Mapper m = createMapper ( ) ; Mapper . MapperType mapperType = new Mapper . MapperType ( ) ; mapperType . setValue ( type ) ; m . setType ( mapperType ) ; m . setFrom ( from ) ; m . setTo ( to ) ; } public void addPropertyref ( PropertyRef ref ) { assertNotReference ( ) ; ptyRefs . addElement ( ref ) ; } public void addPropertyset ( PropertySet ref ) { assertNotReference ( ) ; setRefs . addElement ( ref ) ; } public Mapper createMapper ( ) { assertNotReference ( ) ; if ( mapper != null ) { throw new BuildException ( "Too many <mapper>s!" ) ; } mapper = new Mapper ( getProject ( ) ) ; return mapper ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public void setDynamic ( boolean dynamic ) { assertNotReference ( ) ; this . dynamic = dynamic ; } public void setNegate ( boolean negate ) { assertNotReference ( ) ; this . negate = negate ; } public boolean getDynamic ( ) { return isReference ( ) ? getRef ( ) . dynamic : dynamic ; } public Mapper getMapper ( ) { return isReference ( ) ? getRef ( ) . mapper : mapper ; } private Hashtable getAllSystemProperties ( ) { Hashtable ret = new Hashtable ( ) ; for ( Enumeration e = System . getProperties ( ) . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; ret . put ( name , System . getProperties ( ) . getProperty ( name ) ) ; } return ret ; } public Properties getProperties ( ) { if ( isReference ( ) ) { return getRef ( ) . getProperties ( ) ; } Set names = null ; Project prj = getProject ( ) ; Hashtable props = prj == null ? getAllSystemProperties ( ) : prj . getProperties ( ) ; for ( Enumeration e = setRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet set = ( PropertySet ) e . nextElement ( ) ; props . putAll ( set . getProperties ( ) ) ; } if ( getDynamic ( ) || cachedNames == null ) { names = new HashSet ( ) ; addPropertyNames ( names , props ) ; for ( Enumeration e = setRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet set = ( PropertySet ) e . nextElement ( ) ; names . addAll ( set . getProperties ( ) . keySet ( ) ) ; } if ( negate ) { HashSet complement = new HashSet ( props . keySet ( ) ) ; complement . removeAll ( names ) ; names = complement ; } if ( ! getDynamic ( ) ) { cachedNames = names ; } } else { names = cachedNames ; } FileNameMapper m = null ; Mapper myMapper = getMapper ( ) ; if ( myMapper != null ) { m = myMapper . getImplementation ( ) ; } Properties properties = new Properties ( ) ; for ( Iterator iter = names . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; String value = ( String ) props . get ( name ) ; if ( value != null ) { if ( m != null ) { String [ ] newname = m . mapFileName ( name ) ; if ( newname != null ) { name = newname [ 0 ] ; } } properties . setProperty ( name , value ) ; } } return properties ; } private void addPropertyNames ( Set names , Hashtable properties ) { for ( Enumeration e = ptyRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertyRef r = ( PropertyRef ) e . nextElement ( ) ; if ( r . name != null ) { if ( properties . get ( r . name ) != null ) { names . add ( r . name ) ; } } else if ( r . prefix != null ) { for ( Enumeration p = properties . keys ( ) ; p . hasMoreElements ( ) ; ) { String name = ( String ) p . nextElement ( ) ; if ( name . startsWith ( r . prefix ) ) { names . add ( name ) ; } } } else if ( r . regex != null ) { RegexpMatcherFactory matchMaker = new RegexpMatcherFactory ( ) ; RegexpMatcher matcher = matchMaker . newRegexpMatcher ( ) ; matcher . setPattern ( r . regex ) ; for ( Enumeration p = properties . keys ( ) ; p . hasMoreElements ( ) ; ) { String name = ( String ) p . nextElement ( ) ; if ( matcher . matches ( name ) ) { names . add ( name ) ; } } } else if ( r . builtin != null ) { if ( r . builtin . equals ( BuiltinPropertySetName . ALL ) ) { names . addAll ( properties . keySet ( ) ) ; } else if ( r . builtin . equals ( BuiltinPropertySetName . SYSTEM ) ) { names . addAll ( System . getProperties ( ) . keySet ( ) ) ; } else if ( r . builtin . equals ( BuiltinPropertySetName . COMMANDLINE ) ) { names . addAll ( getProject ( ) . getUserProperties ( ) . keySet ( ) ) ; } else { throw new BuildException ( "Impossible: Invalid builtin " + "attribute!" ) ; } } else { throw new BuildException ( "Impossible: Invalid PropertyRef!" ) ; } } } protected PropertySet getRef ( ) { return ( PropertySet ) getCheckedRef ( PropertySet . class , "propertyset" ) ; } public final void setRefid ( Reference r ) { if ( ! noAttributeSet ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } protected final void assertNotReference ( ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } noAttributeSet = false ; } private boolean noAttributeSet = true ; public static class BuiltinPropertySetName extends EnumeratedAttribute { static final String ALL = "all" ; static final String SYSTEM = "system" ; static final String COMMANDLINE = "commandline" ; public String [ ] getValues ( ) { return new String [ ] { ALL , SYSTEM , COMMANDLINE } ; } } public String toString ( ) { StringBuffer b = new StringBuffer ( ) ; TreeMap sorted = new TreeMap ( getProperties ( ) ) ; for ( Iterator i = sorted . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; if ( b . length ( ) != 0 ) { b . append ( ", " ) ; } b . append ( e . getKey ( ) . toString ( ) ) ; b . append ( "=" ) ; b . append ( e . getValue ( ) . toString ( ) ) ; } return b . toString ( ) ; } public Iterator iterator ( ) { final Enumeration e = getProperties ( ) . propertyNames ( ) ; return new Iterator ( ) { public boolean hasNext ( ) { return e . hasMoreElements ( ) ; } public Object next ( ) { return new PropertyResource ( getProject ( ) , ( String ) e . nextElement ( ) ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } public int size ( ) { return isReference ( ) ? getRef ( ) . size ( ) : getProperties ( ) . size ( ) ; } public boolean isFilesystemOnly ( ) { return isReference ( ) && getRef ( ) . isFilesystemOnly ( ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . j2ee ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class ServerDeploy extends Task { private String action ; private File source ; private Vector vendorTools = new Vector ( ) ; public void addGeneric ( GenericHotDeploymentTool tool ) { tool . setTask ( this ) ; vendorTools . addElement ( tool ) ; } public void addWeblogic ( WebLogicHotDeploymentTool tool ) { tool . setTask ( this ) ; vendorTools . addElement ( tool ) ; } public void addJonas ( JonasHotDeploymentTool tool ) { tool . setTask ( this ) ; vendorTools . addElement ( tool ) ; } public void execute ( ) throws BuildException { for ( Enumeration e = vendorTools . elements ( ) ; e . hasMoreElements ( ) ; ) { HotDeploymentTool tool = ( HotDeploymentTool ) e . nextElement ( ) ; tool . validateAttributes ( ) ; tool . deploy ( ) ; } } public String getAction ( ) { return action ; } public void setAction ( String action ) { this . action = action ; } public File getSource ( ) { return source ; } public void setSource ( File source ) { this . source = source ; } } 	0
package org . apache . tools . ant . util ; import java . util . Vector ; import java . util . Iterator ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class CollectionUtils { public static boolean equals ( Vector v1 , Vector v2 ) { if ( v1 == v2 ) { return true ; } if ( v1 == null || v2 == null ) { return false ; } return v1 . equals ( v2 ) ; } public static boolean equals ( Dictionary d1 , Dictionary d2 ) { if ( d1 == d2 ) { return true ; } if ( d1 == null || d2 == null ) { return false ; } if ( d1 . size ( ) != d2 . size ( ) ) { return false ; } Enumeration e1 = d1 . keys ( ) ; while ( e1 . hasMoreElements ( ) ) { Object key = e1 . nextElement ( ) ; Object value1 = d1 . get ( key ) ; Object value2 = d2 . get ( key ) ; if ( value2 == null || ! value1 . equals ( value2 ) ) { return false ; } } return true ; } public static void putAll ( Dictionary m1 , Dictionary m2 ) { for ( Enumeration it = m2 . keys ( ) ; it . hasMoreElements ( ) ; ) { Object key = it . nextElement ( ) ; m1 . put ( key , m2 . get ( key ) ) ; } } public static final class EmptyEnumeration implements Enumeration { public EmptyEnumeration ( ) { } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) throws NoSuchElementException { throw new NoSuchElementException ( ) ; } } public static Enumeration append ( Enumeration e1 , Enumeration e2 ) { return new CompoundEnumeration ( e1 , e2 ) ; } public static Enumeration asEnumeration ( final Iterator iter ) { return new Enumeration ( ) { public boolean hasMoreElements ( ) { return iter . hasNext ( ) ; } public Object nextElement ( ) { return iter . next ( ) ; } } ; } public static Iterator asIterator ( final Enumeration e ) { return new Iterator ( ) { public boolean hasNext ( ) { return e . hasMoreElements ( ) ; } public Object next ( ) { return e . nextElement ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } private static final class CompoundEnumeration implements Enumeration { private final Enumeration e1 , e2 ; public CompoundEnumeration ( Enumeration e1 , Enumeration e2 ) { this . e1 = e1 ; this . e2 = e2 ; } public boolean hasMoreElements ( ) { return e1 . hasMoreElements ( ) || e2 . hasMoreElements ( ) ; } public Object nextElement ( ) throws NoSuchElementException { if ( e1 . hasMoreElements ( ) ) { return e1 . nextElement ( ) ; } else { return e2 . nextElement ( ) ; } } } } 	1
package org . apache . tools . ant ; import java . io . File ; import java . io . IOException ; import java . io . EOFException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import java . util . Set ; import java . util . HashSet ; import java . util . HashMap ; import java . util . Map ; import java . util . WeakHashMap ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . helper . DefaultExecutor ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Description ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . StringUtils ; public class Project implements ResourceFactory { private static final String LINE_SEP = System . getProperty ( "line.separator" ) ; public static final int MSG_ERR = 0 ; public static final int MSG_WARN = 1 ; public static final int MSG_INFO = 2 ; public static final int MSG_VERBOSE = 3 ; public static final int MSG_DEBUG = 4 ; private static final String VISITING = "VISITING" ; private static final String VISITED = "VISITED" ; public static final String JAVA_1_0 = JavaEnvUtils . JAVA_1_0 ; public static final String JAVA_1_1 = JavaEnvUtils . JAVA_1_1 ; public static final String JAVA_1_2 = JavaEnvUtils . JAVA_1_2 ; public static final String JAVA_1_3 = JavaEnvUtils . JAVA_1_3 ; public static final String JAVA_1_4 = JavaEnvUtils . JAVA_1_4 ; public static final String TOKEN_START = FilterSet . DEFAULT_TOKEN_START ; public static final String TOKEN_END = FilterSet . DEFAULT_TOKEN_END ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String name ; private String description ; private Hashtable references = new AntRefTable ( ) ; private HashMap idReferences = new HashMap ( ) ; private Project parentIdProject = null ; private String defaultTarget ; private Hashtable targets = new Hashtable ( ) ; private FilterSet globalFilterSet = new FilterSet ( ) ; { globalFilterSet . setProject ( this ) ; } private FilterSetCollection globalFilters = new FilterSetCollection ( globalFilterSet ) ; private File baseDir ; private Vector listeners = new Vector ( ) ; private ClassLoader coreLoader = null ; private Map threadTasks = Collections . synchronizedMap ( new WeakHashMap ( ) ) ; private Map threadGroupTasks = Collections . synchronizedMap ( new WeakHashMap ( ) ) ; private InputHandler inputHandler = null ; private InputStream defaultInputStream = null ; private boolean keepGoingMode = false ; private boolean loggingMessage = false ; public void setInputHandler ( InputHandler handler ) { inputHandler = handler ; } public void setDefaultInputStream ( InputStream defaultInputStream ) { this . defaultInputStream = defaultInputStream ; } public InputStream getDefaultInputStream ( ) { return defaultInputStream ; } public InputHandler getInputHandler ( ) { return inputHandler ; } public Project ( ) { inputHandler = new DefaultInputHandler ( ) ; } public Project createSubProject ( ) { Project subProject = null ; try { subProject = ( Project ) ( getClass ( ) . newInstance ( ) ) ; } catch ( Exception e ) { subProject = new Project ( ) ; } initSubProject ( subProject ) ; return subProject ; } public void initSubProject ( Project subProject ) { ComponentHelper . getComponentHelper ( subProject ) . initSubProject ( ComponentHelper . getComponentHelper ( this ) ) ; subProject . setDefaultInputStream ( getDefaultInputStream ( ) ) ; subProject . setKeepGoingMode ( this . isKeepGoingMode ( ) ) ; subProject . setExecutor ( getExecutor ( ) . getSubProjectExecutor ( ) ) ; } public void init ( ) throws BuildException { initProperties ( ) ; ComponentHelper . getComponentHelper ( this ) . initDefaultDefinitions ( ) ; } public void initProperties ( ) throws BuildException { setJavaVersionProperty ( ) ; setSystemProperties ( ) ; setPropertyInternal ( MagicNames . ANT_VERSION , Main . getAntVersion ( ) ) ; setAntLib ( ) ; } private void setAntLib ( ) { File antlib = org . apache . tools . ant . launch . Locator . getClassSource ( Project . class ) ; if ( antlib != null ) { setPropertyInternal ( MagicNames . ANT_LIB , antlib . getAbsolutePath ( ) ) ; } } public AntClassLoader createClassLoader ( Path path ) { return new AntClassLoader ( getClass ( ) . getClassLoader ( ) , this , path ) ; } public AntClassLoader createClassLoader ( ClassLoader parent , Path path ) { return new AntClassLoader ( parent , this , path ) ; } public void setCoreLoader ( ClassLoader coreLoader ) { this . coreLoader = coreLoader ; } public ClassLoader getCoreLoader ( ) { return coreLoader ; } public synchronized void addBuildListener ( BuildListener listener ) { if ( listeners . contains ( listener ) ) { return ; } Vector newListeners = getBuildListeners ( ) ; newListeners . addElement ( listener ) ; listeners = newListeners ; } public synchronized void removeBuildListener ( BuildListener listener ) { Vector newListeners = getBuildListeners ( ) ; newListeners . removeElement ( listener ) ; listeners = newListeners ; } public Vector getBuildListeners ( ) { return ( Vector ) listeners . clone ( ) ; } public void log ( String message ) { log ( message , MSG_INFO ) ; } public void log ( String message , int msgLevel ) { log ( message , null , msgLevel ) ; } public void log ( String message , Throwable throwable , int msgLevel ) { fireMessageLogged ( this , message , throwable , msgLevel ) ; } public void log ( Task task , String message , int msgLevel ) { fireMessageLogged ( task , message , null , msgLevel ) ; } public void log ( Task task , String message , Throwable throwable , int msgLevel ) { fireMessageLogged ( task , message , throwable , msgLevel ) ; } public void log ( Target target , String message , int msgLevel ) { log ( target , message , null , msgLevel ) ; } public void log ( Target target , String message , Throwable throwable , int msgLevel ) { fireMessageLogged ( target , message , throwable , msgLevel ) ; } public FilterSet getGlobalFilterSet ( ) { return globalFilterSet ; } public void setProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setProperty ( null , name , value , true ) ; } public void setNewProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setNewProperty ( null , name , value ) ; } public void setUserProperty ( String name , String value ) { PropertyHelper . getPropertyHelper ( this ) . setUserProperty ( null , name , value ) ; } public void setInheritedProperty ( String name , String value ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . setInheritedProperty ( null , name , value ) ; } private void setPropertyInternal ( String name , String value ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . setProperty ( null , name , value , false ) ; } public String getProperty ( String propertyName ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ( String ) ph . getProperty ( null , propertyName ) ; } public String replaceProperties ( String value ) throws BuildException { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . replaceProperties ( null , value , null ) ; } public String getUserProperty ( String propertyName ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ( String ) ph . getUserProperty ( null , propertyName ) ; } public Hashtable getProperties ( ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . getProperties ( ) ; } public Hashtable getUserProperties ( ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; return ph . getUserProperties ( ) ; } public void copyUserProperties ( Project other ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . copyUserProperties ( other ) ; } public void copyInheritedProperties ( Project other ) { PropertyHelper ph = PropertyHelper . getPropertyHelper ( this ) ; ph . copyInheritedProperties ( other ) ; } public void setDefaultTarget ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public String getDefaultTarget ( ) { return defaultTarget ; } public void setDefault ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public void setName ( String name ) { setUserProperty ( "ant.project.name" , name ) ; this . name = name ; } public String getName ( ) { return name ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { if ( description == null ) { description = Description . getDescription ( this ) ; } return description ; } public void addFilter ( String token , String value ) { if ( token == null ) { return ; } globalFilterSet . addFilter ( new FilterSet . Filter ( token , value ) ) ; } public Hashtable getFilters ( ) { return globalFilterSet . getFilterHash ( ) ; } public void setBasedir ( String baseD ) throws BuildException { setBaseDir ( new File ( baseD ) ) ; } public void setBaseDir ( File baseDir ) throws BuildException { baseDir = FILE_UTILS . normalize ( baseDir . getAbsolutePath ( ) ) ; if ( ! baseDir . exists ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " does not exist" ) ; } if ( ! baseDir . isDirectory ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " is not a directory" ) ; } this . baseDir = baseDir ; setPropertyInternal ( MagicNames . PROJECT_BASEDIR , this . baseDir . getPath ( ) ) ; String msg = "Project base dir set to: " + this . baseDir ; log ( msg , MSG_VERBOSE ) ; } public File getBaseDir ( ) { if ( baseDir == null ) { try { setBasedir ( "." ) ; } catch ( BuildException ex ) { ex . printStackTrace ( ) ; } } return baseDir ; } public void setKeepGoingMode ( boolean keepGoingMode ) { this . keepGoingMode = keepGoingMode ; } public boolean isKeepGoingMode ( ) { return this . keepGoingMode ; } public static String getJavaVersion ( ) { return JavaEnvUtils . getJavaVersion ( ) ; } public void setJavaVersionProperty ( ) throws BuildException { String javaVersion = JavaEnvUtils . getJavaVersion ( ) ; setPropertyInternal ( MagicNames . ANT_JAVA_VERSION , javaVersion ) ; if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) || JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { throw new BuildException ( "Ant cannot work on Java 1.0 / 1.1" ) ; } log ( "Detected Java version: " + javaVersion + " in: " + System . getProperty ( "java.home" ) , MSG_VERBOSE ) ; log ( "Detected OS: " + System . getProperty ( "os.name" ) , MSG_VERBOSE ) ; } public void setSystemProperties ( ) { Properties systemP = System . getProperties ( ) ; Enumeration e = systemP . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String propertyName = ( String ) e . nextElement ( ) ; String value = systemP . getProperty ( propertyName ) ; this . setPropertyInternal ( propertyName , value ) ; } } public void addTaskDefinition ( String taskName , Class taskClass ) throws BuildException { ComponentHelper . getComponentHelper ( this ) . addTaskDefinition ( taskName , taskClass ) ; } public void checkTaskClass ( final Class taskClass ) throws BuildException { ComponentHelper . getComponentHelper ( this ) . checkTaskClass ( taskClass ) ; if ( ! Modifier . isPublic ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is not public" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( Modifier . isAbstract ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is abstract" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } try { taskClass . getConstructor ( ( Class [ ] ) null ) ; } catch ( NoSuchMethodException e ) { final String message = "No public no-arg constructor in " + taskClass ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } catch ( LinkageError e ) { String message = "Could not load " + taskClass + ": " + e ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message , e ) ; } if ( ! Task . class . isAssignableFrom ( taskClass ) ) { TaskAdapter . checkTaskClass ( taskClass , this ) ; } } public Hashtable getTaskDefinitions ( ) { return ComponentHelper . getComponentHelper ( this ) . getTaskDefinitions ( ) ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { ComponentHelper . getComponentHelper ( this ) . addDataTypeDefinition ( typeName , typeClass ) ; } public Hashtable getDataTypeDefinitions ( ) { return ComponentHelper . getComponentHelper ( this ) . getDataTypeDefinitions ( ) ; } public void addTarget ( Target target ) throws BuildException { addTarget ( target . getName ( ) , target ) ; } public void addTarget ( String targetName , Target target ) throws BuildException { if ( targets . get ( targetName ) != null ) { throw new BuildException ( "Duplicate target: `" + targetName + "'" ) ; } addOrReplaceTarget ( targetName , target ) ; } public void addOrReplaceTarget ( Target target ) { addOrReplaceTarget ( target . getName ( ) , target ) ; } public void addOrReplaceTarget ( String targetName , Target target ) { String msg = " +Target: " + targetName ; log ( msg , MSG_DEBUG ) ; target . setProject ( this ) ; targets . put ( targetName , target ) ; } public Hashtable getTargets ( ) { return targets ; } public Task createTask ( String taskType ) throws BuildException { return ComponentHelper . getComponentHelper ( this ) . createTask ( taskType ) ; } public Object createDataType ( String typeName ) throws BuildException { return ComponentHelper . getComponentHelper ( this ) . createDataType ( typeName ) ; } public void setExecutor ( Executor e ) { addReference ( MagicNames . ANT_EXECUTOR_REFERENCE , e ) ; } public Executor getExecutor ( ) { Object o = getReference ( MagicNames . ANT_EXECUTOR_REFERENCE ) ; if ( o == null ) { String classname = getProperty ( MagicNames . ANT_EXECUTOR_CLASSNAME ) ; if ( classname == null ) { classname = DefaultExecutor . class . getName ( ) ; } log ( "Attempting to create object of type " + classname , MSG_DEBUG ) ; try { o = Class . forName ( classname , true , coreLoader ) . newInstance ( ) ; } catch ( ClassNotFoundException seaEnEfEx ) { try { o = Class . forName ( classname ) . newInstance ( ) ; } catch ( Exception ex ) { log ( ex . toString ( ) , MSG_ERR ) ; } } catch ( Exception ex ) { log ( ex . toString ( ) , MSG_ERR ) ; } if ( o == null ) { throw new BuildException ( "Unable to obtain a Target Executor instance." ) ; } setExecutor ( ( Executor ) o ) ; } return ( Executor ) o ; } public void executeTargets ( Vector names ) throws BuildException { getExecutor ( ) . executeTargets ( this , ( String [ ] ) ( names . toArray ( new String [ names . size ( ) ] ) ) ) ; } public void demuxOutput ( String output , boolean isWarning ) { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { log ( output , isWarning ? MSG_WARN : MSG_INFO ) ; } else { if ( isWarning ) { task . handleErrorOutput ( output ) ; } else { task . handleOutput ( output ) ; } } } public int defaultInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( defaultInputStream != null ) { System . out . flush ( ) ; return defaultInputStream . read ( buffer , offset , length ) ; } else { throw new EOFException ( "No input provided for project" ) ; } } public int demuxInput ( byte [ ] buffer , int offset , int length ) throws IOException { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { return defaultInput ( buffer , offset , length ) ; } else { return task . handleInput ( buffer , offset , length ) ; } } public void demuxFlush ( String output , boolean isError ) { Task task = getThreadTask ( Thread . currentThread ( ) ) ; if ( task == null ) { fireMessageLogged ( this , output , isError ? MSG_ERR : MSG_INFO ) ; } else { if ( isError ) { task . handleErrorFlush ( output ) ; } else { task . handleFlush ( output ) ; } } } public void executeTarget ( String targetName ) throws BuildException { if ( targetName == null ) { String msg = "No target specified" ; throw new BuildException ( msg ) ; } executeSortedTargets ( topoSort ( targetName , targets , false ) ) ; } public void executeSortedTargets ( Vector sortedTargets ) throws BuildException { Set succeededTargets = new HashSet ( ) ; BuildException buildException = null ; for ( Enumeration iter = sortedTargets . elements ( ) ; iter . hasMoreElements ( ) ; ) { Target curtarget = ( Target ) iter . nextElement ( ) ; boolean canExecute = true ; for ( Enumeration depIter = curtarget . getDependencies ( ) ; depIter . hasMoreElements ( ) ; ) { String dependencyName = ( ( String ) depIter . nextElement ( ) ) ; if ( ! succeededTargets . contains ( dependencyName ) ) { canExecute = false ; log ( curtarget , "Cannot execute '" + curtarget . getName ( ) + "' - '" + dependencyName + "' failed or was not executed." , MSG_ERR ) ; break ; } } if ( canExecute ) { Throwable thrownException = null ; try { curtarget . performTasks ( ) ; succeededTargets . add ( curtarget . getName ( ) ) ; } catch ( RuntimeException ex ) { if ( ! ( keepGoingMode ) ) { throw ex ; } thrownException = ex ; } catch ( Throwable ex ) { if ( ! ( keepGoingMode ) ) { throw new BuildException ( ex ) ; } thrownException = ex ; } if ( thrownException != null ) { if ( thrownException instanceof BuildException ) { log ( curtarget , "Target '" + curtarget . getName ( ) + "' failed with message '" + thrownException . getMessage ( ) + "'." , MSG_ERR ) ; if ( buildException == null ) { buildException = ( BuildException ) thrownException ; } } else { log ( curtarget , "Target '" + curtarget . getName ( ) + "' failed with message '" + thrownException . getMessage ( ) + "'." , MSG_ERR ) ; thrownException . printStackTrace ( System . err ) ; if ( buildException == null ) { buildException = new BuildException ( thrownException ) ; } } } } } if ( buildException != null ) { throw buildException ; } } public File resolveFile ( String fileName , File rootDir ) { return FILE_UTILS . resolveFile ( rootDir , fileName ) ; } public File resolveFile ( String fileName ) { return FILE_UTILS . resolveFile ( baseDir , fileName ) ; } public static String translatePath ( String toProcess ) { return FileUtils . translatePath ( toProcess ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { FILE_UTILS . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void setFileLastModified ( File file , long time ) throws BuildException { FILE_UTILS . setFileLastModified ( file , time ) ; log ( "Setting modification time for " + file , MSG_VERBOSE ) ; } public static boolean toBoolean ( String s ) { return ( "on" . equalsIgnoreCase ( s ) || "true" . equalsIgnoreCase ( s ) || "yes" . equalsIgnoreCase ( s ) ) ; } public final Vector topoSort ( String root , Hashtable targetTable ) throws BuildException { return topoSort ( new String [ ] { root } , targetTable , true ) ; } public final Vector topoSort ( String root , Hashtable targetTable , boolean returnAll ) throws BuildException { return topoSort ( new String [ ] { root } , targetTable , returnAll ) ; } public final Vector topoSort ( String [ ] root , Hashtable targetTable , boolean returnAll ) throws BuildException { Vector ret = new Vector ( ) ; Hashtable state = new Hashtable ( ) ; Stack visiting = new Stack ( ) ; for ( int i = 0 ; i < root . length ; i ++ ) { String st = ( String ) ( state . get ( root [ i ] ) ) ; if ( st == null ) { tsort ( root [ i ] , targetTable , state , visiting , ret ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + root [ i ] ) ; } } StringBuffer buf = new StringBuffer ( "Build sequence for target(s)" ) ; for ( int j = 0 ; j < root . length ; j ++ ) { buf . append ( ( j == 0 ) ? " `" : ", `" ) . append ( root [ j ] ) . append ( '\'' ) ; } buf . append ( " is " + ret ) ; log ( buf . toString ( ) , MSG_VERBOSE ) ; Vector complete = ( returnAll ) ? ret : new Vector ( ret ) ; for ( Enumeration en = targetTable . keys ( ) ; en . hasMoreElements ( ) ; ) { String curTarget = ( String ) en . nextElement ( ) ; String st = ( String ) state . get ( curTarget ) ; if ( st == null ) { tsort ( curTarget , targetTable , state , visiting , complete ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + curTarget ) ; } } log ( "Complete build sequence is " + complete , MSG_VERBOSE ) ; return ret ; } private void tsort ( String root , Hashtable targetTable , Hashtable state , Stack visiting , Vector ret ) throws BuildException { state . put ( root , VISITING ) ; visiting . push ( root ) ; Target target = ( Target ) targetTable . get ( root ) ; if ( target == null ) { StringBuffer sb = new StringBuffer ( "Target \"" ) ; sb . append ( root ) ; sb . append ( "\" does not exist in the project \"" ) ; sb . append ( name ) ; sb . append ( "\". " ) ; visiting . pop ( ) ; if ( ! visiting . empty ( ) ) { String parent = ( String ) visiting . peek ( ) ; sb . append ( "It is used from target \"" ) ; sb . append ( parent ) ; sb . append ( "\"." ) ; } throw new BuildException ( new String ( sb ) ) ; } for ( Enumeration en = target . getDependencies ( ) ; en . hasMoreElements ( ) ; ) { String cur = ( String ) en . nextElement ( ) ; String m = ( String ) state . get ( cur ) ; if ( m == null ) { tsort ( cur , targetTable , state , visiting , ret ) ; } else if ( m == VISITING ) { throw makeCircularException ( cur , visiting ) ; } } String p = ( String ) visiting . pop ( ) ; if ( root != p ) { throw new RuntimeException ( "Unexpected internal error: expected to " + "pop " + root + " but got " + p ) ; } state . put ( root , VISITED ) ; ret . addElement ( target ) ; } private static BuildException makeCircularException ( String end , Stack stk ) { StringBuffer sb = new StringBuffer ( "Circular dependency: " ) ; sb . append ( end ) ; String c ; do { c = ( String ) stk . pop ( ) ; sb . append ( " <- " ) ; sb . append ( c ) ; } while ( ! c . equals ( end ) ) ; return new BuildException ( new String ( sb ) ) ; } public void inheritIDReferences ( Project parent ) { parentIdProject = parent ; } private Object resolveIdReference ( String key , Project callerProject ) { UnknownElement origUE = ( UnknownElement ) idReferences . get ( key ) ; if ( origUE == null ) { return parentIdProject == null ? null : parentIdProject . resolveIdReference ( key , callerProject ) ; } callerProject . log ( "Warning: Reference " + key + " has not been set at runtime," + " but was found during" + LINE_SEP + "build file parsing, attempting to resolve." + " Future versions of Ant may support" + LINE_SEP + " referencing ids defined in non-executed targets." , MSG_WARN ) ; UnknownElement copyUE = origUE . copy ( callerProject ) ; copyUE . maybeConfigure ( ) ; return copyUE . getRealThing ( ) ; } public void addIdReference ( String id , Object value ) { idReferences . put ( id , value ) ; } public void addReference ( String referenceName , Object value ) { synchronized ( references ) { Object old = ( ( AntRefTable ) references ) . getReal ( referenceName ) ; if ( old == value ) { return ; } if ( old != null && ! ( old instanceof UnknownElement ) ) { log ( "Overriding previous definition of reference to " + referenceName , MSG_VERBOSE ) ; } log ( "Adding reference: " + referenceName , MSG_DEBUG ) ; references . put ( referenceName , value ) ; } } public Hashtable getReferences ( ) { return references ; } public Object getReference ( String key ) { Object ret = references . get ( key ) ; if ( ret != null ) { return ret ; } ret = resolveIdReference ( key , this ) ; if ( ret == null && ! key . equals ( MagicNames . REFID_PROPERTY_HELPER ) ) { Vector p = new Vector ( ) ; PropertyHelper . getPropertyHelper ( this ) . parsePropertyString ( key , new Vector ( ) , p ) ; if ( p . size ( ) == 1 ) { log ( "Unresolvable reference " + key + " might be a misuse of property expansion syntax." , MSG_WARN ) ; } } return ret ; } public String getElementName ( Object element ) { return ComponentHelper . getComponentHelper ( this ) . getElementName ( element ) ; } public void fireBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . buildStarted ( event ) ; } } public void fireBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . buildFinished ( event ) ; } IntrospectionHelper . clearCache ( ) ; } public void fireSubBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { Object listener = iter . next ( ) ; if ( listener instanceof SubBuildListener ) { ( ( SubBuildListener ) listener ) . subBuildStarted ( event ) ; } } } public void fireSubBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { Object listener = iter . next ( ) ; if ( listener instanceof SubBuildListener ) { ( ( SubBuildListener ) listener ) . subBuildFinished ( event ) ; } } } protected void fireTargetStarted ( Target target ) { BuildEvent event = new BuildEvent ( target ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . targetStarted ( event ) ; } } protected void fireTargetFinished ( Target target , Throwable exception ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . targetFinished ( event ) ; } } protected void fireTaskStarted ( Task task ) { registerThreadTask ( Thread . currentThread ( ) , task ) ; BuildEvent event = new BuildEvent ( task ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . taskStarted ( event ) ; } } protected void fireTaskFinished ( Task task , Throwable exception ) { registerThreadTask ( Thread . currentThread ( ) , null ) ; System . out . flush ( ) ; System . err . flush ( ) ; BuildEvent event = new BuildEvent ( task ) ; event . setException ( exception ) ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . taskFinished ( event ) ; } } private void fireMessageLoggedEvent ( BuildEvent event , String message , int priority ) { if ( message . endsWith ( StringUtils . LINE_SEP ) ) { int endIndex = message . length ( ) - StringUtils . LINE_SEP . length ( ) ; event . setMessage ( message . substring ( 0 , endIndex ) , priority ) ; } else { event . setMessage ( message , priority ) ; } synchronized ( this ) { if ( loggingMessage ) { return ; } try { loggingMessage = true ; Iterator iter = listeners . iterator ( ) ; while ( iter . hasNext ( ) ) { BuildListener listener = ( BuildListener ) iter . next ( ) ; listener . messageLogged ( event ) ; } } finally { loggingMessage = false ; } } } protected void fireMessageLogged ( Project project , String message , int priority ) { fireMessageLogged ( project , message , null , priority ) ; } protected void fireMessageLogged ( Project project , String message , Throwable throwable , int priority ) { BuildEvent event = new BuildEvent ( project ) ; event . setException ( throwable ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Target target , String message , int priority ) { fireMessageLogged ( target , message , null , priority ) ; } protected void fireMessageLogged ( Target target , String message , Throwable throwable , int priority ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( throwable ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Task task , String message , int priority ) { fireMessageLogged ( task , message , null , priority ) ; } protected void fireMessageLogged ( Task task , String message , Throwable throwable , int priority ) { BuildEvent event = new BuildEvent ( task ) ; event . setException ( throwable ) ; fireMessageLoggedEvent ( event , message , priority ) ; } public synchronized void registerThreadTask ( Thread thread , Task task ) { if ( task != null ) { threadTasks . put ( thread , task ) ; threadGroupTasks . put ( thread . getThreadGroup ( ) , task ) ; } else { threadTasks . remove ( thread ) ; threadGroupTasks . remove ( thread . getThreadGroup ( ) ) ; } } public Task getThreadTask ( Thread thread ) { Task task = ( Task ) threadTasks . get ( thread ) ; if ( task == null ) { ThreadGroup group = thread . getThreadGroup ( ) ; while ( task == null && group != null ) { task = ( Task ) threadGroupTasks . get ( group ) ; group = group . getParent ( ) ; } } return task ; } private static class AntRefTable extends Hashtable { AntRefTable ( ) { super ( ) ; } private Object getReal ( Object key ) { return super . get ( key ) ; } public Object get ( Object key ) { Object o = getReal ( key ) ; if ( o instanceof UnknownElement ) { UnknownElement ue = ( UnknownElement ) o ; ue . maybeConfigure ( ) ; o = ue . getRealThing ( ) ; } return o ; } } public final void setProjectReference ( final Object obj ) { if ( obj instanceof ProjectComponent ) { ( ( ProjectComponent ) obj ) . setProject ( this ) ; return ; } try { Method method = obj . getClass ( ) . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( method != null ) { method . invoke ( obj , new Object [ ] { this } ) ; } } catch ( Throwable e ) { } } public Resource getResource ( String name ) { return new FileResource ( getBaseDir ( ) , name ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; public class JspNameMangler implements JspMangler { public static final String [ ] keywords = { "assert" , "abstract" , "boolean" , "break" , "byte" , "case" , "catch" , "char" , "class" , "const" , "continue" , "default" , "do" , "double" , "else" , "extends" , "final" , "finally" , "float" , "for" , "goto" , "if" , "implements" , "import" , "instanceof" , "int" , "interface" , "long" , "native" , "new" , "package" , "private" , "protected" , "public" , "return" , "short" , "static" , "super" , "switch" , "synchronized" , "this" , "throw" , "throws" , "transient" , "try" , "void" , "volatile" , "while" } ; public String mapJspToJavaName ( File jspFile ) { return mapJspToBaseName ( jspFile ) + ".java" ; } private String mapJspToBaseName ( File jspFile ) { String className ; className = stripExtension ( jspFile ) ; for ( int i = 0 ; i < keywords . length ; ++ i ) { if ( className . equals ( keywords [ i ] ) ) { className += "%" ; break ; } } StringBuffer modifiedClassName = new StringBuffer ( className . length ( ) ) ; char firstChar = className . charAt ( 0 ) ; if ( Character . isJavaIdentifierStart ( firstChar ) ) { modifiedClassName . append ( firstChar ) ; } else { modifiedClassName . append ( mangleChar ( firstChar ) ) ; } for ( int i = 1 ; i < className . length ( ) ; i ++ ) { char subChar = className . charAt ( i ) ; if ( Character . isJavaIdentifierPart ( subChar ) ) { modifiedClassName . append ( subChar ) ; } else { modifiedClassName . append ( mangleChar ( subChar ) ) ; } } return modifiedClassName . toString ( ) ; } private String stripExtension ( File jspFile ) { String className ; String filename = jspFile . getName ( ) ; if ( filename . endsWith ( ".jsp" ) ) { className = filename . substring ( 0 , filename . length ( ) - 4 ) ; } else { className = filename ; } return className ; } private static String mangleChar ( char ch ) { if ( ch == File . separatorChar ) { ch = '/' ; } String s = Integer . toHexString ( ch ) ; int nzeros = 5 - s . length ( ) ; char [ ] result = new char [ 6 ] ; result [ 0 ] = '_' ; for ( int i = 1 ; i <= nzeros ; ++ i ) { result [ i ] = '0' ; } int resultIndex = 0 ; for ( int i = nzeros + 1 ; i < 6 ; ++ i ) { result [ i ] = s . charAt ( resultIndex ++ ) ; } return new String ( result ) ; } public String mapPath ( String path ) { return null ; } } 	0
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Replace extends MatchingTask { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File src = null ; private NestedString token = null ; private NestedString value = new NestedString ( ) ; private File propertyFile = null ; private File replaceFilterFile = null ; private Properties properties = null ; private Vector replacefilters = new Vector ( ) ; private File dir = null ; private int fileCount ; private int replaceCount ; private boolean summary = false ; private String encoding = null ; public class NestedString { private StringBuffer buf = new StringBuffer ( ) ; public void addText ( String val ) { buf . append ( val ) ; } public String getText ( ) { return buf . toString ( ) ; } } public class Replacefilter { private String token ; private String value ; private String replaceValue ; private String property ; private StringBuffer inputBuffer ; private StringBuffer outputBuffer = new StringBuffer ( ) ; public void validate ( ) throws BuildException { if ( token == null ) { String message = "token is a mandatory attribute " + "of replacefilter." ; throw new BuildException ( message ) ; } if ( "" . equals ( token ) ) { String message = "The token attribute must not be an empty " + "string." ; throw new BuildException ( message ) ; } if ( ( value != null ) && ( property != null ) ) { String message = "Either value or property " + "can be specified, but a replacefilter " + "element cannot have both." ; throw new BuildException ( message ) ; } if ( ( property != null ) ) { if ( propertyFile == null ) { String message = "The replacefilter's property attribute " + "can only be used with the replacetask's " + "propertyFile attribute." ; throw new BuildException ( message ) ; } if ( properties == null || properties . getProperty ( property ) == null ) { String message = "property \"" + property + "\" was not found in " + propertyFile . getPath ( ) ; throw new BuildException ( message ) ; } } replaceValue = getReplaceValue ( ) ; } public String getReplaceValue ( ) { if ( property != null ) { return properties . getProperty ( property ) ; } else if ( value != null ) { return value ; } else if ( Replace . this . value != null ) { return Replace . this . value . getText ( ) ; } else { return "" ; } } public void setToken ( String token ) { this . token = token ; } public String getToken ( ) { return token ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setProperty ( String property ) { this . property = property ; } public String getProperty ( ) { return property ; } StringBuffer getOutputBuffer ( ) { return outputBuffer ; } void setInputBuffer ( StringBuffer input ) { inputBuffer = input ; } boolean process ( ) { if ( inputBuffer . length ( ) > token . length ( ) ) { int pos = replace ( ) ; pos = Math . max ( ( inputBuffer . length ( ) - token . length ( ) ) , pos ) ; outputBuffer . append ( inputBuffer . substring ( 0 , pos ) ) ; inputBuffer . delete ( 0 , pos ) ; return true ; } return false ; } void flush ( ) { replace ( ) ; outputBuffer . append ( inputBuffer . toString ( ) ) ; inputBuffer . delete ( 0 , inputBuffer . length ( ) ) ; } private int replace ( ) { int found = inputBuffer . toString ( ) . indexOf ( token ) ; int pos = - 1 ; while ( found >= 0 ) { inputBuffer . replace ( found , found + token . length ( ) , replaceValue ) ; pos = found + replaceValue . length ( ) ; found = inputBuffer . toString ( ) . indexOf ( token , pos ) ; ++ replaceCount ; } return pos ; } } private class FileInput { private StringBuffer outputBuffer ; private Reader reader ; private char [ ] buffer ; private static final int BUFF_SIZE = 4096 ; FileInput ( File source ) throws IOException { outputBuffer = new StringBuffer ( ) ; buffer = new char [ BUFF_SIZE ] ; if ( encoding == null ) { reader = new BufferedReader ( new FileReader ( source ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( source ) , encoding ) ) ; } } StringBuffer getOutputBuffer ( ) { return outputBuffer ; } boolean readChunk ( ) throws IOException { int bufferLength = 0 ; bufferLength = reader . read ( buffer ) ; if ( bufferLength < 0 ) { return false ; } outputBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; return true ; } void close ( ) throws IOException { reader . close ( ) ; } void closeQuietly ( ) { FileUtils . close ( reader ) ; } } private class FileOutput { private StringBuffer inputBuffer ; private Writer writer ; FileOutput ( File out ) throws IOException { if ( encoding == null ) { writer = new BufferedWriter ( new FileWriter ( out ) ) ; } else { writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( out ) , encoding ) ) ; } } void setInputBuffer ( StringBuffer input ) { inputBuffer = input ; } boolean process ( ) throws IOException { writer . write ( inputBuffer . toString ( ) ) ; inputBuffer . delete ( 0 , inputBuffer . length ( ) ) ; return false ; } void flush ( ) throws IOException { process ( ) ; writer . flush ( ) ; } void close ( ) throws IOException { writer . close ( ) ; } void closeQuietly ( ) { FileUtils . close ( writer ) ; } } public void execute ( ) throws BuildException { Vector savedFilters = ( Vector ) replacefilters . clone ( ) ; Properties savedProperties = properties == null ? null : ( Properties ) properties . clone ( ) ; if ( token != null ) { StringBuffer val = new StringBuffer ( value . getText ( ) ) ; stringReplace ( val , "\r\n" , "\n" ) ; stringReplace ( val , "\n" , StringUtils . LINE_SEP ) ; StringBuffer tok = new StringBuffer ( token . getText ( ) ) ; stringReplace ( tok , "\r\n" , "\n" ) ; stringReplace ( tok , "\n" , StringUtils . LINE_SEP ) ; Replacefilter firstFilter = createPrimaryfilter ( ) ; firstFilter . setToken ( tok . toString ( ) ) ; firstFilter . setValue ( val . toString ( ) ) ; } try { if ( replaceFilterFile != null ) { Properties props = getProperties ( replaceFilterFile ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String tok = e . nextElement ( ) . toString ( ) ; Replacefilter replaceFilter = createReplacefilter ( ) ; replaceFilter . setToken ( tok ) ; replaceFilter . setValue ( props . getProperty ( tok ) ) ; } } validateAttributes ( ) ; if ( propertyFile != null ) { properties = getProperties ( propertyFile ) ; } validateReplacefilters ( ) ; fileCount = 0 ; replaceCount = 0 ; if ( src != null ) { processFile ( src ) ; } if ( dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] srcs = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < srcs . length ; i ++ ) { File file = new File ( dir , srcs [ i ] ) ; processFile ( file ) ; } } if ( summary ) { log ( "Replaced " + replaceCount + " occurrences in " + fileCount + " files." , Project . MSG_INFO ) ; } } finally { replacefilters = savedFilters ; properties = savedProperties ; } } public void validateAttributes ( ) throws BuildException { if ( src == null && dir == null ) { String message = "Either the file or the dir attribute " + "must be specified" ; throw new BuildException ( message , getLocation ( ) ) ; } if ( propertyFile != null && ! propertyFile . exists ( ) ) { String message = "Property file " + propertyFile . getPath ( ) + " does not exist." ; throw new BuildException ( message , getLocation ( ) ) ; } if ( token == null && replacefilters . size ( ) == 0 ) { String message = "Either token or a nested replacefilter " + "must be specified" ; throw new BuildException ( message , getLocation ( ) ) ; } if ( token != null && "" . equals ( token . getText ( ) ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message , getLocation ( ) ) ; } } public void validateReplacefilters ( ) throws BuildException { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter element = ( Replacefilter ) replacefilters . elementAt ( i ) ; element . validate ( ) ; } } public Properties getProperties ( File propertyFile ) throws BuildException { Properties props = new Properties ( ) ; FileInputStream in = null ; try { in = new FileInputStream ( propertyFile ) ; props . load ( in ) ; } catch ( FileNotFoundException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") not found." ; throw new BuildException ( message ) ; } catch ( IOException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") cannot be loaded." ; throw new BuildException ( message ) ; } finally { FileUtils . close ( in ) ; } return props ; } private void processFile ( File src ) throws BuildException { if ( ! src . exists ( ) ) { throw new BuildException ( "Replace: source file " + src . getPath ( ) + " doesn't exist" , getLocation ( ) ) ; } File temp = null ; FileInput in = null ; FileOutput out = null ; try { in = new FileInput ( src ) ; temp = FILE_UTILS . createTempFile ( "rep" , ".tmp" , src . getParentFile ( ) ) ; out = new FileOutput ( temp ) ; int repCountStart = replaceCount ; logFilterChain ( src . getPath ( ) ) ; out . setInputBuffer ( buildFilterChain ( in . getOutputBuffer ( ) ) ) ; while ( in . readChunk ( ) ) { if ( processFilterChain ( ) ) { out . process ( ) ; } } flushFilterChain ( ) ; out . flush ( ) ; in . close ( ) ; in = null ; out . close ( ) ; out = null ; boolean changes = ( replaceCount != repCountStart ) ; if ( changes ) { FILE_UTILS . rename ( temp , src ) ; temp = null ; } } catch ( IOException ioe ) { throw new BuildException ( "IOException in " + src + " - " + ioe . getClass ( ) . getName ( ) + ":" + ioe . getMessage ( ) , ioe , getLocation ( ) ) ; } finally { if ( null != in ) { in . closeQuietly ( ) ; } if ( null != out ) { out . closeQuietly ( ) ; } if ( temp != null ) { if ( ! temp . delete ( ) ) { temp . deleteOnExit ( ) ; } } } } private void flushFilterChain ( ) { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; filter . flush ( ) ; } } private boolean processFilterChain ( ) { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; if ( ! filter . process ( ) ) { return false ; } } return true ; } private StringBuffer buildFilterChain ( StringBuffer inputBuffer ) { StringBuffer buf = inputBuffer ; for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; filter . setInputBuffer ( buf ) ; buf = filter . getOutputBuffer ( ) ; } return buf ; } private void logFilterChain ( String filename ) { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; log ( "Replacing in " + filename + ": " + filter . getToken ( ) + " --> " + filter . getReplaceValue ( ) , Project . MSG_VERBOSE ) ; } } public void setFile ( File file ) { this . src = file ; } public void setSummary ( boolean summary ) { this . summary = summary ; } public void setReplaceFilterFile ( File replaceFilterFile ) { this . replaceFilterFile = replaceFilterFile ; } public void setDir ( File dir ) { this . dir = dir ; } public void setToken ( String token ) { createReplaceToken ( ) . addText ( token ) ; } public void setValue ( String value ) { createReplaceValue ( ) . addText ( value ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public NestedString createReplaceToken ( ) { if ( token == null ) { token = new NestedString ( ) ; } return token ; } public NestedString createReplaceValue ( ) { return value ; } public void setPropertyFile ( File propertyFile ) { this . propertyFile = propertyFile ; } public Replacefilter createReplacefilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . addElement ( filter ) ; return filter ; } private Replacefilter createPrimaryfilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . insertElementAt ( filter , 0 ) ; return filter ; } private void stringReplace ( StringBuffer str , String str1 , String str2 ) { int found = str . toString ( ) . indexOf ( str1 ) ; while ( found >= 0 ) { str . replace ( found , found + str1 . length ( ) , str2 ) ; found = str . toString ( ) . indexOf ( str1 , found + str2 . length ( ) ) ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMkdir extends ClearCase { private String mComment = null ; private String mCfile = null ; private boolean mNoco = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKDIR ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getNoCheckout ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOCHECKOUT ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setNoCheckout ( boolean co ) { mNoco = co ; } public boolean getNoCheckout ( ) { return mNoco ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_NOCHECKOUT = "-nco" ; } 	0
package org . apache . tools . zip ; public class UnrecognizedExtraField implements ZipExtraField { private ZipShort headerId ; public void setHeaderId ( ZipShort headerId ) { this . headerId = headerId ; } public ZipShort getHeaderId ( ) { return headerId ; } private byte [ ] localData ; public void setLocalFileDataData ( byte [ ] data ) { localData = data ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( localData . length ) ; } public byte [ ] getLocalFileDataData ( ) { return localData ; } private byte [ ] centralData ; public void setCentralDirectoryData ( byte [ ] data ) { centralData = data ; } public ZipShort getCentralDirectoryLength ( ) { if ( centralData != null ) { return new ZipShort ( centralData . length ) ; } return getLocalFileDataLength ( ) ; } public byte [ ] getCentralDirectoryData ( ) { if ( centralData != null ) { return centralData ; } return getLocalFileDataData ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) { byte [ ] tmp = new byte [ length ] ; System . arraycopy ( data , offset , tmp , 0 , length ) ; setLocalFileDataData ( tmp ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . XmlConstants ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . SAXException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . ParserConfigurationException ; import java . util . Iterator ; import java . util . HashMap ; import java . io . File ; import java . net . MalformedURLException ; public class SchemaValidate extends XMLValidateTask { private HashMap schemaLocations = new HashMap ( ) ; private boolean fullChecking = true ; private boolean disableDTD = false ; private SchemaLocation anonymousSchema ; public static final String ERROR_SAX_1 = "SAX1 parsers are not supported" ; public static final String ERROR_NO_XSD_SUPPORT = "Parser does not support Xerces or JAXP schema features" ; public static final String ERROR_TOO_MANY_DEFAULT_SCHEMAS = "Only one of defaultSchemaFile and defaultSchemaURL allowed" ; public static final String ERROR_PARSER_CREATION_FAILURE = "Could not create parser" ; public static final String MESSAGE_ADDING_SCHEMA = "Adding schema " ; public static final String ERROR_DUPLICATE_SCHEMA = "Duplicate declaration of schema " ; public void init ( ) throws BuildException { super . init ( ) ; setLenient ( false ) ; } public boolean enableXercesSchemaValidation ( ) { try { setFeature ( XmlConstants . FEATURE_XSD , true ) ; setNoNamespaceSchemaProperty ( XmlConstants . PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION ) ; } catch ( BuildException e ) { log ( e . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } return true ; } private void setNoNamespaceSchemaProperty ( String property ) { String anonSchema = getNoNamespaceSchemaURL ( ) ; if ( anonSchema != null ) { setProperty ( property , anonSchema ) ; } } public boolean enableJAXP12SchemaValidation ( ) { try { setProperty ( XmlConstants . FEATURE_JAXP12_SCHEMA_LANGUAGE , XmlConstants . URI_XSD ) ; setNoNamespaceSchemaProperty ( XmlConstants . FEATURE_JAXP12_SCHEMA_SOURCE ) ; } catch ( BuildException e ) { log ( e . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void addConfiguredSchema ( SchemaLocation location ) { log ( "adding schema " + location , Project . MSG_DEBUG ) ; location . validateNamespace ( ) ; SchemaLocation old = ( SchemaLocation ) schemaLocations . get ( location . getNamespace ( ) ) ; if ( old != null && ! old . equals ( location ) ) { throw new BuildException ( ERROR_DUPLICATE_SCHEMA + location ) ; } schemaLocations . put ( location . getNamespace ( ) , location ) ; } public void setFullChecking ( boolean fullChecking ) { this . fullChecking = fullChecking ; } protected void createAnonymousSchema ( ) { if ( anonymousSchema == null ) { anonymousSchema = new SchemaLocation ( ) ; } anonymousSchema . setNamespace ( "(no namespace)" ) ; } public void setNoNamespaceURL ( String defaultSchemaURL ) { createAnonymousSchema ( ) ; this . anonymousSchema . setUrl ( defaultSchemaURL ) ; } public void setNoNamespaceFile ( File defaultSchemaFile ) { createAnonymousSchema ( ) ; this . anonymousSchema . setFile ( defaultSchemaFile ) ; } public void setDisableDTD ( boolean disableDTD ) { this . disableDTD = disableDTD ; } protected void initValidator ( ) { super . initValidator ( ) ; if ( isSax1Parser ( ) ) { throw new BuildException ( ERROR_SAX_1 ) ; } setFeature ( XmlConstants . FEATURE_NAMESPACES , true ) ; if ( ! enableXercesSchemaValidation ( ) && ! enableJAXP12SchemaValidation ( ) ) { throw new BuildException ( ERROR_NO_XSD_SUPPORT ) ; } setFeature ( XmlConstants . FEATURE_XSD_FULL_VALIDATION , fullChecking ) ; setFeatureIfSupported ( XmlConstants . FEATURE_DISALLOW_DTD , disableDTD ) ; addSchemaLocations ( ) ; } protected XMLReader createDefaultReader ( ) { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; factory . setValidating ( true ) ; factory . setNamespaceAware ( true ) ; XMLReader reader = null ; try { SAXParser saxParser = factory . newSAXParser ( ) ; reader = saxParser . getXMLReader ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( ERROR_PARSER_CREATION_FAILURE , e ) ; } catch ( SAXException e ) { throw new BuildException ( ERROR_PARSER_CREATION_FAILURE , e ) ; } return reader ; } protected void addSchemaLocations ( ) { Iterator it = schemaLocations . values ( ) . iterator ( ) ; StringBuffer buffer = new StringBuffer ( ) ; int count = 0 ; while ( it . hasNext ( ) ) { if ( count > 0 ) { buffer . append ( ' ' ) ; } SchemaLocation schemaLocation = ( SchemaLocation ) it . next ( ) ; String tuple = schemaLocation . getURIandLocation ( ) ; buffer . append ( tuple ) ; log ( "Adding schema " + tuple , Project . MSG_VERBOSE ) ; count ++ ; } if ( count > 0 ) { setProperty ( XmlConstants . PROPERTY_SCHEMA_LOCATION , buffer . toString ( ) ) ; } } protected String getNoNamespaceSchemaURL ( ) { if ( anonymousSchema == null ) { return null ; } else { return anonymousSchema . getSchemaLocationURL ( ) ; } } protected void setFeatureIfSupported ( String feature , boolean value ) { try { getXmlReader ( ) . setFeature ( feature , value ) ; } catch ( SAXNotRecognizedException e ) { log ( "Not recognizied: " + feature , Project . MSG_VERBOSE ) ; } catch ( SAXNotSupportedException e ) { log ( "Not supported: " + feature , Project . MSG_VERBOSE ) ; } } protected void onSuccessfulValidation ( int fileProcessed ) { log ( fileProcessed + MESSAGE_FILES_VALIDATED , Project . MSG_VERBOSE ) ; } public static class SchemaLocation { private String namespace ; private File file ; private String url ; public static final String ERROR_NO_URI = "No namespace URI" ; public static final String ERROR_TWO_LOCATIONS = "Both URL and File were given for schema " ; public static final String ERROR_NO_FILE = "File not found: " ; public static final String ERROR_NO_URL_REPRESENTATION = "Cannot make a URL of " ; public static final String ERROR_NO_LOCATION = "No file or URL supplied for the schema " ; public SchemaLocation ( ) { } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public String getSchemaLocationURL ( ) { boolean hasFile = file != null ; boolean hasURL = isSet ( url ) ; if ( ! hasFile && ! hasURL ) { throw new BuildException ( ERROR_NO_LOCATION + namespace ) ; } if ( hasFile && hasURL ) { throw new BuildException ( ERROR_TWO_LOCATIONS + namespace ) ; } String schema = url ; if ( hasFile ) { if ( ! file . exists ( ) ) { throw new BuildException ( ERROR_NO_FILE + file ) ; } try { schema = FileUtils . getFileUtils ( ) . getFileURL ( file ) . toString ( ) ; } catch ( MalformedURLException e ) { throw new BuildException ( ERROR_NO_URL_REPRESENTATION + file , e ) ; } } return schema ; } public String getURIandLocation ( ) throws BuildException { validateNamespace ( ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( namespace ) ; buffer . append ( ' ' ) ; buffer . append ( getSchemaLocationURL ( ) ) ; return new String ( buffer ) ; } public void validateNamespace ( ) { if ( ! isSet ( getNamespace ( ) ) ) { throw new BuildException ( ERROR_NO_URI ) ; } } private boolean isSet ( String property ) { return property != null && property . length ( ) != 0 ; } public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof SchemaLocation ) ) { return false ; } final SchemaLocation schemaLocation = ( SchemaLocation ) o ; if ( file != null ? ! file . equals ( schemaLocation . file ) : schemaLocation . file != null ) { return false ; } if ( namespace != null ? ! namespace . equals ( schemaLocation . namespace ) : schemaLocation . namespace != null ) { return false ; } if ( url != null ? ! url . equals ( schemaLocation . url ) : schemaLocation . url != null ) { return false ; } return true ; } public int hashCode ( ) { int result ; result = ( namespace != null ? namespace . hashCode ( ) : 0 ) ; result = 29 * result + ( file != null ? file . hashCode ( ) : 0 ) ; result = 29 * result + ( url != null ? url . hashCode ( ) : 0 ) ; return result ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( namespace != null ? namespace : "(anonymous)" ) ; buffer . append ( ' ' ) ; buffer . append ( url != null ? ( url + " " ) : "" ) ; buffer . append ( file != null ? file . getAbsolutePath ( ) : "" ) ; return buffer . toString ( ) ; } } } 	0
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Collections ; import java . util . Iterator ; import java . util . Locale ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . PathTokenizer ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . FileResourceIterator ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Path extends DataType implements Cloneable , ResourceCollection { public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public static Path systemBootClasspath = new Path ( null , System . getProperty ( "sun.boot.class.path" ) ) ; private static final Iterator EMPTY_ITERATOR = Collections . EMPTY_SET . iterator ( ) ; public class PathElement implements ResourceCollection { private String [ ] parts ; public void setLocation ( File loc ) { parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } public void setPath ( String path ) { parts = Path . translatePath ( getProject ( ) , path ) ; } public String [ ] getParts ( ) { return parts ; } public Iterator iterator ( ) { return new FileResourceIterator ( null , parts ) ; } public boolean isFilesystemOnly ( ) { return true ; } public int size ( ) { return parts == null ? 0 : parts . length ; } } private Union union = null ; public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { setProject ( project ) ; } public void setLocation ( File location ) throws BuildException { checkAttributesAllowed ( ) ; createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { checkAttributesAllowed ( ) ; createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( union != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; add ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( fs . getProject ( ) == null ) { fs . setProject ( getProject ( ) ) ; } add ( fs ) ; } public void addFilelist ( FileList fl ) throws BuildException { if ( fl . getProject ( ) == null ) { fl . setProject ( getProject ( ) ) ; } add ( fl ) ; } public void addDirset ( DirSet dset ) throws BuildException { if ( dset . getProject ( ) == null ) { dset . setProject ( getProject ( ) ) ; } add ( dset ) ; } public void add ( Path path ) throws BuildException { if ( path == this ) { throw circularReference ( ) ; } if ( path . getProject ( ) == null ) { path . setProject ( getProject ( ) ) ; } add ( ( ResourceCollection ) path ) ; } public void add ( ResourceCollection c ) { checkChildrenAllowed ( ) ; if ( c == null ) { return ; } if ( union == null ) { union = new Union ( ) ; union . setProject ( getProject ( ) ) ; union . setCache ( false ) ; } union . add ( c ) ; setChecked ( false ) ; } public Path createPath ( ) throws BuildException { Path p = new Path ( getProject ( ) ) ; add ( p ) ; return p ; } public void append ( Path other ) { if ( other == null ) { return ; } add ( other ) ; } public void addExisting ( Path source ) { addExisting ( source , false ) ; } public void addExisting ( Path source , boolean tryUserDir ) { String [ ] list = source . list ( ) ; File userDir = ( tryUserDir ) ? new File ( System . getProperty ( "user.dir" ) ) : null ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = resolveFile ( getProject ( ) , list [ i ] ) ; if ( tryUserDir && ! f . exists ( ) ) { f = new File ( userDir , list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } else { log ( "dropping " + f + " from path as it doesn't exist" , Project . MSG_VERBOSE ) ; } } } public String [ ] list ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . list ( ) ; } return assertFilesystemOnly ( union ) == null ? new String [ 0 ] : union . list ( ) ; } public String toString ( ) { return isReference ( ) ? getCheckedRef ( ) . toString ( ) : union == null ? "" : union . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) { return new String [ 0 ] ; } PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String pathElement = tok . nextToken ( ) ; try { element . append ( resolveFile ( project , pathElement ) . getPath ( ) ) ; } catch ( BuildException e ) { project . log ( "Dropping path element " + pathElement + " as it is not valid relative to the project" , Project . MSG_VERBOSE ) ; } for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; element = new StringBuffer ( ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) { return "" ; } final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public synchronized int size ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . size ( ) ; } dieOnCircularReference ( ) ; return union == null ? 0 : assertFilesystemOnly ( union ) . size ( ) ; } public Object clone ( ) { try { Path result = ( Path ) super . clone ( ) ; result . union = union == null ? union : ( Union ) union . clone ( ) ; return result ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( union != null ) { stk . push ( union ) ; invokeCircularReferenceCheck ( union , stk , p ) ; stk . pop ( ) ; } setChecked ( true ) ; } } private static File resolveFile ( Project project , String relativeName ) { return FileUtils . getFileUtils ( ) . resolveFile ( ( project == null ) ? null : project . getBaseDir ( ) , relativeName ) ; } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { return concatSpecialPath ( defValue , Path . systemClasspath ) ; } public Path concatSystemBootClasspath ( String defValue ) { return concatSpecialPath ( defValue , Path . systemBootClasspath ) ; } private Path concatSpecialPath ( String defValue , Path p ) { Path result = new Path ( getProject ( ) ) ; String order = defValue ; if ( getProject ( ) != null ) { String o = getProject ( ) . getProperty ( "build.sysclasspath" ) ; if ( o != null ) { order = o ; } } if ( order . equals ( "only" ) ) { result . addExisting ( p , true ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( p , true ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( p , true ) ; } return result ; } public void addJavaRuntime ( ) { if ( JavaEnvUtils . isKaffe ( ) ) { File kaffeShare = new File ( System . getProperty ( "java.home" ) + File . separator + "share" + File . separator + "kaffe" ) ; if ( kaffeShare . isDirectory ( ) ) { FileSet kaffeJarFiles = new FileSet ( ) ; kaffeJarFiles . setDir ( kaffeShare ) ; kaffeJarFiles . setIncludes ( "*.jar" ) ; addFileset ( kaffeJarFiles ) ; } } else if ( "GNU libgcj" . equals ( System . getProperty ( "java.vm.name" ) ) ) { addExisting ( systemBootClasspath ) ; } if ( System . getProperty ( "java.vendor" ) . toLowerCase ( Locale . US ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; addFileset ( msZipFiles ) ; } else { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; String [ ] secJars = { "jce" , "jsse" } ; for ( int i = 0 ; i < secJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + secJars [ i ] + ".jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + secJars [ i ] + ".jar" ) ) ; } String [ ] ibmJars = { "core" , "graphics" , "security" , "server" , "xml" } ; for ( int i = 0 ; i < ibmJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + ibmJars [ i ] + ".jar" ) ) ; } addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } public void addExtdirs ( Path extdirs ) { if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( getProject ( ) , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File dir = resolveFile ( getProject ( ) , dirs [ i ] ) ; if ( dir . exists ( ) && dir . isDirectory ( ) ) { FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; addFileset ( fs ) ; } } } public final synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . iterator ( ) ; } dieOnCircularReference ( ) ; return union == null ? EMPTY_ITERATOR : assertFilesystemOnly ( union ) . iterator ( ) ; } public synchronized boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return ( ( Path ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } dieOnCircularReference ( ) ; assertFilesystemOnly ( union ) ; return true ; } protected ResourceCollection assertFilesystemOnly ( ResourceCollection rc ) { if ( rc != null && ! ( rc . isFilesystemOnly ( ) ) ) { throw new BuildException ( getDataTypeName ( ) + " allows only filesystem resources." ) ; } return rc ; } } 	1
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMkelem extends ClearCase { private String mComment = null ; private String mCfile = null ; private boolean mNwarn = false ; private boolean mPtime = false ; private boolean mNoco = false ; private boolean mCheckin = false ; private boolean mMaster = false ; private String mEltype = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKELEM ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getNoWarn ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOWARN ) ; } if ( getNoCheckout ( ) && getCheckin ( ) ) { throw new BuildException ( "Should choose either [nocheckout | checkin]" ) ; } if ( getNoCheckout ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOCHECKOUT ) ; } if ( getCheckin ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_CHECKIN ) ; if ( getPreserveTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PRESERVETIME ) ; } } if ( getMaster ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_MASTER ) ; } if ( getEltype ( ) != null ) { getEltypeCommand ( cmd ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setPreserveTime ( boolean ptime ) { mPtime = ptime ; } public boolean getPreserveTime ( ) { return mPtime ; } public void setNoCheckout ( boolean co ) { mNoco = co ; } public boolean getNoCheckout ( ) { return mNoco ; } public void setCheckin ( boolean ci ) { mCheckin = ci ; } public boolean getCheckin ( ) { return mCheckin ; } public void setMaster ( boolean master ) { mMaster = master ; } public boolean getMaster ( ) { return mMaster ; } public void setEltype ( String eltype ) { mEltype = eltype ; } public String getEltype ( ) { return mEltype ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } private void getEltypeCommand ( Commandline cmd ) { if ( getEltype ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_ELTYPE ) ; cmd . createArgument ( ) . setValue ( getEltype ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_NOWARN = "-nwarn" ; public static final String FLAG_PRESERVETIME = "-ptime" ; public static final String FLAG_NOCHECKOUT = "-nco" ; public static final String FLAG_CHECKIN = "-ci" ; public static final String FLAG_MASTER = "-master" ; public static final String FLAG_ELTYPE = "-eltype" ; } 	0
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . regexp . Regexp ; import org . apache . tools . ant . util . regexp . RegexpFactory ; public class RegularExpression extends DataType { public static final String DATA_TYPE_NAME = "regexp" ; private boolean alreadyInit = false ; private static final RegexpFactory FACTORY = new RegexpFactory ( ) ; private Regexp regexp = null ; private String myPattern ; private boolean setPatternPending = false ; public RegularExpression ( ) { } private void init ( Project p ) { if ( ! alreadyInit ) { this . regexp = FACTORY . newRegexp ( p ) ; alreadyInit = true ; } } private void setPattern ( ) { if ( setPatternPending ) { regexp . setPattern ( myPattern ) ; setPatternPending = false ; } } public void setPattern ( String pattern ) { if ( regexp == null ) { myPattern = pattern ; setPatternPending = true ; } else { regexp . setPattern ( pattern ) ; } } public String getPattern ( Project p ) { init ( p ) ; if ( isReference ( ) ) { return getRef ( p ) . getPattern ( p ) ; } setPattern ( ) ; return regexp . getPattern ( ) ; } public Regexp getRegexp ( Project p ) { init ( p ) ; if ( isReference ( ) ) { return getRef ( p ) . getRegexp ( p ) ; } setPattern ( ) ; return this . regexp ; } public RegularExpression getRef ( Project p ) { return ( RegularExpression ) getCheckedRef ( p ) ; } } 	0
package org . apache . tools . ant . types . resources ; import java . util . Set ; import java . util . HashSet ; import java . util . Iterator ; import java . util . WeakHashMap ; import java . util . NoSuchElementException ; import java . util . ConcurrentModificationException ; class FailFast implements Iterator { private static final WeakHashMap MAP = new WeakHashMap ( ) ; static synchronized void invalidate ( Object o ) { Set s = ( Set ) ( MAP . get ( o ) ) ; if ( s != null ) { s . clear ( ) ; } } private static synchronized void add ( FailFast f ) { Set s = ( Set ) ( MAP . get ( f . parent ) ) ; if ( s == null ) { s = new HashSet ( ) ; MAP . put ( f . parent , s ) ; } s . add ( f ) ; } private static synchronized void remove ( FailFast f ) { Set s = ( Set ) ( MAP . get ( f . parent ) ) ; if ( s != null ) { s . remove ( f ) ; } } private static synchronized void failFast ( FailFast f ) { Set s = ( Set ) ( MAP . get ( f . parent ) ) ; if ( ! s . contains ( f ) ) { throw new ConcurrentModificationException ( ) ; } } private Object parent ; private Iterator wrapped ; FailFast ( Object o , Iterator i ) { if ( o == null ) { throw new IllegalArgumentException ( "parent object is null" ) ; } if ( i == null ) { throw new IllegalArgumentException ( "cannot wrap null iterator" ) ; } parent = o ; if ( i . hasNext ( ) ) { wrapped = i ; add ( this ) ; } } public boolean hasNext ( ) { if ( wrapped == null ) { return false ; } failFast ( this ) ; return wrapped . hasNext ( ) ; } public Object next ( ) { if ( wrapped == null || ! wrapped . hasNext ( ) ) { throw new NoSuchElementException ( ) ; } failFast ( this ) ; try { return wrapped . next ( ) ; } finally { if ( ! wrapped . hasNext ( ) ) { wrapped = null ; remove ( this ) ; } } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } 	0
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import java . io . File ; import java . io . IOException ; public class CopyPath extends Task { public static final String ERROR_NO_DESTDIR = "No destDir specified" ; public static final String ERROR_NO_PATH = "No path specified" ; public static final String ERROR_NO_MAPPER = "No mapper specified" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private FileNameMapper mapper ; private Path path ; private File destDir ; private long granularity = FILE_UTILS . getFileTimestampGranularity ( ) ; private boolean preserveLastModified = false ; public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void add ( FileNameMapper newmapper ) { if ( mapper != null ) { throw new BuildException ( "Only one mapper allowed" ) ; } mapper = newmapper ; } public void setPath ( Path s ) { createPath ( ) . append ( s ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path ; } public void setGranularity ( long granularity ) { this . granularity = granularity ; } public void setPreserveLastModified ( boolean preserveLastModified ) { this . preserveLastModified = preserveLastModified ; } protected void validateAttributes ( ) throws BuildException { if ( destDir == null ) { throw new BuildException ( ERROR_NO_DESTDIR ) ; } if ( mapper == null ) { throw new BuildException ( ERROR_NO_MAPPER ) ; } if ( path == null ) { throw new BuildException ( ERROR_NO_PATH ) ; } } public void execute ( ) throws BuildException { validateAttributes ( ) ; String [ ] sourceFiles = path . list ( ) ; if ( sourceFiles . length == 0 ) { log ( "Path is empty" , Project . MSG_VERBOSE ) ; return ; } for ( int sources = 0 ; sources < sourceFiles . length ; sources ++ ) { String sourceFileName = sourceFiles [ sources ] ; File sourceFile = new File ( sourceFileName ) ; String [ ] toFiles = ( String [ ] ) mapper . mapFileName ( sourceFileName ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String destFileName = toFiles [ i ] ; File destFile = new File ( destDir , destFileName ) ; if ( sourceFile . equals ( destFile ) ) { log ( "Skipping self-copy of " + sourceFileName , Project . MSG_VERBOSE ) ; continue ; } if ( sourceFile . isDirectory ( ) ) { log ( "Skipping directory " + sourceFileName ) ; continue ; } try { log ( "Copying " + sourceFile + " to " + destFile , Project . MSG_VERBOSE ) ; FILE_UTILS . copyFile ( sourceFile , destFile , null , null , false , preserveLastModified , null , null , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + sourceFile + " to " + destFile + " due to " + ioe . getMessage ( ) ; if ( destFile . exists ( ) && ! destFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + destFile ; } throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } } 	0
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; Path p = getBootClassPath ( ) ; if ( p . size ( ) > 0 ) { classpath . append ( p ) ; } if ( includeJavaRuntime ) { classpath . addExtdirs ( extdirs ) ; } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } Commandline cmd = new Commandline ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jvc" : exec ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; boolean msExtensions = true ; String mse = getProject ( ) . getProperty ( "build.compiler.jvc.extensions" ) ; if ( mse != null ) { msExtensions = Project . toBoolean ( mse ) ; } if ( msExtensions ) { cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; } cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0
package org . apache . tools . ant . types . resolver ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . ResourceLocation ; import org . apache . xml . resolver . Catalog ; import org . apache . xml . resolver . CatalogManager ; import org . apache . xml . resolver . tools . CatalogResolver ; public class ApacheCatalogResolver extends CatalogResolver { private XMLCatalog xmlCatalog = null ; static { CatalogManager . getStaticManager ( ) . setIgnoreMissingProperties ( true ) ; System . getProperties ( ) . put ( "xml.catalog.className" , ApacheCatalog . class . getName ( ) ) ; CatalogManager . getStaticManager ( ) . setUseStaticCatalog ( false ) ; } public void setXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog = xmlCatalog ; } public void parseCatalog ( String file ) { Catalog catalog = getCatalog ( ) ; if ( ! ( catalog instanceof ApacheCatalog ) ) { throw new BuildException ( "Wrong catalog type found: " + catalog . getClass ( ) . getName ( ) ) ; } ApacheCatalog apacheCatalog = ( ApacheCatalog ) catalog ; apacheCatalog . setResolver ( this ) ; try { apacheCatalog . parseCatalog ( file ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( ex ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } public void addPublicEntry ( String publicid , String systemid , URL base ) { ResourceLocation dtd = new ResourceLocation ( ) ; dtd . setBase ( base ) ; dtd . setPublicId ( publicid ) ; dtd . setLocation ( systemid ) ; xmlCatalog . addDTD ( dtd ) ; } public void addURIEntry ( String uri , String altURI , URL base ) { ResourceLocation entity = new ResourceLocation ( ) ; entity . setBase ( base ) ; entity . setPublicId ( uri ) ; entity . setLocation ( altURI ) ; xmlCatalog . addEntity ( entity ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . extension ; import java . text . ParseException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . Map ; import java . util . jar . Attributes ; import java . util . jar . Manifest ; import org . apache . tools . ant . util . StringUtils ; public final class Specification { private static final String MISSING = "Missing " ; public static final Attributes . Name SPECIFICATION_TITLE = Attributes . Name . SPECIFICATION_TITLE ; public static final Attributes . Name SPECIFICATION_VERSION = Attributes . Name . SPECIFICATION_VERSION ; public static final Attributes . Name SPECIFICATION_VENDOR = Attributes . Name . SPECIFICATION_VENDOR ; public static final Attributes . Name IMPLEMENTATION_TITLE = Attributes . Name . IMPLEMENTATION_TITLE ; public static final Attributes . Name IMPLEMENTATION_VERSION = Attributes . Name . IMPLEMENTATION_VERSION ; public static final Attributes . Name IMPLEMENTATION_VENDOR = Attributes . Name . IMPLEMENTATION_VENDOR ; public static final Compatibility COMPATIBLE = new Compatibility ( "COMPATIBLE" ) ; public static final Compatibility REQUIRE_SPECIFICATION_UPGRADE = new Compatibility ( "REQUIRE_SPECIFICATION_UPGRADE" ) ; public static final Compatibility REQUIRE_VENDOR_SWITCH = new Compatibility ( "REQUIRE_VENDOR_SWITCH" ) ; public static final Compatibility REQUIRE_IMPLEMENTATION_CHANGE = new Compatibility ( "REQUIRE_IMPLEMENTATION_CHANGE" ) ; public static final Compatibility INCOMPATIBLE = new Compatibility ( "INCOMPATIBLE" ) ; private String specificationTitle ; private DeweyDecimal specificationVersion ; private String specificationVendor ; private String implementationTitle ; private String implementationVendor ; private String implementationVersion ; private String [ ] sections ; public static Specification [ ] getSpecifications ( final Manifest manifest ) throws ParseException { if ( null == manifest ) { return new Specification [ 0 ] ; } final ArrayList results = new ArrayList ( ) ; final Map entries = manifest . getEntries ( ) ; final Iterator keys = entries . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { final String key = ( String ) keys . next ( ) ; final Attributes attributes = ( Attributes ) entries . get ( key ) ; final Specification specification = getSpecification ( key , attributes ) ; if ( null != specification ) { results . add ( specification ) ; } } final ArrayList trimmedResults = removeDuplicates ( results ) ; return ( Specification [ ] ) trimmedResults . toArray ( new Specification [ trimmedResults . size ( ) ] ) ; } public Specification ( final String specificationTitle , final String specificationVersion , final String specificationVendor , final String implementationTitle , final String implementationVersion , final String implementationVendor ) { this ( specificationTitle , specificationVersion , specificationVendor , implementationTitle , implementationVersion , implementationVendor , null ) ; } public Specification ( final String specificationTitle , final String specificationVersion , final String specificationVendor , final String implementationTitle , final String implementationVersion , final String implementationVendor , final String [ ] sections ) { this . specificationTitle = specificationTitle ; this . specificationVendor = specificationVendor ; if ( null != specificationVersion ) { try { this . specificationVersion = new DeweyDecimal ( specificationVersion ) ; } catch ( final NumberFormatException nfe ) { final String error = "Bad specification version format '" + specificationVersion + "' in '" + specificationTitle + "'. (Reason: " + nfe + ")" ; throw new IllegalArgumentException ( error ) ; } } this . implementationTitle = implementationTitle ; this . implementationVendor = implementationVendor ; this . implementationVersion = implementationVersion ; if ( null == this . specificationTitle ) { throw new NullPointerException ( "specificationTitle" ) ; } String [ ] copy = null ; if ( null != sections ) { copy = new String [ sections . length ] ; System . arraycopy ( sections , 0 , copy , 0 , sections . length ) ; } this . sections = copy ; } public String getSpecificationTitle ( ) { return specificationTitle ; } public String getSpecificationVendor ( ) { return specificationVendor ; } public String getImplementationTitle ( ) { return implementationTitle ; } public DeweyDecimal getSpecificationVersion ( ) { return specificationVersion ; } public String getImplementationVendor ( ) { return implementationVendor ; } public String getImplementationVersion ( ) { return implementationVersion ; } public String [ ] getSections ( ) { if ( null == sections ) { return null ; } final String [ ] newSections = new String [ sections . length ] ; System . arraycopy ( sections , 0 , newSections , 0 , sections . length ) ; return newSections ; } public Compatibility getCompatibilityWith ( final Specification other ) { if ( ! specificationTitle . equals ( other . getSpecificationTitle ( ) ) ) { return INCOMPATIBLE ; } final DeweyDecimal otherSpecificationVersion = other . getSpecificationVersion ( ) ; if ( null != specificationVersion ) { if ( null == otherSpecificationVersion || ! isCompatible ( specificationVersion , otherSpecificationVersion ) ) { return REQUIRE_SPECIFICATION_UPGRADE ; } } final String otherImplementationVendor = other . getImplementationVendor ( ) ; if ( null != implementationVendor ) { if ( null == otherImplementationVendor || ! implementationVendor . equals ( otherImplementationVendor ) ) { return REQUIRE_VENDOR_SWITCH ; } } final String otherImplementationVersion = other . getImplementationVersion ( ) ; if ( null != implementationVersion ) { if ( null == otherImplementationVersion || ! implementationVersion . equals ( otherImplementationVersion ) ) { return REQUIRE_IMPLEMENTATION_CHANGE ; } } return COMPATIBLE ; } public boolean isCompatibleWith ( final Specification other ) { return ( COMPATIBLE == getCompatibilityWith ( other ) ) ; } public String toString ( ) { final String brace = ": " ; final StringBuffer sb = new StringBuffer ( SPECIFICATION_TITLE . toString ( ) ) ; sb . append ( brace ) ; sb . append ( specificationTitle ) ; sb . append ( StringUtils . LINE_SEP ) ; if ( null != specificationVersion ) { sb . append ( SPECIFICATION_VERSION ) ; sb . append ( brace ) ; sb . append ( specificationVersion ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != specificationVendor ) { sb . append ( SPECIFICATION_VENDOR ) ; sb . append ( brace ) ; sb . append ( specificationVendor ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationTitle ) { sb . append ( IMPLEMENTATION_TITLE ) ; sb . append ( brace ) ; sb . append ( implementationTitle ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVersion ) { sb . append ( IMPLEMENTATION_VERSION ) ; sb . append ( brace ) ; sb . append ( implementationVersion ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVendor ) { sb . append ( IMPLEMENTATION_VENDOR ) ; sb . append ( brace ) ; sb . append ( implementationVendor ) ; sb . append ( StringUtils . LINE_SEP ) ; } return sb . toString ( ) ; } private boolean isCompatible ( final DeweyDecimal first , final DeweyDecimal second ) { return first . isGreaterThanOrEqual ( second ) ; } private static ArrayList removeDuplicates ( final ArrayList list ) { final ArrayList results = new ArrayList ( ) ; final ArrayList sections = new ArrayList ( ) ; while ( list . size ( ) > 0 ) { final Specification specification = ( Specification ) list . remove ( 0 ) ; final Iterator iterator = list . iterator ( ) ; while ( iterator . hasNext ( ) ) { final Specification other = ( Specification ) iterator . next ( ) ; if ( isEqual ( specification , other ) ) { final String [ ] otherSections = other . getSections ( ) ; if ( null != sections ) { sections . addAll ( Arrays . asList ( otherSections ) ) ; } iterator . remove ( ) ; } } final Specification merged = mergeInSections ( specification , sections ) ; results . add ( merged ) ; sections . clear ( ) ; } return results ; } private static boolean isEqual ( final Specification specification , final Specification other ) { return specification . getSpecificationTitle ( ) . equals ( other . getSpecificationTitle ( ) ) && specification . getSpecificationVersion ( ) . isEqual ( other . getSpecificationVersion ( ) ) && specification . getSpecificationVendor ( ) . equals ( other . getSpecificationVendor ( ) ) && specification . getImplementationTitle ( ) . equals ( other . getImplementationTitle ( ) ) && specification . getImplementationVersion ( ) . equals ( other . getImplementationVersion ( ) ) && specification . getImplementationVendor ( ) . equals ( other . getImplementationVendor ( ) ) ; } private static Specification mergeInSections ( final Specification specification , final ArrayList sectionsToAdd ) { if ( 0 == sectionsToAdd . size ( ) ) { return specification ; } sectionsToAdd . addAll ( Arrays . asList ( specification . getSections ( ) ) ) ; final String [ ] sections = ( String [ ] ) sectionsToAdd . toArray ( new String [ sectionsToAdd . size ( ) ] ) ; return new Specification ( specification . getSpecificationTitle ( ) , specification . getSpecificationVersion ( ) . toString ( ) , specification . getSpecificationVendor ( ) , specification . getImplementationTitle ( ) , specification . getImplementationVersion ( ) , specification . getImplementationVendor ( ) , sections ) ; } private static String getTrimmedString ( final String value ) { return value == null ? null : value . trim ( ) ; } private static Specification getSpecification ( final String section , final Attributes attributes ) throws ParseException { final String name = getTrimmedString ( attributes . getValue ( SPECIFICATION_TITLE ) ) ; if ( null == name ) { return null ; } final String specVendor = getTrimmedString ( attributes . getValue ( SPECIFICATION_VENDOR ) ) ; if ( null == specVendor ) { throw new ParseException ( MISSING + SPECIFICATION_VENDOR , 0 ) ; } final String specVersion = getTrimmedString ( attributes . getValue ( SPECIFICATION_VERSION ) ) ; if ( null == specVersion ) { throw new ParseException ( MISSING + SPECIFICATION_VERSION , 0 ) ; } final String impTitle = getTrimmedString ( attributes . getValue ( IMPLEMENTATION_TITLE ) ) ; if ( null == impTitle ) { throw new ParseException ( MISSING + IMPLEMENTATION_TITLE , 0 ) ; } final String impVersion = getTrimmedString ( attributes . getValue ( IMPLEMENTATION_VERSION ) ) ; if ( null == impVersion ) { throw new ParseException ( MISSING + IMPLEMENTATION_VERSION , 0 ) ; } final String impVendor = getTrimmedString ( attributes . getValue ( IMPLEMENTATION_VENDOR ) ) ; if ( null == impVendor ) { throw new ParseException ( MISSING + IMPLEMENTATION_VENDOR , 0 ) ; } return new Specification ( name , specVersion , specVendor , impTitle , impVersion , impVendor , new String [ ] { section } ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . script ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DynamicConfigurator ; import java . util . Map ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; public class ScriptDefBase extends Task implements DynamicConfigurator { private Map nestedElementMap = new HashMap ( ) ; private Map attributes = new HashMap ( ) ; private String text ; public void execute ( ) { getScript ( ) . executeScript ( attributes , nestedElementMap , this ) ; } private ScriptDef getScript ( ) { String name = getTaskType ( ) ; Map scriptRepository = ( Map ) getProject ( ) . getReference ( MagicNames . SCRIPT_REPOSITORY ) ; if ( scriptRepository == null ) { throw new BuildException ( "Script repository not found for " + name ) ; } ScriptDef definition = ( ScriptDef ) scriptRepository . get ( getTaskType ( ) ) ; if ( definition == null ) { throw new BuildException ( "Script definition not found for " + name ) ; } return definition ; } public Object createDynamicElement ( String name ) { List nestedElementList = ( List ) nestedElementMap . get ( name ) ; if ( nestedElementList == null ) { nestedElementList = new ArrayList ( ) ; nestedElementMap . put ( name , nestedElementList ) ; } Object element = getScript ( ) . createNestedElement ( name ) ; nestedElementList . add ( element ) ; return element ; } public void setDynamicAttribute ( String name , String value ) { ScriptDef definition = getScript ( ) ; if ( ! definition . isAttributeSupported ( name ) ) { throw new BuildException ( "<" + getTaskType ( ) + "> does not support the \"" + name + "\" attribute" ) ; } attributes . put ( name , value ) ; } public void addText ( String text ) { this . text = getProject ( ) . replaceProperties ( text ) ; } public String getText ( ) { return text ; } public void fail ( String message ) { throw new BuildException ( message ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCUpdate extends ClearCase { private boolean mGraphical = false ; private boolean mOverwrite = false ; private boolean mRename = false ; private boolean mCtime = false ; private boolean mPtime = false ; private String mLog = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_UPDATE ) ; checkOptions ( commandLine ) ; getProject ( ) . log ( commandLine . toString ( ) , Project . MSG_DEBUG ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getGraphical ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_GRAPHICAL ) ; } else { if ( getOverwrite ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_OVERWRITE ) ; } else { if ( getRename ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RENAME ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOVERWRITE ) ; } } if ( getCurrentTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_CURRENTTIME ) ; } else { if ( getPreserveTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PRESERVETIME ) ; } } getLogCommand ( cmd ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setGraphical ( boolean graphical ) { mGraphical = graphical ; } public boolean getGraphical ( ) { return mGraphical ; } public void setOverwrite ( boolean ow ) { mOverwrite = ow ; } public boolean getOverwrite ( ) { return mOverwrite ; } public void setRename ( boolean ren ) { mRename = ren ; } public boolean getRename ( ) { return mRename ; } public void setCurrentTime ( boolean ct ) { mCtime = ct ; } public boolean getCurrentTime ( ) { return mCtime ; } public void setPreserveTime ( boolean pt ) { mPtime = pt ; } public boolean getPreserveTime ( ) { return mPtime ; } public void setLog ( String log ) { mLog = log ; } public String getLog ( ) { return mLog ; } private void getLogCommand ( Commandline cmd ) { if ( getLog ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_LOG ) ; cmd . createArgument ( ) . setValue ( getLog ( ) ) ; } } public static final String FLAG_GRAPHICAL = "-graphical" ; public static final String FLAG_LOG = "-log" ; public static final String FLAG_OVERWRITE = "-overwrite" ; public static final String FLAG_NOVERWRITE = "-noverwrite" ; public static final String FLAG_RENAME = "-rename" ; public static final String FLAG_CURRENTTIME = "-ctime" ; public static final String FLAG_PRESERVETIME = "-ptime" ; } 	0
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . net . URL ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . rmic . DefaultRmicAdapter ; import org . apache . tools . ant . taskdefs . rmic . WLRmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . depend . DependencyAnalyzer ; public class Depend extends MatchingTask { private static class ClassFileInfo { private File absoluteFile ; private String className ; private File sourceFile ; private boolean isUserWarned = false ; } private Path srcPath ; private Path destPath ; private File cache ; private String [ ] srcPathList ; private Hashtable affectedClassMap ; private Hashtable classFileInfoMap ; private Hashtable classpathDependencies ; private Hashtable outOfDateClasses ; private boolean closure = false ; private boolean warnOnRmiStubs = true ; private boolean dump = false ; private Path dependClasspath ; private static final String CACHE_FILE_NAME = "dependencies.txt" ; private static final String CLASSNAME_PREPEND = "||:" ; public void setClasspath ( Path classpath ) { if ( dependClasspath == null ) { dependClasspath = classpath ; } else { dependClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return dependClasspath ; } public Path createClasspath ( ) { if ( dependClasspath == null ) { dependClasspath = new Path ( getProject ( ) ) ; } return dependClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setWarnOnRmiStubs ( boolean warnOnRmiStubs ) { this . warnOnRmiStubs = warnOnRmiStubs ; } private Hashtable readCachedDependencies ( File depFile ) throws IOException { Hashtable dependencyMap = new Hashtable ( ) ; BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( depFile ) ) ; String line = null ; Vector dependencyList = null ; String className = null ; int prependLength = CLASSNAME_PREPEND . length ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( CLASSNAME_PREPEND ) ) { dependencyList = new Vector ( ) ; className = line . substring ( prependLength ) ; dependencyMap . put ( className , dependencyList ) ; } else { dependencyList . addElement ( line ) ; } } } finally { if ( in != null ) { in . close ( ) ; } } return dependencyMap ; } private void writeCachedDependencies ( Hashtable dependencyMap ) throws IOException { if ( cache != null ) { PrintWriter pw = null ; try { cache . mkdirs ( ) ; File depFile = new File ( cache , CACHE_FILE_NAME ) ; pw = new PrintWriter ( new FileWriter ( depFile ) ) ; Enumeration e = dependencyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String className = ( String ) e . nextElement ( ) ; pw . println ( CLASSNAME_PREPEND + className ) ; Vector dependencyList = ( Vector ) dependencyMap . get ( className ) ; int size = dependencyList . size ( ) ; for ( int x = 0 ; x < size ; x ++ ) { pw . println ( dependencyList . elementAt ( x ) ) ; } } } finally { if ( pw != null ) { pw . close ( ) ; } } } } private Path getCheckClassPath ( ) { if ( dependClasspath == null ) { return null ; } String [ ] destPathElements = destPath . list ( ) ; String [ ] classpathElements = dependClasspath . list ( ) ; String checkPath = "" ; for ( int i = 0 ; i < classpathElements . length ; ++ i ) { String element = classpathElements [ i ] ; boolean inDestPath = false ; for ( int j = 0 ; j < destPathElements . length && ! inDestPath ; ++ j ) { inDestPath = destPathElements [ j ] . equals ( element ) ; } if ( ! inDestPath ) { if ( checkPath . length ( ) == 0 ) { checkPath = element ; } else { checkPath += ":" + element ; } } } if ( checkPath . length ( ) == 0 ) { return null ; } return new Path ( getProject ( ) , checkPath ) ; } private void determineDependencies ( ) throws IOException { affectedClassMap = new Hashtable ( ) ; classFileInfoMap = new Hashtable ( ) ; boolean cacheDirty = false ; Hashtable dependencyMap = new Hashtable ( ) ; File cacheFile = null ; boolean cacheFileExists = true ; long cacheLastModified = Long . MAX_VALUE ; if ( cache != null ) { cacheFile = new File ( cache , CACHE_FILE_NAME ) ; cacheFileExists = cacheFile . exists ( ) ; cacheLastModified = cacheFile . lastModified ( ) ; if ( cacheFileExists ) { dependencyMap = readCachedDependencies ( cacheFile ) ; } } Enumeration classfileEnum = getClassFiles ( destPath ) . elements ( ) ; while ( classfileEnum . hasMoreElements ( ) ) { ClassFileInfo info = ( ClassFileInfo ) classfileEnum . nextElement ( ) ; log ( "Adding class info for " + info . className , Project . MSG_DEBUG ) ; classFileInfoMap . put ( info . className , info ) ; Vector dependencyList = null ; if ( cache != null ) { if ( cacheFileExists && cacheLastModified > info . absoluteFile . lastModified ( ) ) { dependencyList = ( Vector ) dependencyMap . get ( info . className ) ; } } if ( dependencyList == null ) { DependencyAnalyzer analyzer = new AntAnalyzer ( ) ; analyzer . addRootClass ( info . className ) ; analyzer . addClassPath ( destPath ) ; analyzer . setClosure ( false ) ; dependencyList = new Vector ( ) ; Enumeration depEnum = analyzer . getClassDependencies ( ) ; while ( depEnum . hasMoreElements ( ) ) { dependencyList . addElement ( depEnum . nextElement ( ) ) ; } cacheDirty = true ; dependencyMap . put ( info . className , dependencyList ) ; } Enumeration depEnum = dependencyList . elements ( ) ; while ( depEnum . hasMoreElements ( ) ) { String dependentClass = ( String ) depEnum . nextElement ( ) ; Hashtable affectedClasses = ( Hashtable ) affectedClassMap . get ( dependentClass ) ; if ( affectedClasses == null ) { affectedClasses = new Hashtable ( ) ; affectedClassMap . put ( dependentClass , affectedClasses ) ; } affectedClasses . put ( info . className , info ) ; } } classpathDependencies = null ; Path checkPath = getCheckClassPath ( ) ; if ( checkPath != null ) { classpathDependencies = new Hashtable ( ) ; AntClassLoader loader = getProject ( ) . createClassLoader ( checkPath ) ; Hashtable classpathFileCache = new Hashtable ( ) ; Object nullFileMarker = new Object ( ) ; for ( Enumeration e = dependencyMap . keys ( ) ; e . hasMoreElements ( ) ; ) { String className = ( String ) e . nextElement ( ) ; Vector dependencyList = ( Vector ) dependencyMap . get ( className ) ; Hashtable dependencies = new Hashtable ( ) ; classpathDependencies . put ( className , dependencies ) ; Enumeration e2 = dependencyList . elements ( ) ; while ( e2 . hasMoreElements ( ) ) { String dependency = ( String ) e2 . nextElement ( ) ; Object classpathFileObject = classpathFileCache . get ( dependency ) ; if ( classpathFileObject == null ) { classpathFileObject = nullFileMarker ; if ( ! dependency . startsWith ( "java." ) && ! dependency . startsWith ( "javax." ) ) { URL classURL = loader . getResource ( dependency . replace ( '.' , '/' ) + ".class" ) ; if ( classURL != null ) { if ( classURL . getProtocol ( ) . equals ( "jar" ) ) { String jarFilePath = classURL . getFile ( ) ; int classMarker = jarFilePath . indexOf ( '!' ) ; jarFilePath = jarFilePath . substring ( 0 , classMarker ) ; if ( jarFilePath . startsWith ( "file:" ) ) { classpathFileObject = new File ( FileUtils . getFileUtils ( ) . fromURI ( jarFilePath ) ) ; } else { throw new IOException ( "Bizarre nested path in jar: protocol: " + jarFilePath ) ; } } else if ( classURL . getProtocol ( ) . equals ( "file" ) ) { classpathFileObject = new File ( FileUtils . getFileUtils ( ) . fromURI ( classURL . toExternalForm ( ) ) ) ; } log ( "Class " + className + " depends on " + classpathFileObject + " due to " + dependency , Project . MSG_DEBUG ) ; } } classpathFileCache . put ( dependency , classpathFileObject ) ; } if ( classpathFileObject != null && classpathFileObject != nullFileMarker ) { File jarFile = ( File ) classpathFileObject ; dependencies . put ( jarFile , jarFile ) ; } } } } if ( cache != null && cacheDirty ) { writeCachedDependencies ( dependencyMap ) ; } } private int deleteAllAffectedFiles ( ) { int count = 0 ; for ( Enumeration e = outOfDateClasses . elements ( ) ; e . hasMoreElements ( ) ; ) { String className = ( String ) e . nextElement ( ) ; count += deleteAffectedFiles ( className ) ; ClassFileInfo classInfo = ( ClassFileInfo ) classFileInfoMap . get ( className ) ; if ( classInfo != null && classInfo . absoluteFile . exists ( ) ) { classInfo . absoluteFile . delete ( ) ; count ++ ; } } return count ; } private int deleteAffectedFiles ( String className ) { int count = 0 ; Hashtable affectedClasses = ( Hashtable ) affectedClassMap . get ( className ) ; if ( affectedClasses == null ) { return count ; } for ( Enumeration e = affectedClasses . keys ( ) ; e . hasMoreElements ( ) ; ) { String affectedClass = ( String ) e . nextElement ( ) ; ClassFileInfo affectedClassInfo = ( ClassFileInfo ) affectedClasses . get ( affectedClass ) ; if ( ! affectedClassInfo . absoluteFile . exists ( ) ) { continue ; } if ( affectedClassInfo . sourceFile == null ) { warnOutOfDateButNotDeleted ( affectedClassInfo , affectedClass , className ) ; continue ; } log ( "Deleting file " + affectedClassInfo . absoluteFile . getPath ( ) + " since " + className + " out of date" , Project . MSG_VERBOSE ) ; affectedClassInfo . absoluteFile . delete ( ) ; count ++ ; if ( closure ) { count += deleteAffectedFiles ( affectedClass ) ; } else { if ( affectedClass . indexOf ( "$" ) == - 1 ) { continue ; } String topLevelClassName = affectedClass . substring ( 0 , affectedClass . indexOf ( "$" ) ) ; log ( "Top level class = " + topLevelClassName , Project . MSG_VERBOSE ) ; ClassFileInfo topLevelClassInfo = ( ClassFileInfo ) classFileInfoMap . get ( topLevelClassName ) ; if ( topLevelClassInfo != null && topLevelClassInfo . absoluteFile . exists ( ) ) { log ( "Deleting file " + topLevelClassInfo . absoluteFile . getPath ( ) + " since one of its inner classes was removed" , Project . MSG_VERBOSE ) ; topLevelClassInfo . absoluteFile . delete ( ) ; count ++ ; if ( closure ) { count += deleteAffectedFiles ( topLevelClassName ) ; } } } } return count ; } private void warnOutOfDateButNotDeleted ( ClassFileInfo affectedClassInfo , String affectedClass , String className ) { if ( affectedClassInfo . isUserWarned ) { return ; } int level = Project . MSG_WARN ; if ( ! warnOnRmiStubs ) { if ( isRmiStub ( affectedClass , className ) ) { level = Project . MSG_VERBOSE ; } } log ( "The class " + affectedClass + " in file " + affectedClassInfo . absoluteFile . getPath ( ) + " is out of date due to " + className + " but has not been deleted because its source file" + " could not be determined" , level ) ; affectedClassInfo . isUserWarned = true ; } private boolean isRmiStub ( String affectedClass , String className ) { return isStub ( affectedClass , className , DefaultRmicAdapter . RMI_STUB_SUFFIX ) || isStub ( affectedClass , className , DefaultRmicAdapter . RMI_SKEL_SUFFIX ) || isStub ( affectedClass , className , WLRmic . RMI_STUB_SUFFIX ) || isStub ( affectedClass , className , WLRmic . RMI_SKEL_SUFFIX ) ; } private boolean isStub ( String affectedClass , String baseClass , String suffix ) { return ( baseClass + suffix ) . equals ( affectedClass ) ; } private void dumpDependencies ( ) { log ( "Reverse Dependency Dump for " + affectedClassMap . size ( ) + " classes:" , Project . MSG_DEBUG ) ; Enumeration classEnum = affectedClassMap . keys ( ) ; while ( classEnum . hasMoreElements ( ) ) { String className = ( String ) classEnum . nextElement ( ) ; log ( " Class " + className + " affects:" , Project . MSG_DEBUG ) ; Hashtable affectedClasses = ( Hashtable ) affectedClassMap . get ( className ) ; Enumeration affectedClassEnum = affectedClasses . keys ( ) ; while ( affectedClassEnum . hasMoreElements ( ) ) { String affectedClass = ( String ) affectedClassEnum . nextElement ( ) ; ClassFileInfo info = ( ClassFileInfo ) affectedClasses . get ( affectedClass ) ; log ( "    " + affectedClass + " in " + info . absoluteFile . getPath ( ) , Project . MSG_DEBUG ) ; } } if ( classpathDependencies != null ) { log ( "Classpath file dependencies (Forward):" , Project . MSG_DEBUG ) ; Enumeration classpathEnum = classpathDependencies . keys ( ) ; while ( classpathEnum . hasMoreElements ( ) ) { String className = ( String ) classpathEnum . nextElement ( ) ; log ( " Class " + className + " depends on:" , Project . MSG_DEBUG ) ; Hashtable dependencies = ( Hashtable ) classpathDependencies . get ( className ) ; Enumeration classpathFileEnum = dependencies . elements ( ) ; while ( classpathFileEnum . hasMoreElements ( ) ) { File classpathFile = ( File ) classpathFileEnum . nextElement ( ) ; log ( "    " + classpathFile . getPath ( ) , Project . MSG_DEBUG ) ; } } } } private void determineOutOfDateClasses ( ) { outOfDateClasses = new Hashtable ( ) ; for ( int i = 0 ; i < srcPathList . length ; i ++ ) { File srcDir = getProject ( ) . resolveFile ( srcPathList [ i ] ) ; if ( srcDir . exists ( ) ) { DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , files ) ; } } if ( classpathDependencies == null ) { return ; } Enumeration classpathDepsEnum = classpathDependencies . keys ( ) ; while ( classpathDepsEnum . hasMoreElements ( ) ) { String className = ( String ) classpathDepsEnum . nextElement ( ) ; if ( outOfDateClasses . containsKey ( className ) ) { continue ; } ClassFileInfo info = ( ClassFileInfo ) classFileInfoMap . get ( className ) ; if ( info != null ) { Hashtable dependencies = ( Hashtable ) classpathDependencies . get ( className ) ; for ( Enumeration e2 = dependencies . elements ( ) ; e2 . hasMoreElements ( ) ; ) { File classpathFile = ( File ) e2 . nextElement ( ) ; if ( classpathFile . lastModified ( ) > info . absoluteFile . lastModified ( ) ) { log ( "Class " + className + " is out of date with respect to " + classpathFile , Project . MSG_DEBUG ) ; outOfDateClasses . put ( className , className ) ; break ; } } } } } public void execute ( ) throws BuildException { try { long start = System . currentTimeMillis ( ) ; if ( srcPath == null ) { throw new BuildException ( "srcdir attribute must be set" , getLocation ( ) ) ; } srcPathList = srcPath . list ( ) ; if ( srcPathList . length == 0 ) { throw new BuildException ( "srcdir attribute must be non-empty" , getLocation ( ) ) ; } if ( destPath == null ) { destPath = srcPath ; } if ( cache != null && cache . exists ( ) && ! cache . isDirectory ( ) ) { throw new BuildException ( "The cache, if specified, must " + "point to a directory" ) ; } if ( cache != null && ! cache . exists ( ) ) { cache . mkdirs ( ) ; } determineDependencies ( ) ; if ( dump ) { dumpDependencies ( ) ; } determineOutOfDateClasses ( ) ; int count = deleteAllAffectedFiles ( ) ; long duration = ( System . currentTimeMillis ( ) - start ) / 1000 ; final int summaryLogLevel ; if ( count > 0 ) { summaryLogLevel = Project . MSG_INFO ; } else { summaryLogLevel = Project . MSG_DEBUG ; } log ( "Deleted " + count + " out of date files in " + duration + " seconds" , summaryLogLevel ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } protected void scanDir ( File srcDir , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { File srcFile = new File ( srcDir , files [ i ] ) ; if ( files [ i ] . endsWith ( ".java" ) ) { String filePath = srcFile . getPath ( ) ; String className = filePath . substring ( srcDir . getPath ( ) . length ( ) + 1 , filePath . length ( ) - ".java" . length ( ) ) ; className = ClassFileUtils . convertSlashName ( className ) ; ClassFileInfo info = ( ClassFileInfo ) classFileInfoMap . get ( className ) ; if ( info == null ) { outOfDateClasses . put ( className , className ) ; } else { if ( srcFile . lastModified ( ) > info . absoluteFile . lastModified ( ) ) { outOfDateClasses . put ( className , className ) ; } } } } } private Vector getClassFiles ( Path classLocations ) { String [ ] classLocationsList = classLocations . list ( ) ; Vector classFileList = new Vector ( ) ; for ( int i = 0 ; i < classLocationsList . length ; ++ i ) { File dir = new File ( classLocationsList [ i ] ) ; if ( dir . isDirectory ( ) ) { addClassFiles ( classFileList , dir , dir ) ; } } return classFileList ; } private File findSourceFile ( String classname ) { String sourceFilename = classname + ".java" ; int innerIndex = classname . indexOf ( "$" ) ; if ( innerIndex != - 1 ) { sourceFilename = classname . substring ( 0 , innerIndex ) + ".java" ; } for ( int i = 0 ; i < srcPathList . length ; ++ i ) { File sourceFile = new File ( srcPathList [ i ] , sourceFilename ) ; if ( sourceFile . exists ( ) ) { return sourceFile ; } } return null ; } private void addClassFiles ( Vector classFileList , File dir , File root ) { String [ ] filesInDir = dir . list ( ) ; if ( filesInDir == null ) { return ; } int length = filesInDir . length ; int rootLength = root . getPath ( ) . length ( ) ; for ( int i = 0 ; i < length ; ++ i ) { File file = new File ( dir , filesInDir [ i ] ) ; if ( file . isDirectory ( ) ) { addClassFiles ( classFileList , file , root ) ; } else if ( file . getName ( ) . endsWith ( ".class" ) ) { ClassFileInfo info = new ClassFileInfo ( ) ; info . absoluteFile = file ; String relativeName = file . getPath ( ) . substring ( rootLength + 1 , file . getPath ( ) . length ( ) - 6 ) ; info . className = ClassFileUtils . convertSlashName ( relativeName ) ; info . sourceFile = findSourceFile ( relativeName ) ; classFileList . addElement ( info ) ; } } } public void setSrcdir ( Path srcPath ) { this . srcPath = srcPath ; } public void setDestDir ( Path destPath ) { this . destPath = destPath ; } public void setCache ( File cache ) { this . cache = cache ; } public void setClosure ( boolean closure ) { this . closure = closure ; } public void setDump ( boolean dump ) { this . dump = dump ; } } 	1
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . IOException ; import org . apache . oro . text . perl . Perl5Util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public abstract class P4Base extends org . apache . tools . ant . Task { protected Perl5Util util = null ; protected String shell ; protected String P4Port = "" ; protected String P4Client = "" ; protected String P4User = "" ; protected String P4View = "" ; protected boolean failOnError = true ; protected String P4Opts = "" ; protected String P4CmdOpts = "" ; private boolean inError = false ; private String errorMessage = "" ; public boolean getInError ( ) { return inError ; } public void setInError ( boolean inError ) { this . inError = inError ; } public String getErrorMessage ( ) { return errorMessage ; } public void setErrorMessage ( String errorMessage ) { this . errorMessage = errorMessage ; } public void setPort ( String p4Port ) { this . P4Port = "-p" + p4Port ; } public void setClient ( String p4Client ) { this . P4Client = "-c" + p4Client ; } public void setUser ( String p4User ) { this . P4User = "-u" + p4User ; } public void setGlobalopts ( String p4Opts ) { this . P4Opts = p4Opts ; } public void setView ( String p4View ) { this . P4View = p4View ; } public void setCmdopts ( String p4CmdOpts ) { this . P4CmdOpts = p4CmdOpts ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void init ( ) { util = new Perl5Util ( ) ; String tmpprop ; if ( ( tmpprop = getProject ( ) . getProperty ( "p4.port" ) ) != null ) { setPort ( tmpprop ) ; } if ( ( tmpprop = getProject ( ) . getProperty ( "p4.client" ) ) != null ) { setClient ( tmpprop ) ; } if ( ( tmpprop = getProject ( ) . getProperty ( "p4.user" ) ) != null ) { setUser ( tmpprop ) ; } } protected void execP4Command ( String command ) throws BuildException { execP4Command ( command , null ) ; } protected void execP4Command ( String command , P4Handler handler ) throws BuildException { try { inError = false ; errorMessage = "" ; Commandline commandline = new Commandline ( ) ; commandline . setExecutable ( "p4" ) ; if ( P4Port != null && P4Port . length ( ) != 0 ) { commandline . createArgument ( ) . setValue ( P4Port ) ; } if ( P4User != null && P4User . length ( ) != 0 ) { commandline . createArgument ( ) . setValue ( P4User ) ; } if ( P4Client != null && P4Client . length ( ) != 0 ) { commandline . createArgument ( ) . setValue ( P4Client ) ; } if ( P4Opts != null && P4Opts . length ( ) != 0 ) { commandline . createArgument ( ) . setLine ( P4Opts ) ; } commandline . createArgument ( ) . setLine ( command ) ; log ( commandline . describeCommand ( ) , Project . MSG_VERBOSE ) ; if ( handler == null ) { handler = new SimpleP4OutputHandler ( this ) ; } Execute exe = new Execute ( handler , null ) ; exe . setAntRun ( getProject ( ) ) ; exe . setCommandline ( commandline . getCommandline ( ) ) ; try { exe . execute ( ) ; if ( inError && failOnError ) { throw new BuildException ( errorMessage ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { handler . stop ( ) ; } catch ( Exception e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; } } } catch ( Exception e ) { String failMsg = "Problem exec'ing P4 command: " + e . getMessage ( ) ; if ( failOnError ) { throw new BuildException ( failMsg ) ; } else { log ( failMsg , Project . MSG_ERR ) ; } } } } 	0
package org . apache . tools . tar ; import java . io . FilterOutputStream ; import java . io . OutputStream ; import java . io . IOException ; public class TarOutputStream extends FilterOutputStream { public static final int LONGFILE_ERROR = 0 ; public static final int LONGFILE_TRUNCATE = 1 ; public static final int LONGFILE_GNU = 2 ; protected boolean debug ; protected long currSize ; protected String currName ; protected long currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; private boolean closed = false ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { if ( ! closed ) { this . finish ( ) ; this . buffer . close ( ) ; out . close ( ) ; closed = true ; } } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = entry . getSize ( ) ; } currName = entry . getName ( ) ; } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry '" + currName + "' closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes for entry '" + currName + "'" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	1
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . List ; import java . util . Stack ; import java . util . Vector ; import java . util . Iterator ; import java . util . Collection ; import java . util . Collections ; import java . util . AbstractCollection ; import java . util . NoSuchElementException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; public class Resources extends DataType implements ResourceCollection { public static final ResourceCollection NONE = new ResourceCollection ( ) { public boolean isFilesystemOnly ( ) { return true ; } public Iterator iterator ( ) { return EMPTY_ITERATOR ; } public int size ( ) { return 0 ; } } ; public static final Iterator EMPTY_ITERATOR = new Iterator ( ) { public Object next ( ) { throw new NoSuchElementException ( ) ; } public boolean hasNext ( ) { return false ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; private class MyCollection extends AbstractCollection { private int size ; MyCollection ( ) { size = 0 ; for ( Iterator rci = getNested ( ) . iterator ( ) ; rci . hasNext ( ) ; ) { size += ( ( ResourceCollection ) rci . next ( ) ) . size ( ) ; } } public int size ( ) { return size ; } public Iterator iterator ( ) { return new MyIterator ( ) ; } private class MyIterator implements Iterator { private Iterator rci = getNested ( ) . iterator ( ) ; private Iterator ri = null ; public boolean hasNext ( ) { boolean result = ri != null && ri . hasNext ( ) ; while ( ! result && rci . hasNext ( ) ) { ri = ( ( ResourceCollection ) rci . next ( ) ) . iterator ( ) ; result = ri . hasNext ( ) ; } return result ; } public Object next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } return ri . next ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } } private Vector rc ; private Collection coll ; public synchronized void add ( ResourceCollection c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } if ( rc == null ) { rc = new Vector ( ) ; } rc . add ( c ) ; FailFast . invalidate ( this ) ; coll = null ; setChecked ( false ) ; } public synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return getRef ( ) . iterator ( ) ; } validate ( ) ; return new FailFast ( this , coll . iterator ( ) ) ; } public synchronized int size ( ) { if ( isReference ( ) ) { return getRef ( ) . size ( ) ; } validate ( ) ; return coll . size ( ) ; } public boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return getRef ( ) . isFilesystemOnly ( ) ; } validate ( ) ; for ( Iterator i = getNested ( ) . iterator ( ) ; i . hasNext ( ) ; ) { if ( ( ! ( ( ResourceCollection ) i . next ( ) ) . isFilesystemOnly ( ) ) ) { return false ; } } return true ; } public synchronized String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } if ( coll == null || coll . isEmpty ( ) ) { return "" ; } StringBuffer sb = new StringBuffer ( ) ; for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { if ( sb . length ( ) > 0 ) { sb . append ( File . pathSeparatorChar ) ; } sb . append ( i . next ( ) ) ; } return sb . toString ( ) ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { for ( Iterator i = getNested ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { invokeCircularReferenceCheck ( ( DataType ) o , stk , p ) ; } } setChecked ( true ) ; } } private ResourceCollection getRef ( ) { return ( ResourceCollection ) getCheckedRef ( ResourceCollection . class , "ResourceCollection" ) ; } private synchronized void validate ( ) { dieOnCircularReference ( ) ; coll = ( coll == null ) ? new MyCollection ( ) : coll ; } private synchronized List getNested ( ) { return rc == null ? Collections . EMPTY_LIST : rc ; } } 	0
package org . apache . tools . ant . taskdefs . optional . ssh ; import java . io . File ; import java . io . IOException ; import java . io . EOFException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . FileOutputStream ; import java . io . ByteArrayOutputStream ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . Channel ; public class ScpFromMessage extends AbstractSshMessage { private static final byte LINE_FEED = 0x0a ; private static final int BUFFER_SIZE = 1024 ; private String remoteFile ; private File localFile ; private boolean isRecursive = false ; public ScpFromMessage ( Session session ) { super ( session ) ; } public ScpFromMessage ( boolean verbose , Session session ) { super ( verbose , session ) ; } public ScpFromMessage ( boolean verbose , Session session , String aRemoteFile , File aLocalFile , boolean recursive ) { super ( verbose , session ) ; this . remoteFile = aRemoteFile ; this . localFile = aLocalFile ; this . isRecursive = recursive ; } public ScpFromMessage ( Session session , String aRemoteFile , File aLocalFile , boolean recursive ) { this ( false , session , aRemoteFile , aLocalFile , recursive ) ; } public void execute ( ) throws IOException , JSchException { String command = "scp -f " ; if ( isRecursive ) { command += "-r " ; } command += remoteFile ; Channel channel = openExecChannel ( command ) ; try { OutputStream out = channel . getOutputStream ( ) ; InputStream in = channel . getInputStream ( ) ; channel . connect ( ) ; sendAck ( out ) ; startRemoteCpProtocol ( in , out , localFile ) ; } finally { if ( channel != null ) { channel . disconnect ( ) ; } } log ( "done\n" ) ; } private void startRemoteCpProtocol ( InputStream in , OutputStream out , File localFile ) throws IOException { File startFile = localFile ; while ( true ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; while ( true ) { int read = in . read ( ) ; if ( read < 0 ) { return ; } if ( ( byte ) read == LINE_FEED ) { break ; } stream . write ( read ) ; } String serverResponse = stream . toString ( "UTF-8" ) ; if ( serverResponse . charAt ( 0 ) == 'C' ) { parseAndFetchFile ( serverResponse , startFile , out , in ) ; } else if ( serverResponse . charAt ( 0 ) == 'D' ) { startFile = parseAndCreateDirectory ( serverResponse , startFile ) ; sendAck ( out ) ; } else if ( serverResponse . charAt ( 0 ) == 'E' ) { startFile = startFile . getParentFile ( ) ; sendAck ( out ) ; } else if ( serverResponse . charAt ( 0 ) == '\01' || serverResponse . charAt ( 0 ) == '\02' ) { throw new IOException ( serverResponse . substring ( 1 ) ) ; } } } private File parseAndCreateDirectory ( String serverResponse , File localFile ) { int start = serverResponse . indexOf ( " " ) ; start = serverResponse . indexOf ( " " , start + 1 ) ; String directoryName = serverResponse . substring ( start + 1 ) ; if ( localFile . isDirectory ( ) ) { File dir = new File ( localFile , directoryName ) ; dir . mkdir ( ) ; log ( "Creating: " + dir ) ; return dir ; } return null ; } private void parseAndFetchFile ( String serverResponse , File localFile , OutputStream out , InputStream in ) throws IOException { int start = 0 ; int end = serverResponse . indexOf ( " " , start + 1 ) ; start = end + 1 ; end = serverResponse . indexOf ( " " , start + 1 ) ; long filesize = Long . parseLong ( serverResponse . substring ( start , end ) ) ; String filename = serverResponse . substring ( end + 1 ) ; log ( "Receiving: " + filename + " : " + filesize ) ; File transferFile = ( localFile . isDirectory ( ) ) ? new File ( localFile , filename ) : localFile ; fetchFile ( transferFile , filesize , out , in ) ; waitForAck ( in ) ; sendAck ( out ) ; } private void fetchFile ( File localFile , long filesize , OutputStream out , InputStream in ) throws IOException { byte [ ] buf = new byte [ BUFFER_SIZE ] ; sendAck ( out ) ; FileOutputStream fos = new FileOutputStream ( localFile ) ; int length ; long totalLength = 0 ; long startTime = System . currentTimeMillis ( ) ; boolean trackProgress = getVerbose ( ) && filesize > 102400 ; long initFilesize = filesize ; int percentTransmitted = 0 ; try { while ( true ) { length = in . read ( buf , 0 , ( BUFFER_SIZE < filesize ) ? BUFFER_SIZE : ( int ) filesize ) ; if ( length < 0 ) { throw new EOFException ( "Unexpected end of stream." ) ; } fos . write ( buf , 0 , length ) ; filesize -= length ; totalLength += length ; if ( filesize == 0 ) { break ; } if ( trackProgress ) { percentTransmitted = trackProgress ( initFilesize , totalLength , percentTransmitted ) ; } } } finally { long endTime = System . currentTimeMillis ( ) ; logStats ( startTime , endTime , totalLength ) ; fos . flush ( ) ; fos . close ( ) ; } } } 	1
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import junit . framework . TestListener ; import org . apache . tools . ant . BuildException ; public interface JUnitResultFormatter extends TestListener , JUnitTaskMirror . JUnitResultFormatterMirror { void startTestSuite ( JUnitTest suite ) throws BuildException ; void endTestSuite ( JUnitTest suite ) throws BuildException ; void setOutput ( OutputStream out ) ; void setSystemOutput ( String out ) ; void setSystemError ( String err ) ; } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class Ear extends Jar { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File deploymentDescriptor ; private boolean descriptorAdded ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { setDestFile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "appxml attribute is required" , getLocation ( ) ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/application.xml" ) ) { if ( deploymentDescriptor == null || ! FILE_UTILS . fileNameEquals ( deploymentDescriptor , file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will" + " be ignored (please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath , mode ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	1
package org . apache . tools . ant . util ; import java . io . Reader ; import java . io . IOException ; public interface Tokenizer { String getToken ( Reader in ) throws IOException ; String getPostToken ( ) ; } 	0
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . rmi . Remote ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapter ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapterFactory ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; public class Rmic extends MatchingTask { public static final String ERROR_RMIC_FAILED = "Rmic failed; see the compiler error output for details." ; private File baseDir ; private String classname ; private File sourceBase ; private String stubVersion ; private Path compileClasspath ; private Path extDirs ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private String iiopOpts ; private boolean idl = false ; private String idlOpts ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; private FacadeTaskHelper facade ; public static final String ERROR_UNABLE_TO_VERIFY_CLASS = "Unable to verify class " ; public static final String ERROR_NOT_FOUND = ". It could not be found." ; public static final String ERROR_NOT_DEFINED = ". It is not defined." ; public static final String ERROR_LOADING_CAUSED_EXCEPTION = ". Loading caused Exception: " ; public static final String ERROR_NO_BASE_EXISTS = "base does not exist: " ; public static final String ERROR_NOT_A_DIR = "base is not a directory:" ; public static final String ERROR_BASE_NOT_SET = "base attribute must be set!" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public Rmic ( ) { facade = new FacadeTaskHelper ( RmicAdapterFactory . DEFAULT_COMPILER ) ; } public void setBase ( File base ) { this . baseDir = base ; } public File getBase ( ) { return this . baseDir ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setSourceBase ( File sourceBase ) { this . sourceBase = sourceBase ; } public File getSourceBase ( ) { return sourceBase ; } public void setStubVersion ( String stubVersion ) { this . stubVersion = stubVersion ; } public String getStubVersion ( ) { return stubVersion ; } public void setFiltering ( boolean filter ) { this . filtering = filter ; } public boolean getFiltering ( ) { return filtering ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference pathRef ) { createClasspath ( ) . setRefid ( pathRef ) ; } public Path getClasspath ( ) { return compileClasspath ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public boolean getVerify ( ) { return verify ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public boolean getIiop ( ) { return iiop ; } public void setIiopopts ( String iiopOpts ) { this . iiopOpts = iiopOpts ; } public String getIiopopts ( ) { return iiopOpts ; } public void setIdl ( boolean idl ) { this . idl = idl ; } public boolean getIdl ( ) { return idl ; } public void setIdlopts ( String idlOpts ) { this . idlOpts = idlOpts ; } public String getIdlopts ( ) { return idlOpts ; } public Vector getFileList ( ) { return compileList ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setExtdirs ( Path extDirs ) { if ( this . extDirs == null ) { this . extDirs = extDirs ; } else { this . extDirs . append ( extDirs ) ; } } public Path createExtdirs ( ) { if ( extDirs == null ) { extDirs = new Path ( getProject ( ) ) ; } return extDirs . createPath ( ) ; } public Path getExtdirs ( ) { return extDirs ; } public Vector getCompileList ( ) { return compileList ; } public void setCompiler ( String compiler ) { if ( compiler . length ( ) > 0 ) { facade . setImplementation ( compiler ) ; } } public String getCompiler ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.rmic" ) ) ; return facade . getImplementation ( ) ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { getCompiler ( ) ; return facade . getArgs ( ) ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( ERROR_BASE_NOT_SET , getLocation ( ) ) ; } if ( ! baseDir . exists ( ) ) { throw new BuildException ( ERROR_NO_BASE_EXISTS + baseDir , getLocation ( ) ) ; } if ( ! baseDir . isDirectory ( ) ) { throw new BuildException ( ERROR_NOT_A_DIR + baseDir , getLocation ( ) ) ; } if ( verify ) { log ( "Verify has been turned on." , Project . MSG_VERBOSE ) ; } RmicAdapter adapter = RmicAdapterFactory . getRmic ( getCompiler ( ) , this ) ; adapter . setRmic ( this ) ; Path classpath = adapter . getClasspath ( ) ; loader = getProject ( ) . createClassLoader ( classpath ) ; try { if ( classname == null ) { DirectoryScanner ds = this . getDirectoryScanner ( baseDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( baseDir , files , adapter . getMapper ( ) ) ; } else { scanDir ( baseDir , new String [ ] { classname . replace ( '.' , File . separatorChar ) + ".class" } , adapter . getMapper ( ) ) ; } int fileCount = compileList . size ( ) ; if ( fileCount > 0 ) { log ( "RMI Compiling " + fileCount + " class" + ( fileCount > 1 ? "es" : "" ) + " to " + baseDir , Project . MSG_INFO ) ; if ( ! adapter . execute ( ) ) { throw new BuildException ( ERROR_RMIC_FAILED , getLocation ( ) ) ; } } if ( null != sourceBase && ! baseDir . equals ( sourceBase ) && fileCount > 0 ) { if ( idl ) { log ( "Cannot determine sourcefiles in idl mode, " , Project . MSG_WARN ) ; log ( "sourcebase attribute will be ignored." , Project . MSG_WARN ) ; } else { for ( int j = 0 ; j < fileCount ; j ++ ) { moveGeneratedFile ( baseDir , sourceBase , ( String ) compileList . elementAt ( j ) , adapter ) ; } } } } finally { compileList . removeAllElements ( ) ; } } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws BuildException { String classFileName = classname . replace ( '.' , File . separatorChar ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < generatedFiles . length ; i ++ ) { final String generatedFile = generatedFiles [ i ] ; if ( ! generatedFile . endsWith ( ".class" ) ) { continue ; } final int pos = generatedFile . length ( ) - ".class" . length ( ) ; String sourceFileName = generatedFile . substring ( 0 , pos ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; if ( ! oldFile . exists ( ) ) { continue ; } File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { if ( filtering ) { FILE_UTILS . copyFile ( oldFile , newFile , new FilterSetCollection ( getProject ( ) . getGlobalFilterSet ( ) ) ) ; } else { FILE_UTILS . copyFile ( oldFile , newFile ) ; } oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldFile + " to " + newFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } protected void scanDir ( File baseDir , String [ ] files , FileNameMapper mapper ) { String [ ] newFiles = files ; if ( idl ) { log ( "will leave uptodate test to rmic implementation in idl mode." , Project . MSG_VERBOSE ) ; } else if ( iiop && iiopOpts != null && iiopOpts . indexOf ( "-always" ) > - 1 ) { log ( "no uptodate test as -always option has been specified" , Project . MSG_VERBOSE ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; newFiles = sfs . restrict ( files , baseDir , baseDir , mapper ) ; } for ( int i = 0 ; i < newFiles . length ; i ++ ) { String name = newFiles [ i ] . replace ( File . separatorChar , '.' ) ; name = name . substring ( 0 , name . lastIndexOf ( ".class" ) ) ; compileList . addElement ( name ) ; } } public boolean isValidRmiRemote ( String classname ) { try { Class testClass = loader . loadClass ( classname ) ; if ( testClass . isInterface ( ) && ! iiop && ! idl ) { return false ; } return isValidRmiRemote ( testClass ) ; } catch ( ClassNotFoundException e ) { log ( ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_NOT_FOUND , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { log ( ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_NOT_DEFINED , Project . MSG_WARN ) ; } catch ( Throwable t ) { log ( ERROR_UNABLE_TO_VERIFY_CLASS + classname + ERROR_LOADING_CAUSED_EXCEPTION + t . getMessage ( ) , Project . MSG_WARN ) ; } return false ; } public Class getRemoteInterface ( Class testClass ) { if ( Remote . class . isAssignableFrom ( testClass ) ) { Class [ ] interfaces = testClass . getInterfaces ( ) ; if ( interfaces != null ) { for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( Remote . class . isAssignableFrom ( interfaces [ i ] ) ) { return interfaces [ i ] ; } } } } return null ; } private boolean isValidRmiRemote ( Class testClass ) { return getRemoteInterface ( testClass ) != null ; } public ClassLoader getLoader ( ) { return loader ; } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	1
package org . apache . tools . ant . input ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class DefaultInputHandler implements InputHandler { public DefaultInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { String prompt = getPrompt ( request ) ; BufferedReader r = null ; try { r = new BufferedReader ( new InputStreamReader ( getInputStream ( ) ) ) ; do { System . err . println ( prompt ) ; System . err . flush ( ) ; try { String input = r . readLine ( ) ; request . setInput ( input ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to read input from" + " Console." , e ) ; } } while ( ! request . isInputValid ( ) ) ; } finally { if ( r != null ) { try { r . close ( ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to close input." , e ) ; } } } } protected String getPrompt ( InputRequest request ) { String prompt = request . getPrompt ( ) ; String def = request . getDefaultValue ( ) ; if ( request instanceof MultipleChoiceInputRequest ) { StringBuffer sb = new StringBuffer ( prompt ) ; sb . append ( " (" ) ; Enumeration e = ( ( MultipleChoiceInputRequest ) request ) . getChoices ( ) . elements ( ) ; boolean first = true ; while ( e . hasMoreElements ( ) ) { if ( ! first ) { sb . append ( ", " ) ; } String next = ( String ) e . nextElement ( ) ; if ( next . equals ( def ) ) { sb . append ( '[' ) ; } sb . append ( next ) ; if ( next . equals ( def ) ) { sb . append ( ']' ) ; } first = false ; } sb . append ( ")" ) ; return sb . toString ( ) ; } else if ( def != null ) { return prompt + " [" + def + "]" ; } else { return prompt ; } } protected InputStream getInputStream ( ) { return System . in ; } } 	0
package org . apache . tools . ant . util ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; public class RegexpPatternMapper implements FileNameMapper { protected RegexpMatcher reg = null ; protected char [ ] to = null ; protected StringBuffer result = new StringBuffer ( ) ; public RegexpPatternMapper ( ) throws BuildException { reg = ( new RegexpMatcherFactory ( ) ) . newRegexpMatcher ( ) ; } private boolean handleDirSep = false ; private int regexpOptions = 0 ; public void setHandleDirSep ( boolean handleDirSep ) { this . handleDirSep = handleDirSep ; } public void setCaseSensitive ( boolean caseSensitive ) { if ( ! caseSensitive ) { regexpOptions = RegexpMatcher . MATCH_CASE_INSENSITIVE ; } else { regexpOptions = 0 ; } } public void setFrom ( String from ) throws BuildException { try { reg . setPattern ( from ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Cannot load regular expression matcher" , e ) ; } } public void setTo ( String to ) { this . to = to . toCharArray ( ) ; } public String [ ] mapFileName ( String sourceFileName ) { if ( handleDirSep ) { if ( sourceFileName . indexOf ( "\\" ) != - 1 ) { sourceFileName = sourceFileName . replace ( '\\' , '/' ) ; } } if ( reg == null || to == null || ! reg . matches ( sourceFileName , regexpOptions ) ) { return null ; } return new String [ ] { replaceReferences ( sourceFileName ) } ; } protected String replaceReferences ( String source ) { Vector v = reg . getGroups ( source , regexpOptions ) ; result . setLength ( 0 ) ; for ( int i = 0 ; i < to . length ; i ++ ) { if ( to [ i ] == '\\' ) { if ( ++ i < to . length ) { int value = Character . digit ( to [ i ] , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( to [ i ] ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( to [ i ] ) ; } } return result . substring ( 0 ) ; } } 	1
package org . apache . tools . ant . taskdefs . optional . ccm ; public class CCMCheckinDefault extends CCMCheck { public CCMCheckinDefault ( ) { super ( ) ; setCcmAction ( COMMAND_CHECKIN ) ; setTask ( DEFAULT_TASK ) ; } public static final String DEFAULT_TASK = "default" ; } 	0
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public interface Condition { boolean eval ( ) throws BuildException ; } 	0
package org . apache . tools . ant . taskdefs . optional . unix ; import org . apache . tools . ant . BuildException ; public class Chgrp extends AbstractAccessTask { private boolean haveGroup = false ; public Chgrp ( ) { super . setExecutable ( "chgrp" ) ; } public void setGroup ( String group ) { createArg ( ) . setValue ( group ) ; haveGroup = true ; } protected void checkConfiguration ( ) { if ( ! haveGroup ) { throw new BuildException ( "Required attribute group not set in " + "chgrp" , getLocation ( ) ) ; } super . checkConfiguration ( ) ; } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable" + " attribute" , getLocation ( ) ) ; } } 	0
package org . apache . tools . ant . taskdefs ; public interface XSLTLiaison2 extends XSLTLiaison { void configure ( XSLTProcess xsltTask ) ; } 	0
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . types . Resource ; public interface XSLTLiaison3 extends XSLTLiaison2 { void setStylesheet ( Resource stylesheet ) throws Exception ; } 	0
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; public interface RmicAdapter { void setRmic ( Rmic attributes ) ; boolean execute ( ) throws BuildException ; FileNameMapper getMapper ( ) ; Path getClasspath ( ) ; } 	0
package org . apache . tools . ant . util . java15 ; import org . apache . tools . ant . BuildException ; import java . net . ProxySelector ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . Proxy ; import java . net . SocketAddress ; import java . net . InetSocketAddress ; import java . net . InetAddress ; import java . util . List ; import java . util . Iterator ; public class ProxyDiagnostics { private String destination ; private URI destURI ; public static final String DEFAULT_DESTINATION = "http://ant.apache.org/" ; public ProxyDiagnostics ( String destination ) { this . destination = destination ; try { this . destURI = new URI ( destination ) ; } catch ( URISyntaxException e ) { throw new BuildException ( e ) ; } } public ProxyDiagnostics ( ) { this ( DEFAULT_DESTINATION ) ; } public String toString ( ) { ProxySelector selector = ProxySelector . getDefault ( ) ; List list = selector . select ( destURI ) ; StringBuffer result = new StringBuffer ( ) ; Iterator proxies = list . listIterator ( ) ; while ( proxies . hasNext ( ) ) { Proxy proxy = ( Proxy ) proxies . next ( ) ; SocketAddress address = proxy . address ( ) ; if ( address == null ) { result . append ( "Direct connection\n" ) ; } else { result . append ( proxy . toString ( ) ) ; if ( address instanceof InetSocketAddress ) { InetSocketAddress ina = ( InetSocketAddress ) address ; result . append ( ' ' ) ; result . append ( ina . getHostName ( ) ) ; result . append ( ':' ) ; result . append ( ina . getPort ( ) ) ; if ( ina . isUnresolved ( ) ) { result . append ( " [unresolved]" ) ; } else { InetAddress addr = ina . getAddress ( ) ; result . append ( " [" ) ; result . append ( addr . getHostAddress ( ) ) ; result . append ( ']' ) ; } } result . append ( '\n' ) ; } } return result . toString ( ) ; } } 	0
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import java . util . Enumeration ; public class Xor extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; boolean state = false ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; state ^= c . eval ( ) ; } return state ; } } 	0
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0
package org . apache . tools . ant . filters . util ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . ConstantValue ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . JavaClass ; public final class JavaClassHelper { private static final String LS = System . getProperty ( "line.separator" ) ; public static StringBuffer getConstants ( byte [ ] bytes ) throws IOException { final StringBuffer sb = new StringBuffer ( ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bytes ) ; final ClassParser parser = new ClassParser ( bis , "" ) ; final JavaClass javaClass = parser . parse ( ) ; final Field [ ] fields = javaClass . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { final Field field = fields [ i ] ; if ( field != null ) { final ConstantValue cv = field . getConstantValue ( ) ; if ( cv != null ) { String cvs = cv . toString ( ) ; if ( cvs . startsWith ( "\"" ) && cvs . endsWith ( "\"" ) ) { cvs = cvs . substring ( 1 , cvs . length ( ) - 1 ) ; } sb . append ( field . getName ( ) ) ; sb . append ( '=' ) ; sb . append ( cvs ) ; sb . append ( LS ) ; } } } return sb ; } } 	0
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FilenameFilter ; public class InnerClassFilenameFilter implements FilenameFilter { private String baseClassName ; InnerClassFilenameFilter ( String baseclass ) { int extidx = baseclass . lastIndexOf ( ".class" ) ; if ( extidx == - 1 ) { extidx = baseclass . length ( ) - 1 ; } baseClassName = baseclass . substring ( 0 , extidx ) ; } public boolean accept ( File dir , String filename ) { if ( ( filename . lastIndexOf ( "." ) != filename . lastIndexOf ( ".class" ) ) || ( filename . indexOf ( baseClassName + "$" ) != 0 ) ) { return false ; } return true ; } } 	0
package org . apache . tools . ant . types . resources . selectors ; import java . util . Stack ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Quantifier ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; import org . apache . tools . ant . types . resources . comparators . DelegatedResourceComparator ; public class Compare extends DataType implements ResourceSelector { private static final String ONE_CONTROL_MESSAGE = " the <control> element should be specified exactly once." ; private DelegatedResourceComparator comp = new DelegatedResourceComparator ( ) ; private Quantifier against = Quantifier . ALL ; private Comparison when = Comparison . EQUAL ; private Union control ; public synchronized void add ( ResourceComparator c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } comp . add ( c ) ; } public synchronized void setAgainst ( Quantifier against ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . against = against ; } public synchronized void setWhen ( Comparison when ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . when = when ; } public synchronized ResourceCollection createControl ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( control != null ) { throw oneControl ( ) ; } control = new Union ( ) ; return control ; } public synchronized boolean isSelected ( Resource r ) { if ( isReference ( ) ) { return ( ( ResourceSelector ) getCheckedRef ( ) ) . isSelected ( r ) ; } if ( control == null ) { throw oneControl ( ) ; } int t = 0 , f = 0 ; for ( Iterator it = control . iterator ( ) ; it . hasNext ( ) ; ) { if ( when . evaluate ( comp . compare ( r , ( Resource ) it . next ( ) ) ) ) { t ++ ; } else { f ++ ; } } return against . evaluate ( t , f ) ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( control != null ) { DataType . invokeCircularReferenceCheck ( control , stk , p ) ; } DataType . invokeCircularReferenceCheck ( comp , stk , p ) ; setChecked ( true ) ; } } private BuildException oneControl ( ) { return new BuildException ( super . toString ( ) + ONE_CONTROL_MESSAGE ) ; } } 	0
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class FloatCPInfo extends ConstantCPInfo { public FloatCPInfo ( ) { super ( CONSTANT_FLOAT , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Float ( cpStream . readFloat ( ) ) ) ; } public String toString ( ) { return "Float Constant Pool Entry: " + getValue ( ) ; } } 	0
package org . apache . tools . ant . util ; public interface FileNameMapper { void setFrom ( String from ) ; void setTo ( String to ) ; String [ ] mapFileName ( String sourceFileName ) ; } 	0
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class P4Counter extends P4Base { public String counter = null ; public String property = null ; public boolean shouldSetValue = false ; public boolean shouldSetProperty = false ; public int value = 0 ; public void setName ( String counter ) { this . counter = counter ; } public void setValue ( int value ) { this . value = value ; shouldSetValue = true ; } public void setProperty ( String property ) { this . property = property ; shouldSetProperty = true ; } public void execute ( ) throws BuildException { if ( ( counter == null ) || counter . length ( ) == 0 ) { throw new BuildException ( "No counter specified to retrieve" ) ; } if ( shouldSetValue && shouldSetProperty ) { throw new BuildException ( "Cannot both set the value of the property and retrieve the " + "value of the property." ) ; } String command = "counter " + P4CmdOpts + " " + counter ; if ( ! shouldSetProperty ) { command = "-s " + command ; } if ( shouldSetValue ) { command += " " + value ; } if ( shouldSetProperty ) { final Project myProj = getProject ( ) ; P4Handler handler = new P4HandlerAdapter ( ) { public void process ( String line ) { log ( "P4Counter retrieved line \"" + line + "\"" , Project . MSG_VERBOSE ) ; try { value = Integer . parseInt ( line ) ; myProj . setProperty ( property , "" + value ) ; } catch ( NumberFormatException nfe ) { throw new BuildException ( "Perforce error. " + "Could not retrieve counter value." ) ; } } } ; execP4Command ( command , handler ) ; } else { execP4Command ( command , new SimpleP4OutputHandler ( this ) ) ; } } } 	0
package org . apache . tools . ant . types . resources ; import java . io . IOException ; public class ImmutableResourceException extends IOException { public ImmutableResourceException ( ) { super ( ) ; } public ImmutableResourceException ( String s ) { super ( s ) ; } } 	0
