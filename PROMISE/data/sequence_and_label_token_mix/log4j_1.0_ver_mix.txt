package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class ISO8601DateFormat extends AbsoluteTimeDateFormat { public ISO8601DateFormat ( ) { } public ISO8601DateFormat ( TimeZone timeZone ) { super ( timeZone ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; String month ; switch ( calendar . get ( Calendar . MONTH ) ) { case Calendar . JANUARY : month = "-01-" ; break ; case Calendar . FEBRUARY : month = "-02-" ; break ; case Calendar . MARCH : month = "-03-" ; break ; case Calendar . APRIL : month = "-04-" ; break ; case Calendar . MAY : month = "-05-" ; break ; case Calendar . JUNE : month = "-06-" ; break ; case Calendar . JULY : month = "-07-" ; break ; case Calendar . AUGUST : month = "-08-" ; break ; case Calendar . SEPTEMBER : month = "-09-" ; break ; case Calendar . OCTOBER : month = "-10-" ; break ; case Calendar . NOVEMBER : month = "-11-" ; break ; case Calendar . DECEMBER : month = "-12-" ; break ; default : month = "-NA-" ; break ; } sbuf . append ( month ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	
package org . apache . log4j . net ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . SyslogWriter ; import org . apache . log4j . helpers . SyslogQuietWriter ; import org . apache . log4j . net . SyslogTracerPrintWriter ; public class SyslogAppender extends AppenderSkeleton { final static public int LOG_KERN = 0 ; final static public int LOG_USER = 1 << 3 ; final static public int LOG_MAIL = 2 << 3 ; final static public int LOG_DAEMON = 3 << 3 ; final static public int LOG_AUTH = 4 << 3 ; final static public int LOG_SYSLOG = 5 << 3 ; final static public int LOG_LPR = 6 << 3 ; final static public int LOG_NEWS = 7 << 3 ; final static public int LOG_UUCP = 8 << 3 ; final static public int LOG_CRON = 9 << 3 ; final static public int LOG_AUTHPRIV = 10 << 3 ; final static public int LOG_FTP = 11 << 3 ; final static public int LOG_LOCAL0 = 16 << 3 ; final static public int LOG_LOCAL1 = 17 << 3 ; final static public int LOG_LOCAL2 = 18 << 3 ; final static public int LOG_LOCAL3 = 19 << 3 ; final static public int LOG_LOCAL4 = 20 << 3 ; final static public int LOG_LOCAL5 = 21 << 3 ; final static public int LOG_LOCAL6 = 22 << 3 ; final static public int LOG_LOCAL7 = 23 << 3 ; public static final String SYSLOG_HOST_OPTION = "SyslogHost" ; public static final String FACILITY_OPTION = "Facility" ; public static final String FACILITY_PRINTING_OPTION = "FacilityPrinting" ; protected static final int SYSLOG_HOST_OI = 0 ; protected static final int FACILITY_OI = 1 ; int syslogFacility = LOG_USER ; String facilityStr ; boolean facilityPrinting = false ; SyslogTracerPrintWriter stp ; SyslogQuietWriter sqw ; String syslogHost ; public SyslogAppender ( ) { this . initSyslogFacilityStr ( this . syslogFacility ) ; } public SyslogAppender ( Layout layout , int syslogFacility ) { this . layout = layout ; this . syslogFacility = syslogFacility ; this . initSyslogFacilityStr ( syslogFacility ) ; } public SyslogAppender ( Layout layout , String syslogHost , int syslogFacility ) { this ( layout , syslogFacility ) ; setSyslogHost ( syslogHost ) ; } public void close ( ) { closed = true ; sqw = null ; stp = null ; } private void initSyslogFacilityStr ( int syslogFacility ) { switch ( syslogFacility ) { case LOG_KERN : facilityStr = "kern:" ; break ; case LOG_USER : facilityStr = "user:" ; break ; case LOG_MAIL : facilityStr = "mail:" ; break ; case LOG_DAEMON : facilityStr = "daemon:" ; break ; case LOG_AUTH : facilityStr = "auth:" ; ; break ; case LOG_SYSLOG : facilityStr = "syslog:" ; break ; case LOG_LPR : facilityStr = "lpr:" ; break ; case LOG_NEWS : facilityStr = "news:" ; break ; case LOG_UUCP : facilityStr = "uucp:" ; break ; case LOG_CRON : facilityStr = "cron:" ; break ; case LOG_AUTHPRIV : facilityStr = "authpriv:" ; break ; case LOG_FTP : facilityStr = "ftp:" ; break ; case LOG_LOCAL0 : facilityStr = "local0:" ; break ; case LOG_LOCAL1 : facilityStr = "local1:" ; break ; case LOG_LOCAL2 : facilityStr = "local2:" ; break ; case LOG_LOCAL3 : facilityStr = "local3:" ; break ; case LOG_LOCAL4 : facilityStr = "local4:" ; break ; case LOG_LOCAL5 : facilityStr = "local5:" ; break ; case LOG_LOCAL6 : facilityStr = "local6:" ; break ; case LOG_LOCAL7 : facilityStr = "local7:" ; break ; default : System . err . println ( "\"" + syslogFacility + "\" is an unknown syslog facility. Defaulting to \"USER\"." ) ; this . syslogFacility = LOG_USER ; facilityStr = "user:" ; } } public void append ( LoggingEvent event ) { if ( ! isAsSevereAsThreshold ( event . priority ) ) return ; if ( sqw == null ) { errorHandler . error ( "No syslog host is set for SyslogAppedender named \"" + this . name + "\"." ) ; return ; } String buffer = ( facilityPrinting ? facilityStr : "" ) + layout . format ( event ) ; sqw . setPriority ( event . priority . getSyslogEquivalent ( ) ) ; sqw . write ( buffer ) ; if ( event . throwable != null ) event . throwable . printStackTrace ( stp ) ; else if ( event . throwableInformation != null ) { sqw . write ( event . throwableInformation ) ; } } public void activateOptions ( ) { } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { SYSLOG_HOST_OPTION , FACILITY_OPTION , FACILITY_PRINTING_OPTION } ) ; } public boolean requiresLayout ( ) { return true ; } public void setFacility ( String facilityName ) { if ( facilityName == null ) return ; if ( "KERN" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_KERN ; else if ( "USER" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_USER ; else if ( "MAIL" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_MAIL ; else if ( "DAEMON" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_DAEMON ; else if ( "AUTH" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_AUTH ; else if ( "SYSLOG" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_SYSLOG ; else if ( "LPR" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LPR ; else if ( "NEWS" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_NEWS ; else if ( "UUCP" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_UUCP ; else if ( "CRON" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_CRON ; else if ( "AUTHPRIV" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_AUTHPRIV ; else if ( "FTP" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_FTP ; else if ( "LOCAL0" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL0 ; else if ( "LOCAL1" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL1 ; else if ( "LOCAL2" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL2 ; else if ( "LOCAL3" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL3 ; else if ( "LOCAL4" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL4 ; else if ( "LOCAL5" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL5 ; else if ( "LOCAL6" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL6 ; else if ( "LOCAL7" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL7 ; else { System . err . println ( facilityName + " is an unknown syslog facility. Defaulting to \"USER\"." ) ; this . syslogFacility = LOG_USER ; } this . initSyslogFacilityStr ( this . syslogFacility ) ; if ( sqw != null ) { sqw . setSyslogFacility ( this . syslogFacility ) ; } } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( SYSLOG_HOST_OPTION ) ) this . setSyslogHost ( value ) ; else if ( option . equals ( FACILITY_PRINTING_OPTION ) ) facilityPrinting = OptionConverter . toBoolean ( value , facilityPrinting ) ; else if ( option . equals ( FACILITY_OPTION ) ) { this . setFacility ( value ) ; } } public void setSyslogHost ( String syslogHost ) { this . sqw = new SyslogQuietWriter ( new SyslogWriter ( syslogHost ) , syslogFacility , errorHandler ) ; this . stp = new SyslogTracerPrintWriter ( sqw ) ; this . syslogHost = syslogHost ; } } 	1	
package org . apache . log4j . xml ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . DateLayout ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . XMLReaderFactory ; import org . xml . sax . SAXException ; import org . apache . xerces . parsers . SAXParser ; import org . apache . trax . Processor ; import org . apache . trax . TemplatesBuilder ; import org . apache . trax . Templates ; import org . apache . trax . Transformer ; import org . apache . trax . Result ; import org . apache . trax . ProcessorException ; import org . apache . trax . ProcessorFactoryException ; import org . apache . trax . TransformException ; import org . apache . serialize . SerializerFactory ; import org . apache . serialize . Serializer ; import org . apache . serialize . OutputFormat ; import org . xml . sax . helpers . AttributesImpl ; import java . io . FileOutputStream ; import java . io . IOException ; public class Transform { public static void main ( String [ ] args ) throws Exception { PropertyConfigurator . disableAll ( ) ; PropertyConfigurator . configure ( "x.lcf" ) ; Processor processor = Processor . newInstance ( "xslt" ) ; XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; TemplatesBuilder templatesBuilder = processor . getTemplatesBuilder ( ) ; reader . setContentHandler ( templatesBuilder ) ; if ( templatesBuilder instanceof LexicalHandler ) { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , templatesBuilder ) ; } reader . parse ( args [ 0 ] ) ; Templates templates = templatesBuilder . getTemplates ( ) ; Transformer transformer = templates . newTransformer ( ) ; FileOutputStream fos = new FileOutputStream ( args [ 2 ] ) ; Result result = new Result ( fos ) ; Serializer serializer = SerializerFactory . getSerializer ( "xml" ) ; serializer . setOutputStream ( fos ) ; transformer . setContentHandler ( serializer . asContentHandler ( ) ) ; org . xml . sax . ContentHandler chandler = transformer . getInputContentHandler ( ) ; DC dc = new DC ( chandler ) ; reader . setContentHandler ( dc ) ; if ( chandler instanceof LexicalHandler ) { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , chandler ) ; } else { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , null ) ; } reader . parse ( args [ 1 ] ) ; } } class DC implements ContentHandler { static Category cat = Category . getInstance ( "DC" ) ; ContentHandler chandler ; DC ( ContentHandler chandler ) { this . chandler = chandler ; } public void characters ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { cat . debug ( "characters: [" + new String ( ch , start , length ) + "] called" ) ; chandler . characters ( ch , start , length ) ; } public void endDocument ( ) throws org . xml . sax . SAXException { cat . debug ( "endDocument called." ) ; chandler . endDocument ( ) ; } public void endElement ( String namespaceURI , String localName , String qName ) throws org . xml . sax . SAXException { cat . debug ( "endElement(" + namespaceURI + ", " + localName + ", " + qName + ") called" ) ; chandler . endElement ( namespaceURI , localName , qName ) ; } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { cat . debug ( "endPrefixMapping(" + prefix + ") called" ) ; chandler . endPrefixMapping ( prefix ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { cat . debug ( "ignorableWhitespace called" ) ; chandler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( java . lang . String target , java . lang . String data ) throws org . xml . sax . SAXException { cat . debug ( "processingInstruction called" ) ; chandler . processingInstruction ( target , data ) ; } public void setDocumentLocator ( Locator locator ) { cat . debug ( "setDocumentLocator called" ) ; chandler . setDocumentLocator ( locator ) ; } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { cat . debug ( "skippedEntity(" + name + ")  called" ) ; chandler . skippedEntity ( name ) ; } public void startDocument ( ) throws org . xml . sax . SAXException { cat . debug ( "startDocument called" ) ; chandler . startDocument ( ) ; } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws org . xml . sax . SAXException { cat . debug ( "startElement(" + namespaceURI + ", " + localName + ", " + qName + ")called" ) ; if ( "log4j:event" . equals ( qName ) ) { cat . debug ( "-------------" ) ; if ( atts instanceof org . xml . sax . helpers . AttributesImpl ) { AttributesImpl ai = ( AttributesImpl ) atts ; int i = atts . getIndex ( "timestamp" ) ; ai . setValue ( i , "hello" ) ; } String ts = atts . getValue ( "timestamp" ) ; cat . debug ( "New timestamp is " + ts ) ; } chandler . startElement ( namespaceURI , localName , qName , atts ) ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { cat . debug ( "startPrefixMapping(" + prefix + ", " + uri + ") called" ) ; chandler . startPrefixMapping ( prefix , uri ) ; } } 	0	
package org . apache . log4j . helpers ; import org . apache . log4j . spi . ErrorHandler ; public class OnlyOnceErrorHandler implements ErrorHandler { final String WARN_PREFIX = "log4j warning: " ; final String ERROR_PREFIX = "log4j error: " ; boolean firstTime = true ; public void activateOptions ( ) { } public void error ( String message , Exception e , int errorCode ) { if ( firstTime ) { LogLog . error ( message , e ) ; firstTime = false ; } } public String [ ] getOptionStrings ( ) { return null ; } public void setOption ( String key , String value ) { } public void error ( String message ) { if ( firstTime ) { LogLog . error ( message ) ; firstTime = false ; } } } 	1	
package org . apache . log4j . helpers ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Appender ; import java . util . Vector ; import java . util . Enumeration ; public class AppenderAttachableImpl implements AppenderAttachable { protected Vector appenderList ; public void addAppender ( Appender newAppender ) { if ( newAppender == null ) return ; if ( appenderList == null ) { appenderList = new Vector ( 1 ) ; } if ( ! appenderList . contains ( newAppender ) ) appenderList . addElement ( newAppender ) ; } public int appendLoopOnAppenders ( LoggingEvent event ) { int size = 0 ; Appender appender ; if ( appenderList != null ) { size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; appender . doAppend ( event ) ; } } return size ; } public Enumeration getAllAppenders ( ) { if ( appenderList == null ) return null ; else return appenderList . elements ( ) ; } public Appender getAppender ( String name ) { if ( appenderList == null || name == null ) return null ; int size = appenderList . size ( ) ; Appender appender ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; if ( name . equals ( appender . getName ( ) ) ) return appender ; } return null ; } public void removeAllAppenders ( ) { if ( appenderList != null ) { int len = appenderList . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Appender a = ( Appender ) appenderList . elementAt ( i ) ; a . close ( ) ; } appenderList . removeAllElements ( ) ; appenderList = null ; } } public void removeAppender ( Appender appender ) { if ( appender == null || appenderList == null ) return ; appenderList . removeElement ( appender ) ; } public void removeAppender ( String name ) { if ( name == null || appenderList == null ) return ; int size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( name . equals ( ( ( Appender ) appenderList . elementAt ( i ) ) . getName ( ) ) ) { appenderList . removeElementAt ( i ) ; break ; } } } } 	0	
package org . apache . log4j ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . util . Enumeration ; public class BasicConfigurator { public static final String DISABLE_OVERRIDE_KEY = "log4j.disableOverride" ; public static final String INHERITED = "inherited" ; static { String override = null ; String propertyName = DISABLE_OVERRIDE_KEY ; try { override = System . getProperty ( propertyName , override ) ; } catch ( SecurityException e ) { LogLog . debug ( "Could not read system property \"" + propertyName + "\"." , e ) ; } if ( override != null ) { if ( OptionConverter . toBoolean ( override , true ) ) { LogLog . debug ( "Overriding disable. Non-null system property " + DISABLE_OVERRIDE_KEY + "=[" + override + "]." ) ; Category . disable = Category . DISABLE_OVERRIDE ; } } } protected BasicConfigurator ( ) { } protected void addRenderer ( String renderedClassName , String renderingClassName ) { LogLog . debug ( "Rendering class: [" + renderingClassName + "], Rendered class: [" + renderedClassName + "]." ) ; ObjectRenderer renderer = ( ObjectRenderer ) OptionConverter . instantiateByClassName ( renderingClassName , ObjectRenderer . class , null ) ; if ( renderer == null ) { LogLog . error ( "Could not isntantiate renderer [" + renderingClassName + "]." ) ; return ; } else { try { Class renderedClass = Class . forName ( renderedClassName ) ; Category . defaultHierarchy . rendererMap . put ( renderedClass , renderer ) ; } catch ( ClassNotFoundException e ) { LogLog . error ( "Could not find class [" + renderedClassName + "]." , e ) ; } } } static public void configure ( ) { Category root = Category . getRoot ( ) ; root . addAppender ( new FileAppender ( new PatternLayout ( PatternLayout . TTCC_CONVERSION_PATTERN ) , System . out ) ) ; } static public void configure ( Appender appender ) { Category root = Category . getRoot ( ) ; root . addAppender ( appender ) ; } static public void disable ( Priority p ) { if ( Category . disable != Category . DISABLE_OVERRIDE ) { Category . disable = p . level ; } } static public void disableAll ( ) { disable ( Priority . FATAL ) ; } static public void disableDebug ( ) { disable ( Priority . DEBUG ) ; } static public void disableInfo ( ) { disable ( Priority . INFO ) ; } static public void enableAll ( ) { Category . disable = Category . DISABLE_OFF ; } public static void flagAsShippedCode ( ) { disableInfo ( ) ; } protected static void overrideAsNeeded ( String override ) { if ( override != null ) { LogLog . debug ( "Handling non-null disable override directive: \"" + override + "\"." ) ; if ( OptionConverter . toBoolean ( override , true ) ) { LogLog . debug ( "Overriding all disable methods." ) ; Category . disable = Category . DISABLE_OVERRIDE ; } } } public static void resetConfiguration ( ) { Category . defaultHierarchy . getRoot ( ) . setPriority ( Priority . DEBUG ) ; Category . defaultHierarchy . root . setResourceBundle ( null ) ; Category . disable = Category . DISABLE_OFF ; synchronized ( Category . defaultHierarchy . ht ) { Category . defaultHierarchy . shutdown ( ) ; Enumeration cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . setPriority ( null ) ; c . setAdditivity ( true ) ; c . setResourceBundle ( null ) ; } } Category . defaultHierarchy . rendererMap . clear ( ) ; } } 	1	
package org . apache . log4j . helpers ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . RelativeTimeDateFormat ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . helpers . DateTimeDateFormat ; import org . apache . log4j . helpers . ISO8601DateFormat ; import org . apache . log4j . spi . LoggingEvent ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import java . text . FieldPosition ; abstract public class DateLayout extends Layout { public final static String NULL_DATE_FORMAT = "NULL" ; public final static String RELATIVE_TIME_DATE_FORMAT = "RELATIVE" ; protected FieldPosition pos = new FieldPosition ( 0 ) ; final static public String DATE_FORMAT_OPTION = "DateFormat" ; final static public String TIMEZONE_OPTION = "TimeZone" ; private String timeZoneID ; private String dateFormatOption ; protected DateFormat dateFormat ; protected Date date = new Date ( ) ; public void activateOptions ( ) { setDateFormat ( dateFormatOption ) ; if ( timeZoneID != null && dateFormat != null ) { dateFormat . setTimeZone ( TimeZone . getTimeZone ( timeZoneID ) ) ; } } public String [ ] getOptionStrings ( ) { return new String [ ] { DATE_FORMAT_OPTION , TIMEZONE_OPTION } ; } public void dateFormat ( StringBuffer buf , LoggingEvent event ) { if ( dateFormat != null ) { date . setTime ( event . timeStamp ) ; dateFormat . format ( date , buf , this . pos ) ; buf . append ( ' ' ) ; } } public void setDateFormat ( DateFormat dateFormat , TimeZone timeZone ) { this . dateFormat = dateFormat ; this . dateFormat . setTimeZone ( timeZone ) ; } public void setDateFormat ( String dateFormatType ) { setDateFormat ( dateFormatType , TimeZone . getDefault ( ) ) ; } public void setDateFormat ( String dateFormatType , TimeZone timeZone ) { if ( dateFormatType == null ) { this . dateFormat = null ; return ; } if ( dateFormatType . equalsIgnoreCase ( NULL_DATE_FORMAT ) ) { this . dateFormat = null ; } else if ( dateFormatType . equalsIgnoreCase ( RELATIVE_TIME_DATE_FORMAT ) ) { this . dateFormat = new RelativeTimeDateFormat ( ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) { this . dateFormat = new AbsoluteTimeDateFormat ( timeZone ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) { this . dateFormat = new DateTimeDateFormat ( timeZone ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) { this . dateFormat = new ISO8601DateFormat ( timeZone ) ; } else { this . dateFormat = new SimpleDateFormat ( dateFormatType ) ; this . dateFormat . setTimeZone ( timeZone ) ; } } public void setOption ( String option , String value ) { if ( option . equalsIgnoreCase ( DATE_FORMAT_OPTION ) ) { dateFormatOption = value . toUpperCase ( ) ; } else if ( option . equalsIgnoreCase ( TIMEZONE_OPTION ) ) { timeZoneID = value ; } } } 	0	
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . File ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . CountingQuietWriter ; import org . apache . log4j . spi . LoggingEvent ; public class RollingFileAppender extends FileAppender { static final public String MAX_FILE_SIZE_OPTION = "MaxFileSize" ; static final public String MAX_BACKUP_INDEX_OPTION = "MaxBackupIndex" ; protected long maxFileSize = 10 * 1024 * 1024 ; protected int maxBackupIndex = 1 ; public RollingFileAppender ( ) { super ( ) ; } public RollingFileAppender ( Layout layout , OutputStream os ) { super ( layout , os ) ; } public RollingFileAppender ( Layout layout , Writer writer ) { super ( layout , writer ) ; } public RollingFileAppender ( Layout layout , String filename , boolean append ) throws IOException { super ( layout , filename , append ) ; } public RollingFileAppender ( Layout layout , String filename ) throws IOException { super ( layout , filename ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { MAX_FILE_SIZE_OPTION , MAX_BACKUP_INDEX_OPTION } ) ; } public synchronized void setFile ( String fileName , boolean append ) throws IOException { super . setFile ( fileName , append ) ; if ( append ) { File f = new File ( fileName ) ; ( ( CountingQuietWriter ) qw ) . setCount ( f . length ( ) ) ; } } public synchronized void rollOver ( ) { File target ; File file ; if ( maxBackupIndex > 0 ) { file = new File ( fileName + '.' + maxBackupIndex ) ; if ( file . exists ( ) ) file . delete ( ) ; for ( int i = maxBackupIndex - 1 ; i >= 1 ; i -- ) { file = new File ( fileName + "." + i ) ; if ( file . exists ( ) ) { target = new File ( fileName + '.' + ( i + 1 ) ) ; file . renameTo ( target ) ; } } target = new File ( fileName + "." + 1 ) ; this . closeWriterIfOurs ( ) ; file = new File ( fileName ) ; file . renameTo ( target ) ; } try { this . setFile ( fileName , false ) ; } catch ( IOException e ) { System . err . println ( "setFile(" + fileName + ", false) call failed." ) ; e . printStackTrace ( ) ; } } public void setMaxBackupIndex ( int maxBackups ) { this . maxBackupIndex = maxBackups ; } public void setMaxFileSize ( long maxFileSize ) { this . maxFileSize = maxFileSize ; } public void setOption ( String key , String value ) { super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( MAX_FILE_SIZE_OPTION ) ) { maxFileSize = OptionConverter . toFileSize ( value , maxFileSize + 1 ) ; } else if ( key . equalsIgnoreCase ( MAX_BACKUP_INDEX_OPTION ) ) { maxBackupIndex = OptionConverter . toInt ( value , maxBackupIndex ) ; } } protected void setQWForFiles ( Writer writer ) { this . qw = new CountingQuietWriter ( writer , errorHandler ) ; } protected void subAppend ( LoggingEvent event ) { super . subAppend ( event ) ; if ( ( fileName != null ) && ( ( CountingQuietWriter ) qw ) . getCount ( ) >= maxFileSize ) this . rollOver ( ) ; } } 	1	
package org . apache . log4j ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Layout implements OptionHandler { public final static String LINE_SEP = System . getProperty ( "line.separator" ) ; public final static int LINE_SEP_LEN = LINE_SEP . length ( ) ; abstract public String format ( LoggingEvent event ) ; public String getContentType ( ) { return "text/plain" ; } public String getHeader ( ) { return null ; } public String getFooter ( ) { return null ; } abstract public boolean ignoresThrowable ( ) ; } 	0	
package org . apache . log4j ; public class Priority { int level ; String levelStr ; int syslogEquivalent ; final static int FATAL_INT = 50000 ; final static int ERROR_INT = 40000 ; final static int WARN_INT = 30000 ; final static int INFO_INT = 20000 ; final static int DEBUG_INT = 10000 ; final static public Priority FATAL = new Priority ( FATAL_INT , "FATAL" , 0 ) ; final static public Priority ERROR = new Priority ( ERROR_INT , "ERROR" , 3 ) ; final static public Priority WARN = new Priority ( WARN_INT , "WARN" , 4 ) ; final static public Priority INFO = new Priority ( INFO_INT , "INFO" , 5 ) ; final static public Priority DEBUG = new Priority ( DEBUG_INT , "DEBUG" , 6 ) ; protected Priority ( int level , String levelStr , int syslogEquivalent ) { this . level = level ; this . levelStr = levelStr ; this . syslogEquivalent = syslogEquivalent ; } public final int getSyslogEquivalent ( ) { return syslogEquivalent ; } final public String toString ( ) { return levelStr ; } public final int toInt ( ) { return level ; } public boolean isGreaterOrEqual ( Priority r ) { return level >= r . level ; } public static Priority [ ] getAllPossiblePriorities ( ) { return new Priority [ ] { Priority . FATAL , Priority . ERROR , Priority . WARN , Priority . INFO , Priority . DEBUG } ; } public static Priority toPriority ( String sArg ) { return toPriority ( sArg , Priority . DEBUG ) ; } public static Priority toPriority ( int val ) { switch ( val ) { case DEBUG_INT : return DEBUG ; case INFO_INT : return INFO ; case WARN_INT : return WARN ; case ERROR_INT : return ERROR ; case FATAL_INT : return FATAL ; default : return DEBUG ; } } public static Priority toPriority ( String sArg , Priority defaultPriority ) { if ( sArg == null ) return defaultPriority ; String s = sArg . toUpperCase ( ) ; if ( s . equals ( "DEBUG" ) ) return Priority . DEBUG ; if ( s . equals ( "INFO" ) ) return Priority . INFO ; if ( s . equals ( "WARN" ) ) return Priority . WARN ; if ( s . equals ( "ERROR" ) ) return Priority . ERROR ; if ( s . equals ( "FATAL" ) ) return Priority . FATAL ; return defaultPriority ; } } 	1	
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . FileAppender ; public class DefaultInit { static Category cat = Category . getInstance ( DefaultInit . class . getName ( ) ) ; public static void main ( String [ ] argv ) { cat . debug ( "Hello world" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.DefaultInit " ) ; System . exit ( 1 ) ; } } 	0	
package org . apache . log4j . spi ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Layout ; ; public class LocationInfo implements java . io . Serializable { transient String lineNumber ; transient String fileName ; transient String className ; transient String methodName ; public String fullInfo ; private static StringWriter sw = new StringWriter ( ) ; private static PrintWriter pw = new PrintWriter ( sw ) ; public final static String NA = "?" ; static final long serialVersionUID = - 1325822038990805636L ; static boolean inVisualAge = false ; { try { Class dummy = Class . forName ( "com.ibm.uvm.tools.DebugSupport" ) ; inVisualAge = true ; LogLog . debug ( "Detected IBM VisualAge environment." ) ; } catch ( Throwable e ) { } } public LocationInfo ( Throwable t , String fqnOfCallingClass ) { if ( t == null ) return ; String s ; synchronized ( sw ) { t . printStackTrace ( pw ) ; s = sw . toString ( ) ; sw . getBuffer ( ) . setLength ( 0 ) ; } int ibegin , iend ; ibegin = s . lastIndexOf ( fqnOfCallingClass ) ; if ( ibegin == - 1 ) return ; ibegin = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( ibegin == - 1 ) return ; ibegin += Layout . LINE_SEP_LEN ; iend = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( iend == - 1 ) return ; if ( ! inVisualAge ) { ibegin = s . lastIndexOf ( "at " , iend ) ; if ( ibegin == - 1 ) return ; ibegin += 3 ; } this . fullInfo = s . substring ( ibegin , iend ) ; } public String getClassName ( ) { if ( fullInfo == null ) return NA ; if ( className == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; if ( iend == - 1 ) className = NA ; else { iend = fullInfo . lastIndexOf ( '.' , iend ) ; if ( iend == - 1 ) className = NA ; else className = this . fullInfo . substring ( 0 , iend ) ; } } return className ; } public String getFileName ( ) { if ( fullInfo == null ) return NA ; if ( fileName == null ) { int iend = fullInfo . lastIndexOf ( ':' ) ; if ( iend == - 1 ) fileName = NA ; else { int ibegin = fullInfo . lastIndexOf ( '(' , iend - 1 ) ; fileName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } } return fileName ; } public String getLineNumber ( ) { if ( fullInfo == null ) return NA ; if ( lineNumber == null ) { int iend = fullInfo . lastIndexOf ( ')' ) ; int ibegin = fullInfo . lastIndexOf ( ':' , iend - 1 ) ; if ( ibegin == - 1 ) lineNumber = NA ; else lineNumber = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return lineNumber ; } public String getMethodName ( ) { if ( fullInfo == null ) return NA ; if ( methodName == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; int ibegin = fullInfo . lastIndexOf ( '.' , iend ) ; if ( ibegin == - 1 ) methodName = NA ; else methodName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return methodName ; } } 	1	
package org . apache . log4j . performance ; import java . util . Date ; public class ConcatVsArray { static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.performance.ConcatVsArray " + "string1 string2 runLength\n" + "       where runLength is an integer." ) ; System . exit ( 1 ) ; } public static void main ( String args [ ] ) { if ( args . length != 3 ) { Usage ( ) ; } String s1 = args [ 0 ] ; String s2 = args [ 1 ] ; int runLength = 0 ; try { runLength = Integer . parseInt ( args [ 2 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } double micros ; String [ ] sa ; long before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { sa = new String [ ] { s1 , s2 } ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The anonymous array loop took around " + micros + " microseconds." ) ; String s ; before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { s = s1 + s2 ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The append loop took around " + micros + " microseconds." ) ; } } 	0	
package org . apache . log4j . helpers ; public class LogLog { public static final String CONFIG_DEBUG_KEY = "log4j.configDebug" ; protected static boolean configDebugEnabled = false ; private static final String PREFIX = "log4j: " ; private static final String ERR_PREFIX = "log4j:ERROR " ; static { try { String key = System . getProperty ( CONFIG_DEBUG_KEY ) ; if ( key != null ) configDebugEnabled = OptionConverter . toBoolean ( key , true ) ; } catch ( SecurityException e ) { System . err . println ( PREFIX + "Could not read system property \"" + CONFIG_DEBUG_KEY + "\"." ) ; } } static public void setInternalDebugging ( boolean enabled ) { configDebugEnabled = enabled ; } public static void debug ( String msg ) { if ( configDebugEnabled ) { System . out . println ( PREFIX + msg ) ; } } public static void debug ( String msg , Throwable t ) { if ( configDebugEnabled ) { System . out . println ( PREFIX + msg ) ; if ( t != null ) t . printStackTrace ( System . out ) ; } } public static void error ( String msg ) { System . err . println ( ERR_PREFIX + msg ) ; } public static void error ( String msg , Throwable t ) { System . err . println ( ERR_PREFIX + msg ) ; if ( t != null ) { t . printStackTrace ( ) ; } } } 	1	
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . DateLayout ; import org . apache . log4j . helpers . RelativeTimeDateFormat ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . helpers . DateTimeDateFormat ; import org . apache . log4j . helpers . ISO8601DateFormat ; import org . apache . log4j . spi . LoggingEvent ; public class TTCCLayout extends DateLayout { final static public String THREAD_PRINTING_OPTION = "ThreadPrinting" ; final static public String CATEGORY_PREFIXING_OPTION = "CategoryPrefixing" ; final static public String CONTEXT_PRINTING_OPTION = "ContextPrinting" ; private boolean threadPrinting = true ; private boolean categoryPrefixing = true ; private boolean contextPrinting = true ; protected final StringBuffer buf = new StringBuffer ( 256 ) ; public TTCCLayout ( ) { this . setDateFormat ( RELATIVE_TIME_DATE_FORMAT , null ) ; } public TTCCLayout ( String dateFormatType ) { this . setDateFormat ( dateFormatType ) ; } public String format ( LoggingEvent event ) { buf . setLength ( 0 ) ; dateFormat ( buf , event ) ; if ( this . threadPrinting ) { buf . append ( '[' ) ; buf . append ( event . getThreadName ( ) ) ; buf . append ( "] " ) ; } buf . append ( event . priority . toString ( ) ) ; buf . append ( ' ' ) ; if ( this . categoryPrefixing ) { buf . append ( event . categoryName ) ; buf . append ( ' ' ) ; } if ( this . contextPrinting ) { event . getNDC ( ) ; if ( event . ndc != null ) { buf . append ( event . ndc ) ; buf . append ( ' ' ) ; } } buf . append ( "- " ) ; buf . append ( event . message ) ; buf . append ( LINE_SEP ) ; return buf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { THREAD_PRINTING_OPTION , CATEGORY_PREFIXING_OPTION , CONTEXT_PRINTING_OPTION } ) ; } public boolean ignoresThrowable ( ) { return true ; } public void setOption ( String key , String value ) { super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( THREAD_PRINTING_OPTION ) ) threadPrinting = OptionConverter . toBoolean ( value , threadPrinting ) ; else if ( key . equalsIgnoreCase ( CATEGORY_PREFIXING_OPTION ) ) categoryPrefixing = OptionConverter . toBoolean ( value , categoryPrefixing ) ; else if ( key . equalsIgnoreCase ( CONTEXT_PRINTING_OPTION ) ) contextPrinting = OptionConverter . toBoolean ( value , contextPrinting ) ; } public void setCategoryPrefixing ( boolean categoryPrefixing ) { this . categoryPrefixing = categoryPrefixing ; } public void setThreadPrinting ( boolean threadPrinting ) { this . threadPrinting = threadPrinting ; } } 	0	
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import org . apache . log4j . helpers . LogLog ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . io . ObjectOutputStream ; import java . io . ObjectInputStream ; public class LoggingEvent implements java . io . Serializable { private static long startTime = System . currentTimeMillis ( ) ; transient public String fqnOfCategoryClass ; public String categoryName ; transient public Priority priority ; public String ndc ; public boolean ndcLookupRequired = true ; public String message ; public String threadName ; transient public Throwable throwable ; public String throwableInformation ; public long timeStamp ; public LocationInfo locationInfo ; static final long serialVersionUID = - 868428216207166145L ; public LoggingEvent ( String fqnOfCategoryClass , Category category , Priority priority , String message , Throwable throwable ) { this . fqnOfCategoryClass = fqnOfCategoryClass ; this . categoryName = category . getName ( ) ; this . priority = priority ; this . message = message ; this . throwable = throwable ; timeStamp = System . currentTimeMillis ( ) ; } public static long getStartTime ( ) { return startTime ; } public String getNDC ( ) { if ( ndcLookupRequired ) { ndcLookupRequired = false ; ndc = NDC . get ( ) ; } return ndc ; } public String getThreadName ( ) { if ( threadName == null ) threadName = ( Thread . currentThread ( ) ) . getName ( ) ; return threadName ; } public String getThrowableInformation ( ) { if ( throwable == null ) { return null ; } if ( throwableInformation == null ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; throwable . printStackTrace ( pw ) ; throwableInformation = sw . toString ( ) ; } return throwableInformation ; } private void writeObject ( ObjectOutputStream oos ) throws java . io . IOException { this . getThreadName ( ) ; this . getNDC ( ) ; this . getThrowableInformation ( ) ; oos . defaultWriteObject ( ) ; oos . writeInt ( priority . toInt ( ) ) ; } private void readObject ( ObjectInputStream ois ) throws java . io . IOException , ClassNotFoundException { ois . defaultReadObject ( ) ; priority = Priority . toPriority ( ois . readInt ( ) ) ; if ( locationInfo == null ) locationInfo = new LocationInfo ( null , null ) ; } public void setLocationInformation ( ) { if ( locationInfo == null ) { locationInfo = new LocationInfo ( new Throwable ( ) , fqnOfCategoryClass ) ; } } } 	1	
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; public class Hello { static Category cat = Category . getInstance ( Hello . class ) ; public static void main ( String argv [ ] ) { BasicConfigurator . configure ( ) ; cat . debug ( "Hello world." ) ; cat . info ( "What a beatiful day." ) ; } } 	0	
package org . apache . log4j . helpers ; import java . net . URL ; import java . awt . Image ; import java . awt . Toolkit ; public class Loader extends java . lang . Object { public static Image getGIF_Image ( String path ) { Image img = null ; try { URL url = ClassLoader . getSystemResource ( path ) ; System . out . println ( url ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public static Image getGIF_Image ( URL url ) { Image img = null ; try { System . out . println ( url ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public static URL getHTML_Page ( String path ) { URL url = null ; return ( url = ClassLoader . getSystemResource ( path ) ) ; } } 	1	
package org . apache . log4j . spi ; public interface OptionHandler { void activateOptions ( ) ; String [ ] getOptionStrings ( ) ; void setOption ( String option , String value ) ; } 	0	
package org . apache . log4j . xml ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . DateLayout ; public class XMLLayout extends Layout { private final int DEFAULT_SIZE = 256 ; private final int UPPER_LIMIT = 2048 ; private StringBuffer buf = new StringBuffer ( DEFAULT_SIZE ) ; private boolean locationInfo = false ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public void activateOptions ( ) { } public String format ( LoggingEvent event ) { if ( buf . capacity ( ) > UPPER_LIMIT ) { buf = new StringBuffer ( DEFAULT_SIZE ) ; } else { buf . setLength ( 0 ) ; } buf . append ( "<log4j:event category=\"" ) ; buf . append ( event . categoryName ) ; buf . append ( "\" timestamp=\"" ) ; buf . append ( event . timeStamp ) ; buf . append ( "\" priority=\"" ) ; buf . append ( event . priority ) ; buf . append ( "\" thread=\"" ) ; buf . append ( event . getThreadName ( ) ) ; buf . append ( "\">\r\n" ) ; buf . append ( "<log4j:message>" ) ; buf . append ( event . message ) ; buf . append ( "</log4j:message>\r\n" ) ; String ndc = event . getNDC ( ) ; if ( ndc != null ) { buf . append ( "<log4j:NDC>" ) ; buf . append ( ndc ) ; buf . append ( "</log4j:NDC>\r\n" ) ; } String t = event . getThrowableInformation ( ) ; if ( t != null ) { buf . append ( "<log4j:throwable>" ) ; buf . append ( t ) ; buf . append ( "</log4j:throwable>\r\n" ) ; } if ( locationInfo ) { event . setLocationInformation ( ) ; buf . append ( "<log4j:locationInfo class=\"" ) ; buf . append ( event . locationInfo . getClassName ( ) ) ; buf . append ( "\" method=\"" ) ; buf . append ( event . locationInfo . getMethodName ( ) ) ; buf . append ( "\" file=\"" ) ; buf . append ( event . locationInfo . getFileName ( ) ) ; buf . append ( "\" line=\"" ) ; buf . append ( event . locationInfo . getLineNumber ( ) ) ; buf . append ( "\"/>\r\n" ) ; } buf . append ( "</log4j:event>\r\n\r\n" ) ; return buf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return new String [ ] { LOCATION_INFO_OPTION } ; } public boolean ignoresThrowable ( ) { return false ; } public void setOption ( String key , String value ) { if ( value == null ) return ; if ( key . equals ( LOCATION_INFO_OPTION ) ) { locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } } 	1	
package org . apache . log4j . net ; import java . net . InetAddress ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . InputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; public class SocketNode implements Runnable { Socket socket ; Hierarchy hierarchy ; ObjectInputStream ois ; static Category cat = Category . getInstance ( SocketNode . class . getName ( ) ) ; public SocketNode ( Socket socket , Hierarchy hierarchy ) { this . socket = socket ; this . hierarchy = hierarchy ; try { ois = new ObjectInputStream ( socket . getInputStream ( ) ) ; } catch ( Exception e ) { cat . error ( "Could not open ObjectInputStream to " + socket , e ) ; } } public void run ( ) { LoggingEvent event ; Category remoteCategory ; try { while ( true ) { event = ( LoggingEvent ) ois . readObject ( ) ; remoteCategory = hierarchy . getInstance ( event . categoryName ) ; if ( event . priority . isGreaterOrEqual ( remoteCategory . getChainedPriority ( ) ) ) { remoteCategory . callAppenders ( event ) ; } } } catch ( java . io . EOFException e ) { cat . info ( "Caught java.io.EOFException closing conneciton." ) ; } catch ( java . net . SocketException e ) { cat . info ( "Caught java.net.SocketException closing conneciton." ) ; } catch ( Exception e ) { cat . error ( "Unexpected exception. Closing conneciton." , e ) ; } try { ois . close ( ) ; } catch ( Exception e ) { cat . info ( "Could not close connection." , e ) ; } } } 	0	
package org . apache . log4j . test ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . IOException ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . net . SocketNode ; import org . apache . log4j . net . SocketServer ; public class ShortSocketServer { static Category cat = Category . getInstance ( ShortSocketServer . class . getName ( ) ) ; static int port ; static int delay ; static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] ) ; else usage ( "Wrong number of arguments." ) ; try { LogLog . debug ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; LogLog . debug ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; LogLog . debug ( "Connected to client at " + socket . getInetAddress ( ) ) ; LogLog . debug ( "Starting new socket node." ) ; SocketNode sn = new SocketNode ( socket , Category . getDefaultHierarchy ( ) ) ; Thread t = new Thread ( sn ) ; t . start ( ) ; t . join ( ) ; } catch ( Exception e ) { cat . error ( "Error while in main." , e ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ShortSocketServer . class . getName ( ) + " port configFile delay" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile , String delayStr ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } try { delay = Integer . parseInt ( delayStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret delay number [" + delayStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; } } 	1	
package org . apache . log4j . test ; import org . apache . log4j . * ; import java . util . * ; import java . text . * ; public class L7D { static ResourceBundle [ ] bundles ; public static void main ( String args [ ] ) { if ( args . length == 3 ) init ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + L7D . class . getName ( ) + "configFile ISO639LanguageCode ISO2166CountryCode" ) ; System . exit ( 1 ) ; } static void init ( String configFile , String lanCode , String countryCode ) { PropertyConfigurator . configure ( configFile ) ; bundles = new ResourceBundle [ 3 ] ; try { bundles [ 0 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "en" , "US" ) ) ; bundles [ 1 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "FR" ) ) ; bundles [ 2 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "CH" ) ) ; } catch ( MissingResourceException e ) { e . printStackTrace ( ) ; } } static void test ( ) { Category root = Category . getRoot ( ) ; for ( int i = 0 ; i < bundles . length ; i ++ ) { root . setResourceBundle ( bundles [ i ] ) ; root . l7dlog ( Priority . DEBUG , "bogus1" , null ) ; root . l7dlog ( Priority . INFO , "test" , null ) ; root . l7dlog ( Priority . WARN , "hello_world" , null ) ; root . l7dlog ( Priority . DEBUG , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "bogusMsg" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . INFO , "bogus2" , null ) ; } } } 	0	
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . TracerPrintWriter ; public class FileAppender extends AppenderSkeleton { public static final String FILE_OPTION = "File" ; public static final String IMMEDIATE_FLUSH_OPTION = "ImmediateFlush" ; public static final String APPEND_OPTION = "Append" ; protected boolean fileAppend = true ; protected boolean immediateFlush = true ; protected QuietWriter qw ; protected TracerPrintWriter tp ; protected String fileName = null ; protected boolean qwIsOurs = false ; public FileAppender ( ) { } public FileAppender ( Layout layout , OutputStream os ) { this ( layout , new OutputStreamWriter ( os ) ) ; } public FileAppender ( Layout layout , Writer writer ) { this . layout = layout ; this . setWriter ( writer ) ; } public FileAppender ( Layout layout , String filename , boolean append ) throws IOException { this . layout = layout ; this . setFile ( filename , append ) ; } public FileAppender ( Layout layout , String filename ) throws IOException { this ( layout , filename , true ) ; } public void activateOptions ( ) { if ( fileName != null ) { try { setFile ( fileName , fileAppend ) ; } catch ( java . io . IOException e ) { errorHandler . error ( "setFile(" + fileName + "," + fileAppend + ") call failed." , e , ErrorCode . FILE_OPEN_FAILURE ) ; } } } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } subAppend ( event ) ; } protected boolean checkEntryConditions ( ) { if ( this . qw == null ) { errorHandler . error ( "No output target set for appender named \"" + name + "\"." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for appender named \"" + name + "\"." ) ; return false ; } return true ; } public void close ( ) { this . closed = true ; reset ( ) ; } protected void closeWriterIfOurs ( ) { if ( this . qwIsOurs && this . qw != null ) { try { this . qw . close ( ) ; } catch ( java . io . IOException e ) { LogLog . error ( "Could not close output stream " + qw , e ) ; } } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { FILE_OPTION , APPEND_OPTION , IMMEDIATE_FLUSH_OPTION } ) ; } public synchronized void setErrorHandler ( ErrorHandler eh ) { this . errorHandler = eh ; if ( this . qwIsOurs && this . qw != null ) { this . qw . setErrorHandler ( eh ) ; } } public synchronized void setFile ( String fileName , boolean append ) throws IOException { reset ( ) ; this . setQWForFiles ( new FileWriter ( fileName , append ) ) ; this . tp = new TracerPrintWriter ( qw ) ; this . fileName = fileName ; this . qwIsOurs = true ; } public void setFile ( String fileName ) throws IOException { this . setFile ( fileName , fileAppend ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( FILE_OPTION ) ) { value = value . trim ( ) ; if ( value . equalsIgnoreCase ( "System.out" ) ) setWriter ( new OutputStreamWriter ( System . out ) ) ; else if ( value . equalsIgnoreCase ( "System.err" ) ) setWriter ( new OutputStreamWriter ( System . err ) ) ; else { fileName = value ; } } else if ( key . equalsIgnoreCase ( APPEND_OPTION ) ) { fileAppend = OptionConverter . toBoolean ( value , fileAppend ) ; } else if ( key . equalsIgnoreCase ( IMMEDIATE_FLUSH_OPTION ) ) { immediateFlush = OptionConverter . toBoolean ( value , immediateFlush ) ; } } public synchronized void setWriter ( Writer writer ) { reset ( ) ; this . qw = new QuietWriter ( writer , errorHandler ) ; this . tp = new TracerPrintWriter ( qw ) ; this . qwIsOurs = false ; } protected void setQWForFiles ( Writer writer ) { this . qw = new QuietWriter ( writer , errorHandler ) ; } protected void subAppend ( LoggingEvent event ) { this . qw . write ( this . layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { if ( event . throwable != null ) { event . throwable . printStackTrace ( this . tp ) ; } else if ( event . throwableInformation != null ) { this . qw . write ( event . throwableInformation ) ; } } if ( this . immediateFlush ) { this . qw . flush ( ) ; } } public boolean requiresLayout ( ) { return true ; } protected void reset ( ) { closeWriterIfOurs ( ) ; this . fileName = null ; this . qw = null ; this . tp = null ; } } 	1	
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Appender ; import java . util . Enumeration ; import java . util . Vector ; public class MultipleAppenders { public static void main ( String argv [ ] ) { PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; Enumeration e1 = root . getAllAppenders ( ) ; Vector v = new Vector ( 1 ) ; while ( e1 . hasMoreElements ( ) ) { Appender a = ( Appender ) e1 . nextElement ( ) ; v . addElement ( a ) ; String appenderName = a . getName ( ) ; if ( a != root . getAppender ( appenderName ) ) { System . out . println ( appenderName + " lookup failed. Exiting." ) ; System . exit ( 1 ) ; } root . addAppender ( a ) ; } root . addAppender ( null ) ; Enumeration e2 = root . getAllAppenders ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . elementAt ( i ) != e2 . nextElement ( ) ) { } } if ( e2 . hasMoreElements ( ) ) { System . out . println ( "Failure, e2 has remaining elements. Exiting." ) ; System . exit ( 1 ) ; } System . out . println ( "OK" ) ; } } 	0	
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . io . Writer ; public class HTMLLayout extends Layout { protected final int BUF_SIZE = 256 ; protected final int MAX_CAPACITY = 1024 ; private StringBuffer sbuf = new StringBuffer ( BUF_SIZE ) ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; boolean locationInfo = false ; public void activateOptions ( ) { } public String format ( LoggingEvent event ) { if ( sbuf . capacity ( ) > MAX_CAPACITY ) { sbuf = new StringBuffer ( BUF_SIZE ) ; } else { sbuf . setLength ( 0 ) ; } sbuf . append ( "\r\n\r\n<tr>" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . timeStamp - event . getStartTime ( ) ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . getThreadName ( ) ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; if ( event . priority . isGreaterOrEqual ( Priority . WARN ) ) { sbuf . append ( "<font color=\"#FF0000\">" ) ; sbuf . append ( event . priority ) ; sbuf . append ( "</font>" ) ; } else { sbuf . append ( event . priority ) ; } sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . categoryName ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . getNDC ( ) ) ; sbuf . append ( "</td>\r\n" ) ; if ( locationInfo ) { event . setLocationInformation ( ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . locationInfo . getFileName ( ) ) ; sbuf . append ( ':' ) ; sbuf . append ( event . locationInfo . getLineNumber ( ) ) ; sbuf . append ( "</td>\r\n" ) ; } sbuf . append ( "<td>" ) ; sbuf . append ( event . message ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "</tr>" ) ; if ( event . throwable != null ) { sbuf . append ( "\r\n<tr><td colspan=\"7\">" ) ; sbuf . append ( getThrowableAsHTML ( event . throwable ) ) ; sbuf . append ( "</td></tr>" ) ; } return sbuf . toString ( ) ; } public String getContentType ( ) { return "text/html" ; } public String getHeader ( ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( "<html><body>\r\n" ) ; sbuf . append ( "<table border=\"1\" cellpadding=\"2\">\r\n<tr>\r\n" ) ; sbuf . append ( "<th>Time</th><th>Thread</th><th>Priority</th><th>Category</th>" ) ; sbuf . append ( "<th>NDC</th>" ) ; if ( locationInfo ) { sbuf . append ( "<th>File:Line</th>" ) ; } sbuf . append ( "<th>Message</th></tr>" ) ; return sbuf . toString ( ) ; } public String getFooter ( ) { return "</table></body></html>" ; } public String [ ] getOptionStrings ( ) { return new String [ ] { LOCATION_INFO_OPTION } ; } String getThrowableAsHTML ( Throwable throwable ) { if ( throwable == null ) return null ; StringWriter sw = new StringWriter ( ) ; HTMLPrintWriter hpw = new HTMLPrintWriter ( sw ) ; throwable . printStackTrace ( hpw ) ; return sw . toString ( ) ; } public boolean ignoresThrowable ( ) { return false ; } public void setOption ( String key , String value ) { if ( value == null ) return ; if ( key . equals ( LOCATION_INFO_OPTION ) ) { locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } static class HTMLPrintWriter extends PrintWriter { static String TRACE_PREFIX = "<br>&nbsp;&nbsp;&nbsp;&nbsp;" ; public HTMLPrintWriter ( Writer writer ) { super ( writer ) ; } public void println ( char [ ] c ) { write ( TRACE_PREFIX ) ; this . write ( c ) ; } public void println ( String s ) { write ( TRACE_PREFIX ) ; this . write ( s ) ; } } } 	1	
package org . apache . log4j . helpers ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class NullEnumeration implements Enumeration { private static final NullEnumeration instance = new NullEnumeration ( ) ; private NullEnumeration ( ) { } public static NullEnumeration getInstance ( ) { return instance ; } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) { throw new NoSuchElementException ( ) ; } } 	0	
package org . apache . log4j ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . LoggingEvent ; public interface Appender { void addFilter ( Filter newFilter ) ; public void clearFilters ( ) ; public void close ( ) ; public void doAppend ( LoggingEvent event ) ; public String getName ( ) ; public void setErrorHandler ( ErrorHandler errorHandler ) ; public void setLayout ( Layout layout ) ; public void setName ( String name ) ; public boolean requiresLayout ( ) ; } 	1	
package org . apache . log4j ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OnlyOnceErrorHandler ; import org . apache . log4j . helpers . LogLog ; public abstract class AppenderSkeleton implements Appender , OptionHandler { protected Layout layout ; protected String name ; protected Priority threshold ; protected ErrorHandler errorHandler = new OnlyOnceErrorHandler ( ) ; protected Filter headFilter ; protected Filter tailFilter ; protected boolean closed = false ; public static final String THRESHOLD_OPTION = "Threshold" ; public void activateOptions ( ) { } public void addFilter ( Filter newFilter ) { if ( headFilter == null ) { headFilter = tailFilter = newFilter ; } else { tailFilter . next = newFilter ; tailFilter = newFilter ; } } abstract protected void append ( LoggingEvent event ) ; public void clearFilters ( ) { headFilter = tailFilter = null ; } public void finalize ( ) { if ( this . closed ) return ; LogLog . debug ( "Finalizing appender named [" + name + "]." ) ; close ( ) ; } public ErrorHandler getErrorHandler ( ) { return this . errorHandler ; } public final Filter getFirstFilter ( ) { return headFilter ; } public final String getName ( ) { return this . name ; } public String [ ] getOptionStrings ( ) { return new String [ ] { THRESHOLD_OPTION } ; } public boolean isAsSevereAsThreshold ( Priority priority ) { return ( ( threshold == null ) || priority . isGreaterOrEqual ( threshold ) ) ; } public synchronized void doAppend ( LoggingEvent event ) { if ( closed ) { LogLog . error ( "Attempted to append to closed appender named [" + name + "]." ) ; } if ( ! isAsSevereAsThreshold ( event . priority ) ) { return ; } Filter f = this . headFilter ; FILTER_LOOP : while ( f != null ) { switch ( f . decide ( event ) ) { case Filter . DENY : return ; case Filter . ACCEPT : break FILTER_LOOP ; case Filter . NEUTRAL : f = f . next ; } } this . append ( event ) ; } public void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { LogLog . error ( "It is forbidden to set a null ErrorHandler. Ignoring directive." ) ; } else { this . errorHandler = eh ; } } public void setLayout ( Layout layout ) { this . layout = layout ; } public void setName ( String name ) { this . name = name ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( THRESHOLD_OPTION ) ) { threshold = Priority . toPriority ( value ) ; } } public void setThreshold ( Priority threshold ) { this . threshold = threshold ; } } 	0	
package org . apache . log4j . nt ; import org . apache . log4j . * ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Priority ; import java . io . * ; public class NTEventLogAppender extends AppenderSkeleton { private int _handle = 0 ; private static final int FATAL = Priority . FATAL . toInt ( ) ; private static final int ERROR = Priority . ERROR . toInt ( ) ; private static final int WARN = Priority . WARN . toInt ( ) ; private static final int INFO = Priority . INFO . toInt ( ) ; private static final int DEBUG = Priority . DEBUG . toInt ( ) ; public NTEventLogAppender ( ) { this ( null , null , null ) ; } public NTEventLogAppender ( String source ) { this ( null , source , null ) ; } public NTEventLogAppender ( String server , String source ) { this ( server , source , null ) ; } public NTEventLogAppender ( Layout layout ) { this ( null , null , layout ) ; } public NTEventLogAppender ( String source , Layout layout ) { this ( null , source , layout ) ; } public NTEventLogAppender ( String server , String source , Layout layout ) { if ( source == null ) { source = "Log4j" ; } if ( layout == null ) { this . layout = new TTCCLayout ( ) ; } else { this . layout = layout ; } try { _handle = registerEventSource ( server , source ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; _handle = 0 ; } } public void close ( ) { } public void append ( LoggingEvent event ) { StringWriter sw_writer = new StringWriter ( ) ; PrintWriter pw_writer = new PrintWriter ( sw_writer ) ; pw_writer . print ( layout . format ( event ) ) ; if ( event . throwable != null ) event . throwable . printStackTrace ( pw_writer ) ; pw_writer . close ( ) ; int nt_category = event . priority . toInt ( ) ; if ( nt_category < FATAL || nt_category > DEBUG ) { nt_category = INFO ; } reportEvent ( _handle , sw_writer . toString ( ) , nt_category ) ; } public void finalize ( ) { deregisterEventSource ( _handle ) ; _handle = 0 ; } public boolean requiresLayout ( ) { return true ; } native private int registerEventSource ( String server , String source ) ; native private void reportEvent ( int handle , String message , int priority ) ; native private void deregisterEventSource ( int handle ) ; static { System . loadLibrary ( "NTEventLogAppender" ) ; } } 	1	
package org . apache . log4j . nt . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . nt . NTEventLogAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class NTMin { static Category cat = Category . getInstance ( NTMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { init ( ) ; test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + NTMin . class + "" ) ; System . exit ( 1 ) ; } static void init ( ) { BasicConfigurator . configure ( new NTEventLogAppender ( ) ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . CyclicBuffer ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . TriggeringEventEvaluator ; import java . util . Properties ; import java . util . Date ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . internet . MimeMessage ; import javax . mail . Multipart ; import javax . mail . internet . MimeMultipart ; import javax . mail . internet . MimeBodyPart ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . AddressException ; import javax . mail . internet . MimeUtility ; public class SMTPAppender extends AppenderSkeleton { public static final String TO_OPTION = "To" ; public static final String FROM_OPTION = "From" ; public static final String SUBJECT_OPTION = "Subject" ; public static final String SMTP_HOST_OPTION = "SMTPHost" ; public static final String BUFFER_SIZE_OPTION = "BufferSize" ; public static final String EVALUATOR_CLASS_OPTION = "EvaluatorClass" ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; String to ; String from ; String subject ; String smtpHost ; int bufferSize = 512 ; CyclicBuffer cb = new CyclicBuffer ( bufferSize ) ; Session session ; Message msg ; boolean locationInfo = false ; TriggeringEventEvaluator evaluator ; public SMTPAppender ( ) { this ( new DefaultEvaluator ( ) ) ; } public SMTPAppender ( TriggeringEventEvaluator evaluator ) { this . evaluator = evaluator ; } public void activateOptions ( ) { Properties props = System . getProperties ( ) ; if ( smtpHost != null ) props . put ( "mail.smtp.host" , smtpHost ) ; session = Session . getDefaultInstance ( props , null ) ; msg = new MimeMessage ( session ) ; try { if ( from != null ) msg . setFrom ( getAddress ( from ) ) ; else msg . setFrom ( ) ; msg . setRecipients ( Message . RecipientType . TO , parseAddress ( to ) ) ; if ( subject != null ) msg . setSubject ( subject ) ; } catch ( MessagingException e ) { LogLog . error ( "Could not activate SMTPAppender options." , e ) ; } } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } event . getThreadName ( ) ; event . getNDC ( ) ; if ( locationInfo ) { event . setLocationInformation ( ) ; } cb . add ( event ) ; if ( evaluator . isTriggeringEvent ( event ) ) { sendBuffer ( ) ; } } protected boolean checkEntryConditions ( ) { if ( this . msg == null ) { errorHandler . error ( "Message object not configured." ) ; return false ; } if ( this . evaluator == null ) { errorHandler . error ( "No TriggeringEventEvaluator is set for appender [" + name + "]." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for appender named [" + name + "]." ) ; return false ; } return true ; } public void close ( ) { this . closed = true ; } InternetAddress getAddress ( String addressStr ) { try { return new InternetAddress ( addressStr ) ; } catch ( AddressException e ) { errorHandler . error ( "Could not parse address [" + addressStr + "]." , e , ErrorCode . ADDRESS_PARSE_FAILURE ) ; return null ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { TO_OPTION , FROM_OPTION , SUBJECT_OPTION , SMTP_HOST_OPTION , BUFFER_SIZE_OPTION , LOCATION_INFO_OPTION } ) ; } InternetAddress [ ] parseAddress ( String addressStr ) { try { return InternetAddress . parse ( addressStr , true ) ; } catch ( AddressException e ) { errorHandler . error ( "Could not parse address [" + addressStr + "]." , e , ErrorCode . ADDRESS_PARSE_FAILURE ) ; return null ; } } public boolean requiresLayout ( ) { return true ; } protected void sendBuffer ( ) { try { MimeBodyPart part = new MimeBodyPart ( ) ; StringBuffer sbuf = new StringBuffer ( ) ; String t = layout . getHeader ( ) ; if ( t != null ) sbuf . append ( t ) ; int len = cb . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { sbuf . append ( layout . format ( cb . get ( ) ) ) ; } t = layout . getFooter ( ) ; if ( t != null ) sbuf . append ( t ) ; part . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; Multipart mp = new MimeMultipart ( ) ; mp . addBodyPart ( part ) ; msg . setContent ( mp ) ; msg . setSentDate ( new Date ( ) ) ; Transport . send ( msg ) ; } catch ( Exception e ) { LogLog . error ( "Error occured while sending e-mail notification." , e ) ; } } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( TO_OPTION ) ) to = value ; else if ( option . equals ( FROM_OPTION ) ) from = value ; else if ( option . equals ( SMTP_HOST_OPTION ) ) smtpHost = value ; else if ( option . equals ( SUBJECT_OPTION ) ) subject = value ; else if ( option . equals ( EVALUATOR_CLASS_OPTION ) ) { evaluator = ( TriggeringEventEvaluator ) OptionConverter . instantiateByClassName ( value , TriggeringEventEvaluator . class , evaluator ) ; } else if ( option . equals ( BUFFER_SIZE_OPTION ) ) { bufferSize = OptionConverter . toInt ( value , bufferSize ) ; cb . resize ( bufferSize ) ; } else if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } class DefaultEvaluator implements TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) { return event . priority . isGreaterOrEqual ( Priority . ERROR ) ; } } 	1	
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class QuietWriter extends FilterWriter { protected ErrorHandler errorHandler ; public QuietWriter ( Writer writer , ErrorHandler errorHandler ) { super ( writer ) ; setErrorHandler ( errorHandler ) ; } public void write ( String string ) { try { out . write ( string ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to write [" + string + "]." , e , ErrorCode . WRITE_FAILURE ) ; } } public void flush ( ) { try { out . flush ( ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to flush writer," , e , ErrorCode . FLUSH_FAILURE ) ; } } public void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { throw new IllegalArgumentException ( "Attempted to set null ErrorHandler." ) ; } else { this . errorHandler = eh ; } } } 	0	
package org . apache . log4j . xml . examples ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . xml . examples . XPriority ; public class XCategory extends Category implements OptionHandler { private static XFactory factory = new XFactory ( ) ; static String instanceFQCN = XCategory . class . getName ( ) ; public static final String SUFFIX_OPTION = "Suffix" ; String suffix ; public XCategory ( String name ) { super ( name ) ; } public void activateOptions ( ) { } public void debug ( String message ) { log ( instanceFQCN , Priority . DEBUG , message + suffix , null ) ; } public void fatal ( String message ) { if ( disable <= XPriority . FATAL_INT ) return ; if ( XPriority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , XPriority . FATAL , message , null ) ) ; } public static Category getInstance ( String name ) { return Category . getInstance ( name , factory ) ; } public String [ ] getOptionStrings ( ) { return ( new String [ ] { SUFFIX_OPTION } ) ; } public void setOption ( String option , String value ) { System . out . println ( option + "=" + value ) ; if ( option == null ) { return ; } if ( option . equalsIgnoreCase ( SUFFIX_OPTION ) ) { this . suffix = value ; System . out . println ( "Setting suffix to" + suffix ) ; } } public void trace ( String message ) { if ( disable <= XPriority . TRACE_INT ) return ; if ( XPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , XPriority . TRACE , message , null ) ) ; } private static class XFactory implements CategoryFactory { XFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new XCategory ( name ) ; } } } 	1	
package org . apache . log4j ; class CategoryKey { String name ; int hashCache ; CategoryKey ( String name ) { this . name = name . intern ( ) ; hashCache = name . hashCode ( ) ; } final public int hashCode ( ) { return hashCache ; } final public boolean equals ( Object rArg ) { if ( this == rArg ) return true ; if ( rArg != null && CategoryKey . class == rArg . getClass ( ) ) return name == ( ( CategoryKey ) rArg ) . name ; else return false ; } } 	0	
package org . apache . log4j . xml ; import java . util . * ; import java . net . URL ; import org . w3c . dom . * ; import java . lang . reflect . Method ; import org . apache . log4j . Category ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . Appender ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . FileWatchdog ; import org . xml . sax . InputSource ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import java . net . URL ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . FactoryConfigurationError ; public class DOMConfigurator extends BasicConfigurator implements Configurator { static final String CONFIGURATION_TAG = "configuration" ; static final String RENDERER_TAG = "renderer" ; static final String APPENDER_TAG = "appender" ; static final String APPENDER_REF_TAG = "appender-ref" ; static final String PARAM_TAG = "param" ; static final String LAYOUT_TAG = "layout" ; static final String CATEGORY = "category" ; static final String NAME_ATTR = "name" ; static final String CLASS_ATTR = "class" ; static final String VALUE_ATTR = "value" ; static final String ROOT_TAG = "root" ; static final String PRIORITY_TAG = "priority" ; static final String FILTER_TAG = "filter" ; static final String ERROR_HANDLER_TAG = "errorHandler" ; static final String REF_ATTR = "ref" ; static final String ADDITIVITY_ATTR = "additivity" ; static final String SCFO_ATTR = "disableOverride" ; static final String CONFIG_DEBUG_ATTR = "configDebug" ; static final String RENDERING_CLASS_ATTR = "renderingClass" ; static final String RENDERED_CLASS_ATTR = "renderedClass" ; static final String EMPTY_STR = "" ; static final Class [ ] ONE_STRING_PARAM = new Class [ ] { String . class } ; final static String dbfKey = "javax.xml.parsers.DocumentBuilderFactory" ; Hashtable appenderBag ; public DOMConfigurator ( ) { appenderBag = new Hashtable ( ) ; } protected Appender findAppenderByReference ( Element appenderRef ) { String appenderName = appenderRef . getAttribute ( REF_ATTR ) ; Appender appender = ( Appender ) appenderBag . get ( appenderName ) ; if ( appender != null ) { return appender ; } else { Document doc = appenderRef . getOwnerDocument ( ) ; Element element = null ; NodeList list = doc . getElementsByTagName ( "appender" ) ; for ( int t = 0 ; t < list . getLength ( ) ; t ++ ) { Node node = list . item ( t ) ; NamedNodeMap map = node . getAttributes ( ) ; Node attrNode = map . getNamedItem ( "name" ) ; if ( appenderName . equals ( attrNode . getNodeValue ( ) ) ) { element = ( Element ) node ; break ; } } if ( element == null ) { LogLog . error ( "No appender named [" + appenderName + "] could be found." ) ; return null ; } else { appender = parseAppender ( element ) ; appenderBag . put ( appenderName , appender ) ; return appender ; } } } protected Appender parseAppender ( Element appenderElement ) { String className = appenderElement . getAttribute ( CLASS_ATTR ) ; LogLog . debug ( "Class name: [" + className + ']' ) ; try { Object instance = Class . forName ( className ) . newInstance ( ) ; Appender appender = ( Appender ) instance ; appender . setName ( appenderElement . getAttribute ( NAME_ATTR ) ) ; NodeList children = appenderElement . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; if ( currentElement . getTagName ( ) . equals ( PARAM_TAG ) ) { if ( appender instanceof OptionHandler ) { parseParameters ( currentElement , ( OptionHandler ) appender ) ; } } else if ( currentElement . getTagName ( ) . equals ( LAYOUT_TAG ) ) { appender . setLayout ( parseLayout ( currentElement ) ) ; } else if ( currentElement . getTagName ( ) . equals ( FILTER_TAG ) ) { parseFilters ( currentElement , appender ) ; } else if ( currentElement . getTagName ( ) . equals ( ERROR_HANDLER_TAG ) ) { parseErrorHandler ( currentElement , appender ) ; } else if ( currentElement . getTagName ( ) . equals ( APPENDER_REF_TAG ) ) { String refName = currentElement . getAttribute ( REF_ATTR ) ; if ( appender instanceof AppenderAttachable ) { AppenderAttachable aa = ( AppenderAttachable ) appender ; LogLog . debug ( "Attaching appender named [" + refName + "] to appender named [" + appender . getName ( ) + "]." ) ; aa . addAppender ( findAppenderByReference ( currentElement ) ) ; } else { LogLog . error ( "Requesting attachment of appender named [" + refName + "] to appender named [" + appender . getName ( ) + "] which does not implement org.apache.log4j.spi.AppenderAttachable." ) ; } } } } if ( appender instanceof OptionHandler ) { ( ( OptionHandler ) appender ) . activateOptions ( ) ; } return appender ; } catch ( Exception oops ) { LogLog . error ( "Could not create an Appender. Reported error follows." , oops ) ; return null ; } } protected void parseErrorHandler ( Element element , Appender appender ) { ErrorHandler eh = ( ErrorHandler ) OptionConverter . instantiateByClassName ( element . getAttribute ( CLASS_ATTR ) , org . apache . log4j . spi . ErrorHandler . class , null ) ; if ( eh != null ) { NodeList children = element . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( PARAM_TAG ) ) { parseParameters ( currentElement , eh ) ; } } } appender . setErrorHandler ( eh ) ; } } protected void parseParameters ( Element elem , OptionHandler oh ) { String name = elem . getAttribute ( NAME_ATTR ) ; String value = elem . getAttribute ( VALUE_ATTR ) ; LogLog . debug ( "Handling parameter \"" + name + "=" + value + '\"' ) ; if ( oh instanceof OptionHandler && value != null ) { oh . setOption ( name , OptionConverter . convertSpecialChars ( value ) ) ; } } protected void parseFilters ( Element element , Appender appender ) { String clazz = element . getAttribute ( CLASS_ATTR ) ; Filter filter = ( Filter ) OptionConverter . instantiateByClassName ( clazz , org . apache . log4j . spi . Filter . class , null ) ; if ( filter != null ) { NodeList children = element . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( PARAM_TAG ) ) { parseParameters ( currentElement , filter ) ; } } } appender . addFilter ( filter ) ; } } protected void parseCategory ( Element categoryElement , Hierarchy hierarchy ) { String catName = categoryElement . getAttribute ( NAME_ATTR ) ; Category cat ; String className = categoryElement . getAttribute ( CLASS_ATTR ) ; if ( EMPTY_STR . equals ( className ) ) { LogLog . debug ( "Retreiving an instance of org.apache.log4j.Category." ) ; cat = hierarchy . getInstance ( catName ) ; } else { LogLog . debug ( "Desired category sub-class: [" + className + ']' ) ; try { Class clazz = Class . forName ( className ) ; Method getInstanceMethod = clazz . getMethod ( "getInstance" , ONE_STRING_PARAM ) ; cat = ( Category ) getInstanceMethod . invoke ( null , new Object [ ] { catName } ) ; } catch ( Exception oops ) { LogLog . error ( "Could not retrieve category [" + catName + "]. Reported error follows." , oops ) ; return ; } } synchronized ( cat ) { cat . setAdditivity ( OptionConverter . toBoolean ( categoryElement . getAttribute ( ADDITIVITY_ATTR ) , true ) ) ; parseChildrenOfCategoryElement ( categoryElement , cat , false ) ; } } protected void parseRoot ( Element rootElement , Hierarchy hierarchy ) { Category root = hierarchy . getRoot ( ) ; synchronized ( root ) { parseChildrenOfCategoryElement ( rootElement , root , true ) ; } } protected void parseChildrenOfCategoryElement ( Element catElement , Category cat , boolean isRoot ) { cat . removeAllAppenders ( ) ; NodeList children = catElement . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( APPENDER_REF_TAG ) ) { Element appenderRef = ( Element ) currentNode ; Appender appender = findAppenderByReference ( appenderRef ) ; String refName = appenderRef . getAttribute ( REF_ATTR ) ; if ( appender != null ) LogLog . debug ( "Adding appender named [" + refName + "] to category [" + cat . getName ( ) + "]." ) ; else LogLog . debug ( "Appender named [" + refName + "] not found." ) ; cat . addAppender ( appender ) ; } else if ( tagName . equals ( PRIORITY_TAG ) ) { parsePriority ( currentElement , cat , isRoot ) ; } else if ( tagName . equals ( PARAM_TAG ) ) { if ( cat instanceof OptionHandler ) { OptionHandler oh = ( OptionHandler ) cat ; parseParameters ( currentElement , oh ) ; oh . activateOptions ( ) ; } } } } } protected Layout parseLayout ( Element layout_element ) { String className = layout_element . getAttribute ( CLASS_ATTR ) ; LogLog . debug ( "Parsing layout of class: \"" + className + "\"" ) ; try { Object instance = Class . forName ( className ) . newInstance ( ) ; Layout layout = ( Layout ) instance ; NodeList params = layout_element . getChildNodes ( ) ; final int length = params . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = ( Node ) params . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( PARAM_TAG ) ) { parseParameters ( currentElement , layout ) ; } } } layout . activateOptions ( ) ; return layout ; } catch ( Exception oops ) { LogLog . error ( "Could not create the Layout. Reported error follows." , oops ) ; return null ; } } protected void parserRenderer ( Element element ) { String renderingClass = element . getAttribute ( RENDERING_CLASS_ATTR ) ; String renderedClass = element . getAttribute ( RENDERED_CLASS_ATTR ) ; addRenderer ( renderedClass , renderingClass ) ; } protected void parsePriority ( Element element , Category cat , boolean isRoot ) { String catName = cat . getName ( ) ; if ( isRoot ) { catName = "root" ; } String priStr = element . getAttribute ( VALUE_ATTR ) ; LogLog . debug ( "Priority value for " + catName + " is  [" + priStr + "]." ) ; if ( BasicConfigurator . INHERITED . equals ( priStr ) ) { if ( isRoot ) { LogLog . error ( "Root priority cannot be inherited. Ignoring directive." ) ; } else { cat . setPriority ( null ) ; } } else { String className = element . getAttribute ( CLASS_ATTR ) ; if ( EMPTY_STR . equals ( className ) ) { cat . setPriority ( Priority . toPriority ( priStr ) ) ; } else { LogLog . debug ( "Desired Priority sub-class: [" + className + ']' ) ; try { Class clazz = Class . forName ( className ) ; Method toPriorityMethod = clazz . getMethod ( "toPriority" , ONE_STRING_PARAM ) ; Priority pri = ( Priority ) toPriorityMethod . invoke ( null , new Object [ ] { priStr } ) ; cat . setPriority ( pri ) ; } catch ( Exception oops ) { LogLog . error ( "Could not create priority [" + priStr + "]. Reported error follows." , oops ) ; return ; } } } LogLog . debug ( catName + " priority set to " + cat . getPriority ( ) ) ; } static public void configure ( Element element ) { DOMConfigurator configurator = new DOMConfigurator ( ) ; configurator . parse ( element , Category . getDefaultHierarchy ( ) ) ; } static public void configureAndWatch ( String configFilename ) { configureAndWatch ( configFilename , FileWatchdog . DEFAULT_DELAY ) ; } static public void configureAndWatch ( String configFilename , long delay ) { XMLWatchdog xdog = new XMLWatchdog ( configFilename ) ; xdog . setDelay ( delay ) ; xdog . start ( ) ; } public void doConfigure ( String filename , Hierarchy hierarchy ) { try { doConfigure ( new FileInputStream ( filename ) , hierarchy ) ; } catch ( IOException e ) { LogLog . error ( "Could not open [" + filename + "]." , e ) ; } } public void doConfigure ( URL url , Hierarchy hierarchy ) { try { doConfigure ( url . openStream ( ) , hierarchy ) ; } catch ( IOException e ) { LogLog . error ( "Could not open [" + url + "]." , e ) ; } } public void doConfigure ( InputStream input , Hierarchy hierarchy ) throws FactoryConfigurationError { DocumentBuilderFactory dbf = null ; try { LogLog . debug ( "System property is :" + System . getProperty ( dbfKey ) ) ; dbf = DocumentBuilderFactory . newInstance ( ) ; LogLog . debug ( "Standard DocumentBuilderFactory search succeded." ) ; LogLog . debug ( "DocumentBuilderFactory is: " + dbf . getClass ( ) . getName ( ) ) ; } catch ( FactoryConfigurationError fce ) { Exception e = fce . getException ( ) ; LogLog . debug ( "Could not instantiate a DocumentBuilderFactory." , e ) ; throw fce ; } try { dbf . setValidating ( true ) ; DocumentBuilder docBuilder = dbf . newDocumentBuilder ( ) ; InputSource inputSource = new InputSource ( input ) ; URL dtdURL = DOMConfigurator . class . getResource ( "log4j.dtd" ) ; if ( dtdURL == null ) { LogLog . error ( "Could not find log4j.dtd." ) ; } else { LogLog . debug ( "URL to log4j.dtd is [" + dtdURL . toString ( ) + "]." ) ; inputSource . setSystemId ( dtdURL . toString ( ) ) ; } Document doc = docBuilder . parse ( inputSource ) ; parse ( doc . getDocumentElement ( ) , hierarchy ) ; } catch ( Exception e ) { LogLog . error ( "Could not parse input stream [" + input + "]." , e ) ; } } static public void configure ( String filename ) throws FactoryConfigurationError { new DOMConfigurator ( ) . doConfigure ( filename , Category . getDefaultHierarchy ( ) ) ; } protected void parse ( Element element , Hierarchy hierarchy ) { if ( ! element . getTagName ( ) . equals ( CONFIGURATION_TAG ) ) { LogLog . error ( "DOM element is not a <configuration> element" ) ; return ; } String confDebug = element . getAttribute ( CONFIG_DEBUG_ATTR ) ; LogLog . debug ( "configDebug attribute= \"" + confDebug + "\"." ) ; if ( ! confDebug . equals ( "" ) && ! confDebug . equals ( "null" ) ) { LogLog . setInternalDebugging ( OptionConverter . toBoolean ( confDebug , true ) ) ; } else LogLog . debug ( "Ignoring " + CONFIG_DEBUG_ATTR + " attribute." ) ; String override = element . getAttribute ( SCFO_ATTR ) ; LogLog . debug ( "Disable override=\"" + override + "\"." ) ; if ( ! override . equals ( "" ) && ! override . equals ( "null" ) ) { overrideAsNeeded ( override ) ; } else LogLog . debug ( "Ignoring " + SCFO_ATTR + " attribute." ) ; NodeList children = element . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( CATEGORY ) ) { parseCategory ( currentElement , hierarchy ) ; } else if ( tagName . equals ( ROOT_TAG ) ) { parseRoot ( currentElement , hierarchy ) ; } else if ( tagName . equals ( RENDERER_TAG ) ) { parserRenderer ( currentElement ) ; } } } } } class XMLWatchdog extends FileWatchdog { XMLWatchdog ( String filename ) { super ( filename ) ; } public void doOnChange ( ) { new DOMConfigurator ( ) . doConfigure ( filename , Category . getDefaultHierarchy ( ) ) ; } } 	1	
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; public class ConfigurationFileParsing { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { NDC . push ( "testing" ) ; PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; root . debug ( "Message 1" ) ; root . debug ( "Message 2" ) ; NDC . pop ( ) ; } else { Usage ( "Wrong number of arguments." ) ; } } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ConfigurationFileParsing . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	
package org . apache . log4j . spi ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Filter implements OptionHandler { public Filter next ; public static final int DENY = - 1 ; public static final int NEUTRAL = 0 ; public static final int ACCEPT = 1 ; public void activateOptions ( ) { } abstract public int decide ( LoggingEvent event ) ; } 	1	
package org . apache . log4j . helpers ; import java . io . PrintWriter ; public class TracerPrintWriter extends PrintWriter { protected QuietWriter qWriter ; public TracerPrintWriter ( QuietWriter qWriter ) { super ( qWriter ) ; this . qWriter = qWriter ; } final public void setQuietWriter ( QuietWriter qWriter ) { this . qWriter = qWriter ; } public void println ( Object o ) { this . qWriter . write ( o . toString ( ) ) ; this . qWriter . write ( org . apache . log4j . Layout . LINE_SEP ) ; } public void println ( char [ ] s ) { this . println ( new String ( s ) ) ; } public void println ( String s ) { this . qWriter . write ( s ) ; this . qWriter . write ( org . apache . log4j . Layout . LINE_SEP ) ; } } 	0	
package org . apache . log4j . net ; import java . net . InetAddress ; import java . net . Socket ; import java . io . OutputStream ; import java . io . IOException ; import java . io . ObjectOutputStream ; import java . io . ObjectOutputStream ; import java . io . OutputStreamWriter ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . AppenderSkeleton ; public class SocketAppender extends AppenderSkeleton { InetAddress address ; int port = 4560 ; String hostName ; ObjectOutputStream oos ; int reconnectionDelay = 30000 ; boolean locationInfo = false ; private Connector connector ; int counter = 0 ; private static final int RESET_FREQUENCY = 1 ; public static final String REMOTE_HOST_OPTION = "RemoteHost" ; public static final String PORT_OPTION = "Port" ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public static final String RECONNECTION_DELAY_OPTION = "ReconnectionDelay" ; public SocketAppender ( ) { } public SocketAppender ( InetAddress address , int port ) { this . address = address ; this . port = port ; this . hostName = address . getHostName ( ) ; connect ( address , port ) ; } public SocketAppender ( String host , int port ) { this . port = port ; this . hostName = host ; this . address = getAddressByName ( host ) ; connect ( address , port ) ; } public void activateOptions ( ) { connect ( address , port ) ; } public void close ( ) { this . closed = true ; cleanUp ( ) ; } public void cleanUp ( ) { if ( oos != null ) { try { oos . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not close oos." , e ) ; } oos = null ; } if ( connector != null ) { connector . interrupt ( ) ; connector = null ; } } void connect ( InetAddress address , int port ) { if ( this . address == null ) return ; try { cleanUp ( ) ; oos = new ObjectOutputStream ( new Socket ( address , port ) . getOutputStream ( ) ) ; } catch ( IOException e ) { LogLog . error ( "Could not connect to remote log4j server at [" + address . getHostName ( ) + "]. We will try again later." , e ) ; fireConnector ( ) ; } } public void append ( LoggingEvent event ) { if ( address == null ) { errorHandler . error ( "No remote host is set for SocketAppedender named \"" + this . name + "\"." ) ; return ; } if ( oos != null ) { try { if ( locationInfo ) { event . setLocationInformation ( ) ; } oos . writeObject ( event ) ; oos . flush ( ) ; if ( ++ counter >= RESET_FREQUENCY ) { counter = 0 ; oos . reset ( ) ; } } catch ( IOException e ) { oos = null ; LogLog . debug ( "Detected problem with connection: " + e ) ; fireConnector ( ) ; } } } void fireConnector ( ) { if ( connector == null ) { LogLog . debug ( "Starting a new connector thread." ) ; connector = new Connector ( ) ; connector . setDaemon ( true ) ; connector . setPriority ( Thread . MIN_PRIORITY ) ; connector . start ( ) ; } } InetAddress getAddressByName ( String host ) { try { return InetAddress . getByName ( host ) ; } catch ( Exception e ) { LogLog . error ( "Could not find address of [" + host + "]." , e ) ; return null ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { REMOTE_HOST_OPTION , PORT_OPTION , LOCATION_INFO_OPTION , RECONNECTION_DELAY_OPTION } ) ; } public boolean requiresLayout ( ) { return false ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( REMOTE_HOST_OPTION ) ) address = getAddressByName ( value ) ; else if ( option . equals ( PORT_OPTION ) ) port = OptionConverter . toInt ( value , port ) ; else if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; else if ( option . equals ( RECONNECTION_DELAY_OPTION ) ) reconnectionDelay = OptionConverter . toInt ( value , reconnectionDelay ) ; } class Connector extends Thread { public void run ( ) { Socket socket ; while ( ! isInterrupted ( ) ) { try { sleep ( reconnectionDelay ) ; LogLog . debug ( "Attempting connection to " + address . getHostName ( ) ) ; socket = new Socket ( address , port ) ; synchronized ( this ) { oos = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; connector = null ; break ; } } catch ( InterruptedException e ) { LogLog . debug ( "Connector interrupted. Leaving loop." ) ; return ; } catch ( java . net . ConnectException e ) { LogLog . debug ( "Remote host " + address . getHostName ( ) + " refused connection." ) ; } catch ( IOException e ) { LogLog . debug ( "Could not connect to " + address . getHostName ( ) + ". Exception is " + e ) ; } } } } } 	1	
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class BoundedFIFO { LoggingEvent [ ] buf ; int numElements = 0 ; int first = 0 ; int next = 0 ; int maxSize ; public BoundedFIFO ( int maxSize ) { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; buf = new LoggingEvent [ maxSize ] ; } public LoggingEvent get ( ) { if ( numElements == 0 ) return null ; LoggingEvent r = buf [ first ] ; if ( ++ first == maxSize ) { first = 0 ; } numElements -- ; return r ; } public void put ( LoggingEvent o ) { if ( numElements != maxSize ) { buf [ next ] = o ; if ( ++ next == maxSize ) { next = 0 ; } numElements ++ ; } } public int getMaxSize ( ) { return maxSize ; } public boolean isFull ( ) { return numElements == maxSize ; } public int length ( ) { return numElements ; } public boolean wasEmpty ( ) { return numElements == 1 ; } public boolean wasFull ( ) { return ( numElements + 1 == maxSize ) ; } } 	0	
package org . apache . log4j . net ; import java . net . Socket ; import java . net . ServerSocket ; import java . net . InetAddress ; import java . net . MalformedURLException ; import java . io . IOException ; import java . io . File ; import java . util . Hashtable ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . Priority ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . spi . RootCategory ; public class SocketServer { static String GENERIC = "generic" ; static String CONFIG_FILE_EXT = ".lcf" ; static Category cat = Category . getInstance ( SocketServer . class ) ; static SocketServer server ; static int port ; Hashtable hierarchyMap ; Hierarchy genericHierarchy ; File dir ; public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] ) ; else usage ( "Wrong number of arguments." ) ; try { cat . info ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { cat . info ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; InetAddress inetAddress = socket . getInetAddress ( ) ; cat . info ( "Connected to client at " + inetAddress ) ; Hierarchy h = ( Hierarchy ) server . hierarchyMap . get ( inetAddress ) ; if ( h == null ) { h = server . configureHierarchy ( inetAddress ) ; } cat . info ( "Starting new socket node." ) ; new Thread ( new SocketNode ( socket , h ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SocketServer . class . getName ( ) + " port configFile directory" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile , String dirStr ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; File dir = new File ( dirStr ) ; if ( ! dir . isDirectory ( ) ) { usage ( "[" + dirStr + "] is not a directory." ) ; } server = new SocketServer ( dir ) ; } public SocketServer ( File directory ) { this . dir = directory ; hierarchyMap = new Hashtable ( 11 ) ; } Hierarchy configureHierarchy ( InetAddress inetAddress ) { cat . info ( "Locating configuration file for " + inetAddress ) ; String s = inetAddress . toString ( ) ; int i = s . indexOf ( "/" ) ; if ( i == - 1 ) { cat . warn ( "Could not parse the inetAddress [" + inetAddress + "]. Using default hierarchy." ) ; return genericHierarchy ( ) ; } else { String key = s . substring ( 0 , i ) ; File configFile = new File ( dir , key + CONFIG_FILE_EXT ) ; if ( configFile . exists ( ) ) { Hierarchy h = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; hierarchyMap . put ( inetAddress , h ) ; try { new PropertyConfigurator ( ) . doConfigure ( configFile . toURL ( ) , h ) ; } catch ( MalformedURLException e ) { cat . error ( "Could not convert" + configFile + " to a URL." , e ) ; } return h ; } else { cat . warn ( "Could not find config file [" + configFile + "]." ) ; return genericHierarchy ( ) ; } } } Hierarchy genericHierarchy ( ) { if ( genericHierarchy == null ) { File f = new File ( dir , GENERIC + CONFIG_FILE_EXT ) ; if ( f . exists ( ) ) { genericHierarchy = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; try { new PropertyConfigurator ( ) . doConfigure ( f . toURL ( ) , genericHierarchy ) ; } catch ( MalformedURLException e ) { cat . error ( "Could not convert" + f + " to a URL. Reverting to default hierarchy" , e ) ; genericHierarchy = Category . getDefaultHierarchy ( ) ; } } else { cat . warn ( "Could not find config file [" + f + "]. Will use the default hierarchy." ) ; genericHierarchy = Category . getDefaultHierarchy ( ) ; } } return genericHierarchy ; } } 	1	
package org . apache . log4j . gui ; import org . apache . log4j . helpers . CyclicBuffer ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Priority ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PatternLayout ; import org . apache . log4j . spi . LoggingEvent ; import javax . swing . JList ; import javax . swing . AbstractListModel ; import javax . swing . JFrame ; import javax . swing . JButton ; import javax . swing . JLabel ; import javax . swing . JTable ; import javax . swing . JTextArea ; import javax . swing . table . AbstractTableModel ; import javax . swing . table . TableCellRenderer ; import javax . swing . JScrollPane ; import javax . swing . ListCellRenderer ; import java . awt . Component ; import java . awt . FlowLayout ; import javax . swing . BoxLayout ; import java . awt . BorderLayout ; import java . awt . Dimension ; import java . awt . event . ActionListener ; import java . awt . event . ActionEvent ; import java . awt . Container ; import javax . swing . ImageIcon ; import java . awt . Image ; import java . awt . Toolkit ; import java . net . URL ; import java . awt . Rectangle ; public class JTableAppender extends JTable { static Category cat = Category . getInstance ( JTableAppender . class . getName ( ) ) ; PatternLayout layout ; public JTableAppender ( ) { layout = new PatternLayout ( "%r %p %c [%t] -  %m" ) ; this . setDefaultRenderer ( Object . class , new Renderer ( ) ) ; } public void add ( LoggingEvent event ) { ( ( JTableAppenderModel ) getModel ( ) ) . add ( event ) ; } public Dimension getPreferredSize ( ) { System . out . println ( "getPreferredSize() called" ) ; return super . getPreferredSize ( ) ; } static public void main ( String [ ] args ) { JFrame frame = new JFrame ( "JListView test" ) ; Container container = frame . getContentPane ( ) ; JTableAppender appender = new JTableAppender ( ) ; JTableAppenderModel model = new JTableAppenderModel ( Integer . parseInt ( args [ 0 ] ) ) ; appender . setModel ( model ) ; JScrollPane sp = new JScrollPane ( appender ) ; sp . setPreferredSize ( new Dimension ( 250 , 80 ) ) ; container . setLayout ( new BoxLayout ( container , BoxLayout . X_AXIS ) ) ; container . add ( sp ) ; JButton button = new JButton ( "ADD" ) ; container . add ( button ) ; button . addActionListener ( new JTableAddAction ( appender ) ) ; frame . setVisible ( true ) ; frame . setSize ( new Dimension ( 700 , 700 ) ) ; long before = System . currentTimeMillis ( ) ; int RUN = 10000 ; int i = 0 ; while ( i ++ < RUN ) { LoggingEvent event = new LoggingEvent ( "x" , cat , Priority . ERROR , "Message " + i , null ) ; event . getThreadName ( ) ; if ( i % 10 == 0 ) { event . throwable = new Exception ( "hello " + i ) ; } appender . add ( event ) ; } long after = System . currentTimeMillis ( ) ; System . out . println ( "Time taken :" + ( ( after - before ) * 1000 / RUN ) ) ; } class Renderer extends JTextArea implements TableCellRenderer { Object o = new Object ( ) ; int i = 0 ; public Renderer ( ) { System . out . println ( "Render() called ----------------------" ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { System . out . println ( o + " ============== " + i ++ ) ; if ( value instanceof LoggingEvent ) { LoggingEvent event = ( LoggingEvent ) value ; String str = layout . format ( event ) ; String t = event . getThrowableInformation ( ) ; if ( t != null ) { System . out . println ( "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" ) ; setText ( str + Layout . LINE_SEP + t ) ; } else { setText ( str ) ; } } else { setText ( value . toString ( ) ) ; } return this ; } } } class JTableAppenderModel extends AbstractTableModel { CyclicBuffer cb ; JTableAppenderModel ( int size ) { cb = new CyclicBuffer ( size ) ; } public void add ( LoggingEvent event ) { cb . add ( event ) ; int j = cb . length ( ) ; fireTableDataChanged ( ) ; } public int getColumnCount ( ) { return 1 ; } public int getRowCount ( ) { return cb . length ( ) ; } public Object getValueAt ( int row , int col ) { return cb . get ( row ) ; } } class JTableAddAction implements ActionListener { int j ; JTableAppender appender ; Category cat = Category . getInstance ( "x" ) ; public JTableAddAction ( JTableAppender appender ) { this . appender = appender ; j = 0 ; } public void actionPerformed ( ActionEvent e ) { System . out . println ( "Action occured" ) ; LoggingEvent event = new LoggingEvent ( "x" , cat , Priority . DEBUG , "Message " + j , null ) ; if ( j % 5 == 0 ) { event . throwable = new Exception ( "hello " + j ) ; } j ++ ; appender . add ( event ) ; } } 	0	
package org . apache . log4j . helpers ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . Layout ; import org . apache . log4j . NDC ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; public class PatternParser { private static final char ESCAPE_CHAR = '%' ; private static final int LITERAL_STATE = 0 ; private static final int CONVERTER_STATE = 1 ; private static final int MINUS_STATE = 2 ; private static final int DOT_STATE = 3 ; private static final int MIN_STATE = 4 ; private static final int MAX_STATE = 5 ; static final int FULL_LOCATION_CONVERTER = 1000 ; static final int METHOD_LOCATION_CONVERTER = 1001 ; static final int CLASS_LOCATION_CONVERTER = 1002 ; static final int LINE_LOCATION_CONVERTER = 1003 ; static final int FILE_LOCATION_CONVERTER = 1004 ; static final int RELATIVE_TIME_CONVERTER = 2000 ; static final int THREAD_CONVERTER = 2001 ; static final int PRIORITY_CONVERTER = 2002 ; static final int NDC_CONVERTER = 2003 ; static final int MESSAGE_CONVERTER = 2004 ; int state ; protected StringBuffer currentLiteral = new StringBuffer ( 32 ) ; protected int patternLength ; protected int i ; PatternConverter head ; PatternConverter tail ; protected FormattingInfo formattingInfo = new FormattingInfo ( ) ; protected String pattern ; public PatternParser ( String pattern ) { this . pattern = pattern ; patternLength = pattern . length ( ) ; state = LITERAL_STATE ; } private void addToList ( PatternConverter pc ) { if ( head == null ) { head = tail = pc ; } else { tail . next = pc ; tail = pc ; } } private String extractOption ( ) { if ( ( i < patternLength ) && ( pattern . charAt ( i ) == '{' ) ) { int end = pattern . indexOf ( '}' , i ) ; if ( end > i ) { String r = pattern . substring ( i + 1 , end ) ; i = end + 1 ; return r ; } } return null ; } private int extractPrecisionOption ( ) { String opt = extractOption ( ) ; int r = 0 ; if ( opt != null ) { try { r = Integer . parseInt ( opt ) ; if ( r <= 0 ) { LogLog . error ( "Precision option (" + opt + ") isn't a positive integer." ) ; r = 0 ; } } catch ( NumberFormatException e ) { LogLog . error ( "Category option \"" + opt + "\" not a decimal integer." , e ) ; } } return r ; } public PatternConverter parse ( ) { char c ; i = 0 ; while ( i < patternLength ) { c = pattern . charAt ( i ++ ) ; switch ( state ) { case LITERAL_STATE : if ( i == patternLength ) { currentLiteral . append ( c ) ; continue ; } if ( c == ESCAPE_CHAR ) { switch ( pattern . charAt ( i ) ) { case ESCAPE_CHAR : currentLiteral . append ( c ) ; i ++ ; break ; case 'n' : currentLiteral . append ( Layout . LINE_SEP ) ; i ++ ; break ; default : if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } currentLiteral . setLength ( 0 ) ; currentLiteral . append ( c ) ; state = CONVERTER_STATE ; formattingInfo . reset ( ) ; } } else { currentLiteral . append ( c ) ; } break ; case CONVERTER_STATE : currentLiteral . append ( c ) ; switch ( c ) { case '-' : formattingInfo . leftAlign = true ; break ; case '.' : state = DOT_STATE ; break ; default : if ( c >= '0' && c <= '9' ) { formattingInfo . min = c - '0' ; state = MIN_STATE ; } else finalizeConverter ( c ) ; } break ; case MIN_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . min = formattingInfo . min * 10 + ( c - '0' ) ; else if ( c == '.' ) state = DOT_STATE ; else { finalizeConverter ( c ) ; } break ; case DOT_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) { formattingInfo . max = c - '0' ; state = MAX_STATE ; } else { LogLog . error ( "Error occured in position " + i + ".\n Was expecting digit, instead got char \"" + c + "\"." ) ; state = LITERAL_STATE ; } break ; case MAX_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . max = formattingInfo . max * 10 + ( c - '0' ) ; else { finalizeConverter ( c ) ; state = LITERAL_STATE ; } break ; } } if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } return head ; } protected void finalizeConverter ( char c ) { PatternConverter pc = null ; switch ( c ) { case 'c' : pc = new CategoryPatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'C' : pc = new ClassNamePatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'd' : String dateFormatStr = AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ; DateFormat df ; String dOpt = extractOption ( ) ; if ( dOpt != null ) dateFormatStr = dOpt ; if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) df = new ISO8601DateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) df = new AbsoluteTimeDateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) df = new DateTimeDateFormat ( ) ; else { try { df = new SimpleDateFormat ( dateFormatStr ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Could not instantiate SimpleDateFormat with " + dateFormatStr , e ) ; df = ( DateFormat ) OptionConverter . instantiateByClassName ( "org.apache.log4j.helpers.ISO8601DateFormat" , DateFormat . class , null ) ; } } pc = new DatePatternConverter ( formattingInfo , df ) ; currentLiteral . setLength ( 0 ) ; break ; case 'F' : pc = new LocationPatternConverter ( formattingInfo , FILE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'l' : pc = new LocationPatternConverter ( formattingInfo , FULL_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'L' : pc = new LocationPatternConverter ( formattingInfo , LINE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'm' : pc = new BasicPatternConverter ( formattingInfo , MESSAGE_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'M' : pc = new LocationPatternConverter ( formattingInfo , METHOD_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'p' : pc = new BasicPatternConverter ( formattingInfo , PRIORITY_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'r' : pc = new BasicPatternConverter ( formattingInfo , RELATIVE_TIME_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 't' : pc = new BasicPatternConverter ( formattingInfo , THREAD_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'x' : pc = new BasicPatternConverter ( formattingInfo , NDC_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; default : LogLog . error ( "Unexpected char " + c + " at position " + i ) ; pc = new LiteralPatternConverter ( currentLiteral . toString ( ) ) ; currentLiteral . setLength ( 0 ) ; } addConverter ( pc ) ; } protected void addConverter ( PatternConverter pc ) { currentLiteral . setLength ( 0 ) ; addToList ( pc ) ; state = LITERAL_STATE ; formattingInfo . reset ( ) ; } private static class BasicPatternConverter extends PatternConverter { int type ; BasicPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { switch ( type ) { case RELATIVE_TIME_CONVERTER : return ( Long . toString ( event . timeStamp - LoggingEvent . getStartTime ( ) ) ) ; case THREAD_CONVERTER : return event . getThreadName ( ) ; case PRIORITY_CONVERTER : return event . priority . toString ( ) ; case NDC_CONVERTER : return event . getNDC ( ) ; case MESSAGE_CONVERTER : { return event . message ; } default : return null ; } } } private static class LiteralPatternConverter extends PatternConverter { private String literal ; LiteralPatternConverter ( String value ) { literal = value ; } public final void format ( StringBuffer sbuf , LoggingEvent event ) { sbuf . append ( literal ) ; } public String convert ( LoggingEvent event ) { return literal ; } } private static class DatePatternConverter extends PatternConverter { private DateFormat df ; private Date date ; DatePatternConverter ( FormattingInfo formattingInfo , DateFormat df ) { super ( formattingInfo ) ; date = new Date ( ) ; this . df = df ; } public String convert ( LoggingEvent event ) { date . setTime ( System . currentTimeMillis ( ) ) ; return df . format ( date ) ; } } private class LocationPatternConverter extends PatternConverter { int type ; LocationPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { event . setLocationInformation ( ) ; switch ( type ) { case FULL_LOCATION_CONVERTER : return event . locationInfo . fullInfo ; case METHOD_LOCATION_CONVERTER : return event . locationInfo . getMethodName ( ) ; case LINE_LOCATION_CONVERTER : return event . locationInfo . getLineNumber ( ) ; case FILE_LOCATION_CONVERTER : return event . locationInfo . getFileName ( ) ; default : return null ; } } } private static abstract class NamedPatternConverter extends PatternConverter { int precision ; NamedPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo ) ; this . precision = precision ; } abstract String getFullyQualifiedName ( LoggingEvent event ) ; public String convert ( LoggingEvent event ) { String n = getFullyQualifiedName ( event ) ; if ( precision <= 0 ) return n ; else { int len = n . length ( ) ; int end = len - 1 ; for ( int i = precision ; i > 0 ; i -- ) { end = n . lastIndexOf ( '.' , end - 1 ) ; if ( end == - 1 ) return n ; } return n . substring ( end + 1 , len ) ; } } } private class ClassNamePatternConverter extends NamedPatternConverter { ClassNamePatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { event . setLocationInformation ( ) ; return event . locationInfo . getClassName ( ) ; } } private class CategoryPatternConverter extends NamedPatternConverter { CategoryPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { return event . categoryName ; } } } 	1	
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; final public class RootCategory extends Category { public RootCategory ( Priority priority ) { super ( "root" ) ; this . priority = priority ; } final public Priority getChainedPriority ( ) { return priority ; } final public void setPriority ( Priority priority ) { if ( priority == null ) { LogLog . error ( "You have tried to set a null priority to root." , new Throwable ( ) ) ; } else { this . priority = priority ; } } } 	0	
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SyslogAppender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . FileAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . NDC ; import org . apache . log4j . performance . NOPWriter ; import java . util . Enumeration ; public class Logging { static int runLength ; static int delay = - 1 ; static int burstLen = 100 ; static int DELAY_MULT = 1000 / burstLen ; static Category cat = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.Logging confFile runLength delay burstLen\n" + "        confFile is a configuration file and\n" + "        runLength (integer) is the length of test loop.\n" + "        delay is the time in millisecs to wait every bustLen log requests." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] , null , null ) ; else if ( argv . length == 4 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] , argv [ 3 ] ) ; else Usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; double delta ; String msg = "ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890" ; if ( delay <= 0 ) delta = NoDelayLoop ( cat , msg ) ; else delta = DelayedLoop ( cat , msg ) ; System . out . print ( ( int ) delta ) ; Category . getRoot ( ) . removeAllAppenders ( ) ; System . gc ( ) ; System . gc ( ) ; } static void init ( String configFile , String runLengthStr , String delayStr , String burstLenStr ) { try { runLength = Integer . parseInt ( runLengthStr ) ; if ( delayStr != null ) { delay = Integer . parseInt ( delayStr ) ; } if ( delayStr != null ) { burstLen = Integer . parseInt ( burstLenStr ) ; DELAY_MULT = 1000 / burstLen ; } } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; } DOMConfigurator . configure ( configFile ) ; } static double NoDelayLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double DelayedLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; int j = 0 ; Thread currentThread = Thread . currentThread ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; if ( j ++ == burstLen ) { j = 0 ; try { currentThread . sleep ( delay ) ; } catch ( Exception e ) { } } } double actualTime = ( ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ) ; System . out . println ( "actual time: " + actualTime ) ; return ( actualTime - delay * DELAY_MULT ) ; } } 	1	
package org . apache . log4j . net ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . TracerPrintWriter ; class SyslogTracerPrintWriter extends TracerPrintWriter { static String TAB = "    " ; SyslogTracerPrintWriter ( QuietWriter qWriter ) { super ( qWriter ) ; } public void println ( Object o ) { this . qWriter . write ( o . toString ( ) ) ; } public void println ( String s ) { this . qWriter . write ( TAB + s . substring ( 1 ) ) ; } } 	0	
package org . apache . log4j . helpers ; import java . util . Properties ; import java . net . URL ; import org . apache . log4j . Category ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . PropertyConfigurator ; public class OptionConverter { static String DELIM_START = "${" ; static char DELIM_STOP = '}' ; static int DELIM_START_LEN = 2 ; static int DELIM_STOP_LEN = 1 ; static StringBuffer sbuf = new StringBuffer ( ) ; private OptionConverter ( ) { } public static String [ ] concatanateArrays ( String [ ] l , String [ ] r ) { int len = l . length + r . length ; String [ ] a = new String [ len ] ; System . arraycopy ( l , 0 , a , 0 , l . length ) ; System . arraycopy ( r , 0 , a , l . length , r . length ) ; return a ; } public static String convertSpecialChars ( String s ) { char c ; int len = s . length ( ) ; StringBuffer sbuf = new StringBuffer ( len ) ; int i = 0 ; while ( i < len ) { c = s . charAt ( i ++ ) ; if ( c == '\\' ) { c = s . charAt ( i ++ ) ; if ( c == 'n' ) c = '\n' ; else if ( c == 'r' ) c = '\r' ; else if ( c == 't' ) c = '\t' ; else if ( c == 'f' ) c = '\f' ; else if ( c == '\b' ) c = '\b' ; else if ( c == '\"' ) c = '\"' ; else if ( c == '\'' ) c = '\'' ; else if ( c == '\\' ) c = '\\' ; } sbuf . append ( c ) ; } return sbuf . toString ( ) ; } public static Object instantiateByKey ( Properties props , String key , Class superClass , Object defaultValue ) { String className = props . getProperty ( key ) ; if ( className == null ) { LogLog . error ( "Could not find value for key " + key ) ; return defaultValue ; } return OptionConverter . instantiateByClassName ( className . trim ( ) , superClass , defaultValue ) ; } public static boolean toBoolean ( String value , boolean dEfault ) { if ( value == null ) return dEfault ; String trimmedVal = value . trim ( ) ; if ( "true" . equalsIgnoreCase ( trimmedVal ) ) return true ; if ( "false" . equalsIgnoreCase ( trimmedVal ) ) return false ; return dEfault ; } public static int toInt ( String value , int dEfault ) { if ( value != null ) { String s = value . trim ( ) ; try { return Integer . valueOf ( s ) . intValue ( ) ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; e . printStackTrace ( ) ; } } return dEfault ; } public static long toFileSize ( String value , long dEfault ) { if ( value == null ) return dEfault ; String s = value . trim ( ) . toUpperCase ( ) ; long multiplier = 1 ; int index ; if ( ( index = s . indexOf ( "KB" ) ) != - 1 ) { multiplier = 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "MB" ) ) != - 1 ) { multiplier = 1024 * 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "GB" ) ) != - 1 ) { multiplier = 1024 * 1024 * 1024 ; s = s . substring ( 0 , index ) ; } if ( s != null ) { try { return Long . valueOf ( s ) . longValue ( ) * multiplier ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; LogLog . error ( "[" + value + "] not in expected format." , e ) ; } } return dEfault ; } public static String findAndSubst ( String key , Properties props ) { String value = props . getProperty ( key ) ; if ( value == null ) return null ; try { return substVars ( value , props ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Bad option value [" + value + "]." , e ) ; return value ; } } public static Object instantiateByClassName ( String className , Class superClass , Object defaultValue ) { if ( className != null ) { try { Class classObj = Class . forName ( className ) ; if ( ! superClass . isAssignableFrom ( classObj ) ) LogLog . error ( "A \"" + className + "\" object is not assignable to a \"" + superClass . getName ( ) + "\" object." ) ; return classObj . newInstance ( ) ; } catch ( Exception e ) { LogLog . error ( "Could not instantiate class [" + className + "]." , e ) ; } } return defaultValue ; } public static String substVars ( String val , Properties props ) throws IllegalArgumentException { sbuf . setLength ( 0 ) ; int i = 0 ; int j , k ; while ( true ) { j = val . indexOf ( DELIM_START , i ) ; if ( j == - 1 ) { if ( i == 0 ) return val ; else { sbuf . append ( val . substring ( i , val . length ( ) ) ) ; return sbuf . toString ( ) ; } } else { sbuf . append ( val . substring ( i , j ) ) ; k = val . indexOf ( DELIM_STOP , j ) ; if ( k == - 1 ) { throw new IllegalArgumentException ( '"' + val + "\" has no closing brace. Opening brace at position " + j + '.' ) ; } else { j += DELIM_START_LEN ; String key = val . substring ( j , k ) ; String replacement = System . getProperty ( key ) ; if ( replacement == null && props != null ) { replacement = props . getProperty ( key ) ; } if ( replacement != null ) sbuf . append ( replacement ) ; i = k + DELIM_STOP_LEN ; } } } } static public void selectAndConfigure ( URL url ) { String clazz = url . getRef ( ) ; Configurator configurator = null ; if ( clazz != null ) { LogLog . debug ( "Preferred configurator class: " + clazz ) ; configurator = ( Configurator ) instantiateByClassName ( clazz , Configurator . class , null ) ; if ( configurator == null ) { LogLog . error ( "Could not instantiate configurator [" + clazz + "]." ) ; return ; } } else { String filename = url . getFile ( ) ; if ( filename != null && filename . endsWith ( ".xml" ) ) { configurator = new DOMConfigurator ( ) ; } else { configurator = new PropertyConfigurator ( ) ; } } configurator . doConfigure ( url , Category . defaultHierarchy ) ; } } 	1	
package org . apache . log4j . gui ; import java . awt . Color ; import java . awt . Image ; import java . awt . Toolkit ; import java . io . * ; import java . net . URL ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Hashtable ; import javax . swing . Icon ; import javax . swing . ImageIcon ; import javax . swing . JTextPane ; import javax . swing . text . BadLocationException ; import javax . swing . text . MutableAttributeSet ; import javax . swing . text . SimpleAttributeSet ; import javax . swing . text . StyleConstants ; import javax . swing . text . StyledDocument ; import javax . swing . text . TabSet ; import javax . swing . text . TabStop ; import org . apache . log4j . * ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . Loader ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . TracerPrintWriter ; import org . apache . log4j . helpers . OptionConverter ; public class TextPaneAppender extends AppenderSkeleton { JTextPane textpane ; StyledDocument doc ; TracerPrintWriter tp ; StringWriter sw ; QuietWriter qw ; Hashtable attributes ; Hashtable icons ; private String label ; private boolean fancy ; final String LABEL_OPTION = "Label" ; final String COLOR_OPTION_FATAL = "Color.Emerg" ; final String COLOR_OPTION_ERROR = "Color.Error" ; final String COLOR_OPTION_WARN = "Color.Warn" ; final String COLOR_OPTION_INFO = "Color.Info" ; final String COLOR_OPTION_DEBUG = "Color.Debug" ; final String COLOR_OPTION_BACKGROUND = "Color.Background" ; final String FANCY_OPTION = "Fancy" ; final String FONT_NAME_OPTION = "Font.Name" ; final String FONT_SIZE_OPTION = "Font.Size" ; public static Image loadIcon ( String path ) { Image img = null ; try { URL url = ClassLoader . getSystemResource ( path ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public TextPaneAppender ( Layout layout , String name ) { this ( ) ; this . layout = layout ; this . name = name ; setTextPane ( new JTextPane ( ) ) ; createAttributes ( ) ; createIcons ( ) ; } public TextPaneAppender ( ) { super ( ) ; setTextPane ( new JTextPane ( ) ) ; createAttributes ( ) ; createIcons ( ) ; this . label = "" ; this . sw = new StringWriter ( ) ; this . qw = new QuietWriter ( sw , errorHandler ) ; this . tp = new TracerPrintWriter ( qw ) ; this . fancy = true ; } public void close ( ) { } private void createAttributes ( ) { Priority prio [ ] = Priority . getAllPossiblePriorities ( ) ; attributes = new Hashtable ( ) ; for ( int i = 0 ; i < prio . length ; i ++ ) { MutableAttributeSet att = new SimpleAttributeSet ( ) ; attributes . put ( prio [ i ] , att ) ; StyleConstants . setFontSize ( att , 14 ) ; } StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . ERROR ) , Color . red ) ; StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . WARN ) , Color . orange ) ; StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . INFO ) , Color . gray ) ; StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . DEBUG ) , Color . black ) ; } private void createIcons ( ) { Priority prio [ ] = Priority . getAllPossiblePriorities ( ) ; icons = new Hashtable ( ) ; for ( int i = 0 ; i < prio . length ; i ++ ) { if ( prio [ i ] . equals ( Priority . FATAL ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/RedFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . ERROR ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/RedFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . WARN ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/BlueFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . INFO ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/GreenFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . DEBUG ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/GreenFlag.gif" ) ) ) ; } } public void append ( LoggingEvent event ) { String text = this . layout . format ( event ) ; String trace = "" ; if ( event . throwable != null ) { event . throwable . printStackTrace ( tp ) ; for ( int i = 0 ; i < sw . getBuffer ( ) . length ( ) ; i ++ ) { if ( sw . getBuffer ( ) . charAt ( i ) == '\t' ) sw . getBuffer ( ) . replace ( i , i + 1 , "        " ) ; } trace = sw . toString ( ) ; sw . getBuffer ( ) . delete ( 0 , sw . getBuffer ( ) . length ( ) ) ; } try { if ( fancy ) { textpane . setEditable ( true ) ; textpane . insertIcon ( ( ImageIcon ) icons . get ( event . priority ) ) ; textpane . setEditable ( false ) ; } doc . insertString ( doc . getLength ( ) , text + trace , ( MutableAttributeSet ) attributes . get ( event . priority ) ) ; } catch ( BadLocationException badex ) { System . err . println ( badex ) ; } textpane . setCaretPosition ( doc . getLength ( ) ) ; } public JTextPane getTextPane ( ) { return textpane ; } public String getLabel ( ) { return label ; } public String [ ] getOptionStrings ( ) { return new String [ ] { LABEL_OPTION , COLOR_OPTION_FATAL , COLOR_OPTION_ERROR , COLOR_OPTION_WARN , COLOR_OPTION_INFO , COLOR_OPTION_DEBUG , COLOR_OPTION_BACKGROUND , FANCY_OPTION , FONT_NAME_OPTION , FONT_SIZE_OPTION } ; } private Color parseColor ( String v ) { StringTokenizer st = new StringTokenizer ( v , "," ) ; int val [ ] = { 255 , 255 , 255 , 255 } ; int i = 0 ; while ( st . hasMoreTokens ( ) ) { val [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; i ++ ; } return new Color ( val [ 0 ] , val [ 1 ] , val [ 2 ] , val [ 3 ] ) ; } public void setLayout ( Layout layout ) { this . layout = layout ; } public void setName ( String name ) { this . name = name ; } public void setTextPane ( JTextPane textpane ) { this . textpane = textpane ; textpane . setEditable ( false ) ; textpane . setBackground ( Color . lightGray ) ; this . doc = textpane . getStyledDocument ( ) ; } private void setColor ( Priority p , String v ) { StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( p ) , parseColor ( v ) ) ; } private void setFontSize ( int size ) { Enumeration e = attributes . elements ( ) ; while ( e . hasMoreElements ( ) ) { StyleConstants . setFontSize ( ( MutableAttributeSet ) e . nextElement ( ) , size ) ; } return ; } private void setFontName ( String name ) { Enumeration e = attributes . elements ( ) ; while ( e . hasMoreElements ( ) ) { StyleConstants . setFontFamily ( ( MutableAttributeSet ) e . nextElement ( ) , name ) ; } return ; } public void setOption ( String option , String value ) { if ( option . equalsIgnoreCase ( LABEL_OPTION ) ) this . label = value ; if ( option . equalsIgnoreCase ( COLOR_OPTION_FATAL ) ) setColor ( Priority . FATAL , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_ERROR ) ) setColor ( Priority . ERROR , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_WARN ) ) setColor ( Priority . WARN , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_INFO ) ) setColor ( Priority . INFO , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_DEBUG ) ) setColor ( Priority . DEBUG , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_BACKGROUND ) ) textpane . setBackground ( parseColor ( value ) ) ; if ( option . equalsIgnoreCase ( FANCY_OPTION ) ) fancy = OptionConverter . toBoolean ( value , fancy ) ; if ( option . equalsIgnoreCase ( FONT_SIZE_OPTION ) ) setFontSize ( Integer . parseInt ( value ) ) ; if ( option . equalsIgnoreCase ( FONT_NAME_OPTION ) ) setFontName ( value ) ; return ; } public boolean requiresLayout ( ) { return true ; } } 	0	
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class CyclicBuffer { LoggingEvent [ ] ea ; int first ; int last ; int numElems ; int maxSize ; public CyclicBuffer ( int maxSize ) throws IllegalArgumentException { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; ea = new LoggingEvent [ maxSize ] ; first = 0 ; last = 0 ; numElems = 0 ; } public void add ( LoggingEvent event ) { ea [ last ] = event ; if ( ++ last == maxSize ) last = 0 ; if ( numElems < maxSize ) numElems ++ ; else if ( ++ first == maxSize ) first = 0 ; } public LoggingEvent get ( int i ) { if ( i < 0 || i >= numElems ) return null ; return ea [ ( first + i ) % maxSize ] ; } public int getMaxSize ( ) { return maxSize ; } public LoggingEvent get ( ) { LoggingEvent r = null ; if ( numElems > 0 ) { numElems -- ; r = ea [ first ] ; ea [ first ] = null ; if ( ++ first == maxSize ) first = 0 ; } return r ; } public int length ( ) { return numElems ; } public void resize ( int newSize ) { if ( newSize < 0 ) { throw new IllegalArgumentException ( "Negative array size [" + newSize + "] not allowed." ) ; } if ( newSize == numElems ) return ; LoggingEvent [ ] temp = new LoggingEvent [ newSize ] ; int loopLen = newSize < numElems ? newSize : numElems ; for ( int i = 0 ; i < loopLen ; i ++ ) { temp [ i ] = ea [ first ] ; ea [ first ] = null ; if ( ++ first == numElems ) first = 0 ; } ea = temp ; first = 0 ; numElems = loopLen ; maxSize = newSize ; } } 	1	
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressAsyncAppender extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int BRANCHING_FACTOR = 4 ; static int maxThreads ; static long msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { if ( args . length != 1 ) { usage ( ) ; } DOMConfigurator . configure ( "stressAsyncAppender.xml" ) ; try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java " + StressAsyncAppender . class . getName ( ) + " MAX_THREADS" ) ; System . exit ( 1 ) ; } public StressAsyncAppender ( ) { } public void run ( ) { int loopLength = StressAsyncAppender . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop, loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; synchronized ( lock ) { root . debug ( "Message number " + msgCounter ++ ) ; } } synchronized ( lock ) { StressAsyncAppender . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressAsyncAppender . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstrained ( n ) ; root . debug ( "Creating " + n + " child StressAsyncAppender threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressAsyncAppender, threadCounter = " + ( ++ threadCounter ) ) ; new StressAsyncAppender ( ) . start ( ) ; } } } static public int maxThreadsConstrained ( int a ) { int maxAllowed = StressAsyncAppender . maxThreads - StressAsyncAppender . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public void delay ( long millis ) { try { Thread . currentThread ( ) . sleep ( millis ) ; } catch ( Exception e ) { } } } 	0	
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . BoundedFIFO ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import org . apache . log4j . helpers . LogLog ; import java . util . Enumeration ; public class AsyncAppender extends AppenderSkeleton implements AppenderAttachable { public static final String LOCATION_INFO_OPTION = "LocationInfo" ; static final int BUFFER_SIZE = 128 ; BoundedFIFO bf = new BoundedFIFO ( BUFFER_SIZE ) ; AppenderAttachableImpl aai ; Dispatcher dispatcher ; boolean locationInfo = false ; public AsyncAppender ( ) { aai = new AppenderAttachableImpl ( ) ; dispatcher = new Dispatcher ( bf , aai ) ; dispatcher . start ( ) ; } synchronized public void addAppender ( Appender newAppender ) { aai . addAppender ( newAppender ) ; } public void append ( LoggingEvent event ) { event . getNDC ( ) ; event . getThreadName ( ) ; if ( locationInfo ) { event . setLocationInformation ( ) ; } synchronized ( bf ) { if ( bf . isFull ( ) ) { try { bf . wait ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "AsyncAppender cannot be interrupted." , e ) ; } } bf . put ( event ) ; if ( bf . wasEmpty ( ) ) { bf . notify ( ) ; } } } public void close ( ) { closed = true ; dispatcher . interrupt ( ) ; try { dispatcher . join ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "Got an InterruptedException while waiting for the " + "dispatcher to finish." , e ) ; } dispatcher = null ; bf = null ; } public Enumeration getAllAppenders ( ) { return aai . getAllAppenders ( ) ; } public Appender getAppender ( String name ) { return aai . getAppender ( name ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { LOCATION_INFO_OPTION } ) ; } public boolean requiresLayout ( ) { return false ; } synchronized public void removeAllAppenders ( ) { aai . removeAllAppenders ( ) ; } synchronized public void removeAppender ( Appender appender ) { aai . removeAppender ( appender ) ; } synchronized public void removeAppender ( String name ) { aai . removeAppender ( name ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } class Dispatcher extends Thread { BoundedFIFO bf ; AppenderAttachableImpl aai ; Dispatcher ( BoundedFIFO bf , AppenderAttachableImpl aai ) { this . bf = bf ; this . aai = aai ; this . setPriority ( Thread . MIN_PRIORITY ) ; } public void run ( ) { LoggingEvent event ; while ( true ) { synchronized ( bf ) { if ( bf . length ( ) == 0 ) { if ( interrupted ( ) ) { return ; } try { bf . wait ( ) ; } catch ( InterruptedException e ) { break ; } } event = bf . get ( ) ; if ( bf . wasFull ( ) ) { bf . notify ( ) ; } } if ( aai != null ) aai . appendLoopOnAppenders ( event ) ; } } } 	1	
package org . apache . log4j . performance ; public class SystemTime { static int RUN_LENGTH = 1000000 ; static public void main ( String [ ] args ) { double t = systemCurrentTimeLoop ( ) ; System . out . println ( "Average System.currentTimeMillis() call took " + t ) ; t = currentThreadNameloop ( ) ; System . out . println ( "Average Thread.currentThread().getName() call took " + t ) ; } static double systemCurrentTimeLoop ( ) { long before = System . currentTimeMillis ( ) ; long l ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { l = System . currentTimeMillis ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double currentThreadNameloop ( ) { long before = System . currentTimeMillis ( ) ; String t ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { t = Thread . currentThread ( ) . getName ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	
package org . apache . log4j . varia ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; public class PriorityMatchFilter extends Filter { public static final String PRIORITY_TO_MATCH_OPTION = "PriorityToMatch" ; public static final String ACCEPT_ON_MATCH_OPTION = "AcceptOnMatch" ; boolean acceptOnMatch = true ; Priority priorityToMatch ; public int decide ( LoggingEvent event ) { if ( this . priorityToMatch == null ) { return Filter . NEUTRAL ; } boolean matchOccured = false ; if ( this . priorityToMatch == event . priority ) { matchOccured = true ; } if ( this . acceptOnMatch ^ matchOccured ) { return Filter . DENY ; } else { return Filter . ACCEPT ; } } public String [ ] getOptionStrings ( ) { return new String [ ] { PRIORITY_TO_MATCH_OPTION , ACCEPT_ON_MATCH_OPTION } ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( PRIORITY_TO_MATCH_OPTION ) ) { priorityToMatch = Priority . toPriority ( value , null ) ; } else if ( key . equalsIgnoreCase ( ACCEPT_ON_MATCH_OPTION ) ) { acceptOnMatch = OptionConverter . toBoolean ( value , acceptOnMatch ) ; } } } 	1	
package org . apache . log4j . or ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . LogLog ; import javax . jms . Message ; import javax . jms . JMSException ; import javax . jms . DeliveryMode ; import java . util . Enumeration ; public class MessageRenderer implements ObjectRenderer { public MessageRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof Message ) { StringBuffer sbuf = new StringBuffer ( ) ; Message m = ( Message ) o ; try { sbuf . append ( "DeliveryMode=" ) ; switch ( m . getJMSDeliveryMode ( ) ) { case DeliveryMode . NON_PERSISTENT : sbuf . append ( "NON_PERSISTENT" ) ; break ; case DeliveryMode . PERSISTENT : sbuf . append ( "PERSISTENT" ) ; break ; default : sbuf . append ( "UNKNOWN" ) ; } sbuf . append ( ", CorrelationID=" ) ; sbuf . append ( m . getJMSCorrelationID ( ) ) ; sbuf . append ( ", Destination=" ) ; sbuf . append ( m . getJMSDestination ( ) ) ; sbuf . append ( ", Expiration=" ) ; sbuf . append ( m . getJMSExpiration ( ) ) ; sbuf . append ( ", MessageID=" ) ; sbuf . append ( m . getJMSMessageID ( ) ) ; sbuf . append ( ", Priority=" ) ; sbuf . append ( m . getJMSPriority ( ) ) ; sbuf . append ( ", Redelivered=" ) ; sbuf . append ( m . getJMSRedelivered ( ) ) ; sbuf . append ( ", ReplyTo=" ) ; sbuf . append ( m . getJMSReplyTo ( ) ) ; sbuf . append ( ", Timestamp=" ) ; sbuf . append ( m . getJMSTimestamp ( ) ) ; sbuf . append ( ", Type=" ) ; sbuf . append ( m . getJMSType ( ) ) ; } catch ( JMSException e ) { LogLog . error ( "Could not parse Message." , e ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . NDC ; import org . apache . log4j . helpers . PatternParser ; import org . apache . log4j . helpers . PatternConverter ; import org . apache . log4j . helpers . OptionConverter ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import java . util . Vector ; import java . text . FieldPosition ; public class PatternLayout extends Layout { final static public String CONVERSION_PATTERN_OPTION = "ConversionPattern" ; public final static String DEFAULT_CONVERSION_PATTERN = "%m\n" ; public final static String TTCC_CONVERSION_PATTERN = "%r [%t] %p %c %x - %m%n" ; protected final int BUF_SIZE = 256 ; protected final int MAX_CAPACITY = 1024 ; private StringBuffer sbuf = new StringBuffer ( BUF_SIZE ) ; private PatternConverter head ; private String timezone ; public PatternLayout ( ) { this ( DEFAULT_CONVERSION_PATTERN ) ; } public PatternLayout ( String pattern ) { head = createPatternParser ( ( pattern == null ) ? DEFAULT_CONVERSION_PATTERN : pattern ) . parse ( ) ; } public void activateOptions ( ) { } protected PatternParser createPatternParser ( String pattern ) { return new PatternParser ( pattern ) ; } public String format ( LoggingEvent event ) { if ( sbuf . capacity ( ) > MAX_CAPACITY ) { sbuf = new StringBuffer ( BUF_SIZE ) ; } else { sbuf . setLength ( 0 ) ; } PatternConverter c = head ; while ( c != null ) { c . format ( sbuf , event ) ; c = c . next ; } return sbuf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return new String [ ] { CONVERSION_PATTERN_OPTION } ; } public boolean ignoresThrowable ( ) { return true ; } public void setConversionPattern ( String conversionPattern ) { setOption ( CONVERSION_PATTERN_OPTION , conversionPattern ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; if ( option . equalsIgnoreCase ( CONVERSION_PATTERN_OPTION ) ) { head = createPatternParser ( value ) . parse ( ) ; } } } 	1	
package org . apache . log4j . helpers ; import java . io . Writer ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import java . io . IOException ; public class SyslogWriter extends Writer { final int SYSLOG_PORT = 514 ; static String syslogHost ; private InetAddress address ; private DatagramSocket ds ; public SyslogWriter ( String syslogHost ) { this . syslogHost = syslogHost ; try { this . address = InetAddress . getByName ( syslogHost ) ; } catch ( UnknownHostException e ) { LogLog . error ( "Could not find " + syslogHost + ". All logging will FAIL." , e ) ; } try { this . ds = new DatagramSocket ( ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; LogLog . error ( "Could not instantiate DatagramSocket to " + syslogHost + ". All logging will FAIL." , e ) ; } } public void write ( char [ ] buf , int off , int len ) throws IOException { this . write ( new String ( buf , off , len ) ) ; } public void write ( String string ) throws IOException { DatagramPacket packet = new DatagramPacket ( string . getBytes ( ) , string . length ( ) , address , SYSLOG_PORT ) ; if ( this . ds != null ) ds . send ( packet ) ; } public void flush ( ) { } public void close ( ) { } } 	0	
package org . apache . log4j . helpers ; import java . io . File ; import org . apache . log4j . helpers . LogLog ; public abstract class FileWatchdog extends Thread { static final public long DEFAULT_DELAY = 60000 ; protected String filename ; protected long delay = DEFAULT_DELAY ; File file ; long lastModif = 0 ; boolean warnedAlready = false ; protected FileWatchdog ( String filename ) { this . filename = filename ; file = new File ( filename ) ; setDaemon ( true ) ; checkAndConfigure ( ) ; } public void setDelay ( long delay ) { this . delay = delay ; } abstract protected void doOnChange ( ) ; protected void checkAndConfigure ( ) { if ( file . exists ( ) ) { long l = file . lastModified ( ) ; if ( l > lastModif ) { lastModif = l ; doOnChange ( ) ; warnedAlready = false ; } } else { if ( ! warnedAlready ) { LogLog . debug ( "[" + filename + "] does not exist." ) ; warnedAlready = true ; } } } public void run ( ) { while ( ! interrupted ( ) ) { try { Thread . currentThread ( ) . sleep ( delay ) ; } catch ( InterruptedException e ) { } checkAndConfigure ( ) ; } } } 	1	
package org . apache . log4j . performance ; import java . io . Writer ; import java . io . IOException ; public class NOPWriter extends Writer { public void write ( char [ ] cbuf ) throws IOException { } public void write ( char [ ] cbuf , int off , int len ) throws IOException { } public void write ( int b ) throws IOException { } public void write ( String s ) throws IOException { } public void write ( String s , int off , int len ) throws IOException { } public void flush ( ) throws IOException { } public void close ( ) throws IOException { System . err . println ( "Close called." ) ; } } 	0	
package org . apache . log4j ; import java . util . Hashtable ; import java . util . Enumeration ; import org . apache . log4j . spi . RootCategory ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . or . ObjectRenderer ; public class Hierarchy { static private CategoryFactory defaultFactory = new DefaultCategoryFactory ( ) ; Hashtable ht ; Category root ; RendererMap rendererMap ; public Hierarchy ( Category root ) { ht = new Hashtable ( ) ; this . root = root ; this . root . myContext = this ; rendererMap = new RendererMap ( ) ; } public void addRenderer ( Class classToRender , ObjectRenderer or ) { rendererMap . put ( classToRender , or ) ; } public void clear ( ) { ht . clear ( ) ; } public Category exists ( String name ) { Object o = ht . get ( new CategoryKey ( name ) ) ; if ( o instanceof Category ) { return ( Category ) o ; } else { return null ; } } public Category getInstance ( String name ) { return getInstance ( name , defaultFactory ) ; } public Category getInstance ( String name , CategoryFactory factory ) { CategoryKey key = new CategoryKey ( name ) ; Category category ; synchronized ( ht ) { Object o = ht . get ( key ) ; if ( o == null ) { category = factory . makeNewCategoryInstance ( name ) ; category . setHierarchy ( this ) ; ht . put ( key , category ) ; updateParents ( category ) ; return category ; } else if ( o instanceof Category ) { return ( Category ) o ; } else if ( o instanceof ProvisionNode ) { category = factory . makeNewCategoryInstance ( name ) ; ht . put ( key , category ) ; updateChildren ( ( ProvisionNode ) o , category ) ; updateParents ( category ) ; return category ; } else { return null ; } } } public RendererMap getRendererMap ( ) { return rendererMap ; } public Category getRoot ( ) { return root ; } final private void updateParents ( Category cat ) { String name = cat . name ; int length = name . length ( ) ; boolean parentFound = false ; for ( int i = name . lastIndexOf ( '.' , length - 1 ) ; i >= 0 ; i = name . lastIndexOf ( '.' , i - 1 ) ) { String substr = name . substring ( 0 , i ) ; CategoryKey key = new CategoryKey ( substr ) ; Object o = ht . get ( key ) ; if ( o == null ) { ProvisionNode pn = new ProvisionNode ( cat ) ; ht . put ( key , pn ) ; } else if ( o instanceof Category ) { parentFound = true ; cat . parent = ( Category ) o ; break ; } else if ( o instanceof ProvisionNode ) { ( ( ProvisionNode ) o ) . addElement ( cat ) ; } else { Exception e = new IllegalStateException ( "unexpected object type " + o . getClass ( ) + " in ht." ) ; e . printStackTrace ( ) ; } } if ( ! parentFound ) cat . parent = root ; } final private void updateChildren ( ProvisionNode pn , Category cat ) { final int last = pn . size ( ) ; childLoop : for ( int i = 0 ; i < last ; i ++ ) { Category c = ( Category ) pn . elementAt ( i ) ; if ( c . parent != null && c . parent . name . startsWith ( cat . name ) ) { continue childLoop ; } while ( c . parent != null && c . parent . name . startsWith ( cat . name ) ) { c = c . parent ; } cat . parent = c . parent ; c . parent = cat ; } } public void shutdown ( ) { Category root = getRoot ( ) ; root . closeNestedAppenders ( ) ; synchronized ( ht ) { Enumeration cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . closeNestedAppenders ( ) ; } root . removeAllAppenders ( ) ; cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . removeAllAppenders ( ) ; } } } } 	1	
package org . apache . log4j . xml . test ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . xml . test . TPriority ; public class TCategory extends Category implements OptionHandler { private static TFactory factory = new TFactory ( ) ; static String instanceFQCN = TCategory . class . getName ( ) ; public static final String SUFFIX_OPTION = "Suffix" ; String suffix ; public TCategory ( String name ) { super ( name ) ; } public void activateOptions ( ) { } public void debug ( String message ) { log ( instanceFQCN , Priority . DEBUG , message + suffix , null ) ; } public static Category getInstance ( String name ) { return Category . getInstance ( name , factory ) ; } public String [ ] getOptionStrings ( ) { return ( new String [ ] { SUFFIX_OPTION } ) ; } public void setOption ( String option , String value ) { System . out . println ( option + "=" + value ) ; if ( option == null ) { return ; } if ( option . equalsIgnoreCase ( SUFFIX_OPTION ) ) { this . suffix = value ; System . out . println ( "Setting suffix to" + suffix ) ; } } public void trace ( String message ) { if ( disable <= TPriority . TRACE_INT ) return ; if ( TPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , TPriority . TRACE , message , null ) ) ; } public void trace ( String message , Exception e ) { if ( disable <= TPriority . TRACE_INT ) return ; if ( TPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , TPriority . TRACE , message , e ) ) ; } private static class TFactory implements CategoryFactory { TFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new TCategory ( name ) ; } } } 	0	
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; import org . apache . log4j . Priority ; import java . io . IOException ; import java . util . Enumeration ; public class Shallow { static Category cat = Category . getInstance ( Shallow . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Shallow . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; NDC . push ( "NDC" ) ; Category root = Category . getRoot ( ) ; cat . debug ( "Message " + ++ i ) ; root . debug ( "Message " + i ) ; cat . info ( "Message " + ++ i ) ; root . info ( "Message " + i ) ; cat . warn ( "Message " + ++ i ) ; root . warn ( "Message " + i ) ; cat . error ( "Message " + ++ i ) ; root . error ( "Message " + i ) ; cat . log ( Priority . FATAL , "Message " + ++ i ) ; root . log ( Priority . FATAL , "Message " + i ) ; Exception e = new Exception ( "Just testing" ) ; cat . debug ( "Message " + ++ i , e ) ; root . debug ( "Message " + i , e ) ; cat . info ( "Message " + ++ i , e ) ; root . info ( "Message " + i , e ) ; cat . warn ( "Message " + ++ i , e ) ; root . warn ( "Message " + i , e ) ; cat . error ( "Message " + ++ i , e ) ; root . error ( "Message " + i , e ) ; cat . log ( Priority . FATAL , "Message " + ++ i , e ) ; root . log ( Priority . FATAL , "Message " + i , e ) ; Category . shutdown ( ) ; System . gc ( ) ; } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	1	
