package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . ZipOutputStream ; import java . io . File ; import java . io . IOException ; public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { setDestFile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "WEB-INF/web.xml" ) ; super . addFileset ( fs ) ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "webxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "WEB-INF/web.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a WEB-INF/web.xml which will be ignored " + "(please use webxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	1	
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import java . net . MalformedURLException ; import java . net . HttpURLConnection ; import java . net . URLConnection ; import java . net . URL ; public class Http extends ProjectComponent implements Condition { private String spec = null ; public void setUrl ( String url ) { spec = url ; } private int errorsBeginAt = 400 ; public void SetErrorsBeginAt ( int errorsBeginAt ) { this . errorsBeginAt = errorsBeginAt ; } public boolean eval ( ) throws BuildException { if ( spec == null ) { throw new BuildException ( "No url specified in http condition" ) ; } log ( "Checking for " + spec , Project . MSG_VERBOSE ) ; try { URL url = new URL ( spec ) ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpURLConnection ) { HttpURLConnection http = ( HttpURLConnection ) conn ; int code = http . getResponseCode ( ) ; log ( "Result code for " + spec + " was " + code , Project . MSG_VERBOSE ) ; if ( code > 0 && code < errorsBeginAt ) { return true ; } else { return false ; } } } catch ( java . io . IOException e ) { return false ; } } catch ( MalformedURLException e ) { throw new BuildException ( "Badly formed URL: " + spec , e ) ; } return true ; } } 	1	
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileUtils ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class FixCRLF extends MatchingTask { private static final int UNDEF = - 1 ; private static final int NOTJAVA = 0 ; private static final int LOOKING = 1 ; private static final int IN_CHAR_CONST = 2 ; private static final int IN_STR_CONST = 3 ; private static final int IN_SINGLE_COMMENT = 4 ; private static final int IN_MULTI_COMMENT = 5 ; private static final int ASIS = 0 ; private static final int CR = 1 ; private static final int LF = 2 ; private static final int CRLF = 3 ; private static final int ADD = 1 ; private static final int REMOVE = - 1 ; private static final int SPACES = - 1 ; private static final int TABS = 1 ; private static final int INBUFLEN = 8192 ; private static final int LINEBUFLEN = 200 ; private static final char CTRLZ = '' ; private int tablength = 8 ; private String spaces = "        " ; private StringBuffer linebuf = new StringBuffer ( 1024 ) ; private StringBuffer linebuf2 = new StringBuffer ( 1024 ) ; private int eol ; private String eolstr ; private int ctrlz ; private int tabs ; private boolean javafiles = false ; private File srcDir ; private File destDir = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private String encoding = null ; public FixCRLF ( ) { tabs = ASIS ; if ( Os . isFamily ( "mac" ) ) { ctrlz = REMOVE ; eol = CR ; eolstr = "\r" ; } else if ( Os . isFamily ( "dos" ) ) { ctrlz = ASIS ; eol = CRLF ; eolstr = "\r\n" ; } else { ctrlz = REMOVE ; eol = LF ; eolstr = "\n" ; } } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setJavafiles ( boolean javafiles ) { this . javafiles = javafiles ; } public void setEol ( CrLf attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "asis" ) ) { eol = ASIS ; } else if ( option . equals ( "cr" ) ) { eol = CR ; eolstr = "\r" ; } else if ( option . equals ( "lf" ) ) { eol = LF ; eolstr = "\n" ; } else { eol = CRLF ; eolstr = "\r\n" ; } } public void setCr ( AddAsisRemove attr ) { log ( "DEPRECATED: The cr attribute has been deprecated," , Project . MSG_WARN ) ; log ( "Please use the eol attribute instead" , Project . MSG_WARN ) ; String option = attr . getValue ( ) ; CrLf c = new CrLf ( ) ; if ( option . equals ( "remove" ) ) { c . setValue ( "lf" ) ; } else if ( option . equals ( "asis" ) ) { c . setValue ( "asis" ) ; } else { c . setValue ( "crlf" ) ; } setEol ( c ) ; } public void setTab ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { tabs = SPACES ; } else if ( option . equals ( "asis" ) ) { tabs = ASIS ; } else { tabs = TABS ; } } public void setTablength ( int tlength ) throws BuildException { if ( tlength < 2 || tlength > 80 ) { throw new BuildException ( "tablength must be between 2 and 80" , location ) ; } tablength = tlength ; StringBuffer sp = new StringBuffer ( ) ; for ( int i = 0 ; i < tablength ; i ++ ) { sp . append ( ' ' ) ; } spaces = sp . toString ( ) ; } public void setEof ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { ctrlz = REMOVE ; } else if ( option . equals ( "asis" ) ) { ctrlz = ASIS ; } else { ctrlz = ADD ; } } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void execute ( ) throws BuildException { if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } log ( "options:" + " eol=" + ( eol == ASIS ? "asis" : eol == CR ? "cr" : eol == LF ? "lf" : "crlf" ) + " tab=" + ( tabs == TABS ? "add" : tabs == ASIS ? "asis" : "remove" ) + " eof=" + ( ctrlz == ADD ? "add" : ctrlz == ASIS ? "asis" : "remove" ) + " tablength=" + tablength + " encoding=" + ( encoding == null ? "default" : encoding ) , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { processFile ( files [ i ] ) ; } } private Reader getReader ( File f ) throws IOException { return ( encoding == null ) ? new FileReader ( f ) : new InputStreamReader ( new FileInputStream ( f ) , encoding ) ; } private void processFile ( String file ) throws BuildException { File srcFile = new File ( srcDir , file ) ; File destD = destDir == null ? srcDir : destDir ; File tmpFile = null ; BufferedWriter outWriter ; OneLiner . BufferLine line ; OneLiner lines = new OneLiner ( srcFile ) ; try { try { tmpFile = fileUtils . createTempFile ( "fixcrlf" , "" , destD ) ; Writer writer = ( encoding == null ) ? new FileWriter ( tmpFile ) : new OutputStreamWriter ( new FileOutputStream ( tmpFile ) , encoding ) ; outWriter = new BufferedWriter ( writer ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } while ( lines . hasMoreElements ( ) ) { int endComment ; try { line = ( OneLiner . BufferLine ) lines . nextElement ( ) ; } catch ( NoSuchElementException e ) { throw new BuildException ( e ) ; } String lineString = line . getLineString ( ) ; int linelen = line . length ( ) ; if ( tabs == ASIS ) { try { outWriter . write ( lineString ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int ptr ; while ( ( ptr = line . getNext ( ) ) < linelen ) { switch ( lines . getState ( ) ) { case NOTJAVA : notInConstant ( line , line . length ( ) , outWriter ) ; break ; case IN_MULTI_COMMENT : endComment = lineString . indexOf ( "*/" , line . getNext ( ) ) ; if ( endComment >= 0 ) { endComment += 2 ; lines . setState ( LOOKING ) ; } else { endComment = linelen ; } notInConstant ( line , endComment , outWriter ) ; break ; case IN_SINGLE_COMMENT : notInConstant ( line , line . length ( ) , outWriter ) ; lines . setState ( LOOKING ) ; break ; case IN_CHAR_CONST : case IN_STR_CONST : int begin = line . getNext ( ) ; char terminator = ( lines . getState ( ) == IN_STR_CONST ? '\"' : '\'' ) ; endOfCharConst ( line , terminator ) ; while ( line . getNext ( ) < line . getLookahead ( ) ) { if ( line . getNextCharInc ( ) == '\t' ) { line . setColumn ( line . getColumn ( ) + tablength - ( line . getColumn ( ) % tablength ) ) ; } else { line . incColumn ( ) ; } } try { outWriter . write ( line . substring ( begin , line . getNext ( ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } lines . setState ( LOOKING ) ; break ; case LOOKING : nextStateChange ( line ) ; notInConstant ( line , line . getLookahead ( ) , outWriter ) ; break ; } } } try { outWriter . write ( eolstr ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { if ( ctrlz == ASIS ) { outWriter . write ( lines . getEofStr ( ) ) ; } else if ( ctrlz == ADD ) { outWriter . write ( CTRLZ ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { outWriter . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { lines . close ( ) ; lines = null ; } catch ( IOException e ) { throw new BuildException ( "Unable to close source file " + srcFile ) ; } File destFile = new File ( destD , file ) ; if ( destFile . exists ( ) ) { log ( "destFile exists" , Project . MSG_DEBUG ) ; if ( ! fileUtils . contentEquals ( destFile , tmpFile ) ) { log ( destFile + " is being written" , Project . MSG_DEBUG ) ; if ( ! destFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + destFile ) ; } if ( ! tmpFile . renameTo ( destFile ) ) { throw new BuildException ( "Failed to transform " + srcFile + " to " + destFile + ". Couldn't rename temporary file: " + tmpFile ) ; } } else { log ( destFile + " is not written, as the contents are identical" , Project . MSG_DEBUG ) ; if ( ! tmpFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + tmpFile ) ; } } } else { log ( "destFile does not exist" , Project . MSG_DEBUG ) ; if ( ! tmpFile . renameTo ( destFile ) ) { throw new BuildException ( "Failed to transform " + srcFile + " to " + destFile + ". Couldn't rename temporary file: " + tmpFile ) ; } } tmpFile = null ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { if ( lines != null ) { lines . close ( ) ; } } catch ( IOException io ) { log ( "Error closing " + srcFile , Project . MSG_ERR ) ; } if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private void nextStateChange ( OneLiner . BufferLine bufline ) throws BuildException { int eol = bufline . length ( ) ; int ptr = bufline . getNext ( ) ; while ( ptr < eol ) { switch ( bufline . getChar ( ptr ++ ) ) { case '\'' : bufline . setState ( IN_CHAR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '\"' : bufline . setState ( IN_STR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '/' : if ( ptr < eol ) { if ( bufline . getChar ( ptr ) == '*' ) { bufline . setState ( IN_MULTI_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } else if ( bufline . getChar ( ptr ) == '/' ) { bufline . setState ( IN_SINGLE_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } } break ; } } bufline . setLookahead ( ptr ) ; } private void endOfCharConst ( OneLiner . BufferLine bufline , char terminator ) throws BuildException { int ptr = bufline . getNext ( ) ; int eol = bufline . length ( ) ; char c ; ptr ++ ; while ( ptr < eol ) { if ( ( c = bufline . getChar ( ptr ++ ) ) == '\\' ) { ptr ++ ; } else { if ( c == terminator ) { bufline . setLookahead ( ptr ) ; return ; } } } throw new BuildException ( "endOfCharConst: unterminated char constant" ) ; } private void notInConstant ( OneLiner . BufferLine bufline , int end , BufferedWriter outWriter ) { int nextTab ; int nextStop ; int tabspaces ; String line = bufline . substring ( bufline . getNext ( ) , end ) ; int place = 0 ; int col = bufline . getColumn ( ) ; linebuf . setLength ( 0 ) ; while ( ( nextTab = line . indexOf ( ( int ) '\t' , place ) ) >= 0 ) { linebuf . append ( line . substring ( place , nextTab ) ) ; col += nextTab - place ; tabspaces = tablength - ( col % tablength ) ; linebuf . append ( spaces . substring ( 0 , tabspaces ) ) ; col += tabspaces ; place = nextTab + 1 ; } linebuf . append ( line . substring ( place , line . length ( ) ) ) ; String linestring = new String ( linebuf . toString ( ) ) ; if ( tabs == REMOVE ) { try { outWriter . write ( linestring ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int tabCol ; linebuf2 . setLength ( 0 ) ; place = 0 ; col = bufline . getColumn ( ) ; int placediff = col - 0 ; nextStop = col + ( tablength - col % tablength ) ; if ( nextStop - col < 2 ) { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; place = nextStop - placediff ; nextStop += tablength ; } for ( ; nextStop - placediff <= linestring . length ( ) ; nextStop += tablength ) { for ( tabCol = nextStop ; -- tabCol - placediff >= place && linestring . charAt ( tabCol - placediff ) == ' ' ; ) { ; } if ( nextStop - tabCol > 2 ) { linebuf2 . append ( linestring . substring ( place , ++ tabCol - placediff ) ) ; linebuf2 . append ( '\t' ) ; } else { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; } place = nextStop - placediff ; } linebuf2 . append ( linestring . substring ( place , linestring . length ( ) ) ) ; try { outWriter . write ( linebuf2 . toString ( ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } bufline . setColumn ( bufline . getColumn ( ) + linestring . length ( ) ) ; bufline . setNext ( end ) ; } class OneLiner implements Enumeration { private int state = javafiles ? LOOKING : NOTJAVA ; private StringBuffer eolStr = new StringBuffer ( LINEBUFLEN ) ; private StringBuffer eofStr = new StringBuffer ( ) ; private BufferedReader reader ; private StringBuffer line = new StringBuffer ( ) ; private boolean reachedEof = false ; public OneLiner ( File srcFile ) throws BuildException { try { reader = new BufferedReader ( getReader ( srcFile ) , INBUFLEN ) ; nextLine ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected void nextLine ( ) throws BuildException { int ch = - 1 ; int eolcount = 0 ; eolStr . setLength ( 0 ) ; line . setLength ( 0 ) ; try { ch = reader . read ( ) ; while ( ch != - 1 && ch != '\r' && ch != '\n' ) { line . append ( ( char ) ch ) ; ch = reader . read ( ) ; } if ( ch == - 1 && line . length ( ) == 0 ) { reachedEof = true ; return ; } switch ( ( char ) ch ) { case '\r' : ++ eolcount ; eolStr . append ( '\r' ) ; reader . mark ( 2 ) ; switch ( ( ch = reader . read ( ) ) ) { case '\r' : if ( ( char ) ( ch = reader . read ( ) ) == '\n' ) { eolcount += 2 ; eolStr . append ( "\r\n" ) ; } else { reader . reset ( ) ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; case - 1 : break ; default : reader . reset ( ) ; break ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; } if ( eolcount == 0 ) { int i = line . length ( ) ; while ( -- i >= 0 && line . charAt ( i ) == CTRLZ ) { } if ( i < line . length ( ) - 1 ) { eofStr . append ( line . toString ( ) . substring ( i + 1 ) ) ; if ( i < 0 ) { line . setLength ( 0 ) ; reachedEof = true ; } else { line . setLength ( i + 1 ) ; } } } } catch ( IOException e ) { throw new BuildException ( e ) ; } } public String getEofStr ( ) { return eofStr . toString ( ) ; } public int getState ( ) { return state ; } public void setState ( int state ) { this . state = state ; } public boolean hasMoreElements ( ) { return ! reachedEof ; } public Object nextElement ( ) throws NoSuchElementException { if ( ! hasMoreElements ( ) ) { throw new NoSuchElementException ( "OneLiner" ) ; } BufferLine tmpLine = new BufferLine ( line . toString ( ) , eolStr . toString ( ) ) ; nextLine ( ) ; return tmpLine ; } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } class BufferLine { private int next = 0 ; private int column = 0 ; private int lookahead = UNDEF ; private String line ; private String eolStr ; public BufferLine ( String line , String eolStr ) throws BuildException { next = 0 ; column = 0 ; this . line = line ; this . eolStr = eolStr ; } public int getNext ( ) { return next ; } public void setNext ( int next ) { this . next = next ; } public int getLookahead ( ) { return lookahead ; } public void setLookahead ( int lookahead ) { this . lookahead = lookahead ; } public char getChar ( int i ) { return line . charAt ( i ) ; } public char getNextChar ( ) { return getChar ( next ) ; } public char getNextCharInc ( ) { return getChar ( next ++ ) ; } public int getColumn ( ) { return column ; } public void setColumn ( int col ) { column = col ; } public int incColumn ( ) { return column ++ ; } public int length ( ) { return line . length ( ) ; } public int getEolLength ( ) { return eolStr . length ( ) ; } public String getLineString ( ) { return line ; } public String getEol ( ) { return eolStr ; } public String substring ( int begin ) { return line . substring ( begin ) ; } public String substring ( int begin , int end ) { return line . substring ( begin , end ) ; } public void setState ( int state ) { OneLiner . this . setState ( state ) ; } public int getState ( ) { return OneLiner . this . getState ( ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } public static class CrLf extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" } ; } } } 	1	
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Vector ; public class XmlProperty extends org . apache . tools . ant . Task { private File src ; private String prefix = "" ; private boolean keepRoot = true ; private boolean validate = false ; private boolean collapseAttributes = false ; private org . w3c . dom . Document document ; public XmlProperty ( ) { super ( ) ; } public void init ( ) { super . init ( ) ; } public void execute ( ) throws BuildException { BufferedInputStream configurationStream = null ; try { configurationStream = new BufferedInputStream ( new FileInputStream ( src ) ) ; DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setValidating ( validate ) ; factory . setNamespaceAware ( false ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; document = builder . parse ( configurationStream ) ; Element topElement = document . getDocumentElement ( ) ; NodeList topChildren = topElement . getChildNodes ( ) ; int numChildren = topChildren . getLength ( ) ; log ( "Using prefix: \"" + prefix + "\"" , Project . MSG_DEBUG ) ; if ( keepRoot ) { addNodeRecursively ( topElement , prefix ) ; } else { for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( topChildren . item ( i ) , prefix ) ; } } } catch ( SAXException sxe ) { Exception x = sxe ; if ( sxe . getException ( ) != null ) x = sxe . getException ( ) ; throw new BuildException ( x ) ; } catch ( ParserConfigurationException pce ) { throw new BuildException ( pce ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe ) ; } finally { if ( configurationStream != null ) { try { configurationStream . close ( ) ; } catch ( Exception e ) { } } } } void addNodeRecursively ( org . w3c . dom . Node node , String prefix ) { if ( node . hasAttributes ( ) ) { org . w3c . dom . NamedNodeMap nodeAttributes = node . getAttributes ( ) ; for ( int i = 0 ; i < nodeAttributes . getLength ( ) ; i ++ ) { Node attributeNode = nodeAttributes . item ( i ) ; String attributeName ; if ( collapseAttributes ) { attributeName = prefix + ( prefix . trim ( ) . equals ( "" ) ? "" : "." ) + node . getNodeName ( ) + "." + attributeNode . getNodeName ( ) ; } else { attributeName = prefix + ( prefix . trim ( ) . equals ( "" ) ? "" : "." ) + node . getNodeName ( ) + "(" + attributeNode . getNodeName ( ) + ")" ; } String attributeValue = attributeNode . getNodeValue ( ) ; log ( attributeName + ":" + attributeValue , Project . MSG_DEBUG ) ; project . setNewProperty ( attributeName , attributeValue ) ; } } if ( node . getNodeType ( ) == Node . TEXT_NODE ) { String nodeText = node . getNodeValue ( ) ; if ( nodeText . trim ( ) . length ( ) != 0 ) { log ( prefix + ":" + nodeText , Project . MSG_DEBUG ) ; project . setNewProperty ( prefix , nodeText ) ; } } if ( node . hasChildNodes ( ) ) { prefix += ( ( prefix . trim ( ) . equals ( "" ) ? "" : "." ) + node . getNodeName ( ) ) ; org . w3c . dom . NodeList nodeChildren = node . getChildNodes ( ) ; int numChildren = nodeChildren . getLength ( ) ; for ( int i = 0 ; i < numChildren ; i ++ ) { addNodeRecursively ( nodeChildren . item ( i ) , prefix ) ; } } } public void setFile ( File src ) { this . src = src ; } public void setPrefix ( String prefix ) { this . prefix = prefix . trim ( ) ; } public void setKeeproot ( boolean keepRoot ) { this . keepRoot = keepRoot ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public void setCollapseAttributes ( boolean collapseAttributes ) { this . collapseAttributes = collapseAttributes ; } } 	1	
package org . apache . tools . ant ; import java . lang . reflect . Method ; public class TaskAdapter extends Task { private Object proxy ; public static void checkTaskClass ( final Class taskClass , final Project project ) { try { final Method executeM = taskClass . getMethod ( "execute" , null ) ; if ( ! Void . TYPE . equals ( executeM . getReturnType ( ) ) ) { final String message = "return type of execute() should be " + "void but was \"" + executeM . getReturnType ( ) + "\" in " + taskClass ; project . log ( message , Project . MSG_WARN ) ; } } catch ( NoSuchMethodException e ) { final String message = "No public execute() in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } } public void execute ( ) throws BuildException { Method setProjectM = null ; try { Class c = proxy . getClass ( ) ; setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( proxy , new Object [ ] { project } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception ex ) { log ( "Error setting project in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } Method executeM = null ; try { Class c = proxy . getClass ( ) ; executeM = c . getMethod ( "execute" , new Class [ 0 ] ) ; if ( executeM == null ) { log ( "No public execute() in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( "No public execute() in " + proxy . getClass ( ) ) ; } executeM . invoke ( proxy , null ) ; return ; } catch ( java . lang . reflect . InvocationTargetException ie ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_ERR ) ; Throwable t = ie . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( ( BuildException ) t ) ; } else { throw new BuildException ( t ) ; } } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return this . proxy ; } } 	1	
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . io . File ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . io . IOException ; public abstract class DefaultCompilerAdapter implements CompilerAdapter { protected Path src ; protected File destDir ; protected String encoding ; protected boolean debug = false ; protected boolean optimize = false ; protected boolean deprecation = false ; protected boolean depend = false ; protected boolean verbose = false ; protected String target ; protected Path bootclasspath ; protected Path extdirs ; protected Path compileClasspath ; protected Path compileSourcepath ; protected Project project ; protected Location location ; protected boolean includeAntRuntime ; protected boolean includeJavaRuntime ; protected String memoryInitialSize ; protected String memoryMaximumSize ; protected File [ ] compileList ; protected static String lSep = System . getProperty ( "line.separator" ) ; protected Javac attributes ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; public void setJavac ( Javac attributes ) { this . attributes = attributes ; src = attributes . getSrcdir ( ) ; destDir = attributes . getDestdir ( ) ; encoding = attributes . getEncoding ( ) ; debug = attributes . getDebug ( ) ; optimize = attributes . getOptimize ( ) ; deprecation = attributes . getDeprecation ( ) ; depend = attributes . getDepend ( ) ; verbose = attributes . getVerbose ( ) ; target = attributes . getTarget ( ) ; bootclasspath = attributes . getBootclasspath ( ) ; extdirs = attributes . getExtdirs ( ) ; compileList = attributes . getFileList ( ) ; compileClasspath = attributes . getClasspath ( ) ; compileSourcepath = attributes . getSourcepath ( ) ; project = attributes . getProject ( ) ; location = attributes . getLocation ( ) ; includeAntRuntime = attributes . getIncludeantruntime ( ) ; includeJavaRuntime = attributes . getIncludejavaruntime ( ) ; memoryInitialSize = attributes . getMemoryInitialSize ( ) ; memoryMaximumSize = attributes . getMemoryMaximumSize ( ) ; } public Javac getJavac ( ) { return attributes ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( project ) ; if ( destDir != null ) { classpath . setLocation ( destDir ) ; } if ( compileClasspath == null ) { if ( includeAntRuntime ) { classpath . addExisting ( Path . systemClasspath ) ; } } else { if ( includeAntRuntime ) { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "ignore" ) ) ; } } if ( includeJavaRuntime ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd ) { return setupJavacCommandlineSwitches ( cmd , false ) ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd , boolean useDebugLevel ) { Path classpath = getCompileClasspath ( ) ; Path sourcepath = null ; if ( compileSourcepath != null ) { sourcepath = compileSourcepath ; } else { sourcepath = src ; } String memoryParameterPrefix = assumeJava11 ( ) ? "-J-" : "-J-X" ; if ( memoryInitialSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryInitialSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "ms" + memoryInitialSize ) ; } } if ( memoryMaximumSize != null ) { if ( ! attributes . isForkedJavac ( ) ) { attributes . log ( "Since fork is false, ignoring " + "memoryMaximumSize setting." , Project . MSG_WARN ) ; } else { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "mx" + memoryMaximumSize ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; if ( assumeJava11 ( ) ) { Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; cp . append ( sourcepath ) ; cmd . createArgument ( ) . setPath ( cp ) ; } else { cmd . createArgument ( ) . setPath ( classpath ) ; if ( sourcepath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( sourcepath ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } if ( bootclasspath != null && bootclasspath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bootclasspath ) ; } if ( extdirs != null && extdirs . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } } if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { if ( useDebugLevel && ! assumeJava11 ( ) ) { String debugLevel = attributes . getDebugLevel ( ) ; if ( debugLevel != null ) { cmd . createArgument ( ) . setValue ( "-g:" + debugLevel ) ; } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else if ( ! assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-g:none" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( depend ) { if ( assumeJava11 ( ) ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } else if ( assumeJava12 ( ) ) { cmd . createArgument ( ) . setValue ( "-Xdepend" ) ; } else { attributes . log ( "depend attribute is not supported by the " + "modern compiler" , Project . MSG_WARN ) ; } } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; return cmd ; } protected Commandline setupModernJavacCommandlineSwitches ( Commandline cmd ) { setupJavacCommandlineSwitches ( cmd , true ) ; if ( attributes . getSource ( ) != null && ! assumeJava13 ( ) ) { cmd . createArgument ( ) . setValue ( "-source" ) ; cmd . createArgument ( ) . setValue ( attributes . getSource ( ) ) ; } return cmd ; } protected Commandline setupModernJavacCommand ( ) { Commandline cmd = new Commandline ( ) ; setupModernJavacCommandlineSwitches ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected Commandline setupJavacCommand ( ) { return setupJavacCommand ( false ) ; } protected Commandline setupJavacCommand ( boolean debugLevelCheck ) { Commandline cmd = new Commandline ( ) ; setupJavacCommandlineSwitches ( cmd , debugLevelCheck ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . length != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( lSep ) ; for ( int i = 0 ; i < compileList . length ; i ++ ) { String arg = compileList [ i ] . getAbsolutePath ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg + lSep ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName ) { String [ ] commandArray = null ; File tmpFile = null ; try { if ( Commandline . toString ( args ) . length ( ) > 4096 && firstFileName >= 0 ) { PrintWriter out = null ; try { String userDirName = System . getProperty ( "user.dir" ) ; File userDir = new File ( userDirName ) ; tmpFile = fileUtils . createTempFile ( "files" , "" , userDir ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + tmpFile ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = args ; } try { Execute exe = new Execute ( new LogStreamHandler ( attributes , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; return exe . getExitValue ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running " + args [ 0 ] + " compiler" , e , location ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void addExtdirsToClasspath ( Path classpath ) { classpath . addExtdirs ( extdirs ) ; } protected void addCurrentCompilerArgs ( Commandline cmd ) { cmd . addArguments ( getJavac ( ) . getCurrentCompilerArgs ( ) ) ; } protected boolean assumeJava11 ( ) { return "javac1.1" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) ; } protected boolean assumeJava12 ( ) { return "javac1.2" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) ; } protected boolean assumeJava13 ( ) { return "javac1.3" . equals ( attributes . getCompilerVersion ( ) ) || ( "classic" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "modern" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) || ( "extJavac" . equals ( attributes . getCompilerVersion ( ) ) && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) ; } } 	1	
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . ZipOutputStream ; import java . io . File ; import java . io . IOException ; public class Ear extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { setDestFile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "appxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/application.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will" + " be ignored (please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	1	
package org . apache . tools . ant . taskdefs . email ; import org . apache . tools . ant . ProjectComponent ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintStream ; public class Message extends ProjectComponent { private File messageSource = null ; private StringBuffer buffer = new StringBuffer ( ) ; private String mimeType = "text/plain" ; private boolean specified = false ; public Message ( ) { } public Message ( String text ) { addText ( text ) ; } public Message ( File file ) { messageSource = file ; } public void addText ( String text ) { buffer . append ( text ) ; } public void setSrc ( File src ) { this . messageSource = src ; } public void setMimeType ( String mimeType ) { this . mimeType = mimeType ; specified = true ; } public String getMimeType ( ) { return mimeType ; } public void print ( PrintStream out ) throws IOException { if ( messageSource != null ) { FileReader freader = new FileReader ( messageSource ) ; try { BufferedReader in = new BufferedReader ( freader ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { out . println ( getProject ( ) . replaceProperties ( line ) ) ; } } finally { freader . close ( ) ; } } else { out . println ( getProject ( ) . replaceProperties ( buffer . toString ( ) ) ) ; } } public boolean isMimeTypeSpecified ( ) { return specified ; } } 	1	
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; public class EmailTask extends Task { public static final String AUTO = "auto" ; public static final String MIME = "mime" ; public static final String UU = "uu" ; public static final String PLAIN = "plain" ; public static class Encoding extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { AUTO , MIME , UU , PLAIN } ; } } private String encoding = AUTO ; private String host = "localhost" ; private int port = 25 ; private String subject = null ; private Message message = null ; private boolean failOnError = true ; private boolean includeFileNames = false ; private String messageMimeType = null ; private EmailAddress from = null ; private Vector toList = new Vector ( ) ; private Vector ccList = new Vector ( ) ; private Vector bccList = new Vector ( ) ; private Vector files = new Vector ( ) ; private Vector filesets = new Vector ( ) ; public void setEncoding ( Encoding encoding ) { this . encoding = encoding . getValue ( ) ; } public void setMailport ( int port ) { this . port = port ; } public void setMailhost ( String host ) { this . host = host ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setMessage ( String message ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( message ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageFile ( File file ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( file ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageMimeType ( String type ) { this . messageMimeType = type ; } public void addMessage ( Message message ) throws BuildException { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = message ; } public void addFrom ( EmailAddress address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = address ; } public void setFrom ( String address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = new EmailAddress ( address ) ; } public void addTo ( EmailAddress address ) { toList . addElement ( address ) ; } public void setToList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { toList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addCc ( EmailAddress address ) { ccList . addElement ( address ) ; } public void setCcList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { ccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addBcc ( EmailAddress address ) { bccList . addElement ( address ) ; } public void setBccList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { bccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setFiles ( String filenames ) { StringTokenizer t = new StringTokenizer ( filenames , ", " ) ; while ( t . hasMoreTokens ( ) ) { files . addElement ( project . resolveFile ( t . nextToken ( ) ) ) ; } } public void addFileset ( FileSet fs ) { filesets . addElement ( fs ) ; } public void setIncludefilenames ( boolean includeFileNames ) { this . includeFileNames = includeFileNames ; } public boolean getIncludeFileNames ( ) { return includeFileNames ; } public void execute ( ) { Message savedMessage = message ; Vector savedFiles = ( Vector ) files . clone ( ) ; try { Mailer mailer = null ; boolean autoFound = false ; if ( encoding . equals ( MIME ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.MimeMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using MIME mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise MIME mail" , Project . MSG_WARN ) ; } } if ( encoding . equals ( UU ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.UUMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using UU mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise UU mail" , Project . MSG_WARN ) ; } } if ( encoding . equals ( PLAIN ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { mailer = new PlainMailer ( ) ; autoFound = true ; log ( "Using plain mail" , Project . MSG_VERBOSE ) ; } if ( mailer == null ) { throw new BuildException ( "Failed to initialise encoding: " + encoding ) ; } if ( message == null ) { message = new Message ( ) ; message . setProject ( getProject ( ) ) ; } if ( from == null || from . getAddress ( ) == null ) { throw new BuildException ( "A from element is required" ) ; } if ( toList . isEmpty ( ) && ccList . isEmpty ( ) && bccList . isEmpty ( ) ) { throw new BuildException ( "At least one of to,cc or bcc must " + "be supplied" ) ; } if ( messageMimeType != null ) { if ( message . isMimeTypeSpecified ( ) ) { throw new BuildException ( "The mime type can only be " + "specified in one location" ) ; } else { message . setMimeType ( messageMimeType ) ; } } Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] includedFiles = ds . getIncludedFiles ( ) ; File baseDir = ds . getBasedir ( ) ; for ( int j = 0 ; j < includedFiles . length ; ++ j ) { File file = new File ( baseDir , includedFiles [ j ] ) ; files . addElement ( file ) ; } } log ( "Sending email: " + subject , Project . MSG_INFO ) ; log ( "From " + from , Project . MSG_VERBOSE ) ; log ( "To " + toList , Project . MSG_VERBOSE ) ; log ( "Cc " + ccList , Project . MSG_VERBOSE ) ; log ( "Bcc " + bccList , Project . MSG_VERBOSE ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setMessage ( message ) ; mailer . setFrom ( from ) ; mailer . setToList ( toList ) ; mailer . setCcList ( ccList ) ; mailer . setBccList ( bccList ) ; mailer . setFiles ( files ) ; mailer . setSubject ( subject ) ; mailer . setTask ( this ) ; mailer . setIncludeFileNames ( includeFileNames ) ; mailer . send ( ) ; int count = files . size ( ) ; log ( "Sent email with " + count + " attachment" + ( count == 1 ? "" : "s" ) , Project . MSG_INFO ) ; } catch ( BuildException e ) { log ( "Failed to send email" , Project . MSG_WARN ) ; if ( failOnError ) { throw e ; } } finally { message = savedMessage ; files = savedFiles ; } } } 	1	
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . FileOutputStream ; import java . io . OutputStream ; import java . io . FileInputStream ; import java . io . BufferedOutputStream ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . tar . TarOutputStream ; import org . apache . tools . tar . TarConstants ; import org . apache . tools . tar . TarEntry ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class Tar extends MatchingTask { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; File tarFile ; File baseDir ; private TarLongFileMode longFileMode = new TarLongFileMode ( ) ; Vector filesets = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; private TarCompressionMethod compression = new TarCompressionMethod ( ) ; public TarFileSet createTarFileSet ( ) { TarFileSet fileset = new TarFileSet ( ) ; filesets . addElement ( fileset ) ; return fileset ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setDestFile ( File destFile ) { this . tarFile = destFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { log ( "DEPRECATED - The setLongfile(String) method has been deprecated." + " Use setLongfile(Tar.TarLongFileMode) instead." ) ; this . longFileMode = new TarLongFileMode ( ) ; longFileMode . setValue ( mode ) ; } public void setLongfile ( TarLongFileMode mode ) { this . longFileMode = mode ; } public void setCompression ( TarCompressionMethod mode ) { this . compression = mode ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , location ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , location ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , location ) ; } Vector savedFileSets = ( Vector ) filesets . clone ( ) ; try { if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , location ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basedir " + "attribute or some nested filesets." , location ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; if ( ! archiveIsUpToDate ( files ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( fs . getDir ( project ) , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include " + "itself" , location ) ; } } } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( compression . compress ( new BufferedOutputStream ( new FileOutputStream ( tarFile ) ) ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . isTruncateMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . isFailMode ( ) || longFileMode . isOmitMode ( ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; if ( files . length > 1 && fs . getFullpath ( ) . length ( ) > 0 ) { throw new BuildException ( "fullpath attribute may only " + "be specified for " + "filesets that specify a " + "single file." ) ; } for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( fs . getDir ( project ) , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , fs ) ; } } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( tOut != null ) { try { tOut . close ( ) ; } catch ( IOException e ) { } } } } finally { filesets = savedFileSets ; } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { FileInputStream fIn = null ; String fullpath = tarFileSet . getFullpath ( ) ; if ( fullpath . length ( ) > 0 ) { vPath = fullpath ; } else { if ( vPath . length ( ) <= 0 ) { return ; } if ( file . isDirectory ( ) && ! vPath . endsWith ( "/" ) ) { vPath += "/" ; } String prefix = tarFileSet . getPrefix ( ) ; if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) ) { prefix = prefix + "/" ; } vPath = prefix + vPath ; } if ( vPath . startsWith ( "/" ) && ! tarFileSet . getPreserveLeadingSlashes ( ) ) { int l = vPath . length ( ) ; if ( l <= 1 ) { return ; } vPath = vPath . substring ( 1 , l ) ; } try { if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . isOmitMode ( ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . isWarnMode ( ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed " + "successfully by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . isFailMode ( ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , location ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setModTime ( file . lastModified ( ) ) ; if ( ! file . isDirectory ( ) ) { te . setSize ( file . length ( ) ) ; te . setMode ( tarFileSet . getMode ( ) ) ; } te . setUserName ( tarFileSet . getUserName ( ) ) ; te . setGroupName ( tarFileSet . getGroup ( ) ) ; tOut . putNextEntry ( te ) ; if ( ! file . isDirectory ( ) ) { fIn = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = fIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } tOut . closeEntry ( ) ; } finally { if ( fIn != null ) { fIn . close ( ) ; } } } protected boolean archiveIsUpToDate ( String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , baseDir , null , mm ) . length == 0 ; } public static class TarFileSet extends FileSet { private String [ ] files = null ; private int mode = 0100644 ; private String userName = "" ; private String groupName = "" ; private String prefix = "" ; private String fullpath = "" ; private boolean preserveLeadingSlashes = false ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { DirectoryScanner ds = getDirectoryScanner ( p ) ; String [ ] directories = ds . getIncludedDirectories ( ) ; String [ ] filesPerSe = ds . getIncludedFiles ( ) ; files = new String [ directories . length + filesPerSe . length ] ; System . arraycopy ( directories , 0 , files , 0 , directories . length ) ; System . arraycopy ( filesPerSe , 0 , files , directories . length , filesPerSe . length ) ; } return files ; } public void setMode ( String octalString ) { this . mode = 0100000 | Integer . parseInt ( octalString , 8 ) ; } public int getMode ( ) { return mode ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getUserName ( ) { return userName ; } public void setGroup ( String groupName ) { this . groupName = groupName ; } public String getGroup ( ) { return groupName ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public void setPreserveLeadingSlashes ( boolean b ) { this . preserveLeadingSlashes = b ; } public boolean getPreserveLeadingSlashes ( ) { return preserveLeadingSlashes ; } } public static class TarLongFileMode extends EnumeratedAttribute { public static final String WARN = "warn" ; public static final String FAIL = "fail" ; public static final String TRUNCATE = "truncate" ; public static final String GNU = "gnu" ; public static final String OMIT = "omit" ; private final String [ ] validModes = { WARN , FAIL , TRUNCATE , GNU , OMIT } ; public TarLongFileMode ( ) { super ( ) ; setValue ( WARN ) ; } public String [ ] getValues ( ) { return validModes ; } public boolean isTruncateMode ( ) { return TRUNCATE . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isWarnMode ( ) { return WARN . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isGnuMode ( ) { return GNU . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFailMode ( ) { return FAIL . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isOmitMode ( ) { return OMIT . equalsIgnoreCase ( getValue ( ) ) ; } } public static final class TarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public TarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } private OutputStream compress ( final OutputStream ostream ) throws IOException { final String value = getValue ( ) ; if ( GZIP . equals ( value ) ) { return new GZIPOutputStream ( ostream ) ; } else { if ( BZIP2 . equals ( value ) ) { ostream . write ( 'B' ) ; ostream . write ( 'Z' ) ; return new CBZip2OutputStream ( ostream ) ; } } return ostream ; } } } 	1	
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Environment ; import java . io . File ; import java . io . PrintStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Vector ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private Environment env = new Environment ( ) ; private boolean fork = false ; private boolean newEnvironment = false ; private File dir = null ; private File out ; private PrintStream outStream = null ; private boolean failOnError = false ; private boolean append = false ; private Long timeout = null ; public void execute ( ) throws BuildException { File savedDir = dir ; int err = - 1 ; try { if ( ( err = executeJava ( ) ) != 0 ) { if ( failOnError ) { throw new BuildException ( "Java returned: " + err , location ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } } finally { dir = savedDir ; } } public int executeJava ( ) throws BuildException { String classname = cmdl . getClassname ( ) ; if ( classname == null && cmdl . getJar ( ) == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( ! fork && cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot execute a jar in non-forked mode." + " Please set fork='true'. " ) ; } if ( fork ) { log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; } else { if ( cmdl . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( newEnvironment || null != env . getVariables ( ) ) { log ( "Changes to environment variables are ignored when same " + "JVM is used." , Project . MSG_WARN ) ; } log ( "Running in same VM " + cmdl . describeJavaCommand ( ) , Project . MSG_VERBOSE ) ; } try { if ( fork ) { return run ( cmdl . getCommandline ( ) ) ; } else { try { run ( cmdl ) ; return 0 ; } catch ( ExitException ex ) { return ex . getStatus ( ) ; } } } catch ( BuildException e ) { if ( failOnError ) { throw e ; } else { log ( e . getMessage ( ) , Project . MSG_ERR ) ; return 0 ; } } catch ( Throwable t ) { if ( failOnError ) { throw new BuildException ( t ) ; } else { log ( t . getMessage ( ) , Project . MSG_ERR ) ; return 0 ; } } } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return cmdl . createClasspath ( project ) . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setJar ( File jarfile ) throws BuildException { if ( cmdl . getClassname ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command." ) ; } cmdl . setJar ( jarfile . getAbsolutePath ( ) ) ; } public void setClassname ( String s ) throws BuildException { if ( cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' " + "attributes in same command" ) ; } cmdl . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; cmdl . createArgument ( ) . setLine ( s ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; cmdl . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return cmdl . createVmArgument ( ) ; } public void setJvm ( String s ) { cmdl . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { cmdl . addSysproperty ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { this . out = out ; } public void setMaxmemory ( String max ) { cmdl . setMaxmemory ( max ) ; } public void setJVMVersion ( String value ) { cmdl . setVmversion ( value ) ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setAppend ( boolean append ) { this . append = append ; } public void setTimeout ( Long value ) { timeout = value ; } protected void handleOutput ( String line ) { if ( outStream != null ) { outStream . println ( line ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( outStream != null ) { outStream . println ( line ) ; } else { super . handleErrorOutput ( line ) ; } } private void run ( CommandlineJava command ) throws BuildException { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; exe . setTimeout ( timeout ) ; if ( out != null ) { try { outStream = new PrintStream ( new FileOutputStream ( out . getAbsolutePath ( ) , append ) ) ; exe . execute ( project ) ; } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( outStream != null ) { outStream . close ( ) ; } } } else { exe . execute ( project ) ; } } private int run ( String [ ] command ) throws BuildException { FileOutputStream fos = null ; try { Execute exe = null ; if ( out == null ) { exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , createWatchdog ( ) ) ; } else { fos = new FileOutputStream ( out . getAbsolutePath ( ) , append ) ; exe = new Execute ( new PumpStreamHandler ( fos ) , createWatchdog ( ) ) ; } exe . setAntRun ( project ) ; if ( dir == null ) { dir = project . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , location ) ; } exe . setWorkingDirectory ( dir ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; exe . setCommandline ( command ) ; try { int rc = exe . execute ( ) ; if ( exe . killedProcess ( ) ) { log ( "Timeout: killed the sub-process" , Project . MSG_WARN ) ; } return rc ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException io ) { } } } } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { cmdl . clearJavaArgs ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } } 	1	
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . util . StringUtils ; import java . io . File ; import java . io . FileOutputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . FileNotFoundException ; public class ExecTask extends Task { private String os ; private File out ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Long timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private FileOutputStream fos = null ; private ByteArrayOutputStream baos = null ; private String outputprop ; private String resultProperty ; private boolean failIfExecFails = true ; private boolean append = false ; private boolean vmLauncher = true ; public void setTimeout ( Long value ) { timeout = value ; } public void setTimeout ( Integer value ) { if ( value == null ) { timeout = null ; } else { setTimeout ( new Long ( value . intValue ( ) ) ) ; } } public void setExecutable ( String value ) { cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated. " + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { this . out = out ; } public void setOutputproperty ( String outputprop ) { this . outputprop = outputprop ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; } protected void maybeSetResultPropertyValue ( int result ) { String res = Integer . toString ( result ) ; if ( resultProperty != null ) { project . setNewProperty ( resultProperty , res ) ; } } public void setFailIfExecutionFails ( boolean flag ) { failIfExecFails = flag ; } public void setAppend ( boolean append ) { this . append = append ; } public void execute ( ) throws BuildException { File savedDir = dir ; checkConfiguration ( ) ; if ( isValidOs ( ) ) { try { runExec ( prepareExec ( ) ) ; } finally { dir = savedDir ; } } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , location ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory you specified does not " + "exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( "The directory you specified is not a " + "directory" ) ; } } protected boolean isValidOs ( ) { String myos = System . getProperty ( "os.name" ) ; log ( "Current OS is " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "This OS, " + myos + " was not found in the specified list of valid OSes: " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void setVMLauncher ( boolean vmLauncher ) { this . vmLauncher = vmLauncher ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) { dir = project . getBaseDir ( ) ; } Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( dir ) ; exe . setVMLauncher ( vmLauncher ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected final void runExecute ( Execute exe ) throws IOException { int err = - 1 ; err = exe . execute ( ) ; if ( exe . killedProcess ( ) ) { log ( "Timeout: killed the sub-process" , Project . MSG_WARN ) ; } maybeSetResultPropertyValue ( err ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( taskType + " returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } if ( baos != null ) { BufferedReader in = new BufferedReader ( new StringReader ( Execute . toString ( baos ) ) ) ; String line = null ; StringBuffer val = new StringBuffer ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( val . length ( ) != 0 ) { val . append ( StringUtils . LINE_SEP ) ; } val . append ( line ) ; } project . setNewProperty ( outputprop , val . toString ( ) ) ; } } protected void runExec ( Execute exe ) throws BuildException { log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( cmdl . getCommandline ( ) ) ; try { runExecute ( exe ) ; } catch ( IOException e ) { if ( failIfExecFails ) { throw new BuildException ( "Execute failed: " + e . toString ( ) , e , location ) ; } else { log ( "Execute failed: " + e . toString ( ) , Project . MSG_ERR ) ; } } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { if ( out != null ) { try { fos = new FileOutputStream ( out . getAbsolutePath ( ) , append ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( fos ) ; } catch ( FileNotFoundException fne ) { throw new BuildException ( "Cannot write to " + out , fne , location ) ; } catch ( IOException ioe ) { throw new BuildException ( "Cannot write to " + out , ioe , location ) ; } } else if ( outputprop != null ) { baos = new ByteArrayOutputStream ( ) ; log ( "Output redirected to ByteArray" , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( baos ) ; } else { return new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } protected void logFlush ( ) { try { if ( fos != null ) { fos . close ( ) ; } if ( baos != null ) { baos . close ( ) ; } } catch ( IOException io ) { } } } 	1	
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . Method ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . taskdefs . optional . TraXLiaison ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . XMLCatalog ; import org . xml . sax . EntityResolver ; public class XSLTProcess extends MatchingTask implements XSLTLogger { private File destDir = null ; private File baseDir = null ; private String xslFile = null ; private String targetExtension = ".html" ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private String processor ; private Path classpath = null ; private XSLTLiaison liaison ; private boolean stylesheetLoaded = false ; private boolean force = false ; private FileUtils fileUtils ; private Vector outputProperties = new Vector ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; private static final String TRAX_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ; private static final String XSLP_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.XslpLiaison" ; private static final String XALAN_LIAISON_CLASS = "org.apache.tools.ant.taskdefs.optional.XalanLiaison" ; private boolean performDirectoryScan = true ; public XSLTProcess ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void setScanIncludedDirectories ( boolean b ) { performDirectoryScan = b ; } public void execute ( ) throws BuildException { File savedBaseDir = baseDir ; DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( xslFile == null ) { throw new BuildException ( "no stylesheet specified" , location ) ; } try { if ( baseDir == null ) { baseDir = project . resolveFile ( "." ) ; } liaison = getLiaison ( ) ; if ( liaison instanceof XSLTLoggerAware ) { ( ( XSLTLoggerAware ) liaison ) . setLogger ( this ) ; } log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; File stylesheet = project . resolveFile ( xslFile ) ; if ( ! stylesheet . exists ( ) ) { stylesheet = fileUtils . resolveFile ( baseDir , xslFile ) ; if ( stylesheet . exists ( ) ) { log ( "DEPRECATED - the style attribute should be relative " + "to the project\'s" ) ; log ( "             basedir, not the tasks\'s basedir." ) ; } } if ( inFile != null && outFile != null ) { process ( inFile , outFile , stylesheet ) ; return ; } if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } if ( performDirectoryScan ) { dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } } } } finally { liaison = null ; stylesheetLoaded = false ; baseDir = savedBaseDir ; } } public void setForce ( boolean force ) { this . force = force ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = xslFile ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( project ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProcessor ( String processor ) { this . processor = processor ; } public void addConfiguredXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog . addConfiguredXMLCatalog ( xmlCatalog ) ; } private void resolveProcessor ( String proc ) throws Exception { if ( proc . equals ( "trax" ) ) { final Class clazz = loadClass ( TRAX_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xslp" ) ) { log ( "DEPRECATED - xslp processor is deprecated. Use trax or " + "xalan instead." ) ; final Class clazz = loadClass ( XSLP_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xalan" ) ) { final Class clazz = loadClass ( XALAN_LIAISON_CLASS ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else { liaison = ( XSLTLiaison ) loadClass ( proc ) . newInstance ( ) ; } } private Class loadClass ( String classname ) throws Exception { if ( classpath == null ) { return Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( project , classpath ) ; Class c = al . loadClass ( classname ) ; AntClassLoader . initializeClass ( c ) ; return c ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void process ( File baseDir , String xmlFile , File destDir , File stylesheet ) throws BuildException { String fileExt = targetExtension ; File outFile = null ; File inFile = null ; try { long styleSheetLastModified = stylesheet . lastModified ( ) ; inFile = new File ( baseDir , xmlFile ) ; if ( inFile . isDirectory ( ) ) { log ( "Skipping " + inFile + " it is a directory." , Project . MSG_VERBOSE ) ; return ; } int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + fileExt ) ; } else { outFile = new File ( destDir , xmlFile + fileExt ) ; } if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , File stylesheet ) throws BuildException { try { long styleSheetLastModified = stylesheet . lastModified ( ) ; log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = fileUtils . getParentFile ( targetFile ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } protected XSLTLiaison getLiaison ( ) { if ( liaison == null ) { if ( processor != null ) { try { resolveProcessor ( processor ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } else { try { resolveProcessor ( "trax" ) ; } catch ( Throwable e1 ) { try { resolveProcessor ( "xalan" ) ; } catch ( Throwable e2 ) { try { resolveProcessor ( "xslp" ) ; } catch ( Throwable e3 ) { e3 . printStackTrace ( ) ; e2 . printStackTrace ( ) ; throw new BuildException ( e1 ) ; } } } } } return liaison ; } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public class Param { private String name = null ; private String expression = null ; public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) { throw new BuildException ( "Name attribute is missing." ) ; } return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) { throw new BuildException ( "Expression attribute is missing." ) ; } return expression ; } } public OutputProperty createOutputProperty ( ) { OutputProperty p = new OutputProperty ( ) ; outputProperties . addElement ( p ) ; return p ; } public static class OutputProperty { private String name ; private String value ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } public void init ( ) throws BuildException { super . init ( ) ; xmlCatalog . setProject ( project ) ; } protected void configureLiaison ( File stylesheet ) throws BuildException { if ( stylesheetLoaded ) { return ; } stylesheetLoaded = true ; try { log ( "Loading stylesheet " + stylesheet , Project . MSG_INFO ) ; liaison . setStylesheet ( stylesheet ) ; for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } if ( liaison instanceof TraXLiaison ) { configureTraXLiaison ( ( TraXLiaison ) liaison ) ; } } catch ( Exception ex ) { log ( "Failed to transform using stylesheet " + stylesheet , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } protected void configureTraXLiaison ( TraXLiaison liaison ) { if ( xmlCatalog != null ) { liaison . setEntityResolver ( xmlCatalog ) ; liaison . setURIResolver ( xmlCatalog ) ; } for ( Enumeration props = outputProperties . elements ( ) ; props . hasMoreElements ( ) ; ) { OutputProperty prop = ( OutputProperty ) props . nextElement ( ) ; liaison . setOutputProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } } } 	1	
package org . apache . tools . ant . types ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import java . util . Stack ; public class ZipFileSet extends FileSet { private File srcFile = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; public ZipFileSet ( ) { super ( ) ; } protected ZipFileSet ( FileSet fileset ) { super ( fileset ) ; } public void setDir ( File dir ) throws BuildException { if ( srcFile != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void setSrc ( File srcFile ) { if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . srcFile = srcFile ; } public File getSrc ( ) { return srcFile ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( srcFile != null ) { ZipScanner zs = new ZipScanner ( ) ; zs . setSrc ( srcFile ) ; super . setDir ( p . getBaseDir ( ) ) ; setupDirectoryScanner ( zs , p ) ; zs . init ( ) ; return zs ; } else { return super . getDirectoryScanner ( p ) ; } } protected AbstractFileSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof FileSet ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a fileset" ; throw new BuildException ( msg ) ; } else { return ( AbstractFileSet ) o ; } } } 	1	
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . PrintStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . lang . reflect . Method ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; public class Ant extends Task { private File dir = null ; private String antFile = null ; private String target = null ; private String output = null ; private boolean inheritAll = true ; private boolean inheritRefs = false ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Project newProject ; private PrintStream out = null ; public void setInheritAll ( boolean value ) { inheritAll = value ; } public void setInheritRefs ( boolean value ) { inheritRefs = value ; } public void init ( ) { newProject = new Project ( ) ; newProject . setJavaVersionProperty ( ) ; newProject . addTaskDefinition ( "property" , ( Class ) project . getTaskDefinitions ( ) . get ( "property" ) ) ; } private void reinit ( ) { init ( ) ; final int count = properties . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Property p = ( Property ) properties . elementAt ( i ) ; Property newP = ( Property ) newProject . createTask ( "property" ) ; newP . setName ( p . getName ( ) ) ; if ( p . getValue ( ) != null ) { newP . setValue ( p . getValue ( ) ) ; } if ( p . getFile ( ) != null ) { newP . setFile ( p . getFile ( ) ) ; } if ( p . getResource ( ) != null ) { newP . setResource ( p . getResource ( ) ) ; } if ( p . getPrefix ( ) != null ) { newP . setPrefix ( p . getPrefix ( ) ) ; } if ( p . getRefid ( ) != null ) { newP . setRefid ( p . getRefid ( ) ) ; } if ( p . getEnvironment ( ) != null ) { newP . setEnvironment ( p . getEnvironment ( ) ) ; } if ( p . getClasspath ( ) != null ) { newP . setClasspath ( p . getClasspath ( ) ) ; } properties . setElementAt ( newP , i ) ; } } private void initializeProject ( ) { newProject . setInputHandler ( getProject ( ) . getInputHandler ( ) ) ; Vector listeners = project . getBuildListeners ( ) ; final int count = listeners . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { newProject . addBuildListener ( ( BuildListener ) listeners . elementAt ( i ) ) ; } if ( output != null ) { File outfile = null ; if ( dir != null ) { outfile = FileUtils . newFileUtils ( ) . resolveFile ( dir , output ) ; } else { outfile = getProject ( ) . resolveFile ( output ) ; } try { out = new PrintStream ( new FileOutputStream ( outfile ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; newProject . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } Hashtable taskdefs = project . getTaskDefinitions ( ) ; Enumeration et = taskdefs . keys ( ) ; while ( et . hasMoreElements ( ) ) { String taskName = ( String ) et . nextElement ( ) ; if ( taskName . equals ( "property" ) ) { continue ; } Class taskClass = ( Class ) taskdefs . get ( taskName ) ; newProject . addTaskDefinition ( taskName , taskClass ) ; } Hashtable typedefs = project . getDataTypeDefinitions ( ) ; Enumeration e = typedefs . keys ( ) ; while ( e . hasMoreElements ( ) ) { String typeName = ( String ) e . nextElement ( ) ; Class typeClass = ( Class ) typedefs . get ( typeName ) ; newProject . addDataTypeDefinition ( typeName , typeClass ) ; } getProject ( ) . copyUserProperties ( newProject ) ; if ( ! inheritAll ) { newProject . setSystemProperties ( ) ; } else { Hashtable props = getProject ( ) . getProperties ( ) ; e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = e . nextElement ( ) . toString ( ) ; if ( "basedir" . equals ( arg ) || "ant.file" . equals ( arg ) ) { continue ; } String value = props . get ( arg ) . toString ( ) ; if ( newProject . getProperty ( arg ) == null ) { newProject . setNewProperty ( arg , value ) ; } } } } protected void handleOutput ( String line ) { if ( newProject != null ) { newProject . demuxOutput ( line , false ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( newProject != null ) { newProject . demuxOutput ( line , true ) ; } else { super . handleErrorOutput ( line ) ; } } public void execute ( ) throws BuildException { File savedDir = dir ; String savedAntFile = antFile ; String savedTarget = target ; try { if ( newProject == null ) { reinit ( ) ; } if ( ( dir == null ) && ( inheritAll ) ) { dir = project . getBaseDir ( ) ; } initializeProject ( ) ; if ( dir != null ) { newProject . setBaseDir ( dir ) ; if ( savedDir != null ) { newProject . setInheritedProperty ( "basedir" , dir . getAbsolutePath ( ) ) ; } } else { dir = project . getBaseDir ( ) ; } overrideProperties ( ) ; if ( antFile == null ) { antFile = "build.xml" ; } File file = FileUtils . newFileUtils ( ) . resolveFile ( dir , antFile ) ; antFile = file . getAbsolutePath ( ) ; log ( "calling target " + ( target != null ? target : "[default]" ) + " in build file " + antFile . toString ( ) , Project . MSG_VERBOSE ) ; newProject . setUserProperty ( "ant.file" , antFile ) ; ProjectHelper . configureProject ( newProject , new File ( antFile ) ) ; if ( target == null ) { target = newProject . getDefaultTarget ( ) ; } addReferences ( ) ; if ( newProject . getBaseDir ( ) . equals ( project . getBaseDir ( ) ) && newProject . getProperty ( "ant.file" ) . equals ( project . getProperty ( "ant.file" ) ) && getOwningTarget ( ) != null && target . equals ( this . getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "ant task calling its own parent " + "target" ) ; } newProject . executeTarget ( target ) ; } finally { newProject = null ; if ( output != null && out != null ) { try { out . close ( ) ; } catch ( final Exception e ) { } } dir = savedDir ; antFile = savedAntFile ; target = savedTarget ; } } private void overrideProperties ( ) throws BuildException { Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . setProject ( newProject ) ; p . execute ( ) ; } getProject ( ) . copyInheritedProperties ( newProject ) ; } private void addReferences ( ) throws BuildException { Hashtable thisReferences = ( Hashtable ) project . getReferences ( ) . clone ( ) ; Hashtable newReferences = newProject . getReferences ( ) ; Enumeration e ; if ( references . size ( ) > 0 ) { for ( e = references . elements ( ) ; e . hasMoreElements ( ) ; ) { Reference ref = ( Reference ) e . nextElement ( ) ; String refid = ref . getRefId ( ) ; if ( refid == null ) { throw new BuildException ( "the refid attribute is required" + " for reference elements" ) ; } if ( ! thisReferences . containsKey ( refid ) ) { log ( "Parent project doesn't contain any reference '" + refid + "'" , Project . MSG_WARN ) ; continue ; } thisReferences . remove ( refid ) ; String toRefid = ref . getToRefid ( ) ; if ( toRefid == null ) { toRefid = refid ; } copyReference ( refid , toRefid ) ; } } if ( inheritRefs ) { for ( e = thisReferences . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( newReferences . containsKey ( key ) ) { continue ; } copyReference ( key , key ) ; } } } private void copyReference ( String oldKey , String newKey ) { Object orig = project . getReference ( oldKey ) ; Class c = orig . getClass ( ) ; Object copy = orig ; try { Method cloneM = c . getMethod ( "clone" , new Class [ 0 ] ) ; if ( cloneM != null ) { copy = cloneM . invoke ( orig , new Object [ 0 ] ) ; } } catch ( Exception e ) { } if ( copy instanceof ProjectComponent ) { ( ( ProjectComponent ) copy ) . setProject ( newProject ) ; } else { try { Method setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( copy , new Object [ ] { newProject } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception e2 ) { String msg = "Error setting new project instance for " + "reference with id " + oldKey ; throw new BuildException ( msg , e2 , location ) ; } } newProject . addReference ( newKey , copy ) ; } public void setDir ( File d ) { this . dir = d ; } public void setAntfile ( String s ) { this . antFile = s ; } public void setTarget ( String s ) { this . target = s ; } public void setOutput ( String s ) { this . output = s ; } public Property createProperty ( ) { if ( newProject == null ) { reinit ( ) ; } Property p = new Property ( true , getProject ( ) ) ; p . setProject ( newProject ) ; p . setTaskName ( "property" ) ; properties . addElement ( p ) ; return p ; } public void addReference ( Reference r ) { references . addElement ( r ) ; } public static class Reference extends org . apache . tools . ant . types . Reference { public Reference ( ) { super ( ) ; } private String targetid = null ; public void setToRefid ( String targetid ) { this . targetid = targetid ; } public String getToRefid ( ) { return targetid ; } } } 	1	
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import java . io . File ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . Reader ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . FileReader ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import java . sql . Connection ; import java . sql . Statement ; import java . sql . SQLException ; import java . sql . SQLWarning ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; public class SQLExec extends JDBCTask { public static class DelimiterType extends EnumeratedAttribute { public static final String NORMAL = "normal" ; public static final String ROW = "row" ; public String [ ] getValues ( ) { return new String [ ] { NORMAL , ROW } ; } } private int goodSql = 0 ; private int totalSql = 0 ; private Connection conn = null ; private Vector filesets = new Vector ( ) ; private Statement statement = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private File output = null ; private String onError = "abort" ; private String encoding = null ; private boolean append = false ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . delimiterType = delimiterType . getValue ( ) ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setOutput ( File output ) { this . output = output ; } public void setAppend ( boolean append ) { this . append = append ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void execute ( ) throws BuildException { Vector savedTransaction = ( Vector ) transactions . clone ( ) ; String savedSqlCommand = sqlCommand ; sqlCommand = sqlCommand . trim ( ) ; try { if ( srcFile == null && sqlCommand . length ( ) == 0 && filesets . isEmpty ( ) ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file or fileset, " + "transactions or sql statement " + "must be set!" , location ) ; } } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , location ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File srcDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { Transaction t = createTransaction ( ) ; t . setSrc ( new File ( srcDir , srcFiles [ j ] ) ) ; } } Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; conn = getConnection ( ) ; if ( ! isValidRdbms ( conn ) ) { return ; } try { statement = conn . createStatement ( ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getAbsolutePath ( ) , append ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! isAutocommit ( ) ) { log ( "Commiting transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } catch ( SQLException e ) { if ( ! isAutocommit ( ) && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } finally { transactions = savedTransaction ; sqlCommand = savedSqlCommand ; } } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { String sql = "" ; String line = "" ; BufferedReader in = new BufferedReader ( reader ) ; while ( ( line = in . readLine ( ) ) != null ) { line = line . trim ( ) ; line = project . replaceProperties ( line ) ; if ( line . startsWith ( "//" ) ) { continue ; } if ( line . startsWith ( "--" ) ) { continue ; } StringTokenizer st = new StringTokenizer ( line ) ; if ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( "REM" . equalsIgnoreCase ( token ) ) { continue ; } } sql += " " + line ; sql = sql . trim ( ) ; if ( line . indexOf ( "--" ) >= 0 ) { sql += "\n" ; } if ( ( delimiterType . equals ( DelimiterType . NORMAL ) && sql . endsWith ( delimiter ) ) || ( delimiterType . equals ( DelimiterType . ROW ) && line . equals ( delimiter ) ) ) { log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; execSQL ( sql . substring ( 0 , sql . length ( ) - delimiter . length ( ) ) , out ) ; sql = "" ; } } if ( ! sql . equals ( "" ) ) { execSQL ( sql , out ) ; } } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) { return ; } try { totalSql ++ ; if ( ! statement . execute ( sql ) ) { log ( statement . getUpdateCount ( ) + " rows affected" , Project . MSG_VERBOSE ) ; } else { if ( print ) { printResults ( out ) ; } } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) { throw e ; } log ( e . toString ( ) , Project . MSG_ERR ) ; } } protected void printResults ( PrintStream out ) throws java . sql . SQLException { ResultSet rs = null ; do { rs = statement . getResultSet ( ) ; if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line . setLength ( 0 ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line . setLength ( 0 ) ; } } } while ( statement . getMoreResults ( ) ) ; out . println ( ) ; } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private File tSrcFile = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { this . tSrcFile = src ; } public void addText ( String sql ) { this . tSqlCommand += sql ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcFile != null ) { log ( "Executing file: " + tSrcFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; Reader reader = ( encoding == null ) ? new FileReader ( tSrcFile ) : new InputStreamReader ( new FileInputStream ( tSrcFile ) , encoding ) ; try { runStatements ( reader , out ) ; } finally { reader . close ( ) ; } } } } } 	1	
package org . apache . tools . ant ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . io . File ; import java . io . FileInputStream ; import java . io . PrintStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Vector ; import java . util . Properties ; import java . util . Enumeration ; public class Main { public static final String DEFAULT_BUILD_FILENAME = "build.xml" ; private int msgOutputLevel = Project . MSG_INFO ; private File buildFile ; private static PrintStream out = System . out ; private static PrintStream err = System . err ; private Vector targets = new Vector ( 5 ) ; private Properties definedProps = new Properties ( ) ; private Vector listeners = new Vector ( 5 ) ; private Vector propertyFiles = new Vector ( 5 ) ; private String loggerClassname = null ; private String inputHandlerClassname = null ; private boolean emacsMode = false ; private boolean readyToRun = false ; private boolean projectHelp = false ; private static boolean isLogFileUsed = false ; private static void printMessage ( Throwable t ) { String message = t . getMessage ( ) ; if ( message != null ) { System . err . println ( message ) ; } } public static void start ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { Main m = null ; try { Diagnostics . validateVersion ( ) ; m = new Main ( args ) ; } catch ( Throwable exc ) { printMessage ( exc ) ; System . exit ( 1 ) ; } if ( additionalUserProperties != null ) { for ( Enumeration e = additionalUserProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String property = additionalUserProperties . getProperty ( key ) ; m . definedProps . put ( key , property ) ; } } try { m . runBuild ( coreLoader ) ; System . exit ( 0 ) ; } catch ( BuildException be ) { if ( m . err != System . err ) { printMessage ( be ) ; } System . exit ( 1 ) ; } catch ( Throwable exc ) { exc . printStackTrace ( ) ; printMessage ( exc ) ; System . exit ( 1 ) ; } finally { if ( isLogFileUsed ) { if ( out != null ) { try { out . close ( ) ; } catch ( final Exception e ) { } } if ( err != null ) { try { err . close ( ) ; } catch ( final Exception e ) { } } } } } public static void main ( String [ ] args ) { start ( args , null , null ) ; } protected Main ( String [ ] args ) throws BuildException { String searchForThis = null ; PrintStream logTo = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( "-help" ) ) { printUsage ( ) ; return ; } else if ( arg . equals ( "-version" ) ) { printVersion ( ) ; return ; } else if ( arg . equals ( "-diagnostics" ) ) { Diagnostics . doReport ( System . out ) ; return ; } else if ( arg . equals ( "-quiet" ) || arg . equals ( "-q" ) ) { msgOutputLevel = Project . MSG_WARN ; } else if ( arg . equals ( "-verbose" ) || arg . equals ( "-v" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_VERBOSE ; } else if ( arg . equals ( "-debug" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_DEBUG ; } else if ( arg . equals ( "-logfile" ) || arg . equals ( "-l" ) ) { try { File logFile = new File ( args [ i + 1 ] ) ; i ++ ; logTo = new PrintStream ( new FileOutputStream ( logFile ) ) ; isLogFileUsed = true ; } catch ( IOException ioe ) { String msg = "Cannot write on the specified log file. " + "Make sure the path exists and you have write " + "permissions." ; System . out . println ( msg ) ; return ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a log file when " + "using the -log argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-buildfile" ) || arg . equals ( "-file" ) || arg . equals ( "-f" ) ) { try { buildFile = new File ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a buildfile when " + "using the -buildfile argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-listener" ) ) { try { listeners . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a classname when " + "using the -listener argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . startsWith ( "-D" ) ) { String name = arg . substring ( 2 , arg . length ( ) ) ; String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( posEq + 1 ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < args . length - 1 ) { value = args [ ++ i ] ; } definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( loggerClassname != null ) { System . out . println ( "Only one logger class may " + " be specified." ) ; return ; } try { loggerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { System . out . println ( "You must specify a classname when " + "using the -logger argument" ) ; return ; } } else if ( arg . equals ( "-inputhandler" ) ) { if ( inputHandlerClassname != null ) { System . out . println ( "Only one input handler class may " + "be specified." ) ; return ; } try { inputHandlerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { System . out . println ( "You must specify a classname when " + "using the -inputhandler argument" ) ; return ; } } else if ( arg . equals ( "-emacs" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) ) { if ( i < args . length - 1 ) { searchForThis = args [ ++ i ] ; } else { searchForThis = DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-propertyfile" ) ) { try { propertyFiles . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a property filename when " + "using the -propertyfile argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown argument: " + arg ; System . out . println ( msg ) ; printUsage ( ) ; return ; } else { targets . addElement ( arg ) ; } } if ( buildFile == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( System . getProperty ( "user.dir" ) , searchForThis ) ; } else { buildFile = new File ( DEFAULT_BUILD_FILENAME ) ; } } if ( ! buildFile . exists ( ) ) { System . out . println ( "Buildfile: " + buildFile + " does not exist!" ) ; throw new BuildException ( "Build failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( "What? Buildfile: " + buildFile + " is a dir!" ) ; throw new BuildException ( "Build failed" ) ; } for ( int propertyFileIndex = 0 ; propertyFileIndex < propertyFiles . size ( ) ; propertyFileIndex ++ ) { String filename = ( String ) propertyFiles . elementAt ( propertyFileIndex ) ; Properties props = new Properties ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( filename ) ; props . load ( fis ) ; } catch ( IOException e ) { System . out . println ( "Could not load property file " + filename + ": " + e . getMessage ( ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } } Enumeration propertyNames = props . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String name = ( String ) propertyNames . nextElement ( ) ; if ( definedProps . getProperty ( name ) == null ) { definedProps . put ( name , props . getProperty ( name ) ) ; } } } if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Buildfile: " + buildFile ) ; } if ( logTo != null ) { out = err = logTo ; System . setOut ( out ) ; System . setErr ( out ) ; } readyToRun = true ; } private File getParentFile ( File file ) { String filename = file . getAbsolutePath ( ) ; file = new File ( filename ) ; filename = file . getParent ( ) ; if ( filename != null && msgOutputLevel >= Project . MSG_VERBOSE ) { System . out . println ( "Searching in " + filename ) ; } return ( filename == null ) ? null : new File ( filename ) ; } private File findBuildFile ( String start , String suffix ) throws BuildException { if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Searching for " + suffix + " ..." ) ; } File parent = new File ( new File ( start ) . getAbsolutePath ( ) ) ; File file = new File ( parent , suffix ) ; while ( ! file . exists ( ) ) { parent = getParentFile ( parent ) ; if ( parent == null ) { throw new BuildException ( "Could not locate a build file!" ) ; } file = new File ( parent , suffix ) ; } return file ; } private void runBuild ( ClassLoader coreLoader ) throws BuildException { if ( ! readyToRun ) { return ; } final Project project = new Project ( ) ; project . setCoreLoader ( coreLoader ) ; Throwable error = null ; try { addBuildListeners ( project ) ; addInputHandler ( project ) ; PrintStream err = System . err ; PrintStream out = System . out ; SecurityManager oldsm = null ; if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { oldsm = System . getSecurityManager ( ) ; } try { System . setOut ( new PrintStream ( new DemuxOutputStream ( project , false ) ) ) ; System . setErr ( new PrintStream ( new DemuxOutputStream ( project , true ) ) ) ; if ( ! projectHelp ) { project . fireBuildStarted ( ) ; } project . init ( ) ; project . setUserProperty ( "ant.version" , getAntVersion ( ) ) ; Enumeration e = definedProps . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) definedProps . get ( arg ) ; project . setUserProperty ( arg , value ) ; } project . setUserProperty ( "ant.file" , buildFile . getAbsolutePath ( ) ) ; ProjectHelper . configureProject ( project , buildFile ) ; if ( projectHelp ) { printDescription ( project ) ; printTargets ( project , msgOutputLevel > Project . MSG_INFO ) ; return ; } if ( targets . size ( ) == 0 ) { targets . addElement ( project . getDefaultTarget ( ) ) ; } project . executeTargets ( targets ) ; } finally { if ( oldsm != null ) { System . setSecurityManager ( oldsm ) ; } System . setOut ( out ) ; System . setErr ( err ) ; } } catch ( RuntimeException exc ) { error = exc ; throw exc ; } catch ( Error err ) { error = err ; throw err ; } finally { if ( ! projectHelp ) { project . fireBuildFinished ( error ) ; } } } protected void addBuildListeners ( Project project ) { project . addBuildListener ( createLogger ( ) ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { String className = ( String ) listeners . elementAt ( i ) ; try { BuildListener listener = ( BuildListener ) Class . forName ( className ) . newInstance ( ) ; project . addBuildListener ( listener ) ; } catch ( Throwable exc ) { throw new BuildException ( "Unable to instantiate listener " + className , exc ) ; } } } private void addInputHandler ( Project project ) { InputHandler handler = null ; if ( inputHandlerClassname == null ) { handler = new DefaultInputHandler ( ) ; } else { try { handler = ( InputHandler ) ( Class . forName ( inputHandlerClassname ) . newInstance ( ) ) ; } catch ( ClassCastException e ) { String msg = "The specified input handler class " + inputHandlerClassname + " does not implement the InputHandler interface" ; throw new BuildException ( msg ) ; } catch ( Exception e ) { String msg = "Unable to instantiate specified input handler " + "class " + inputHandlerClassname + " : " + e . getClass ( ) . getName ( ) ; throw new BuildException ( msg ) ; } } project . setInputHandler ( handler ) ; } private BuildLogger createLogger ( ) { BuildLogger logger = null ; if ( loggerClassname != null ) { try { logger = ( BuildLogger ) ( Class . forName ( loggerClassname ) . newInstance ( ) ) ; } catch ( ClassCastException e ) { System . err . println ( "The specified logger class " + loggerClassname + " does not implement the BuildLogger interface" ) ; throw new RuntimeException ( ) ; } catch ( Exception e ) { System . err . println ( "Unable to instantiate specified logger " + "class " + loggerClassname + " : " + e . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( ) ; } } else { logger = new DefaultLogger ( ) ; } logger . setMessageOutputLevel ( msgOutputLevel ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( err ) ; logger . setEmacsMode ( emacsMode ) ; return logger ; } private static void printUsage ( ) { String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "ant [options] [target [target2 [target3] ...]]" + lSep ) ; msg . append ( "Options: " + lSep ) ; msg . append ( "  -help                  print this message" + lSep ) ; msg . append ( "  -projecthelp           print project help information" + lSep ) ; msg . append ( "  -version               print the version information and exit" + lSep ) ; msg . append ( "  -diagnostics           print information that might be helpful to" + lSep ) ; msg . append ( "                         diagnose or report problems." + lSep ) ; msg . append ( "  -quiet, -q             be extra quiet" + lSep ) ; msg . append ( "  -verbose, -v           be extra verbose" + lSep ) ; msg . append ( "  -debug                 print debugging information" + lSep ) ; msg . append ( "  -emacs                 produce logging information without adornments" + lSep ) ; msg . append ( "  -logfile <file>        use given file for log" + lSep ) ; msg . append ( "    -l     <file>                ''" + lSep ) ; msg . append ( "  -logger <classname>    the class which is to perform logging" + lSep ) ; msg . append ( "  -listener <classname>  add an instance of class as a project listener" + lSep ) ; msg . append ( "  -buildfile <file>      use given buildfile" + lSep ) ; msg . append ( "    -file    <file>              ''" + lSep ) ; msg . append ( "    -f       <file>              ''" + lSep ) ; msg . append ( "  -D<property>=<value>   use value for given property" + lSep ) ; msg . append ( "  -propertyfile <name>   load all properties from file with -D" + lSep ) ; msg . append ( "                         properties taking precedence" + lSep ) ; msg . append ( "  -inputhandler <class>  the class which will handle input requests" + lSep ) ; msg . append ( "  -find <file>           search for buildfile towards the root of the" + lSep ) ; msg . append ( "                         filesystem and use it" + lSep ) ; System . out . println ( msg . toString ( ) ) ; } private static void printVersion ( ) throws BuildException { System . out . println ( getAntVersion ( ) ) ; } private static String antVersion = null ; public static synchronized String getAntVersion ( ) throws BuildException { if ( antVersion == null ) { try { Properties props = new Properties ( ) ; InputStream in = Main . class . getResourceAsStream ( "/org/apache/tools/ant/version.txt" ) ; props . load ( in ) ; in . close ( ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "Apache Ant version " ) ; msg . append ( props . getProperty ( "VERSION" ) ) ; msg . append ( " compiled on " ) ; msg . append ( props . getProperty ( "DATE" ) ) ; antVersion = msg . toString ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not load the version information:" + ioe . getMessage ( ) ) ; } catch ( NullPointerException npe ) { throw new BuildException ( "Could not load the version information." ) ; } } return antVersion ; } private static void printDescription ( Project project ) { if ( project . getDescription ( ) != null ) { project . log ( project . getDescription ( ) ) ; } } private static void printTargets ( Project project , boolean printSubTargets ) { int maxLength = 0 ; Enumeration ptargets = project . getTargets ( ) . elements ( ) ; String targetName ; String targetDescription ; Target currentTarget ; Vector topNames = new Vector ( ) ; Vector topDescriptions = new Vector ( ) ; Vector subNames = new Vector ( ) ; while ( ptargets . hasMoreElements ( ) ) { currentTarget = ( Target ) ptargets . nextElement ( ) ; targetName = currentTarget . getName ( ) ; targetDescription = currentTarget . getDescription ( ) ; if ( targetDescription == null ) { int pos = findTargetPosition ( subNames , targetName ) ; subNames . insertElementAt ( targetName , pos ) ; } else { int pos = findTargetPosition ( topNames , targetName ) ; topNames . insertElementAt ( targetName , pos ) ; topDescriptions . insertElementAt ( targetDescription , pos ) ; if ( targetName . length ( ) > maxLength ) { maxLength = targetName . length ( ) ; } } } printTargets ( project , topNames , topDescriptions , "Main targets:" , maxLength ) ; if ( topNames . size ( ) == 0 ) { printSubTargets = true ; } if ( printSubTargets ) { printTargets ( project , subNames , null , "Subtargets:" , 0 ) ; } String defaultTarget = project . getDefaultTarget ( ) ; if ( defaultTarget != null && ! "" . equals ( defaultTarget ) ) { project . log ( "Default target: " + defaultTarget ) ; } } private static int findTargetPosition ( Vector names , String name ) { int res = names . size ( ) ; for ( int i = 0 ; i < names . size ( ) && res == names . size ( ) ; i ++ ) { if ( name . compareTo ( ( String ) names . elementAt ( i ) ) < 0 ) { res = i ; } } return res ; } private static void printTargets ( Project project , Vector names , Vector descriptions , String heading , int maxlen ) { String lSep = System . getProperty ( "line.separator" ) ; String spaces = "    " ; while ( spaces . length ( ) < maxlen ) { spaces += spaces ; } StringBuffer msg = new StringBuffer ( ) ; msg . append ( heading + lSep + lSep ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { msg . append ( " " ) ; msg . append ( names . elementAt ( i ) ) ; if ( descriptions != null ) { msg . append ( spaces . substring ( 0 , maxlen - ( ( String ) names . elementAt ( i ) ) . length ( ) + 2 ) ) ; msg . append ( descriptions . elementAt ( i ) ) ; } msg . append ( lSep ) ; } project . log ( msg . toString ( ) ) ; } } 	1	
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; class ProcessDestroyer extends Thread { private Vector processes = new Vector ( ) ; public ProcessDestroyer ( ) { try { Class [ ] paramTypes = { Thread . class } ; Method addShutdownHook = Runtime . class . getMethod ( "addShutdownHook" , paramTypes ) ; Object [ ] args = { this } ; addShutdownHook . invoke ( Runtime . getRuntime ( ) , args ) ; } catch ( Exception e ) { } } public boolean add ( Process process ) { processes . addElement ( process ) ; return processes . contains ( process ) ; } public boolean remove ( Process process ) { return processes . removeElement ( process ) ; } public void run ( ) { synchronized ( processes ) { Enumeration e = processes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( Process ) e . nextElement ( ) ) . destroy ( ) ; } } } } 	1	
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread inputThread ; private Thread errorThread ; private OutputStream out , err ; public PumpStreamHandler ( OutputStream out , OutputStream err ) { this . out = out ; this . err = err ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { createProcessErrorPump ( is , err ) ; } public void setProcessInputStream ( OutputStream os ) { } public void start ( ) { inputThread . start ( ) ; errorThread . start ( ) ; } public void stop ( ) { try { inputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } try { err . flush ( ) ; } catch ( IOException e ) { } try { out . flush ( ) ; } catch ( IOException e ) { } } protected OutputStream getErr ( ) { return err ; } protected OutputStream getOut ( ) { return out ; } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { inputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { final Thread result = new Thread ( new StreamPumper ( is , os ) ) ; result . setDaemon ( true ) ; return result ; } } 	1	
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . io . PrintStream ; public class ExecuteJava implements Runnable , TimeoutObserver { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; private Method main = null ; private Long timeout = null ; private Throwable caught = null ; private boolean timedOut = false ; private Thread thread = null ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setOutput ( PrintStream out ) { } public void setTimeout ( Long timeout ) { this . timeout = timeout ; } public void execute ( Project project ) throws BuildException { final String classname = javaCommand . getExecutable ( ) ; AntClassLoader loader = null ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) } ; Class target = null ; if ( classpath == null ) { target = Class . forName ( classname ) ; } else { loader = new AntClassLoader ( project . getCoreLoader ( ) , project , classpath , false ) ; loader . setIsolated ( true ) ; loader . setThreadContextLoader ( ) ; target = loader . forceLoadClass ( classname ) ; AntClassLoader . initializeClass ( target ) ; } main = target . getMethod ( "main" , param ) ; if ( main == null ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } if ( timeout == null ) { run ( ) ; } else { thread = new Thread ( this , "ExecuteJava" ) ; Task currentThreadTask = project . getThreadTask ( Thread . currentThread ( ) ) ; project . registerThreadTask ( thread , currentThreadTask ) ; thread . setDaemon ( true ) ; Watchdog w = new Watchdog ( timeout . longValue ( ) ) ; w . addTimeoutObserver ( this ) ; synchronized ( this ) { thread . start ( ) ; w . start ( ) ; try { wait ( ) ; } catch ( InterruptedException e ) { } if ( timedOut ) { project . log ( "Timeout: sub-process interrupted" , Project . MSG_WARN ) ; } else { thread = null ; w . stop ( ) ; } } } if ( caught != null ) { throw caught ; } } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + "." + " Make sure you have it in your" + " classpath" ) ; } catch ( SecurityException e ) { throw e ; } catch ( Throwable e ) { throw new BuildException ( e ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; } if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } } } public void run ( ) { final Object [ ] argument = { javaCommand . getArguments ( ) } ; try { main . invoke ( null , argument ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof InterruptedException ) ) { caught = t ; } } catch ( Throwable t ) { caught = t ; } finally { synchronized ( this ) { notifyAll ( ) ; } } } public synchronized void timeoutOccured ( Watchdog w ) { if ( thread != null ) { timedOut = true ; thread . interrupt ( ) ; } notifyAll ( ) ; } public boolean killedProcess ( ) { return timedOut ; } } 	1	
package org . apache . tools . ant . util ; import java . io . BufferedInputStream ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . lang . reflect . Method ; import java . text . DecimalFormat ; import java . util . Random ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import java . net . URL ; import java . net . MalformedURLException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . taskdefs . condition . Os ; public class FileUtils { private static Random rand = new Random ( System . currentTimeMillis ( ) ) ; private static Object lockReflection = new Object ( ) ; private static java . lang . reflect . Method setLastModified = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; public static FileUtils newFileUtils ( ) { return new FileUtils ( ) ; } protected FileUtils ( ) { } public URL getFileURL ( File file ) throws MalformedURLException { String uri = "file:" + file . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; for ( int i = uri . indexOf ( '#' ) ; i != - 1 ; i = uri . indexOf ( '#' ) ) { uri = uri . substring ( 0 , i ) + "%23" + uri . substring ( i + 1 ) ; } if ( file . isDirectory ( ) ) { uri += "/" ; } return new URL ( uri ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , null , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified , encoding ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , filterChains , overwrite , preserveLastModified , encoding , project ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , null , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { copyFile ( sourceFile , destFile , filters , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , preserveLastModified , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { copyFile ( sourceFile , destFile , filters , null , overwrite , preserveLastModified , encoding , null ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { if ( overwrite || ! destFile . exists ( ) || destFile . lastModified ( ) < sourceFile . lastModified ( ) ) { if ( destFile . exists ( ) && destFile . isFile ( ) ) { destFile . delete ( ) ; } File parent = getParentFile ( destFile ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } final boolean filterSetsAvailable = ( filters != null && filters . hasFilters ( ) ) ; final boolean filterChainsAvailable = ( filterChains != null && filterChains . size ( ) > 0 ) ; if ( filterSetsAvailable || filterChainsAvailable ) { BufferedReader in = null ; BufferedWriter out = null ; try { if ( encoding == null ) { in = new BufferedReader ( new FileReader ( sourceFile ) ) ; out = new BufferedWriter ( new FileWriter ( destFile ) ) ; } else { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sourceFile ) , encoding ) ) ; out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( destFile ) , encoding ) ) ; } if ( filterChainsAvailable ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( 8192 ) ; crh . setPrimaryReader ( in ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; Reader rdr = crh . getAssembledReader ( ) ; in = new BufferedReader ( rdr ) ; } int length ; String newline = null ; String line = in . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { if ( filterSetsAvailable ) { newline = filters . replaceTokens ( line ) ; } else { newline = line ; } out . write ( newline ) ; out . newLine ( ) ; } line = in . readLine ( ) ; } } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } else { FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( sourceFile ) ; out = new FileOutputStream ( destFile ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } finally { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } } if ( preserveLastModified ) { setFileLastModified ( destFile , sourceFile . lastModified ( ) ) ; } } } protected final Method getSetLastModified ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return null ; } if ( setLastModified == null ) { synchronized ( lockReflection ) { if ( setLastModified == null ) { try { setLastModified = java . io . File . class . getMethod ( "setLastModified" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { throw new BuildException ( "File.setlastModified not in JDK > 1.1?" , nse ) ; } } } } return setLastModified ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return ; } Long [ ] times = new Long [ 1 ] ; if ( time < 0 ) { times [ 0 ] = new Long ( System . currentTimeMillis ( ) ) ; } else { times [ 0 ] = new Long ( time ) ; } try { getSetLastModified ( ) . invoke ( file , times ) ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new BuildException ( "Exception setting the modification time " + "of " + file , nested ) ; } catch ( Throwable other ) { throw new BuildException ( "Exception setting the modification time " + "of " + file , other ) ; } } public File resolveFile ( File file , String filename ) { filename = filename . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( ! onNetWare ) { if ( filename . startsWith ( File . separator ) || ( filename . length ( ) >= 2 && Character . isLetter ( filename . charAt ( 0 ) ) && filename . charAt ( 1 ) == ':' ) ) { return normalize ( filename ) ; } } else { int colon = filename . indexOf ( ":" ) ; if ( filename . startsWith ( File . separator ) || ( colon > - 1 ) ) { return normalize ( filename ) ; } } if ( file == null ) { return new File ( filename ) ; } File helpFile = new File ( file . getAbsolutePath ( ) ) ; StringTokenizer tok = new StringTokenizer ( filename , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String part = tok . nextToken ( ) ; if ( part . equals ( ".." ) ) { helpFile = getParentFile ( helpFile ) ; if ( helpFile == null ) { String msg = "The file or path you specified (" + filename + ") is invalid relative to " + file . getPath ( ) ; throw new BuildException ( msg ) ; } } else if ( part . equals ( "." ) ) { } else { helpFile = new File ( helpFile , part ) ; } } return new File ( helpFile . getAbsolutePath ( ) ) ; } public File normalize ( String path ) { String orig = path ; path = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; int colon = path . indexOf ( ":" ) ; if ( ! onNetWare ) { if ( ! path . startsWith ( File . separator ) && ! ( path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && colon == 1 ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } } else { if ( ! path . startsWith ( File . separator ) && ( colon == - 1 ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } } boolean dosWithDrive = false ; String root = null ; if ( ( ! onNetWare && path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && path . charAt ( 1 ) == ':' ) || ( onNetWare && colon > - 1 ) ) { dosWithDrive = true ; char [ ] ca = path . replace ( '/' , '\\' ) . toCharArray ( ) ; StringBuffer sbRoot = new StringBuffer ( ) ; for ( int i = 0 ; i < colon ; i ++ ) { sbRoot . append ( Character . toUpperCase ( ca [ i ] ) ) ; } sbRoot . append ( ':' ) ; if ( colon + 1 < path . length ( ) ) { sbRoot . append ( File . separatorChar ) ; } root = sbRoot . toString ( ) ; StringBuffer sbPath = new StringBuffer ( ) ; for ( int i = colon + 1 ; i < ca . length ; i ++ ) { if ( ( ca [ i ] != '\\' ) || ( ca [ i ] == '\\' && ca [ i - 1 ] != '\\' ) ) { sbPath . append ( ca [ i ] ) ; } } path = sbPath . toString ( ) . replace ( '\\' , File . separatorChar ) ; } else { if ( path . length ( ) == 1 ) { root = File . separator ; path = "" ; } else if ( path . charAt ( 1 ) == File . separatorChar ) { root = File . separator + File . separator ; path = path . substring ( 2 ) ; } else { root = File . separator ; path = path . substring ( 1 ) ; } } Stack s = new Stack ( ) ; s . push ( root ) ; StringTokenizer tok = new StringTokenizer ( path , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String thisToken = tok . nextToken ( ) ; if ( "." . equals ( thisToken ) ) { continue ; } else if ( ".." . equals ( thisToken ) ) { if ( s . size ( ) < 2 ) { throw new BuildException ( "Cannot resolve path " + orig ) ; } else { s . pop ( ) ; } } else { s . push ( thisToken ) ; } } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i > 1 ) { sb . append ( File . separatorChar ) ; } sb . append ( s . elementAt ( i ) ) ; } path = sb . toString ( ) ; if ( dosWithDrive ) { path = path . replace ( '/' , '\\' ) ; } return new File ( path ) ; } public File createTempFile ( String prefix , String suffix , File parentDir ) { File result = null ; String parent = null ; if ( parentDir != null ) { parent = parentDir . getPath ( ) ; } DecimalFormat fmt = new DecimalFormat ( "#####" ) ; synchronized ( rand ) { do { result = new File ( parent , prefix + fmt . format ( rand . nextInt ( ) ) + suffix ) ; } while ( result . exists ( ) ) ; } return result ; } public boolean contentEquals ( File f1 , File f2 ) throws IOException { if ( f1 . exists ( ) != f2 . exists ( ) ) { return false ; } if ( ! f1 . exists ( ) ) { return true ; } if ( f1 . isDirectory ( ) || f2 . isDirectory ( ) ) { return false ; } if ( f1 . equals ( f2 ) ) { return true ; } if ( f1 . length ( ) != f2 . length ( ) ) { return false ; } InputStream in1 = null ; InputStream in2 = null ; try { in1 = new BufferedInputStream ( new FileInputStream ( f1 ) ) ; in2 = new BufferedInputStream ( new FileInputStream ( f2 ) ) ; int expectedByte = in1 . read ( ) ; while ( expectedByte != - 1 ) { if ( expectedByte != in2 . read ( ) ) { return false ; } expectedByte = in1 . read ( ) ; } if ( in2 . read ( ) != - 1 ) { return false ; } return true ; } finally { if ( in1 != null ) { try { in1 . close ( ) ; } catch ( IOException e ) { } } if ( in2 != null ) { try { in2 . close ( ) ; } catch ( IOException e ) { } } } } public File getParentFile ( File f ) { if ( f != null ) { String p = f . getParent ( ) ; if ( p != null ) { return new File ( p ) ; } } return null ; } public static final String readFully ( Reader rdr ) throws IOException { return readFully ( rdr , 8192 ) ; } public static final String readFully ( Reader rdr , int bufferSize ) throws IOException { if ( bufferSize <= 0 ) { throw new IllegalArgumentException ( "Buffer size must be greater " + "than 0" ) ; } final char [ ] buffer = new char [ bufferSize ] ; int bufferLength = 0 ; String text = null ; StringBuffer textBuffer = null ; while ( bufferLength != - 1 ) { bufferLength = rdr . read ( buffer ) ; if ( bufferLength != - 1 ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( new String ( buffer , 0 , bufferLength ) ) ; } else { textBuffer . append ( new String ( buffer , 0 , bufferLength ) ) ; } } } if ( textBuffer != null ) { text = textBuffer . toString ( ) ; } return text ; } public boolean createNewFile ( File f ) throws IOException { if ( f != null ) { if ( f . exists ( ) ) { return false ; } FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; fos . write ( new byte [ 0 ] ) ; } finally { if ( fos != null ) { fos . close ( ) ; } } return true ; } return false ; } public boolean isSymbolicLink ( File parent , String name ) throws IOException { File resolvedParent = new File ( parent . getCanonicalPath ( ) ) ; File toTest = new File ( resolvedParent , name ) ; return ! toTest . getAbsolutePath ( ) . equals ( toTest . getCanonicalPath ( ) ) ; } public String removeLeadingPath ( File leading , File path ) { String l = normalize ( leading . getAbsolutePath ( ) ) . getAbsolutePath ( ) + File . separator ; String p = normalize ( path . getAbsolutePath ( ) ) . getAbsolutePath ( ) ; if ( p . startsWith ( l ) ) { return p . substring ( l . length ( ) ) ; } else { return p ; } } } 	1	
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . util . StringUtils ; public abstract class AbstractCvsTask extends Task { public static final int DEFAULT_COMPRESSION_LEVEL = 3 ; private Commandline cmd = new Commandline ( ) ; private Vector vecCommandlines = new Vector ( ) ; private String cvsRoot ; private String cvsRsh ; private String cvsPackage ; private static final String default_command = "checkout" ; private String command = null ; private boolean quiet = false ; private int compression = 0 ; private boolean noexec = false ; private int port = 0 ; private File passFile = null ; private File dest ; private boolean append = false ; private File output ; private File error ; private boolean failOnError = false ; private ExecuteStreamHandler executeStreamHandler ; private OutputStream outputStream ; private OutputStream errorStream ; public AbstractCvsTask ( ) { super ( ) ; } public void setExecuteStreamHandler ( ExecuteStreamHandler handler ) { this . executeStreamHandler = handler ; } protected ExecuteStreamHandler getExecuteStreamHandler ( ) { if ( this . executeStreamHandler == null ) { setExecuteStreamHandler ( new PumpStreamHandler ( getOutputStream ( ) , getErrorStream ( ) ) ) ; } return this . executeStreamHandler ; } protected void setOutputStream ( OutputStream outputStream ) { this . outputStream = outputStream ; } protected OutputStream getOutputStream ( ) { if ( this . outputStream == null ) { if ( output != null ) { try { setOutputStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { setOutputStream ( new LogOutputStream ( this , Project . MSG_INFO ) ) ; } } return this . outputStream ; } protected void setErrorStream ( OutputStream errorStream ) { this . errorStream = errorStream ; } protected OutputStream getErrorStream ( ) { if ( this . errorStream == null ) { if ( error != null ) { try { setErrorStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { setErrorStream ( new LogOutputStream ( this , Project . MSG_WARN ) ) ; } } return this . errorStream ; } protected void runCommand ( Commandline toExecute ) throws BuildException { Environment env = new Environment ( ) ; if ( port > 0 ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_CLIENT_PORT" ) ; var . setValue ( String . valueOf ( port ) ) ; env . addVariable ( var ) ; } if ( passFile == null ) { File defaultPassFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; if ( defaultPassFile . exists ( ) ) this . setPassfile ( defaultPassFile ) ; } if ( passFile != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_PASSFILE" ) ; var . setValue ( String . valueOf ( passFile ) ) ; env . addVariable ( var ) ; log ( "Using cvs passfile: " + String . valueOf ( passFile ) , Project . MSG_INFO ) ; } if ( cvsRsh != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_RSH" ) ; var . setValue ( String . valueOf ( cvsRsh ) ) ; env . addVariable ( var ) ; } Execute exe = new Execute ( getExecuteStreamHandler ( ) , null ) ; exe . setAntRun ( project ) ; if ( dest == null ) { dest = project . getBaseDir ( ) ; } if ( ! dest . exists ( ) ) { dest . mkdirs ( ) ; } exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; exe . setEnvironment ( env . getVariables ( ) ) ; try { String actualCommandLine = executeToString ( exe ) ; log ( actualCommandLine , Project . MSG_VERBOSE ) ; int retCode = exe . execute ( ) ; log ( "retCode=" + retCode , Project . MSG_DEBUG ) ; if ( failOnError && retCode != 0 ) { throw new BuildException ( "cvs exited with error code " + retCode + StringUtils . LINE_SEP + "Command line was [" + actualCommandLine + "]" , location ) ; } } catch ( IOException e ) { if ( failOnError ) { throw new BuildException ( e , location ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } catch ( BuildException e ) { if ( failOnError ) { throw ( e ) ; } else { Throwable t = e . getException ( ) ; if ( t == null ) { t = e ; } log ( "Caught exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e , location ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } finally { if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( IOException e ) { } } if ( errorStream != null ) { try { errorStream . close ( ) ; } catch ( IOException e ) { } } } } public void execute ( ) throws BuildException { String savedCommand = getCommand ( ) ; if ( this . getCommand ( ) == null && vecCommandlines . size ( ) == 0 ) { this . setCommand ( AbstractCvsTask . default_command ) ; } String c = this . getCommand ( ) ; Commandline cloned = null ; if ( c != null ) { cloned = ( Commandline ) cmd . clone ( ) ; cloned . createArgument ( true ) . setLine ( c ) ; this . addConfiguredCommandline ( cloned , true ) ; } try { for ( int i = 0 ; i < vecCommandlines . size ( ) ; i ++ ) { this . runCommand ( ( Commandline ) vecCommandlines . elementAt ( i ) ) ; } } finally { if ( cloned != null ) { removeCommandline ( cloned ) ; } setCommand ( savedCommand ) ; } } private String executeToString ( Execute execute ) { StringBuffer stringBuffer = new StringBuffer ( Commandline . describeCommand ( execute . getCommandline ( ) ) ) ; String newLine = StringUtils . LINE_SEP ; String [ ] variableArray = execute . getEnvironment ( ) ; if ( variableArray != null ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( newLine ) ; stringBuffer . append ( "environment:" ) ; stringBuffer . append ( newLine ) ; for ( int z = 0 ; z < variableArray . length ; z ++ ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( "\t" ) ; stringBuffer . append ( variableArray [ z ] ) ; } } return stringBuffer . toString ( ) ; } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) { root = null ; } } this . cvsRoot = root ; } public String getCvsRoot ( ) { return this . cvsRoot ; } public void setCvsRsh ( String rsh ) { if ( rsh != null ) { if ( rsh . trim ( ) . equals ( "" ) ) { rsh = null ; } } this . cvsRsh = rsh ; } public String getCvsRsh ( ) { return this . cvsRsh ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return this . port ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public File getPassFile ( ) { return this . passFile ; } public void setDest ( File dest ) { this . dest = dest ; } public File getDest ( ) { return this . dest ; } public void setPackage ( String p ) { this . cvsPackage = p ; } public String getPackage ( ) { return this . cvsPackage ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-r" ) ; addCommandArgument ( p ) ; } } public void addCommandArgument ( String arg ) { this . addCommandArgument ( cmd , arg ) ; } public void addCommandArgument ( Commandline c , String arg ) { c . createArgument ( ) . setValue ( arg ) ; } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-D" ) ; addCommandArgument ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public String getCommand ( ) { return this . command ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setAppend ( boolean value ) { this . append = value ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } protected void configureCommandline ( Commandline c ) { if ( c == null ) { return ; } c . setExecutable ( "cvs" ) ; if ( cvsPackage != null ) { c . createArgument ( ) . setLine ( cvsPackage ) ; } if ( this . compression > 0 && this . compression < 10 ) { c . createArgument ( true ) . setValue ( "-z" + this . compression ) ; } if ( quiet ) { c . createArgument ( true ) . setValue ( "-q" ) ; } if ( noexec ) { c . createArgument ( true ) . setValue ( "-n" ) ; } if ( cvsRoot != null ) { c . createArgument ( true ) . setLine ( "-d" + cvsRoot ) ; } } protected void removeCommandline ( Commandline c ) { vecCommandlines . removeElement ( c ) ; } public void addConfiguredCommandline ( Commandline c ) { this . addConfiguredCommandline ( c , false ) ; } public void addConfiguredCommandline ( Commandline c , boolean insertAtStart ) { if ( c == null ) { return ; } this . configureCommandline ( c ) ; if ( insertAtStart ) { vecCommandlines . insertElementAt ( c , 0 ) ; } else { vecCommandlines . addElement ( c ) ; } } public void setCompressionLevel ( int level ) { this . compression = level ; } public void setCompression ( boolean usecomp ) { setCompressionLevel ( usecomp ? AbstractCvsTask . DEFAULT_COMPRESSION_LEVEL : 0 ) ; } } 	1	
package org . apache . tools . ant ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Stack ; public class XmlLogger implements BuildLogger { private int msgOutputLevel = Project . MSG_DEBUG ; private PrintStream outStream ; private static final DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private static final String STACKTRACE_TAG = "stacktrace" ; private Document doc = builder . newDocument ( ) ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private TimedElement buildElement = null ; private static class TimedElement { private long startTime ; private Element element ; } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildElement = new TimedElement ( ) ; buildElement . startTime = System . currentTimeMillis ( ) ; buildElement . element = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildElement . startTime ; buildElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . element . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; Throwable t = event . getException ( ) ; Text errText = doc . createCDATASection ( StringUtils . getStackTrace ( t ) ) ; Element stacktrace = doc . createElement ( STACKTRACE_TAG ) ; stacktrace . appendChild ( errText ) ; buildElement . element . appendChild ( stacktrace ) ; } String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } String xslUri = event . getProject ( ) . getProperty ( "ant.XmlLogger.stylesheet.uri" ) ; if ( xslUri == null ) { xslUri = "log.xsl" ; } Writer out = null ; try { OutputStream stream = outStream ; if ( stream == null ) { stream = new FileOutputStream ( outFilename ) ; } out = new OutputStreamWriter ( stream , "UTF8" ) ; out . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" ) ; if ( xslUri . length ( ) > 0 ) { out . write ( "<?xml-stylesheet type=\"text/xsl\" href=\"" + xslUri + "\"?>\n\n" ) ; } ( new DOMElementWriter ( ) ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to write log file" , exc ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { } } } buildElement = null ; } private Stack getStack ( ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack == null ) { threadStack = new Stack ( ) ; threadStacks . put ( Thread . currentThread ( ) , threadStack ) ; } return threadStack ; } public void targetStarted ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = new TimedElement ( ) ; targetElement . startTime = System . currentTimeMillis ( ) ; targetElement . element = doc . createElement ( TARGET_TAG ) ; targetElement . element . setAttribute ( NAME_ATTR , target . getName ( ) ) ; targets . put ( target , targetElement ) ; getStack ( ) . push ( targetElement ) ; } public void targetFinished ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement != null ) { long totalTime = System . currentTimeMillis ( ) - targetElement . startTime ; targetElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; TimedElement parentElement = null ; Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != targetElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished target element = " + targetElement . element ) ; } if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } if ( parentElement == null ) { buildElement . element . appendChild ( targetElement . element ) ; } else { parentElement . element . appendChild ( targetElement . element ) ; } } } public void taskStarted ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = new TimedElement ( ) ; taskElement . startTime = System . currentTimeMillis ( ) ; taskElement . element = doc . createElement ( TASK_TAG ) ; String name = event . getTask ( ) . getTaskName ( ) ; taskElement . element . setAttribute ( NAME_ATTR , name ) ; taskElement . element . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; tasks . put ( task , taskElement ) ; getStack ( ) . push ( taskElement ) ; } public void taskFinished ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = ( TimedElement ) tasks . get ( task ) ; if ( taskElement != null ) { long totalTime = System . currentTimeMillis ( ) - taskElement . startTime ; taskElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; Target target = task . getOwningTarget ( ) ; TimedElement targetElement = null ; if ( target != null ) { targetElement = ( TimedElement ) targets . get ( target ) ; } if ( targetElement == null ) { buildElement . element . appendChild ( taskElement . element ) ; } else { targetElement . element . appendChild ( taskElement . element ) ; } Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != taskElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished task element = " + taskElement . element ) ; } } } } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority > msgOutputLevel ) { return ; } Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Text messageText = doc . createCDATASection ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; TimedElement parentElement = null ; Task task = event . getTask ( ) ; Target target = event . getTarget ( ) ; if ( task != null ) { parentElement = ( TimedElement ) tasks . get ( task ) ; } if ( parentElement == null && target != null ) { parentElement = ( TimedElement ) targets . get ( target ) ; } if ( parentElement == null ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack != null ) { if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } } if ( parentElement != null ) { parentElement . element . appendChild ( messageElement ) ; } else { buildElement . element . appendChild ( messageElement ) ; } } public void setMessageOutputLevel ( int level ) { msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . outStream = new PrintStream ( output , true ) ; } public void setEmacsMode ( boolean emacsMode ) { } public void setErrorPrintStream ( PrintStream err ) { } } 	1	
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . taskdefs . condition . Os ; import java . io . File ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . ByteArrayOutputStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; public class Execute { public static final int INVALID = Integer . MAX_VALUE ; private String [ ] cmdl = null ; private String [ ] env = null ; private int exitValue = INVALID ; private ExecuteStreamHandler streamHandler ; private ExecuteWatchdog watchdog ; private File workingDirectory = null ; private Project project = null ; private boolean newEnvironment = false ; private boolean useVMLauncher = true ; private static String antWorkingDirectory = System . getProperty ( "user.dir" ) ; private static CommandLauncher vmLauncher = null ; private static CommandLauncher shellLauncher = null ; private static Vector procEnvironment = null ; private static ProcessDestroyer processDestroyer = new ProcessDestroyer ( ) ; static { try { vmLauncher = new Java13CommandLauncher ( ) ; } catch ( NoSuchMethodException exc ) { } if ( Os . isFamily ( "mac" ) ) { shellLauncher = new MacCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "os/2" ) ) { shellLauncher = new WinNTCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "windows" ) ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } if ( ! Os . isFamily ( "win9x" ) ) { shellLauncher = new WinNTCommandLauncher ( baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun.bat" , baseLauncher ) ; } } else if ( Os . isFamily ( "netware" ) ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } shellLauncher = new PerlScriptCommandLauncher ( "bin/antRun.pl" , baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun" , new CommandLauncher ( ) ) ; } } public static synchronized Vector getProcEnvironment ( ) { if ( procEnvironment != null ) { return procEnvironment ; } procEnvironment = new Vector ( ) ; try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Execute exe = new Execute ( new PumpStreamHandler ( out ) ) ; exe . setCommandline ( getProcEnvCommand ( ) ) ; exe . setNewenvironment ( true ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { } BufferedReader in = new BufferedReader ( new StringReader ( toString ( out ) ) ) ; String var = null ; String line , lineSep = System . getProperty ( "line.separator" ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . indexOf ( '=' ) == - 1 ) { if ( var == null ) { var = lineSep + line ; } else { var += lineSep + line ; } } else { if ( var != null ) { procEnvironment . addElement ( var ) ; } var = line ; } } if ( var != null ) { procEnvironment . addElement ( var ) ; } } catch ( java . io . IOException exc ) { exc . printStackTrace ( ) ; } return procEnvironment ; } private static String [ ] getProcEnvCommand ( ) { if ( Os . isFamily ( "os/2" ) ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else if ( Os . isFamily ( "windows" ) ) { if ( ! Os . isFamily ( "win9x" ) ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else { String [ ] cmd = { "command.com" , "/c" , "set" } ; return cmd ; } } else if ( Os . isFamily ( "z/os" ) ) { String [ ] cmd = { "/bin/env" } ; return cmd ; } else if ( Os . isFamily ( "unix" ) ) { String [ ] cmd = { "/usr/bin/env" } ; return cmd ; } else if ( Os . isFamily ( "netware" ) ) { String [ ] cmd = { "env" } ; return cmd ; } else { String [ ] cmd = null ; return cmd ; } } public static String toString ( ByteArrayOutputStream bos ) { if ( Os . isFamily ( "z/os" ) ) { try { bos . toString ( "Cp1047" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } return bos . toString ( ) ; } public Execute ( ) { this ( new PumpStreamHandler ( ) , null ) ; } public Execute ( ExecuteStreamHandler streamHandler ) { this ( streamHandler , null ) ; } public Execute ( ExecuteStreamHandler streamHandler , ExecuteWatchdog watchdog ) { this . streamHandler = streamHandler ; this . watchdog = watchdog ; } public String [ ] getCommandline ( ) { return cmdl ; } public void setCommandline ( String [ ] commandline ) { cmdl = commandline ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public String [ ] getEnvironment ( ) { if ( env == null || newEnvironment ) { return env ; } return patchEnvironment ( ) ; } public void setEnvironment ( String [ ] env ) { this . env = env ; } public void setWorkingDirectory ( File wd ) { if ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) { workingDirectory = null ; } else { workingDirectory = wd ; } } public void setAntRun ( Project project ) throws BuildException { this . project = project ; } public void setVMLauncher ( boolean useVMLauncher ) { this . useVMLauncher = useVMLauncher ; } public static Process launch ( Project project , String [ ] command , String [ ] env , File dir , boolean useVM ) throws IOException { CommandLauncher launcher = vmLauncher != null ? vmLauncher : shellLauncher ; if ( ! useVM ) { launcher = shellLauncher ; } return launcher . exec ( project , command , env , dir ) ; } public int execute ( ) throws IOException { final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; try { streamHandler . setProcessInputStream ( process . getOutputStream ( ) ) ; streamHandler . setProcessOutputStream ( process . getInputStream ( ) ) ; streamHandler . setProcessErrorStream ( process . getErrorStream ( ) ) ; } catch ( IOException e ) { process . destroy ( ) ; throw e ; } streamHandler . start ( ) ; processDestroyer . add ( process ) ; if ( watchdog != null ) { watchdog . start ( process ) ; } waitFor ( process ) ; processDestroyer . remove ( process ) ; if ( watchdog != null ) { watchdog . stop ( ) ; } streamHandler . stop ( ) ; if ( watchdog != null ) { watchdog . checkException ( ) ; } return getExitValue ( ) ; } protected void waitFor ( Process process ) { try { process . waitFor ( ) ; setExitValue ( process . exitValue ( ) ) ; } catch ( InterruptedException e ) { } } protected void setExitValue ( int value ) { exitValue = value ; } public int getExitValue ( ) { return exitValue ; } public boolean killedProcess ( ) { return watchdog != null && watchdog . killedProcess ( ) ; } private String [ ] patchEnvironment ( ) { Vector osEnv = ( Vector ) getProcEnvironment ( ) . clone ( ) ; for ( int i = 0 ; i < env . length ; i ++ ) { int pos = env [ i ] . indexOf ( '=' ) ; String key = env [ i ] . substring ( 0 , pos + 1 ) ; int size = osEnv . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { if ( ( ( String ) osEnv . elementAt ( j ) ) . startsWith ( key ) ) { osEnv . removeElementAt ( j ) ; break ; } } osEnv . addElement ( env [ i ] ) ; } String [ ] result = new String [ osEnv . size ( ) ] ; osEnv . copyInto ( result ) ; return result ; } public static void runCommand ( Task task , String [ ] cmdline ) throws BuildException { try { task . log ( Commandline . describeCommand ( cmdline ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( new LogStreamHandler ( task , Project . MSG_INFO , Project . MSG_ERR ) ) ; exe . setAntRun ( task . getProject ( ) ) ; exe . setCommandline ( cmdline ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { throw new BuildException ( cmdline [ 0 ] + " failed with return code " + retval , task . getLocation ( ) ) ; } } catch ( java . io . IOException exc ) { throw new BuildException ( "Could not launch " + cmdline [ 0 ] + ": " + exc , task . getLocation ( ) ) ; } } private static class CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { if ( project != null ) { project . log ( "Execute:CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( cmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot execute a process in different " + "directory under this JVM" ) ; } } private static class Java11CommandLauncher extends CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { String [ ] newcmd = new String [ cmd . length ] ; for ( int i = 0 ; i < cmd . length ; i ++ ) { newcmd [ i ] = Commandline . quoteArgument ( cmd [ i ] ) ; } if ( project != null ) { project . log ( "Execute:Java11CommandLauncher: " + Commandline . describeCommand ( newcmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( newcmd , env ) ; } } private static class Java13CommandLauncher extends CommandLauncher { public Java13CommandLauncher ( ) throws NoSuchMethodException { _execWithCWD = Runtime . class . getMethod ( "exec" , new Class [ ] { String [ ] . class , String [ ] . class , File . class } ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { try { if ( project != null ) { project . log ( "Execute:Java13CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } Object [ ] arguments = { cmd , env , workingDir } ; return ( Process ) _execWithCWD . invoke ( Runtime . getRuntime ( ) , arguments ) ; } catch ( InvocationTargetException exc ) { Throwable realexc = exc . getTargetException ( ) ; if ( realexc instanceof ThreadDeath ) { throw ( ThreadDeath ) realexc ; } else if ( realexc instanceof IOException ) { throw ( IOException ) realexc ; } else { throw new BuildException ( "Unable to execute command" , realexc ) ; } } catch ( Exception exc ) { throw new BuildException ( "Unable to execute command" , exc ) ; } } private Method _execWithCWD ; } private static class CommandLauncherProxy extends CommandLauncher { CommandLauncherProxy ( CommandLauncher launcher ) { _launcher = launcher ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { return _launcher . exec ( project , cmd , env ) ; } private CommandLauncher _launcher ; } private static class WinNTCommandLauncher extends CommandLauncherProxy { WinNTCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 6 ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = "cd" ; newcmd [ 3 ] = "/d" ; newcmd [ 4 ] = commandDir . getAbsolutePath ( ) ; newcmd [ 5 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class MacCommandLauncher extends CommandLauncherProxy { MacCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } System . getProperties ( ) . put ( "user.dir" , workingDir . getAbsolutePath ( ) ) ; try { return exec ( project , cmd , env ) ; } finally { System . getProperties ( ) . put ( "user.dir" , antWorkingDirectory ) ; } } } private static class ScriptCommandLauncher extends CommandLauncherProxy { ScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; _script = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + _script ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 2 ] ; newcmd [ 0 ] = antRun ; newcmd [ 1 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 2 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String _script ; } private static class PerlScriptCommandLauncher extends CommandLauncherProxy { PerlScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; _script = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + _script ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 3 ] ; newcmd [ 0 ] = "perl" ; newcmd [ 1 ] = antRun ; newcmd [ 2 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 3 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String _script ; } } 	1	
package org . apache . tools . ant ; public class ExitException extends SecurityException { private int status ; public ExitException ( int status ) { super ( "ExitException: status " + status ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	1	
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Cvs ; import org . apache . tools . ant . util . FileUtils ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; public class CvsTagDiff extends Task { static final String FILE_IS_NEW = " is new; current revision " ; static final String FILE_HAS_CHANGED = " changed from revision " ; static final String FILE_WAS_REMOVED = " is removed" ; private Cvs m_cvs ; private String m_package ; private String m_startTag ; private String m_endTag ; private String m_startDate ; private String m_endDate ; private File m_destfile ; private FileUtils m_fileUtils = FileUtils . newFileUtils ( ) ; public void init ( ) throws BuildException { m_cvs = ( Cvs ) getProject ( ) . createTask ( "cvs" ) ; } public void setCompressionLevel ( int level ) { m_cvs . setCompressionLevel ( level ) ; } public void setCompression ( boolean usecomp ) { m_cvs . setCompression ( usecomp ) ; } public void setCvsRoot ( String cvsRoot ) { m_cvs . setCvsRoot ( cvsRoot ) ; } public void setCvsRsh ( String rsh ) { m_cvs . setCvsRsh ( rsh ) ; } public void setPackage ( String p ) { m_package = p ; } public void setQuiet ( boolean quiet ) { m_cvs . setQuiet ( quiet ) ; } public void setPort ( int port ) { m_cvs . setPort ( port ) ; } public void setPassfile ( File f ) { m_cvs . setPassfile ( f ) ; } public void setFailOnError ( boolean b ) { m_cvs . setFailOnError ( b ) ; } public void setStartTag ( String s ) { m_startTag = s ; } public void setStartDate ( String s ) { m_startDate = s ; } public void setEndTag ( String s ) { m_endTag = s ; } public void setEndDate ( String s ) { m_endDate = s ; } public void setDestFile ( File f ) { m_destfile = f ; } public void execute ( ) throws BuildException { validate ( ) ; String rdiff = "rdiff -s " + ( m_startTag != null ? ( "-r " + m_startTag ) : ( "-D " + m_startDate ) ) + " " + ( m_endTag != null ? ( "-r " + m_endTag ) : ( "-D " + m_endDate ) ) + " " + m_package ; log ( "Cvs command is " + rdiff , Project . MSG_VERBOSE ) ; m_cvs . setCommand ( rdiff ) ; File tmpFile = null ; try { tmpFile = m_fileUtils . createTempFile ( "cvstagdiff" , ".log" , null ) ; m_cvs . setOutput ( tmpFile ) ; m_cvs . execute ( ) ; CvsTagEntry [ ] entries = parseRDiff ( tmpFile ) ; writeTagDiff ( entries ) ; } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private CvsTagEntry [ ] parseRDiff ( File tmpFile ) throws BuildException { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( tmpFile ) ) ; int headerLength = 5 + m_package . length ( ) + 1 ; Vector entries = new Vector ( ) ; String line = reader . readLine ( ) ; int index ; CvsTagEntry entry = null ; while ( null != line ) { line = line . substring ( headerLength ) ; if ( ( index = line . indexOf ( FILE_IS_NEW ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = line . substring ( index + FILE_IS_NEW . length ( ) ) ; entries . addElement ( entry = new CvsTagEntry ( filename , rev ) ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_HAS_CHANGED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; int revSeparator = line . indexOf ( " to " , index ) ; String prevRevision = line . substring ( index + FILE_HAS_CHANGED . length ( ) , revSeparator ) ; String revision = line . substring ( revSeparator + 4 ) ; entries . addElement ( entry = new CvsTagEntry ( filename , revision , prevRevision ) ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_WAS_REMOVED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; entries . addElement ( entry = new CvsTagEntry ( filename ) ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } line = reader . readLine ( ) ; } CvsTagEntry [ ] array = new CvsTagEntry [ entries . size ( ) ] ; entries . copyInto ( array ) ; return array ; } catch ( IOException e ) { throw new BuildException ( "Error in parsing" , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } } private void writeTagDiff ( CvsTagEntry [ ] entries ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( m_destfile ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; writer . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; writer . print ( "<tagdiff " ) ; if ( m_startTag != null ) { writer . print ( "startTag=\"" + m_startTag + "\" " ) ; } else { writer . print ( "startDate=\"" + m_startDate + "\" " ) ; } if ( m_endTag != null ) { writer . print ( "endTag=\"" + m_endTag + "\" " ) ; } else { writer . print ( "endDate=\"" + m_endDate + "\" " ) ; } writer . println ( ">" ) ; for ( int i = 0 , c = entries . length ; i < c ; i ++ ) { writeTagEntry ( writer , entries [ i ] ) ; } writer . println ( "</tagdiff>" ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( UnsupportedEncodingException uee ) { log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( IOException ioe ) { } } } } private void writeTagEntry ( PrintWriter writer , CvsTagEntry entry ) { writer . println ( "\t<entry>" ) ; writer . println ( "\t\t<file>" ) ; writer . println ( "\t\t\t<name>" + entry . getFile ( ) + "</name>" ) ; if ( entry . getRevision ( ) != null ) { writer . println ( "\t\t\t<revision>" + entry . getRevision ( ) + "</revision>" ) ; } if ( entry . getPreviousRevision ( ) != null ) { writer . println ( "\t\t\t<prevrevision>" + entry . getPreviousRevision ( ) + "</prevrevision>" ) ; } writer . println ( "\t\t</file>" ) ; writer . println ( "\t</entry>" ) ; } private void validate ( ) throws BuildException { if ( null == m_package ) { throw new BuildException ( "Package/module must be set." ) ; } if ( null == m_destfile ) { throw new BuildException ( "Destfile must be set." ) ; } if ( null == m_startTag && null == m_startDate ) { throw new BuildException ( "Start tag or start date must be set." ) ; } if ( null != m_startTag && null != m_startDate ) { throw new BuildException ( "Only one of start tag and start date " + "must be set." ) ; } if ( null == m_endTag && null == m_endDate ) { throw new BuildException ( "End tag or end date must be set." ) ; } if ( null != m_endTag && null != m_endDate ) { throw new BuildException ( "Only one of end tag and end date must " + "be set." ) ; } } } 	1	
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . io . IOException ; import java . util . Date ; import java . util . Vector ; import java . util . zip . ZipInputStream ; import java . util . zip . ZipEntry ; public class Expand extends Task { private File dest ; private File source ; private boolean overwrite = true ; private Vector patternsets = new Vector ( ) ; private Vector filesets = new Vector ( ) ; public void execute ( ) throws BuildException { if ( "expand" . equals ( taskType ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } if ( source == null && filesets . size ( ) == 0 ) { throw new BuildException ( "src attribute and/or filesets must be " + "specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( dest . exists ( ) && ! dest . isDirectory ( ) ) { throw new BuildException ( "Dest must be a directory." , location ) ; } FileUtils fileUtils = FileUtils . newFileUtils ( ) ; if ( source != null ) { if ( source . isDirectory ( ) ) { throw new BuildException ( "Src must not be a directory." + " Use nested filesets instead." , location ) ; } else { expandFile ( fileUtils , source , dest ) ; } } if ( filesets . size ( ) > 0 ) { for ( int j = 0 ; j < filesets . size ( ) ; j ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( j ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { File file = new File ( fromDir , files [ i ] ) ; expandFile ( fileUtils , file , dest ) ; } } } } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; ZipInputStream zis = null ; try { zis = new ZipInputStream ( new FileInputStream ( srcF ) ) ; ZipEntry ze = null ; while ( ( ze = zis . getNextEntry ( ) ) != null ) { extractFile ( fileUtils , srcF , dir , zis , ze . getName ( ) , new Date ( ze . getTime ( ) ) , ze . isDirectory ( ) ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( IOException e ) { } } } } protected void extractFile ( FileUtils fileUtils , File srcF , File dir , InputStream compressedInputStream , String entryName , Date entryDate , boolean isDirectory ) throws IOException { if ( patternsets != null && patternsets . size ( ) > 0 ) { String name = entryName ; boolean included = false ; for ( int v = 0 ; v < patternsets . size ( ) ; v ++ ) { PatternSet p = ( PatternSet ) patternsets . elementAt ( v ) ; String [ ] incls = p . getIncludePatterns ( project ) ; if ( incls != null ) { for ( int w = 0 ; w < incls . length ; w ++ ) { boolean isIncl = DirectoryScanner . match ( incls [ w ] , name ) ; if ( isIncl ) { included = true ; break ; } } } String [ ] excls = p . getExcludePatterns ( project ) ; if ( excls != null ) { for ( int w = 0 ; w < excls . length ; w ++ ) { boolean isExcl = DirectoryScanner . match ( excls [ w ] , name ) ; if ( isExcl ) { included = false ; break ; } } } } if ( ! included ) { return ; } } File f = fileUtils . resolveFile ( dir , entryName ) ; try { if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= entryDate . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; return ; } log ( "expanding " + entryName + " to " + f , Project . MSG_VERBOSE ) ; File dirF = fileUtils . getParentFile ( f ) ; dirF . mkdirs ( ) ; if ( isDirectory ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( f ) ; while ( ( length = compressedInputStream . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; fos = null ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException e ) { } } } } fileUtils . setFileLastModified ( f , entryDate . getTime ( ) ) ; } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } public void addPatternset ( PatternSet set ) { patternsets . addElement ( set ) ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } } 	1	
package org . apache . tools . ant . taskdefs ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . input . InputRequest ; import org . apache . tools . ant . input . MultipleChoiceInputRequest ; import org . apache . tools . ant . util . StringUtils ; public class Input extends Task { private String validargs = null ; private String message = "" ; private String addproperty = null ; public void setValidargs ( String validargs ) { this . validargs = validargs ; } public void setAddproperty ( String addproperty ) { this . addproperty = addproperty ; } public void setMessage ( String message ) { this . message = message ; } public void addText ( String msg ) { message += getProject ( ) . replaceProperties ( msg ) ; } public Input ( ) { } public void execute ( ) throws BuildException { InputRequest request = null ; if ( validargs != null ) { Vector accept = StringUtils . split ( validargs , ',' ) ; request = new MultipleChoiceInputRequest ( message , accept ) ; } else { request = new InputRequest ( message ) ; } getProject ( ) . getInputHandler ( ) . handleInput ( request ) ; if ( addproperty != null ) { project . setNewProperty ( addproperty , request . getInput ( ) ) ; } } } 	1	
