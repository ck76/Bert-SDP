TypeError: 'LSTM' object is not subscriptable梯度消失或爆炸的危害:

如果在训练过程中发生了梯度消失，权重无法被更新，最终导致训练失败; 梯度爆炸所带来的梯度过大，大幅度更新网络参数，在极端情况下，结果会溢出（NaN值）.
小节总结:

学习了传统RNN的结构并进行了分析;
它的输入有两部分, 分别是h(t-1)以及x(t), 代表上一时间步的隐层输出, 以及此时间步的输入, 它们进入RNN结构体后, 会"融合"到一起, 这种融合我们根据结构解释可知, 是将二者进行拼接, 形成新的张量[x(t), h(t-1)], 之后这个新的张量将通过一个全连接层(线性层), 该层使用tanh作为激活函数, 最终得到该时间步的输出h(t), 它将作为下一个时间步的输入和x(t+1)一起进入结构体. 以此类推.
根据结构分析得出了传统RNN的计算公式.
学习了激活函数tanh的作用:
用于帮助调节流经网络的值, tanh函数将值压缩在-1和1之间.
学习了Pytorch中传统RNN工具的使用:
位置: 在torch.nn工具包之中, 通过torch.nn.RNN可调用.
nn.RNN类初始化主要参数解释:
input_size: 输入张量x中特征维度的大小.
hidden_size: 隐层张量h中特征维度的大小.
num_layers: 隐含层的数量.
nonlinearity: 激活函数的选择, 默认是tanh.
nn.RNN类实例化对象主要参数解释:
input: 输入张量x.
h0: 初始化的隐层张量h.
实现了nn.RNN的使用示例, 获得RNN的真实返回结果样式.
学习了传统RNN的优势:
由于内部结构简单, 对计算资源要求低, 相比之后我们要学习的RNN变体:LSTM和GRU模型参数总量少了很多, 在短序列任务上性能和效果都表现优异.
学习了传统RNN的缺点:
传统RNN在解决长序列之间的关联时, 通过实践，证明经典RNN表现很差, 原因是在进行反向传播的时候, 过长的序列导致梯度的计算异常, 发生梯度消失或爆炸.
学习了什么是梯度消失或爆炸:
根据反向传播算法和链式法则, 得到梯度的计算的简化公式:其中sigmoid的导数值域是固定的, 在[0, 0.25]之间, 而一旦公式中的w也小于1, 那么通过这样的公式连乘后, 最终的梯度就会变得非常非常小, 这种现象称作梯度消失. 反之, 如果我们人为的增大w的值, 使其大于1, 那么连乘够就可能造成梯度过大, 称作梯度爆炸.
梯度消失或爆炸的危害:
如果在训练过程中发生了梯度消失，权重无法被更新，最终导致训练失败; 梯度爆炸所带来的梯度过大，大幅度更新网络参数，在极端情况下，结果会溢出（NaN值）.
————————————————
版权声明：本文为CSDN博主「あずにゃん」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zimiao552147572/article/details/105520740